{"./":{"url":"./","title":"Introduction","keywords":"","body":"Simplechan developer document SimpleChainis a public chain with the design concept of one main chain and multiple sub-chains. Through the multi-level distributed value network design, it supports the deployment and expansion of blockchains in multiple consensus and multiple business scenarios, supports cross-chain transactions and sub-chains that meet tens of millions of TPS, involving distributed computing, judicial digitization, digital auction, real estate, digital entertainment games, transaction settlement, and other scenarios, jointly Build a new digital economy ecosystem. WithSimpleChainmian network running, We have seen more and more Blockchain enthusiasts and technology developers participate in our technology community and ecosystem construction. Welcome more technology developers to join our technology community. Our documents are designed to serve developers and community enthusiasts to quickly understand and get startedSimpleChain。Document fromSimpleChainCommunity and SimpleChainThe core team maintains it together, so you are welcome to make your own contribution here! We hope that the document can be understood more clearly SimpleChaintechnology and ecosystem. At the beginning SimpleChainBefore network development, you need to make the following preparations: Understand the basic concepts of blockchain Have a certain mainstream programming and development foundation Have Right SimpleChainUnderstanding of basic attributes and specific understanding of your business needs We sincerely welcome everyone to join our SimpleChainCommunity developer friends and based on SimpleChainOrganize applications on the ground. "},"1_quickStart.html":{"url":"1_quickStart.html","title":"Quick Start","keywords":"","body":"This page provides guidelines for different types of users, allowing developers to quickly find what they need. If you want to know SimpleChainthe basic concept. Entering SimpleChain Technical details or in SimpleChainBefore developing smart contracts，first understand SimpleChainBasic concepts andSimpleChainit is helpful to have a thorough understanding. You can learn aboutSimpleChain some basic concepts of account system, economic model and voting process. If you want to use SimpleChain Even if you are not a developer, you can joinSimpleChainCommunity and SimpleChainMake contributions to daily operations. You can have a look Browser. If you are a developer For developers, there are many materials to help you. Run and operate SimpleChain You can choose to run a local single-node network or join SimpleChain network. You can use command line tools to operate SimpleChain. Intelligent contract development For smart contract developers, you can refer to the smart contract development section for more information. We also provide some examples for smart contract developers to describe how to write/deploy/run contracts. Landing case This is used SimpleChaina landing case of development. SDK and API SDKs and APIs are also provided for developers: Javascript SDK Java SDK Python SDK JSON RPC API If you are interested in technical details For those who are interested in technical details, you can learn about the database infrastructure, network layer, and virtual machines. You will be able to understand through these documentsSimpleChain the internal logic help If you have any questions, please feel free Medium, Telegram forum for help. "},"2_BuildNode/":{"url":"2_BuildNode/","title":"Build Node","keywords":"","body":"Docker image building Obtain an image： docker pull simplechain/sipe:latest Start node: docker run -it -p 30312:30312 simplechain/sipe Enable RPC: docker run -it -p 8545:8545 -p 30312:30312 simplechain/sipe --rpc --rpcaddr \"0.0.0.0\" Enable the JavaScript console: docker run -it -p 30303:30303 simplechain/sipe console Store block data in a specified directory: docker run -it -p 30312:30312 -v /path/on/host:/root/.simplechain simplechain/sipe If RPC is enabled, you can run the following command to check whether your node is successfully started: curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":68}' Installation package construction Open theofficial websiteof Simplechain and drop down to find the SimpleNode module, as shown in the following figure: Download the corresponding version according to your server system. After downloading, follow the prompts to install it. After installation, create a wallet account by using the credential. Then you can pay or receive sipc, mining, and publish contracts. Account： Mining Contract Source code construction Preliminary preparations: Go language environment (1.10 or higher), C language compiler 1.Download SimpleChain You can clone a project locally through git or https://github.com/simplechain-org/go- Download directly from the simplechain page. git clone https://github.com/simplechain-org/go-simplechain.git 2.Install sipe 1.Enter the go-simplechain root directory. cd go-simplechain 2.Use the make tool to install sipe. make sipe >>> /usr/local/go/bin/go install -ldflags -X main.gitCommit=9d73f67e1dc5587a95f52c13fee93be6434b42ac -s -v ./cmd/sipe github.com/simplechain-org/go-simplechain/core ... github.com/simplechain-org/go-simplechain/cmd/sipe Done building. Run \"/Users/yuanchao/go/src/github.com/simplechain-org/go-simplechain/build/bin/sipe\" to launch sipe. When the above output appears on the terminal, the make execution is successful. In this case, the sipe executable file is generated in the go-simplechain/build/bin directory. You can move it to any directory or add it to environment variables to facilitate the running of sipe programs. Start sipe 1.Create a folder for storing node data： mkdir chaindata 2.Start the sipe Master network node Enable the RPC service and specify the RPC listening address as 127.0.0.1, Port 8545. The node data storage directory is chaindata ./sipe --rpc --rpcaddr 127.0.0.1 --rpcport 8545 --datadir chaindata When an output similar to the following appears, the startup is successful and the SimpleChain master Network block is synchronized. INFO [06-19|09:35:01.481] Maximum peer count ETH=25 LES=0 total=25 INFO [06-19|09:35:01.492] Starting peer-to-peer node instance=Sipe/v1.0.2-stable-0cbf2a41/darwin-amd64/go1.12.1 ... INFO [06-19|09:35:33.700] Block synchronisation started INFO [06-19|09:35:36.756] Imported new block headers count=192\\ elapsed=22.273ms number=192 hash=bb758a...bea1b6 ignored=0 3.Start the sipe console Create a new terminal window and run the following command to open an interaction console connected to this node. sipe attach chaindata/sipe.ipc 4.Create an account Use the following command to create an account in the started console. > personal.newAccount() Passphrase: Repeat passphrase: \"0xc8d8ba3bdba3a1e3ca1d6cd48106d84036f6c0bd\" //account address After the account is created, the console returns the account address and generates a json file for the account in chaindata/keystore. This file can obtain the account private key through password parsing. 5.Enable mining Restart the sipe node，enable mining, and specify the miner address as the account address you created. The number of mining Threads is 1. sipe --rpc --rpcaddr 127.0.0.1 --rpcport 8545 --datadir chaindata --mine --minerthreads=1 --etherbase=0xc8d8ba3bdba3a1e3ca1d6cd48106d84036f6c0bd You can also specify the miner address and enable mining in the console. > miner.setEtherbase('0xc8d8ba3bdba3a1e3ca1d6cd48106d84036f6c0bd') > miner.start() "},"47_techniqueLanguage.html":{"url":"47_techniqueLanguage.html","title":"Technical Manual","keywords":"","body":"We need to know some common terms and nouns before we begin to understand Simplechain and learn more about Simplechain in the future. Proper noun External account：EOAs(External Owned Accounts), associated with personal private key. Can be used to send transactions (transfer Sipc or send messages), like a savings card with a digital ID. Contract account：Contracts Accounts, which can store contract codes and contract data on Simplechain. External users cannot directly operate this account. It can only be called directly or indirectly from an external account. Account Status： account state, which indicates the status of an account in Simplechain. The account status changes when the account data changes. The account status includes four items: nonce, balance, root hash value of account storage content, and hash value of account code. Status data is not directly stored in the block. Account Nonce: account random number, which is the transaction count of the account. To prevent replay attacks. Smart Contract：Smart Contract,Simplechain supports writing Smart Contract code through Turing's complete advanced programming language. After being deployed on the chain, you can accept transaction requests and events from outside to trigger the execution of specific contract code logic and further generate new transactions and events. Even call other smart contracts. World State：state, which manages the mapping relationship between account address and account state. The status of all accounts constitutes the status of the entire blockchain. Trading：Transaction is the only way for external interaction with Simplechain. It must be signed by an external account. The miner executes the Transaction and finally packages it into the block. Transaction receipt：Receipt, which is convenient for zero-knowledge proof, index and search of transactions, and codes some specific information during transaction execution as transaction receipts. Block：block is a data block composed of a set of transactions, some auxiliary information (block header for short), and other block header hashes. Other block header hash indicates the parent block or the back block. uncle block：Uncle Block，an orphan Block that cannot be part of the main chain. If you are lucky enough to be taken into the Block chain by later blocks, it becomes Uncle Block. Additional rewards will be given to the blocks that have retained the isolated blocks. Once a block becomes a block, the block will be rewarded. Reduce Simplechain soft forking and balance the benefits of miners with slow network speed through the block reward mechanism. Random number：nonce，recorded in the block header, proof of hard work. Gas：fuel is a visualized concept of the amount of resources consumed during the operation of EVM when a transaction is packaged into a block. It is a metaphor that fuel is required to run EVM. In Simplechain, CPU resources and storage resources are expressed in accordance with built-in rules and Gas is used as a resource unit. Each time a virtual machine command is executed, a certain amount of Gas is consumed. GasPrice: fuel price, any transaction needs to include a unit price of fuel that is willing to pay, and finally according to the amount of fuel consumed by the transaction, the handling fee (usedGas * gasPrice) is calculated and paid to the miners. Price forecast：GPO(Gas Price Oracle),Gas Price forecast, predict the future GasPrice trend according to GasPrice of historical transactions. Technical terms ZKP: Zero Knowledge Proof. EVM：Ethereum Virtual Machine，which is a lightweight sandbox Virtual Machine for executing transactions. Message：A message is a virtual object that cannot be serialized and only exists in the running environment of Simplechain. A message mainly includes the sender, receiver, and gasLimit of the message; 序列化：RLP is used to encode data into a set of byte data to facilitate data exchange and storage. RLP: ecursive length prefix encoding, a data encoding protocol that can compress data, is often used to serialize data in Simplechain. MPT：Merkel compressed prefix Tree, Merkle Patricia Tree, is a modified data structure that combines the advantages of Merkel Tree and prefix Tree, it is an important data structure used in Simplechain to organize and manage account data and generate transaction set hash. Patricia Trie: a compressed prefix tree, a tree that saves more space. For each node of trie, if the node is the only son of its parent node, it is combined with the parent node; Merkle Tree: Merkel Tree, also known as Hash Tree, the value of the leaf node of Merkel Tree is the content of the data item, or the Hash value of the data item; The value of the non-leaf node is based on the information of its child node, then it is calculated according to the Hash algorithm. Whisper：ciphertext is a communication protocol based on P2P. Through Whisper, nodes can send information to a specific node, achieve dual-node private chat and communication on multiple nodes by topic. It is mainly designed for DApp with large-scale point-to-point data discovery, signal negotiation, minimum transmission communication and complete privacy protection. Swarm： it is a distributed storage platform and content distribution service, and is the local basic Layer Service of Simplechain web3 technology stack; LLL，Sperpent、Mutan和Solidity：the programming language used to write intelligent contract code, which can be compiled into EVM code. ERC20: it can be understood as a Token protocol specification of Simplechain. All Token contracts developed based on Simplechain comply with this specification. Tokens that comply with the ERC20 protocol specifications can be supported by various Simplechain wallets. ERC721: it is a Token protocol specification established on the ERC20 standard and a smart contract standard for non-fundable tokens (NFTs for short). "},"3_sipcCoin.html":{"url":"3_sipcCoin.html","title":"Sipc Coin","keywords":"","body":"Sipcis a public blockchain platformSimpleChain the circulation of tokens on the chain, issued at the beginning of 2019, the total amount of tokens issued is100000000Pieces. SimpleChainit is a public chain with the design concept of one main chain and multiple sub-chains. It supports blockchain deployment and expansion in multiple consensus and business scenarios, and supports cross-chain transactions, support sub-chains to meet tens of millions of TPS, involving distributed computing, judicial digitization, digital auction, real estate, digital entertainment games, transaction settlement and other scenarios. Circulation platform ZT Support wallet SIPC ChainBox Market tool Feixiaohao mytoken Support mine pool Matpool Dxpool Simpool "},"4_PublishCoin/":{"url":"4_PublishCoin/","title":"Publish Coin","keywords":"","body":"How to issue digital assets on SimpleChain Prerequisites Preparations for implementing publish coin on the chain include: Download and deploy SimpleChain. Start the node. Create an account. Ensure that the account is unlocked and has a token. Preparatory work Understand the ERC20 token standard. Explanation: The implementation of tokens on SimpleChain needs to follow the ERC20 standard. //ERC20Token.sol //ERC 合约标准，该标准规定在发 Token 之前，需要指定 token 的名称、标识、总量、实现合 //约标准函数等 pragma solidity ^0.4.26; contract ERC20Token { //获取 token 名称 function name() public constant returns (string name); //获取 token 标识 function symbol() public constant returns (string symbol); //获取 token 的最小分割量 function decimals() public constant returns (uint8 decimals); //获取 token 的总量 function totalSupply() public constant returns (uint256 totalSupply); //获取_owner 账户当前的 token 量 function balanceOf(address _owner) public constant returns (uint256 balance); //转账交易 function transfer(address _to, uint256 _value) public returns (bool success); //由_from 向_to 进行转账 function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); //许可_spender 能从调用合约方法的账户转出总量为_value 的 token function approve(address _spender, uint256 _value) public returns (bool success); //获取_spender 可以从账户_owner 中转出 token 的剩余数量 function allowance(address _owner, address _spender) public constant returns (uint remaining); //转账事件(transfer、transferFrom 会触发该事件) event Transfer(address indexed _from, address indexed _to, uint256 _value); //许可事件(approve 会触发该事件) event Approval(address indexed _owner, address indexed _spender, uint256 _value); } Compile token contracts that meet ERC20 standards. //Mytoken.sol pragma solidity ^0.4.26; import \"./ERC20Token.sol\"; contract MyToken is ERC20Token { string private _name; string private _symbol; uint8 private _decimals = 18; //此处建议为 18，代表最小单位为 0.1^18 uint256 private _totalSupply; //存储账户的 token 总量 mapping(address => uint256) private _balances; //存储前一个address允许后一个address转出token的剩余数量 mapping(address => mapping(address => uint256)) private _allowances; function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol) public{ _name = tokenName; _symbol = tokenSymbol; _totalSupply = initialSupply * 10 ** uint256(_decimals); _balances[msg.sender] = _totalSupply; } function name() public constant returns (string name){ name = _name; } function symbol() public constant returns (string symbol){ symbol = _symbol; } function decimals() public constant returns (uint8 decimals){ decimals = _decimals; } function totalSupply() public constant returns (uint256 totalSupply){ totalSupply = _totalSupply; } function balanceOf(address _owner) public constant returns (uint256 balance){ balance = _balances[_owner]; } function transfer(address _to, uint256 _value) public returns (bool success){ require(_balances[msg.sender] >= _value); //保证发出交易的账户 token 足够完成转账 _balances[msg.sender] -= _value; _balances[_to] += value; Transfer(msg.sender, _to, _value); success = true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){ require(_balances[_from] >= _value); //保证_from 账户 token 足够完成转 账 require(_allowances[_from][msg.sender] >= _value); //保证_from 账户允许 执行账户转出的 token 剩余量足够 _balances[_from] -= _value; _allowances[_from][msg.sender] -= _value; _balances[_to] += _value; Transfer(_from, _to, _value); success = true; } } //许可_spender 能从调用合约方法的账户转出总量为_value 的 token function approve(address _spender, uint256 _value) public returns (bool success){ _allowances[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); success = true; } //获取_spender 可以从账户_owner 中转出 token 的剩余数量 function allowance(address _owner, address _spender) public constant returns (uint256 remaining){ remaining = _allowances[_owner][_spender]; } } Contract compilation: Use a browser to open Remix Solidity IDE. Add ERC20Token.sol and MyToken.sol to the browser folder. Select the Compile option in the right-side box of the webpage and select the version of the contract compiler (0.4.26 is selected in this article). Click Start to compile. Contract deployment Select the Run option and select the Web3 Provider in the Environment. In the dialog box that appears, enter the port of the currently enabled sipe node. Select an unlocked Account with a token. Select the MyToken contract, enter the initialization parameters in the Deploy field: total number of tokens, token name, token identifier, and click Deploy. Wait about one minute until the contract deployment is completed. If the contract appears in the Deployed Contracts column, the deployment is completed. So far, the Fa Bi completed. Contract Verification Execute the decimals,name,symbol,totalSupply methods of the contract to check whether the token is successfully created. Execute the transfer method, expand the transfer method to transfer money to other accounts, and use balanceOf to check whether the transfer is successful. "},"5_concoct.html":{"url":"5_concoct.html","title":"Deploy","keywords":"","body":"SimpleChainthe basic configuration of the service chain, startSimpleChain node, you need to load the chain configuration. Therefore, inSimpleChain the main network (mainnet) and test network (testnet) configurations are built in. When the node is initially started, different chain configurations are loaded by default according to different parameters (-dev,-testnet). Chain Configuration Different from traditional software, because of the non-tamper nature of the blockchain, it requires the same block, regardless of the software version when the block is released or the software version n years later. All must ensure that the software does the same operation on the out-of-block block. Therefore, the blockchain configuration of the blockchain cannot be changed at will, and important historical changes need to be maintained. The following is the core configuration information of the chain, which is defined in params/config.go: // ChainConfig is the core config which determines the blockchain settings. // ChainConfig is stored in the database on a per block basis. This means // that any network, identified by its genesis block, can have its own // set of configuration options. type ChainConfig struct { ChainID *big.Int `json:\"chainId\"` // chainId identifies the current chain and is used for replay protection SingularityBlock *big.Int `json:\"singularityBlock,omitempty\"` // Singularity switch block (nil = no fork, 0 = already on singularity) EWASMBlock *big.Int `json:\"ewasmBlock,omitempty\"` // EWASM switch block (nil = no fork, 0 = already activated) // Various consensus engines Ethash *EthashConfig `json:\"ethash,omitempty\"` Clique *CliqueConfig `json:\"clique,omitempty\"` Scrypt *ScryptConfig `json:\"scrypt,omitempty\"` DPoS *DPoSConfig `json:\"dpos,omitempty\"` Raft bool `json:\"raft,omitempty\"` Istanbul *IstanbulConfig `json:\"istanbul,omitempty\"` } The blockchain cannot be tampered with. Non-centralized programs make the upgrade of blockchain network programs more complicated. The core configuration of Simplechain reflects the critical moments of the entire Simplechain network. As aboveSimpleChainChain configuration, not the program is initially written, but SimpleChain development is accumulated during major changes in consensus agreements. The following is a description of the role of each configuration: ChainID ChianIDis the identifier of the current chain to prevent replay attacks. SingularityBlock Hard Fork height. This means that from this height, the new District block is restricted by the new version of consensus rules. Because consensus changes are involved, if you want to continue accepting new blocks, you must upgrade the Simplechain program, which belongs to the blockchain hard fork. If you do not want to accept consensus changes, you can use the new ChainID to continue the original consensus independently, and the version must be maintained independently. EWASMBlock Ethash Ethashthe consensus algorithm engine configuration. Ethash is the consensus algorithm of Ethereum. It is a PoW consensus algorithm. It can be used as a consensus algorithm for Simplechain sub-chains. Clique Clique POA consensus algorithm is configured as a consensus engine. PoA consensus algorithm is also one of the consensus algorithms that Simplechain can choose. You can choose this consensus algorithm when building a test chain and a private chain. Scrypt Scryptthe consensus algorithm engine configuration. Scrypt is the consensus algorithm of the Simplechain main chain, which belongs to the PoW consensus algorithm. DPoS DPoS is a consensus algorithm of Simplechain sub-chains. Because Simplechain is a blockchain architecture with one master and multiple sub-chains, multiple consensus algorithms can be selected for sub-chains, DPos is a consensus algorithm that can be selected for sub-chains. Raft Raftis a consensus algorithm that you can choose from the Simplechain sub-chain. Raft selects a noble leader and gives him all the responsibilities to manage and copy logs to achieve consistency.性。 Istanbul IstanbulSimplechain consensus engine configuration "},"6_genesis/":{"url":"6_genesis/","title":"Genesis Block","keywords":"","body":"The genesis block is the zero th block, and other blocks are directly or indirectly referenced to the genesis block. Therefore, the correct creation block information must be loaded at the beginning of the node startup and cannot be arbitrarily modified. SimpleChainyou can use the creation configuration file to initialize the creation block. You can also use the creation configuration that uses multiple built-in network environments. Default useSimpleChain Master network creation configuration. Genesis configuration file If you need to build SimpleChain private chain, then it is necessary to understand the creation configuration, otherwise you don't care about the creation configuration. The following is an example of creation configuration in JSON format: { \"config\": { \"chainId\": 100, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"alloc\" : {}, \"coinbase\" : \"0x0000000000000000000000000000000000000000\", \"difficulty\" : \"0x20000\", \"extraData\" : \"\", \"gasLimit\" : \"0x2fefd8\", \"nonce\" : \"0x0000000000000042\", \"mixhash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"timestamp\" : \"0x00\" } According to the configuration usage, it can be divided into three categories: Chain configuration configthe item defines the chain configuration, which affects the consensus protocol. Although the chain configuration has little impact on Genesis, the block-out rules of new blocks all depend on the chain configuration. Information configuration of Genesis block head nonce：random number, corresponding to the genesis block Nonce Field. timestamp：UTC timestamp, corresponding to the genesis block Time Field. extraData：additional data, corresponding to the genesis block Extra Field. gasLimit：required, fuel upper limit, corresponding to the genesis block GasLimit Field. difficulty：required, difficulty coefficient, corresponding to the genesis block Difficulty Field. When building a private chain, you need to select the appropriate difficulty value according to the situation to adjust the block. mixHash：a hash value, corresponding to MixDigest Field. Together with the nonce value, sufficient calculations have been performed on the block. coinbase：An address corresponding to Coinbase Field. 3.Initial account asset allocation alloc Item is the initial account asset allocation in Genesis. When a genesis block is generated, the account assets in this dataset are written into the block, which is equivalent to pre-mining. This is very useful for development testing and private chains. You can directly allocate assets to any number of accounts without mining. Chuangshi block loading process When running Simplechain, you must load the creation configuration and the creation block according to the configuration file, and verify its validity. If the configuration information is changed at will, problems such as consensus verification failure may occur. The program can continue to run only when loading and checking pass. The preceding figure shows a brief process. The following two sub-processes are \"loading the creation configuration\" and \"installing the creation block. Load Genesis configuration Which Creation configuration should be used depends on when the user starts Sipe. The following figure shows the flow chart of creation configuration selection: You can use Sipe command parameters to select different network configurations networkid Select, you can also use the network name to enable. 1.Use networkid, Different networks use different ID. 1=Frontier，main network environment, is the default option. 2=Morden test network, but disabled. 3=Ropsten test network. 4=Rinkeby test network. 2.Directly use the network name: testnet: Ropsten tests the network. rinkeby: Rinkeby tests the network. goerli: Görli tests the network. dev: local development environment. When Sipe is started, select to load different network configurations according to different parameters and correspond to different network environments. If no choice is made, although no choice is made here, the main network configuration will be used by default in the subsequent process. Install the genesis block First, you need to read the genesis block hash from the database based on the block height 0. If it does not exist, the local startup is the first time. Use the runtime creation configuration directly to build the creation block. For the first time, you also need to store the creation block and chain configuration. If it exists, you need to use the runtime creation configuration to build the creation block and compare it with the created block hash that has been stored this time. Once inconsistent, an error is returned and cannot continue. Then, you need to check the chain configuration. Obtain the chain configuration from the database first. If it does not exist, use the runtime chain configuration directly without verification. Otherwise, check whether the runtime chain configuration is correct and replace the update only when it is correct. However, there is an exception: the Master network configuration cannot be changed at will and is controlled by code rather than manually specified. In general, Simplechain uses the Master network configuration by default. It only creates and stores the creation block when it is running for the first time. In other cases, it is only used for verification. In addition to the main network, the chain configuration can be changed at any time under the rules. Build and create blocks We have known the overall process above. Here we will describe in detail how Simplechain generates creation blocks based on the creation configuration. The core code is located in core/genesis.go:229: func (g *Genesis) ToBlock(db ethdb.Database) *types.Block{ if db == nil { db = rawdb.NewMemoryDatabase() } statedb, _ := state.New(common.Hash{}, state.NewDatabase(db))//1 for addr, account := range g.Alloc { //2 statedb.AddBalance(addr, account.Balance) statedb.SetCode(addr, account.Code) statedb.SetNonce(addr, account.Nonce) for key, value := range account.Storage { statedb.SetState(addr, key, value) } } root := statedb.IntermediateRoot(false)//3 head := &types.Header{//4 Number: new(big.Int).SetUint64(g.Number), Nonce: types.EncodeNonce(g.Nonce), Time: g.Timestamp, ParentHash: g.ParentHash, Extra: g.ExtraData, GasLimit: g.GasLimit, GasUsed: g.GasUsed, Difficulty: g.Difficulty, MixDigest: g.Mixhash, Coinbase: g.Coinbase, Root: root, } //5 if g.GasLimit == 0 { head.GasLimit = params.GenesisGasLimit } if g.Difficulty == nil { head.Difficulty = params.GenesisDifficulty } statedb.Commit(false)//6 statedb.Database().TrieDB().Commit(root, true)//7 return types.NewBlock(head, nil, nil, nil)//8 } The preceding code is the code logic that generates the creation block based on the creation configuration. The details are as follows: Genesis block has no parent block, initialize the new from zero state (Follow-up articles will be explained in detail state Object). Traversal configuration Alloc Item account collection data, directly written to the state. Not only can be set here balance , you can also set code , nonce And any multiple storage Data. It means that smart contracts can be deployed directly when creating the world. For example, the following configuration deployed a configuration named093f59f1d91017d30d8c2caa78feb5beb0d2cfafsmart contract. \"alloc\": { \"093f59f1d91017d30d8c2caa78feb5beb0d2cfaf\": { \"balance\": \"0xffffffffffffffff\", \"nonce\": \"0x3\", \"code\":\"0x606060\", \"storage\":{ \"11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa\":\"1234ff\" } } } After the account data is written into the state, the root value of Merkel tree for the state data can be calculated, which is called StateRoot . This value is recorded in the block header Root Field. Part of the creation configuration is directly mapped to the block header to complete the creation of the block header. Because GasLimit And Difficulty Directly affects the next block outbound processing.Therefore, the default configuration is used when it is not set (Difficulty = 131072,GasLimit = 4712388). Submit the state to submit the state data to the underlying memory trie data. Update memory trie data to db. This is an unnecessary step, because the submission to the database is done externally, here you only need to be responsible for generating blocks. Use the block header to create a block, and there is no transaction record in the block. "},"7_account.html":{"url":"7_account.html","title":"Account","keywords":"","body":"Compared with Bitcoin's \"UTXO\" balance model, SimpleChain similar to Simplechain the account balance model is used. SimpleChain it enriches the account content and can store any amount of data in addition to the balance. And use the maintainability of account data to build an intelligent contract account. Actually SimpleChainit is an account model refined to realize smart contracts. Isolate data in an account. The information between accounts is independent of each other and does not interfere with each other. Cooperate again SimpleChainVirtual machine, let the smart contract sandbox run. SimpleChain as an intelligent contract operation platform, accounts are divided into two types: external account (EOAs) and contract account. External account EOAs-external owned accouts are accounts created by people through private keys. It is the mapping of real-world financial accounts, and anyone with the private key of the account can control the account. Just like a bank card, when you withdraw money from an ATM, you only need to enter the correct password to trade. This is also the only medium for human beings to communicate with Simplechain account books, becauseSimpleChain transaction in needs to be signed, You can only use a private external account signature. Summary of external account characteristics: Have sipc balance. Can send transactions, including transfer and execution of contract codes. Controlled by the private key. No relevant executable code. Contract account The account that contains the contract code. Created by an external account or contract, the contract is automatically assigned to an account address when created, Used to store contract code and stored data generated during contract deployment or execution. The contract account address is generated by the SHA3 hash algorithm, not the private key. Because of the selfless key, no one can use the contract account as an external account. Contract execution code can only be driven through external accounts. The following is the contract address generation algorithm: Keccak256(rlp([sender,nonce])[12:] // crypto/crypto.go:74 func CreateAddress(b common.Address, nonce uint64) common.Address { data, _ := rlp.EncodeToBytes([]interface{}{b, nonce}) return common.BytesToAddress(Keccak256(data)[12:]) } Because the contract is created by another account, the creator's address and the random number of the transaction are hashed and then the truncated part is generated. It is particularly important to note that inEIP1014 another algorithm for generating contract addresses proposed in. Its purpose is to facilitate the status channel by determining a stable contract address for content output. You can know the exact contract address before deploying the contract. The following is the algorithm method:keccak256( 0xff ++ address ++ salt ++ keccak256(init_code))[12:]。 // crypto/crypto.go:81 func CreateAddress2(b common.Address, salt [32]byte, inithash []byte) common.Address { return common.BytesToAddress(Keccak256([]byte{0xff}, b.Bytes(), salt[:], inithash)[12:]) } Summary of contract account characteristics: Have sipc balance. Relevant executable code (contract code). Contract codes can be called by transactions or other contract messages. Other contract codes can be called when the contract code is executed. When the contract code is executed, it can perform complex operations and permanently change the data storage inside the contract. Difference comparison To sum up, the following table lists the differences between the two types of accounts, and contract accounts are better than external accounts. However, the external account is the only medium for people to communicate with Simplechain, and it is complementary to the contract account. Item External account Contract account private Key ✔️ ✖️ balance ✔️ ✔️ code ✖️ ✔️ Multiple signature ✖️ ✔️ Control mode Private key control Execute the contract through an external account Multiple signatures are listed above because SimpleChain an external account is created by only one independent private key and cannot be signed multiple times. However, the contract is programmable, and the logic conforming to multiple signatures can be written to implement an account that supports multiple signatures. Account data structure SimpleChainData is organized by accounts, and changes in account data cause changes in account status. this causes changes in the Simplechain state. Logically, the data structures of the two types of accounts are the same: The corresponding code is as follows: // core/state/state_object.go:100 type Account struct { Nonce uint64 Balance *big.Int Root common.Hash CodeHash []byte } However, the data storage is slightly different, because the external account does not have internal storage data and contract code, so the external account data StateRootHash And CodeHash Is an empty default value. Once it belongs to an empty default value, it is not stored in the corresponding physical database. In the program logic, exist code The contract account. That CodeHash When the value is null, the account is an external account, otherwise it is a contract account. The above figure is SimpleChain the account data storage structure. In fact, only key data is stored within the account, while the contract code and the contract data are associated by corresponding hash values. Because each account object will be treated as a SimpleChain the data storage of a leaf in the account tree cannot be too large. In the field of cryptography, Nonce represents a number that is used only once. It is often a random or pseudo random number to avoid duplication. SimpleChain adding Nonce to the account can avoid replay attacks, but not randomly generated. The initial Nonce value of the account is 0. The Nonce value is added once for each subsequent account execution. The counting logic of one of them is as follows: // core/state_transition.go:212 st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1) The additional advantage of this is that Nonce can generally be used as the counter for the number of transactions of the account, especially for the contract account, the number of times the contract is called can be accurately recorded. and Balance Then record the number of sipcs owned by the account, which is called account balance. Transfer assets (Transfer) are in one account Balance Add up and reduce in another account. // core/evm.go:94 func Transfer(db vm.StateDB, sender, recipient common.Address, amount *big.Int) { db.SubBalance(sender, amount) db.AddBalance(recipient, amount) } // core/vm/evm.go:191 if !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) { return nil, gas, ErrInsufficientBalance } // core/vm/evm.go:214 evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value) Of course, the balance of the transferor must be guaranteed to be sufficient. Before the transfer CanTransfer Check, If the balance is sufficient, execute Transfer Transfer Value The number of ether. Account Status hash value StateRoot, is the root value of a Merkle Patricia Tree composed of methods and field information owned by the contract. In short, it is the root node value of a binary Tree. Any slight change in the contract status will eventually cause StateRoot Change, so the change of contract status will be reflected in the account StateRoot Up. At the same time, you can directly use StateRoot Quickly read a specific state data from Leveldb, such as the contract creator. Pass SimpleChain API web3.eth.getStorageAt data at any position in the contract can be read. Next, let's use a sample code to feel SimpleChaindata storage. import(...) var toAddr =common.HexToAddress var toHash =common.BytesToHash func main() { statadb, _ := state.New(common.Hash{}, state.NewDatabase(rawdb.NewMemoryDatabase()))// 1 acct1:=toAddr(\"0x0bB141C2F7d4d12B1D27E62F86254e6ccEd5FF9a\")// 2 acct2:=toAddr(\"0x77de172A492C40217e48Ebb7EEFf9b2d7dF8151B\") statadb.AddBalance(acct1,big.NewInt(100)) statadb.AddBalance(acct2,big.NewInt(888)) contract:=crypto.CreateAddress(acct1,statadb.GetNonce(acct1))//3 statadb.CreateAccount(contract) statadb.SetCode(contract,[]byte(\"contract code bytes\"))//4 statadb.SetNonce(contract,1) statadb.SetState(contract,toHash([]byte(\"owner\")),toHash(acct1.Bytes()))//5 statadb.SetState(contract,toHash([]byte(\"name\")),toHash([]byte(\"ysqi\"))) statadb.SetState(contract,toHash([]byte(\"online\")),toHash([]byte{1}) statadb.SetState(contract,toHash([]byte(\"online\")),toHash([]byte{}))//6 statadb.Commit(true)//7 fmt.Println(string(statadb.Dump()))//8 } In the above code, we created three accounts and submitted them to the database. Finally, print out the data information of all accounts in the current data: A line of code involves multiple operations. First, create a memory KV database and package it as a stata database instance, Finally, use an empty DB-level StateRoot , initialize a Simplechain statadb. Define two accounts acct1 and acct2, and add 100 and 888 to the account balance respectively. Simulate the creation process of a contract account, create a contract account address from the external account acct1, and load the address into statadb. Add the contract code to the newly created contract account, while writing the contract code, Can use crypto.Keccak256Hash(code) Calculate the contract code hash and keep it in the account data. Simulate the contract execution process, involving modifying the contract status and adding three new status data owner , name And online , corresponding to different values. What is different from the previous is that it is given status online The assignment is empty []byte{} Because the default value for all states is []byte{} , When submitted to the database, Leveldb deletes this record from the database file if it considers these states to have no valid values. Therefore, this operation is actually a delete State online Operation. All the above operations only occur in the statdb memory and are not actually written to database files. Implementation Commit , then all changes about statadb will be updated to the database file. Once the data is submitted, you can use Dump Command to find all data related to this stata from the database, including all accounts. And return it in JSON format. Here, we will directly print out the returned results. The code execution output is as follows: { \"root\": \"3a25b0816cf007c0b878ca7a62ba35ee0337fa53703f281c41a791a137519f00\", \"accounts\": { \"0bb141c2f7d4d12b1d27e62f86254e6cced5ff9a\": { \"balance\": \"100\", \"nonce\": 0, \"root\": \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"codeHash\": \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"code\": \"\", \"storage\": {} }, \"77de172a492c40217e48ebb7eeff9b2d7df8151b\": { \"balance\": \"888\", \"nonce\": 0, \"root\": \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"codeHash\": \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"code\": \"\", \"storage\": {} }, \"80580f576731dc1e1dcc53d80b261e228c447cdd\": { \"balance\": \"0\", \"nonce\": 1, \"root\": \"1f6d937817f2ac217d8b123c4983c45141e50bd0c358c07f3c19c7b526dd4267\", \"codeHash\": \"c668dac8131a99c411450ba912234439ace20d1cc1084f8e198fee0a334bc592\", \"code\": \"636f6e747261637420636f6465206279746573\", \"storage\": { \"000000000000000000000000000000000000000000000000000000006e616d65\": \"8479737169\", \"0000000000000000000000000000000000000000000000000000006f776e6572\": \"940bb141c2f7d4d12b1d27e62f86254e6cced5ff9a\" } } } } We can see that these displayed data directly correspond to all the operations we just performed. Only contract accounts storage And code . And external account codeHash And root The same value is a default value. "},"8_transaction/":{"url":"8_transaction/","title":"Transaction","keywords":"","body":"SimpleChaintransaction refers to the transfer of certain assets from an external account to an account, Or send a message to a smart contract. in SimpleChainnetwork, transaction execution belongs to a transaction. It has the characteristics of atomicity, consistency, isolation and persistence. ` atom： Is the indivisible minimum execution unit, either do it or not do it. same： the execution of the same transaction must change the Simplechain account book from one consistency state to another. isolate： The transaction will not be disturbed by other transactions during execution. lasting： once the transaction is submitted, the change to Simplechain account book is permanent. Subsequent operations will not affect it. Because it is a transaction type, we need to ensure that the transaction meets some design requirements before executing the transaction. The transaction must be unique and can distinguish different transactions and the same transaction cannot be submitted to the Ledger repeatedly. The transaction content must not be changed, the transactions received by each node must be consistent, and the change of account book status during transaction execution is also consistent. Transactions must be legally signed. Only transactions with correct signatures can be executed. Transactions cannot occupy too many system resources and affect the execution of other transactions. The design requirements for transactions involve all aspects of the software system, but the most basic part is the transaction data itself. Transaction data structure The following figure is SimpleChaintransaction data structure is divided into four parts according to the purpose. The beginning is a number of uint64 type, which is called a random number. Used to cancel transactions, prevent double flowers and modify SimpleChain Nonce value of the account (account data structure). The second part is about the setting of transaction execution restrictions, gas for willing to offerSimpleChainmaximum fuel limit for virtual machine operation. gasPrice is the unit price of fuel that is willing to pay. gasPrcie * gas it is the highest handling fee that is willing to pay for this transaction. The third part is the input of transaction sender SimpleChain the initial information for the virtual machine To execute this transaction: the virtual machine operation object (recipient), the asset (Value) transferred from the transaction sender To the operation object, and the virtual machine runtime input. When To is empty, it means that the virtual machine has no operation object. In this case, the virtual machine will use the input content to deploy a new contract. The fourth part is the signature result of the transaction sender. You can use the transaction content and signature result to deduce the signer, that is, the address of the transaction sender. The combination of four parts solves the problem of transaction security, realizes the interactive mode of intelligent contracts and provides flexible and adjustable transaction handling fees. Transaction object definition Specific to the code, SimpleChain defines a transaction object as an externally accessibleTransation objects and embedded objects that are invisible to external packagestxdata . Lowercase txdata It is the feature of Go language. The initial letter is lowercase, which is equivalent to that in other programming languages. private Modifier, indicating that the data structure is invisible to external packets. The same lowercase object field (such as hash in Transaction) also indicates that the external package cannot access this field. Otherwise, the definition of uppercase type, field, method, etc. is regarded public . // core/types/transaction.go:38 type Transaction struct { data txdata // caches hash atomic.Value size atomic.Value from atomic.Value } type txdata struct { AccountNonce uint64 Price *big.Int GasLimit uint64 Recipient *common.Address Amount *big.Int Payload []byte // Signature values V *big.Int R *big.Int S *big.Int // This is only used when marshaling to JSON. Hash *common.Hash `json:\"hash\" rlp:\"-\"` } First look at the private txdata The structure defines the necessary content in the transaction message, which corresponds to the transaction data structure mentioned above in sequence. There are three points that need special attention. First, because hash operation is involved, the order of field definition cannot be adjusted at will, and fields must be defined as required under non-special processing conditions. So txdata The fields defined in conform to the content order of Simplechain transaction messages. Second, when monetary calculation is involved, the problem of inaccurate calculation cannot be caused by lack of accuracy. Therefore, in all blockchain designs such as Simplechain and Bitcoin, the currency type is an integer, but the minimum value 1 The value of the currency represented is different. InSimpleChaina sipc is equal to the 18th power Amount of 10. When 10 billion sipcs are to be represented, the Amount is equal to the 27th power of 10. It has far exceeded the range (0-18446744073709551615) that Uint64 can represent. ThereforeSimpleChainall use the large numbers provided by the Go standard package big.Int Perform currency operations and define currencies. Here Price And Amount Both are of the big.Int pointer type. In addition, the three values of the signature also use the big.Int type because the number is too large. The third is the last Hash Field, which is not part of the transaction content, just to include the transaction hash in the transaction JSON. To prevent participation hash, the field is marked rlp:\"-\" . In addition, Transaction also defines three cache items: Transaction hash, Transaction size, and Transaction sender (from). The cache is used frequently and consumes a large amount of CPU. Hash operation is the most common operation in a blockchain. Data on all chains is basically involved in hash operation. However, hash operations are CPU intensive, so it is necessary to cache some hash operations to reduce CPU computing. After the transaction hash value is calculated for the first time, the transaction hash is cached on the hash field. func (tx *Transaction) Hash() common.Hash { if hash := tx.hash.Load(); hash != nil { return hash.(common.Hash) } v := rlpHash(tx) tx.hash.Store(v) return v } hash is atomic.Value Type, which is the atomic operation object provided by the Go standard package. This prevents concurrency from causing multiple hash calculations. First, the atom loads the hash value, and returns if it exists. If it does not exist, hash calculation is performed on the transaction (rlpHash, yes SimpleChain)，save the hash result and return it. The second cache is the transaction size. Transaction size refers to the data size after RLP encoding of transaction information. Represents the network transmission size of the transaction, the block size of the transaction, and the storage size of the transaction. When each transaction enters the transaction pool, you must check whether the transaction size exceeds 32KB . When pushing transaction data to other nodes, you must subcontract and push data when the transaction size does not exceed the maximum network message limit (default 10MB). To avoid repeated computing overhead, cache after the first computing. func (tx *Transaction) Size() common.StorageSize { if size := tx.size.Load(); size != nil { return size.(common.StorageSize) } c := writeCounter(0) rlp.Encode(&c, &tx.data) tx.size.Store(common.StorageSize(c)) return common.StorageSize(c) } As above, execute rlp.Encode Obtain the available data size, cache the result and return it. rlp is a set of blockchain data encoding and decoding protocols defined by Simplechain, instead of using common gzip, json, and Protobuf encoding formats. The purpose is to compress data as much as possible. After all, there are only several common data types in the blockchain data structure, which can meet the requirements without complicated protocols. The last cache item is the transaction sender (from). The sender of the transaction performs reverse computation based on the signature, which is also CPU-intensive. In order to ensure the legality of the transaction, the procedure involves taking the address of the transaction sender and verifying the legality of the sender everywhere. Only the correct signature can get the sender's address. Therefore, the transaction sender is also cached. //core/types/transaction_signing.go:72 func Sender(signer Signer, tx *Transaction) (common.Address, error) { if sc := tx.from.Load(); sc != nil { sigCache := sc.(sigCache) if sigCache.signer.Equal(signer) { return sigCache.from, nil } } addr, err := signer.Sender(tx) if err != nil { return common.Address{}, err } tx.from.Store(sigCache{signer: signer, from: addr}) return addr, nil } A special point is needed Signer Unsign and pass Signer Obtains the Sender. If it is valid, it is cached and returned. However, when using the cached content, you also need to check whether the two signers are consistent, because different Signer algorithms are different, and the transaction signers obtained are also different. Note that the above three cache usage have a precondition: Once a transaction object is created, the transaction content cannot be modified. This is also one of the reasons why the Transaction object is defined separately in the private txdata rather than directly defined in the Transaction. As shown in the following figure, only the transaction object method can be called to obtain the transaction content, and there is no way to modify the content of an existing transaction object. Transaction object method introduction In addition to providing external transaction content access, transaction object Transtion also defines some auxiliary methods. Let's introduce the methods in turn. ChainId() and Protected() func (tx *Transaction) ChainId() *big.Int { return deriveChainId(tx.data.V) } func (tx *Transaction) Protected() bool { return isProtectedV(tx.data.V) } From Transaction Signature content VMedium extraction chain ID . It is used to determine the validity of the signature when obtaining the transaction signer, once it is protected Protected() The signature information must contain the current chain ID, otherwise it is an illegal transaction. RLP interface implementation method func (tx *Transaction) EncodeRLP(w io.Writer) error { return rlp.Encode(w, &tx.data) } func (tx *Transaction) DecodeRLP(s *rlp.Stream) error { _, size, _ := s.Kind() err := s.Decode(&tx.data) if err == nil { tx.size.Store(common.StorageSize(rlp.ListSize(size))) } return err } Unlike other object-oriented languages, an object is considered to belong to an interface type as long as it has all methods to implement an interface in Go language. Here, the Transaction implements Encoder And Decoder Two interfaces. //rlp/encode.go:36 type Encoder interface { EncodeRLP(io.Writer) error } type Decoder interface { DecodeRLP(*Stream) error } This means that RLP encoding and decoding will be performed by two custom methods. RLP encoding decodes transactions. In fact, the transaction content txdata is encoded and decoded. At the same time, the transaction size is cached when the transaction is decoded. JJSON interface implementation func (tx *Transaction) MarshalJSON() ([]byte, error) { hash := tx.Hash() data := tx.data data.Hash = &hash return data.MarshalJSON() } func (tx *Transaction) UnmarshalJSON(input []byte) error { var dec txdata if err := dec.UnmarshalJSON(input); err != nil { return err } withSignature := dec.V.Sign() != 0 || dec.R.Sign() != 0 || dec.S.Sign() != 0 if withSignature { var V byte if isProtectedV(dec.V) { chainID := deriveChainId(dec.V).Uint64() V = byte(dec.V.Uint64() - 35 - 2*chainID) } else { V = byte(dec.V.Uint64() - 27) } if !crypto.ValidateSignatureValues(V, dec.R, dec.S, false) { return ErrInvalidSig } } *tx = Transaction{data: dec} return nil } This is a standard json package encoding and decoding method. It mainly returns JSON format data that meets the requirements when calling web3 APIs. The transaction hash is attached during encoding, and the validity of the signature format is also verified during decoding. The following is an example of complete transaction data in JSON format. { \"nonce\": \"0x16\", \"gasPrice\": \"0x2\", \"gas\": \"0x1\", \"to\": \"0x0100000000000000000000000000000000000000\", \"value\": \"0x0\", \"input\": \"0x616263646566\", \"v\": \"0x25\", \"r\": \"0x3c46a1ff9d0dd2129a7f8fbc3e45256d85890d9d63919b42dac1eb8dfa443a32\", \"s\": \"0x6b2be3f225ae31f7ca18efc08fa403eb73b848359a63cd9fdeb61e1b83407690\", \"hash\": \"0xb848eb905affc383b4f431f8f9d3676733ea96bcae65638c0ada6e45038fb3a6\" } json all numeric fields are expressed in hexadecimal numbers. This is to unify all data formats and serve large numbers of big.Int. The bignumber Library is specially built into the web3js library to process large numbers. "},"9_block/":{"url":"9_block/","title":"Block","keywords":"","body":"Simplechainit can be regarded as a database, and changes in database data are catalyzed by transactions. In order to manage transactions effectively and orderly, one or more transactions must be formed into one data block before they can be submitted to the database. This data Block is a Block. A block not only contains multiple transactions, but also records some additional data for correct submission to the database. The following figure shows the structure and relationship of Simplechain block data. When explaining the block data structure, other data must be presented together. Only by mastering the data sources in the block can you truly understand the block chain data. The block is divided into two parts: the block Header and the block Body. The block header is rich in information. It not only establishes contact with the previous unit, but also records some transaction execution information and miner work information. The above figure involves a very important concept Trie, whose full name is Merkel compressed prefix tree. Block header data interpretation The data of each field is as follows: parentHash Is a hash value that records the hash value of the parent block directly referenced by this block. Only through this record can the blocks be organized in an orderly manner to form a blockchain. In addition, the content of the parent block can be prevented from being modified. Because of data modification, the block hash is bound to change. Therefore, a block directly or indirectly strengthens all parent blocks, the encryption algorithm ensures that historical blocks cannot be modified. sha3Uncles Is a hash value that represents multiple uncle blocks referenced by the block. The block body also contains the block header information of multiple uncle, while sha3Uncles is the RLPHASH hash value of the Uncle block set. In Bitcoin, only when blocks are successfully dug out and accepted by other nodes can they be rewarded. This is a reward for all miners to strive for accounting rights and joint rewards. Simplechain is slightly different from Simplechain. It cannot be an orphan block in the main chain. If you are lucky enough to be taken into the block chain by later blocks, it will become an orphan block. Additional rewards will be given to the blocks that have retained the isolated blocks. Once a block becomes a block, the block will be rewarded. Reduce Simplechain soft forking and balance the benefits of miners with slow network speed through the block reward mechanism. miner Is an address, indicating that the block is dug by the miners of this account, and the mining reward will be issued to this account. stateRoot Is a hash value that indicates the snapshot ID of the Simplechain status after all transactions in this block are executed. Because Simplechain is described as a state machine system, the snapshot ID is called a state hash value. And because the status hash is generated by all account states according to Merkel prefix tree algorithm, it is called status Merkel tree root value. transactionsRoot Is a hash value, indicating that all transactions in the block generate a Merkel tree root node hash value. It is a cryptographic summary of guaranteed transactions. This Root can directly verify whether a transaction is included in this block. receiptRoot Is a hash value, which is also a hash value of Merkel tree root node. A collection of transaction receipt information generated after a block transaction is executed. logsBloom Is a 256-Byte array. Extract the self-receipt to quickly locate and find the intelligent contract event information in the transaction receipt. difficulty Is a big.Int value, indicating the difficulty coefficient that this block can be dug up. number Is the big.Int value, indicating the height of the block. It is used to mark the sequence number of a block. On a block chain, the block height must increase continuously. gasLimit Is the uint64 value, indicating the amount of Gas and fuel allowed to be consumed in this block. This value is dynamically adjusted based on the parent block. The purpose of the adjustment is to adjust the number of transactions that the block can contain. gasUsed Is the uint64 value, indicating the amount of Gas and fuel actually consumed during the execution of all transactions in this block. timestamp Is the value of uint64, which indicates the UTC timestamp of the block. Unit: seconds. Because Simplechain produces a block for an average of 14.5 seconds (12 seconds in the white paper), the block timestamp can be used as a timestamp service, but cannot be fully trusted. extraData Is a Byte array of unfixed length, up to 32 bits. It is completely customized by miners, who usually write some public promotion content or use it as a vote. mixHash Is a hash value. Check whether the block is correctly dug out. It is actually a hash value when the block header data does not contain nonce. nonce Is an 8-length Byte, which is actually a uint64 value. It is used to verify whether the block is correctly dug up. mixHash can only prove the PoW workload with a correct nonce. key code The following is the block header and block structure definition code defined in Simplechain code. All core codes are in the core/types/block.go file: //core/types/block.go:70 type Header struct { ParentHash common.Hash `json:\"parentHash\" gencodec:\"required\"` UncleHash common.Hash `json:\"sha3Uncles\" gencodec:\"required\"` Coinbase common.Address `json:\"miner\" gencodec:\"required\"` Root common.Hash `json:\"stateRoot\" gencodec:\"required\"` TxHash common.Hash `json:\"transactionsRoot\" gencodec:\"required\"` ReceiptHash common.Hash `json:\"receiptsRoot\" gencodec:\"required\"` Bloom Bloom `json:\"logsBloom\" gencodec:\"required\"` Difficulty *big.Int `json:\"difficulty\" gencodec:\"required\"` Number *big.Int `json:\"number\" gencodec:\"required\"` GasLimit uint64 `json:\"gasLimit\" gencodec:\"required\"` GasUsed uint64 `json:\"gasUsed\" gencodec:\"required\"` Time uint64 `json:\"timestamp\" gencodec:\"required\"` Extra []byte `json:\"extraData\" gencodec:\"required\"` MixDigest common.Hash `json:\"mixHash\"` Nonce BlockNonce `json:\"nonce\"` } type Body struct { Transactions []*Transaction Uncles []*Header } To create a block, call the NewBlock function: func NewBlock(header *Header, txs []*Transaction, uncles []*Header, receipts []*Receipt) *Block { b := &Block{header: CopyHeader(header), td: new(big.Int)} // TODO: panic if len(txs) != len(receipts) if len(txs) == 0 { b.header.TxHash = EmptyRootHash } else { b.header.TxHash = DeriveSha(Transactions(txs)) b.transactions = make(Transactions, len(txs)) copy(b.transactions, txs) } if len(receipts) == 0 { b.header.ReceiptHash = EmptyRootHash } else { b.header.ReceiptHash = DeriveSha(Receipts(receipts)) b.header.Bloom = CreateBloom(receipts) } if len(uncles) == 0 { b.header.UncleHash = EmptyUncleHash } else { b.header.UncleHash = CalcUncleHash(uncles) b.uncles = make([]*Header, len(uncles)) for i := range uncles { b.uncles[i] = CopyHeader(uncles[i]) } } return b } "},"10_transactionReceipt/":{"url":"10_transactionReceipt/","title":"Transaction Receipt","keywords":"","body":"Unlike bitcoin, Simplechain serves as an intelligent contract platform. When each transaction is executed as a message in the Simplechain virtual machine, a transaction Receipt is obtained. This transaction receipt records the processing result information about this transaction: The receipt information is divided into three parts: consensus information, transaction information, and block information. The following describes all kinds of information. Introduction to transaction receipt Transaction receipt consensus information Consensus means that this part of information is also involved in the verification when verifying the validity of the block. The reason for this information to participate in verification is to ensure that transactions must be executed in a fixed order in the block and record the status information after the transaction is executed. This can strengthen the transaction order. //core/state_processor.go:104 var root []byte if config.IsByzantium(header.Number) { statedb.Finalise(true) } else { root = statedb.IntermediateRoot(config.IsEIP158(header.Number)).Bytes() } //... receipt := types.NewReceipt(root, failed, *usedGas) CumulativeGasUsed：the accumulated Gas consumed by executed transactions in the block, including the current transaction. Logs: the list of smart contract events generated by the execution of the current transaction. Bloom：an event Bloom filter extracted from Logs to quickly detect whether an event on a topic exists in Logs. How does this information participate in consensus verification? In fact, only the receipt hash is involved in the verification, while the receipt hash calculation only contains this information. First, the root hash value of Merkel tree that obtains the receipt information of the entire block during verification. Then judge whether the hash value is the same as the content defined by the block header. //core/block_validator.go:92 receiptSha := types.DeriveSha(receipts) if receiptSha != header.ReceiptHash { return fmt.Errorf(\"invalid receipt root hash (remote: %x local: %x)\", header.ReceiptHash, receiptSha) } The root hash value generated by the function types. Metastesha is to form the Merck tree with the RLP encoding information of the list element (here is the transaction receipt), and finally obtain the hash value of the list. //core/types/derive_sha.go:32 func DeriveSha(list DerivableList) common.Hash { keybuf := new(bytes.Buffer) trie := new(trie.Trie) for i := 0; i The transaction receipt implements the RLP encoding interface. In the method EncodeRLP, a private tunntrlp is built. //core/types/receipt.go:119 func (r *Receipt) EncodeRLP(w io.Writer) error { return rlp.Encode(w, &receiptRLP{r.statusEncoding(), r.CumulativeGasUsed, r.Bloom, r.Logs}) } Transaction receipt transaction information This part of information records the transaction information corresponding to the receipt, including: TxHash ： the transaction hash corresponding to the transaction receipt. ContractAddress： records the address of the new contract when the transaction is deployed. //core/state_processor.go:118 if msg.To() == nil { receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce()) } GasUsed: the Gas handling fee consumed in the execution of this transaction Transaction receipt block information This part of information is to facilitate external reading of transaction receipts, not only to know the transaction execution, but also to specify the number of transactions in which block the transaction belongs. BlockHash: the hash of the block where the transaction is located. BlockNumber: the height of the block where the transaction is located. TransactionIndex：the sequence number of the transaction in the block. These three information are specified in real time when the transaction receipt is read from the Leveldb database. //core/rawdb/accessors_chain.go:315 receipts := make(types.Receipts, len(storageReceipts)) logIndex := uint(0) for i, receipt := range storageReceipts { //... receipts[i] = (*types.Receipt)(receipt) receipts[i].BlockHash = hash receipts[i].BlockNumber = big.NewInt(0).SetUint64(number) receipts[i].TransactionIndex = uint(i) } Transaction receipt structure Transaction receipt is the transaction execution result information sorted out according to the results after the Simplechain virtual machine processes the transaction. It reflects the Simplechain changes and transaction execution status before and after the transaction is executed. The construction details have already been mentioned before and will not be described in detail. The complete transaction receipt construction code is given here. // core/state_processor.go:94 context := NewEVMContext(msg, header, bc, author) vmenv := vm.NewEVM(context, statedb, config, cfg) _, gas, failed, err := ApplyMessage(vmenv, msg, gp) if err != nil { return nil, 0, err } var root []byte if config.IsByzantium(header.Number) { statedb.Finalise(true) } else { root = statedb.IntermediateRoot(config.IsEIP158(header.Number)).Bytes() } *usedGas += gas receipt := types.NewReceipt(root, failed, *usedGas) receipt.TxHash = tx.Hash() receipt.GasUsed = gas if msg.To() == nil { receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce()) } receipt.Logs = statedb.GetLogs(tx.Hash()) receipt.Bloom = types.CreateBloom(types.Receipts{receipt}) receipt.BlockHash = statedb.BlockHash() receipt.BlockNumber = header.Number receipt.TransactionIndex = uint(statedb.TxIndex()) return receipt, gas, err Transaction receipt storage As an intermediate product of transaction execution, the transaction receipt is used to quickly obtain the execution details of a transaction. Simplechain stores transaction receipts in real time when following block storage. However, in order to reduce the storage capacity, only necessary content is stored. First, convert the transaction receipt object to simplified content during storage. //core/rawdb/accessors_chain.go:338 storageReceipts := make([]*types.ReceiptForStorage, len(receipts)) for i, receipt := range receipts { storageReceipts[i] = (*types.ReceiptForStorage)(receipt) } Streamlined content is a structure that is specifically defined for storage. RLP encoding is used to store the transaction receipt set. //core/rawdb/accessors_chain.go:342 bytes, err := rlp.EncodeToBytes(storageReceipts) if err != nil { log.Crit(\"Failed to encode block receipts\", \"err\", err) } if err := db.Put(blockReceiptsKey(number, hash), bytes); err != nil { log.Crit(\"Failed to store block receipts\", \"err\", err) } Look at the EncodeRLP method of tunntforstorage to know what content is stored //core/types/receipt.go:179 func (r *ReceiptForStorage) EncodeRLP(w io.Writer) error { enc := &receiptStorageRLP{ PostStateOrStatus: (*Receipt)(r).statusEncoding(), CumulativeGasUsed: r.CumulativeGasUsed, TxHash: r.TxHash, ContractAddress: r.ContractAddress, Logs: make([]*LogForStorage, len(r.Logs)), GasUsed: r.GasUsed, } for i, log := range r.Logs { enc.Logs[i] = (*LogForStorage)(log) } return rlp.Encode(w, enc) } According to the EncodeRLP method, it can be concluded that only part of the content is stored during storage, and the Logs are also specially processed. LogForStorage "},"11_constructDesign/":{"url":"11_constructDesign/","title":"Structure Design","keywords":"","body":"The following figure shows the overall architecture of Simplechain: Top-level architecture design The blockchain can be simply divided into three layers: protocol layer, extension layer, and application layer. The protocol layer can be divided into storage layer and network layer, which are independent but inseparable. The top layer of Simplechain is DApp, which is the display layer of the entire blockchain. It exchanges with the intelligent contract layer through Web3.js. For example, Simplechain uses web3-js, the application layer of a blockchain can be a mobile terminal, a web terminal, or an existing server that is integrated into the application layer. All smart contracts run on EVM (virtual machines) and use RPC(Remote Procedure Call Protocol, which is A process method called by B through the network). Under EVM and RPC, there are four core contents of Simplechain, including blockChain, consensus algorithm, mining, and network layer. All parts except DApp are in the client sipe of Simplechain. From the perspective of data structure The protocol layer is the underlying technology. This layer is usually a complete blockchain product, similar to the operating system of our computer. It maintains network nodes and only provides APIs for calling. Network programming, distributed algorithm, encryption signature, data storage technology and other four aspects, distributed algorithm is basically a business logic implementation, can be achieved in any language, the encrypted signature technology is used directly and simply, and the database technology is also mainly used at the use level. Storage layer:A Block + Lian Biao and blockchain data structure. The database used in Simplechain is levelDB. Network layer:p2p network, the implementation of P2P network and concurrent processing are the difficulties in development, so for those languages with strong network programming ability and simple concurrent processing, block chain applications in Nodejs Development Zone, gradually becoming more and more popular, Go language began to be very popular. Consensus layer:That is, the incentive layer, through the mining mechanism, formulates the way of obtaining currency through the blockchain. For example, Bitcoin uses POW(Proof of Work workload): The better the performance of a computer, the easier it is to obtain monetary rewards. And POS(Proof of Stake equity certification mechanism): similar to the concept of crowdfunding dividends, it will pay interest to holders according to the amount and time of currency you hold. Extension layer:Similar to computer drivers, this part of Simplechain includes EVM (virtual machine) and intelligent contract. To make blockchain products more practical, such as Simplechain's \"smart contract\" concept, which is a typical application development at the expansion level. Contract layer:Previous blockchains did not have this layer. Therefore, the original blockchain can only conduct transactions, but cannot be used in other fields or other logical processing. But the emergence of contract layer and intelligent contract is \"programmable contract\", or \"contract intelligence\", in which \"intelligence\" is the intelligence of execution, that is to say, to reach a certain condition, the automatic execution of contracts makes the use of blockchains in other fields a reality. Application layer:Similar to various software programs in a computer, the display layer of the blockchain. DAPP is also an application at this level. It publishes smart contracts to the blockchain. People access this block through addresses and then interact with smart contracts. Simplechain uses web3-js. The application layer of a blockchain can be a mobile terminal, a web terminal, or an existing server that is integrated into the application layer. The DAPP developed based on this actually encapsulates a layer of Web applications on the basis of intelligent contracts. The issue of tokens and so on are all at this level, and interact with intelligent contracts through Web applications provided by DAPP. Aggregate chain architecture SimpleChain designs an aggregate chain structure of a main chain and multiple sub-chains, which supports blockchain deployment and expansion in various business scenarios. The SimpleChain main chain adopts the mature PoW mechanism, while the sub-chain can set consensus algorithms suitable for its own scenarios according to business requirements, and form a two-way anchoring method with the main chain through atomic exchange or cross-chain nodes, cross-chain transactions with other sub-chains. This main chain mechanism can help the sub-chain obtain the final consistency guarantee provided by the SimpleChain main chain on the premise of meeting thousands of levels of performance per second. The Simplechain sub-chain can be either a public chain or a consortium chain. Its chain structure is similar to that of the main chain (see blockchain architecture design). However, due to different business requirements, different consensus algorithms can be used to achieve thousands of TPS performance, or other custom development functions. The main chain and sub-chain achieve mutual anchoring, information exchange and capital flow through cross-chain protocols. The cross-chain protocol (see cross-chain protocol) adopts the free notary mechanism. All users in the whole network ecosystem can participate in and supervise it. The community's self-care ability can be effectively utilized to effectively ensure the reliability of cross-chain information, the transaction is safe and orderly. At the same time, Simplechain Foundation has carried out the research on the economic model of the main chain and established a set of incentive mechanism for the sustainable and healthy development of Simplechain ecosystem. Under the effect of this mechanism, the main chain ecosystem will integrate and promote each other, common development. "},"12_structAndStore/":{"url":"12_structAndStore/","title":"Data Struct and ","keywords":"","body":"The Block and transaction data of Simplechain are ultimately stored in Level DB In the database. Level DB A database is a key-value database. key is generally related to hash, while value is the RLP encoding for storing content. KV storage LevelDB Trigg tree Merkle Patricia Trie is a prefix tree that uses hash to index data. Macroscopically speaking, the triggtree is a prefix tree that uses key to query the value. To query the value by using the key is to use the key to index on the Modbus tree. After passing through multiple intermediate nodes, it finally reaches the leaf node where the data is stored. In terms of details, the triggtree is a Merkle tree. The index of each node on each tree is the hash value of this node. When using the key to search for a value, the hash value of the next node to be redirected and the hash value of the next node are obtained based on the fact that the key is within a certain node, you can retrieve the data of the next node from the underlying database, and then use the key to query the hash value of the next node in the next node until the leaf node where the value is located is reached. When the data of a leaf node on the Modbus tree is updated, the hash of the leaf node will also be updated, the hash of all intermediate nodes traced back to the root node by this leaf node is updated. Finally, the hash of the root node of the profiler is also updated. When you want to index this new data, use the new root node hash of profiler to find a new root node from the underlying database, and then traverse it layer by layer to finally find the new data. If you want to query historical data, you can use the old root hash to retrieve the old root node from the underlying database and traverse it down to query historical data. The implementation diagram of triggtree (the picture is from the Yellow Book of Ethereum) Account State On Simplechain, data is stored in account units. In each account, data such as the code, parameters, and nonce of the contract (user) are stored. The data of the account is indexed by the address of the account. As the account data changes, the hash of the account also changes. At the same time, the hash of the root of profiler also changes. When the account data is different, the root of the corresponding profiler is different. Here, Ethereum concretizes this layer of meaning and puts forward the concept of \"state. Call the hash of triggroot as state root. Different state root, corresponding to different \"states\", corresponding to the query of different Modbus root nodes, then, use the account address to query the account data in this status from the root node of different profiles. Different states may result in different amount of account queries, because the root node of the modifier is different. state root is a field in a block, and each block corresponds to a different \"state\". Transactions in the block operate on the account to change the data in the account. account data varies in different blocks, that is, the state of this block is different, specifically, the state root is different. Take the state root of the block from a certain block and query the root node of the profiler, then the data History of the account in the block can be indexed. 二、Index storage StormDB StormDB(a simple and powerful toolkit for BoltDB)is a boltDB-based database that supports indexing and search queries. Compared with traditional relational databases such as MySQL and Oracle, StormDB uses a single file storage without a separate service, SImplechain uses it to store cross-chain transactions for easier system migration. Noun explanation Bucket Storage unit of a custom object Id The primary key index of the stored object. The index is unique and cannot be duplicated. Index Sort indexes. Currently, only numeric fields (int8, int16, int32, int64, uint8, uint16, uint32, uint64) are supported, other types are sorted by byte comparison after encoding. Unique Unique hash index Options Query options, such as Limit, OrderBy, Skip, and so on. Matcher The input condition of the query. It supports Eq, Gt(greater than), Lt(less than), And, Or, Not, And Re (regular match). Example Take the cross-chain transaction storage structure as an example to explain the above terms. type CrossTransactionIndexed struct { PK uint64 `storm:\"id,increment\"` CtxId common.Hash `storm:\"unique\"` From common.Address `storm:\"index\"` To common.Address `storm:\"index\"` TxHash common.Hash `storm:\"index\"` Price *big.Float `storm:\"index\"` Status uint8 `storm:\"index\"` Value *big.Int BlockNum uint64 `storm:\"index\"` BlockHash common.Hash DestinationId *big.Int DestinationValue *big.Int `storm:\"index\"` Input []byte V []*big.Int R []*big.Int S []*big.Int } The explanation is as follows: storm:\"id,increment\"：indicates that this field is the primary key, and increment indicates that it automatically increments when inserted. storm:\"unique\"：indicates that this field uses a non-repeatable hash index. storm:\"index\"：indicates that this field uses a sort index. CRUD and transactions Insert object user := User{ ID: 10, Group: \"staff\", Email: \"john@provider.com\", Name: \"John\", Age: 21, CreatedAt: time.Now(), } err := db.Save(&user) // err == nil user.ID++ err = db.Save(&user) // err == storm.ErrAlreadyExists update object // Update multiple fields err := db.Update(&User{ID: 10, Name: \"Jack\", Age: 45}) // Update a single field err := db.UpdateField(&User{ID: 10}, \"Age\", 0) Delete object err := db.DeleteStruct(&user) Delete Bucket err := db.Drop(&User) //OR err := db.Drop(\"User\") Query object var users []User err := db.Find(\"Group\", \"staff\", &users, storm.Skip(10)) err = db.Find(\"Group\", \"staff\", &users, storm.Limit(10)) err = db.Find(\"Group\", \"staff\", &users, storm.Reverse()) err = db.Find(\"Group\", \"staff\", &users, storm.Limit(10), storm.Skip(10), storm.Reverse()) err = db.All(&users, storm.Limit(10), storm.Skip(10), storm.Reverse()) err = db.AllByIndex(\"CreatedAt\", &users, storm.Limit(10), storm.Skip(10), storm.Reverse()) err = db.Range(\"Age\", 10, 21, &users, storm.Limit(10), storm.Skip(10), storm.Reverse()) Conditional query query := db.Select(q.Gte(\"Age\", 7), q.Lte(\"Age\", 77)) var users []User err = query.Find(&users) Use transactions tx, err := db.Begin(true) if err != nil { return err } defer tx.Rollback() accountA.Amount -= 100 accountB.Amount += 100 err = tx.Save(accountA) if err != nil { return err } err = tx.Save(accountB) if err != nil { return err } return tx.Commit() Efficient memory multi-index storage To meet different index types and efficiency requirements, stormDB alone is difficult to meet. Therefore, a multi-index structure is introduced into the memory to store data with high read/write frequency. Hash index The hash indexes used in Simplechain are all hash indexes with unique key values, so map is directly used for storage. Insert and update idx := make(map[Key]Value) idx[key]=value Delete delete(idx,key) Read if v,ok := idx[key]; ok {//...} Sort index Simplechain uses red and black trees as sorting indexes to store any data type with sequence requirements. Initialization redblacktree.NewWith(container.UInt64Comparator, true) Insert and update idx.Put(key,value) Query itr := idx.Get(key) Delete key idx.Remove(key) Delete a specific object for it:=idx.LowerBound(key); it!=idx.UpperBound(key); it.Next() { if ... { idx.RemoveOne(itr) break } } "},"50_togetherStep.html":{"url":"50_togetherStep.html","title":"Data Synchronize","keywords":"","body":"Basic synchronization process Synchronization is a very important function of blockchain nodes. It is consensus to provide the consensus with the necessary operating conditions. Synchronization is divided into transaction synchronization and status synchronization. Transaction synchronization ensures that each transaction can reach each node correctly. Status synchronization can ensure that the backward nodes in the block can return to the latest status correctly. Only nodes with the latest block status can participate in the consensus. Transaction synchronization Transaction synchronization allows transactions on the blockchain to reach all nodes as much as possible. Provides the basis for packaging transactions into blocks in consensus. A transaction (tx1) is sent from the client to a node. After receiving the transaction, the node will put the transaction into its own transaction Pool (Tx Pool) for consensus packaging. At the same time, the node broadcasts the transaction to other nodes. After receiving the transaction, other nodes will also put the transaction into their own transaction pool. The transaction may be lost during the process of sending. In order to make the transaction reach all nodes as much as possible, the node that receives the broadcast transaction will choose other nodes according to a certain strategy, broadcast again. Transaction broadcast strategy If each node has no restrictions on forwarding or broadcasting received transactions, the bandwidth will be occupied and the transaction broadcast avalanche will occur. In order to avoid the avalanche of transaction Broadcasting, Simplechain chose a relatively delicate transaction broadcasting strategy based on experience. On the premise of ensuring the reachability of the transaction as much as possible, reduce the repeated transaction broadcast as much as possible. For transactions from the SDK, broadcast to all nodes A transaction is broadcast only once on a node. When a duplicate transaction is received, no secondary broadcast is performed. Through the above strategy, transactions can reach all nodes as much as possible, but a transaction cannot reach a node with a minimum probability. This situation is allowed. The purpose of reaching as many nodes as possible is to package, reach consensus, and confirm the transaction as soon as possible, so that the transaction can be executed as quickly as possible. When the transaction does not reach a certain node, the transaction execution time will only be longer and the correctness of the transaction will not be affected. Status synchronization Status synchronization is to keep the status of blockchain nodes up to date. The status of a blockchain is the new and old data that a blockchain node currently holds, that is, the height of the current block that a node holds. If the block height of a node is the highest block height of the blockchain, the node has the latest status of the blockchain. Only nodes with the latest status can participate in the consensus and carry out the consensus of the next new district. When a new node is added to the blockchain, or a node that has been disconnected is restored to the network, the block of this node lags behind other nodes, and the status is not up to date. Status synchronization is required. As shown in the figure, the Node (Node 1) that needs state synchronization initiatively requests other nodes to download the block. During the entire download process, the download load is distributed to multiple nodes. Status synchronization and Download Queue When a blockchain node is running, it regularly broadcasts its highest block height to other nodes. After a node receives the block height broadcasted by other nodes, it compares it with its own block height. If its own block height falls behind this block height, the block download process is started. The download of the block is completed by request. The node that enters the download process randomly selects the node that meets the requirements and sends the block interval to be downloaded. The node that receives the download request will reply to the corresponding block based on the request content. The node that receives the reply block maintains a download queue locally to buffer and sort the downloaded blocks. A download queue is a priority queue in order of block heights. The downloaded blocks are continuously inserted into the Download Queue. When the blocks in the queue can connect to the current local blockchain of the node, the blocks are taken out of the download queue, connect to the current local blockchain. Examples of synchronization scenarios Transaction synchronization The process of broadcasting a transaction to all nodes: A transaction is sent to a node through a channel or RPC The node that receives the transaction broadcasts the transaction to other nodes in full. After other nodes receive the transaction, to be on the safe side, select 25% of the nodes to broadcast again The node receives a broadcast transaction and will not broadcast it again Status synchronization Broadcast logic when node blocks Outbound block of a node This section broadcasts its latest status (latest block height, highest block hash, Genesis block hash) to all nodes After other nodes receive the peer status, the peer data managed locally is updated. "},"13_p2pNetwork.html":{"url":"13_p2pNetwork.html","title":"p2p network","keywords":"","body":"Design objectives Simplechain P2P The module provides efficient, universal, and secure basic network communication functions, supports unicast, multicast, and broadcast of blockchain messages, supports status synchronization of blockchain nodes, and supports multiple protocols. Main functions of P2P Blockchain Node Identification: A blockchain node is uniquely identified by the blockchain Node Identification, and the blockchain node is addressed by the blockchain node identification on the blockchain network. Manage network connections: Maintain long TCP connections between blockchain nodes on the blockchain network, automatically disconnect abnormal connections, and automatically lift connections Message sending and receiving: Unicast, multicast, or broadcast messages between blockchain nodes in the blockchain network Status synchronization: Synchronization status between blockchain nodes Simplechain Node Identification The Node Identification of Simplechain is generated by the public key of the ECC algorithm. Each blockchain node must have a unique ECC key pair. The Node Identification uniquely identifies a blockchain node in the blockchain network. In general, to join a blockchain network, a node key node.key file in ECC format is required. In addition to the unique blockchain Node Identification, Simplechain nodes can also focus on topics for addressing. Simplechain node addressing: Blockchain Node Identification addressing: Use the blockchain Node Identification to locate a unique blockchain node in the blockchain network. Topic addressing: Use the Topic to locate a group of nodes that focus on the Topic in the blockchain network. Manage network connections A long TCP connection is automatically initiated and maintained between Simplechain nodes. When a system fault or network exception occurs, the connection is automatically restarted. When a connection is established between nodes, the CA certificate is used for authentication. Connection establishment process participant node A participant node B Node A->>Node A: Load the Key Node B->>Node B: Load the key Node A->>NOde B: Initiate the connection Node B->>Node A: Successful Node B->Node A: Initiate SSL handshake Node B->Node A: Successful handshake, establish SSL connection Sending and receiving messages Messages between nodes support unicast, multicast, and broadcast. Unicast: a single node sends a message to a single blockchain node and identifies the address through the blockchain node. Multicast: a single node sends messages to a group of blockchain nodes through Topic addressing Broadcast: a single node sends messages to all blockchain nodes Unicast process sequenceDiagram participant node A participant node B node A->>node A: Filter online nodes based on node ID node A->>node B: Send message node B->>node A: message return packet Multicast process sequenceDiagram participant node A participant node B participant node C participant node D node A->>node A: 根据Topic 1，选择节点B、C node A->>node B: 发送消息 nide A->>node C: 发送消息 node B->>node B: 根据Topic 2，选择节点C、D node B->>node C: 发送消息 node B->>node D: 发送消息 node C->>node C: 根据Topic 3，选择节点D node C->>node B: 发送消息 Broadcast process sequenceDiagram participant node A participant node B participant node C participant node D 节点A->>节点A: 遍历所有节点ID 节点A->>节点B: 发送消息 节点A->>节点C: 发送消息 节点A->>节点D: 发送消息 节点B->>节点B: 遍历所有节点ID 节点B->>节点C: 发送消息 节点B->>节点D: 发送消息 节点C->>节点C: 遍历所有节点ID 节点C->>节点D: 发送消息 Status synchronization Each node maintains its own state, broadcasts the Seq of the state on the whole network at a fixed time, and synchronizes it with other nodes. sequenceDiagram participant node A participant node B node A->node B: 广播seq node A->>node A: 判断节点B的seq是否变化 node A->>node B: seq变化，发起状态查询请求 node B->>node A: 返回节点状态 node A->>node A: 更新节点B的状态和seq "},"14_consensus/":{"url":"14_consensus/","title":"Consensus mechanism","keywords":"","body":"Consensus mechanism is an algorithm for distributed consensus of blockchain transactions. Due to high or low network latency in a point-to-point network, the order of transactions received by each node may be different, therefore, the blockchain system needs to design a mechanism to enable nodes to reach a consensus on the order of transactions that occur at about the same time. This is the consensus mechanism. PoW consensus algorithm PoW proves that you have completed the characteristics of the corresponding work hash function through the work results: Collision-free, that is, there is no case where the input values are different and the hash values are the same after hash transformation. Concealment, that is, given a hash value, it is infeasible to reverse the input value. There is no better method than exhaustive to make hash values fall within a specific range. POW algorithm principle: the node searches for the appropriate hash value by constantly changing random numbers. When the node first calculates the appropriate hash value, if the packaged block passes the verification of other consensus nodes, it is added to the blockchain. Introduction to Scrypt algorithm The mining algorithm adopted by Simplechain is Scrypt algorithm. Scrypt is a memory-dependent POW algorithm that conforms to the PoW consensus mechanism. The Scrypt algorithm also needs to calculate the hash value, but more memory resources are needed in the Scrypt calculation process. Scrypt algorithm process Several functions used by the Scrypt algorithm are interlocking. This section describes the calling order of the functions from inside to outside. Salsa20/8 #define R(a,b) (((a) > (32 - (b)))) void salsa20_word_specification(uint32 out[16],uint32 in[16]) { int i; uint32 x[16]; for (i = 0;i 0;i -= 2) { x[ 4] ^= R(x[ 0]+x[12], 7); x[ 8] ^= R(x[ 4]+x[ 0], 9); x[12] ^= R(x[ 8]+x[ 4],13); x[ 0] ^= R(x[12]+x[ 8],18); x[ 9] ^= R(x[ 5]+x[ 1], 7); x[13] ^= R(x[ 9]+x[ 5], 9); x[ 1] ^= R(x[13]+x[ 9],13); x[ 5] ^= R(x[ 1]+x[13],18); x[14] ^= R(x[10]+x[ 6], 7); x[ 2] ^= R(x[14]+x[10], 9); x[ 6] ^= R(x[ 2]+x[14],13); x[10] ^= R(x[ 6]+x[ 2],18); x[ 3] ^= R(x[15]+x[11], 7); x[ 7] ^= R(x[ 3]+x[15], 9); x[11] ^= R(x[ 7]+x[ 3],13); x[15] ^= R(x[11]+x[ 7],18); x[ 1] ^= R(x[ 0]+x[ 3], 7); x[ 2] ^= R(x[ 1]+x[ 0], 9); x[ 3] ^= R(x[ 2]+x[ 1],13); x[ 0] ^= R(x[ 3]+x[ 2],18); x[ 6] ^= R(x[ 5]+x[ 4], 7); x[ 7] ^= R(x[ 6]+x[ 5], 9); x[ 4] ^= R(x[ 7]+x[ 6],13); x[ 5] ^= R(x[ 4]+x[ 7],18); x[11] ^= R(x[10]+x[ 9], 7); x[ 8] ^= R(x[11]+x[10], 9); x[ 9] ^= R(x[ 8]+x[11],13); x[10] ^= R(x[ 9]+x[ 8],18); x[12] ^= R(x[15]+x[14], 7); x[13] ^= R(x[12]+x[15], 9); x[14] ^= R(x[13]+x[12],13); x[15] ^= R(x[14]+x[13],18); } for (i = 0;i scryptBlockMix Parameters: r Block size parameter. Input: B[0] || B[1] || ... || B[2 * r - 1] Input octet string (of size 128 * r octets), treated as 2 * r 64-octet blocks, where each element in B is a 64-octet block. Output: B'[0] || B'[1] || ... || B'[2 * r - 1] Output octet string. Steps: 1. X = B[2 * r - 1] 2. for i = 0 to 2 * r - 1 do T = X xor B[i] X = Salsa (T) Y[i] = X end for 3. B' = (Y[0], Y[2], ..., Y[2 * r - 2], Y[1], Y[3], ..., Y[2 * r - 1]) scryptROMix Input: r Block size parameter. B Input octet vector of length 128 * r octets. N CPU/Memory cost parameter, must be larger than 1, a power of 2, and less than 2^(128 * r / 8). Output: B' Output octet vector of length 128 * r octets. Steps: 1. X = B 2. for i = 0 to N - 1 do V[i] = X X = scryptBlockMix (X) end for 3. for i = 0 to N - 1 do j = Integerify (X) mod N where Integerify (B[0] ... B[2 * r - 1]) is defined as the result of interpreting B[2 * r - 1] as a little-endian integer. T = X xor V[j] X = scryptBlockMix (T) end for 4. B' = X scrypt Input: P Passphrase, an octet string. S Salt, an octet string. N CPU/Memory cost parameter, must be larger than 1, a power of 2, and less than 2^(128 * r / 8). r Block size parameter. p Parallelization parameter, a positive integer less than or equal to ((2^32-1) * hLen) / MFLen where hLen is 32 and MFlen is 128 * r. dkLen Intended output length in octets of the derived key; a positive integer less than or equal to (2^32 - 1) * hLen where hLen is 32. Output: DK Derived key, of length dkLen octets. Steps: 1. Initialize an array B consisting of p blocks of 128 * r octets each: B[0] || B[1] || ... || B[p - 1] = PBKDF2-HMAC-SHA256 (P, S, 1, p * 128 * r) 2. for i = 0 to p - 1 do B[i] = scryptROMix (r, B[i], N) end for 3. DK = PBKDF2-HMAC-SHA256 (P, B[0] || B[1] || ... || B[p - 1], 1, dkLen) In the mining algorithm, the selected parameters are: P：block header; S：block header; N：fixed as 1024; r：fixed as 1; p：fixed as 1; dkLen：fixed to 32, that is, the output length is 32 bytes. Therefore, the hash value of the block header of the Wright coin is powhash = scrypt(blockheader, blockheader, 1024, 1, 1, 32). You can refer to the Go language version for obtaining the block header hash in Wright coin. // Copyright (c) 2013-2016 The btcsuite developers // Use of this source code is governed by an ISC // license that can be found in the LICENSE file. package wire import ( \"bytes\" \"io\" \"time\" \"golang.org/x/crypto/scrypt\" \"github.com/ltcsuite/ltcd/chaincfg/chainhash\" ) // MaxBlockHeaderPayload is the maximum number of bytes a block header can be. // Version 4 bytes + Timestamp 4 bytes + Bits 4 bytes + Nonce 4 bytes + // PrevBlock and MerkleRoot hashes. const MaxBlockHeaderPayload = 16 + (chainhash.HashSize * 2) // BlockHeader defines information about a block and is used in the bitcoin // block (MsgBlock) and headers (MsgHeaders) messages. type BlockHeader struct { // Version of the block. This is not the same as the protocol version. Version int32 // Hash of the previous block header in the block chain. PrevBlock chainhash.Hash // Merkle tree reference to hash of all transactions for the block. MerkleRoot chainhash.Hash // Time the block was created. This is, unfortunately, encoded as a // uint32 on the wire and therefore is limited to 2106. Timestamp time.Time // Difficulty target for the block. Bits uint32 // Nonce used to generate the block. Nonce uint32 } // blockHeaderLen is a constant that represents the number of bytes for a block // header. const blockHeaderLen = 80 // BlockHash computes the block identifier hash for the given block header. func (h *BlockHeader) BlockHash() chainhash.Hash { // Encode the header and double sha256 everything prior to the number of // transactions. Ignore the error returns since there is no way the // encode could fail except being out of memory which would cause a // run-time panic. buf := bytes.NewBuffer(make([]byte, 0, MaxBlockHeaderPayload)) _ = writeBlockHeader(buf, 0, h) return chainhash.DoubleHashH(buf.Bytes()) } // PowHash returns the litecoin scrypt hash of this block header. This value is // used to check the PoW on blocks advertised on the network. func (h *BlockHeader) PowHash() (*chainhash.Hash, error) { var powHash chainhash.Hash buf := bytes.NewBuffer(make([]byte, 0, MaxBlockHeaderPayload)) _ = writeBlockHeader(buf, 0, h) scryptHash, err := scrypt.Key(buf.Bytes(), buf.Bytes(), 1024, 1, 1, 32) if err != nil { return nil, err } copy(powHash[:], scryptHash) return &powHash, nil } // BtcDecode decodes r using the bitcoin protocol encoding into the receiver. // This is part of the Message interface implementation. // See Deserialize for decoding block headers stored to disk, such as in a // database, as opposed to decoding block headers from the wire. func (h *BlockHeader) BtcDecode(r io.Reader, pver uint32, enc MessageEncoding) error { return readBlockHeader(r, pver, h) } // BtcEncode encodes the receiver to w using the bitcoin protocol encoding. // This is part of the Message interface implementation. // See Serialize for encoding block headers to be stored to disk, such as in a // database, as opposed to encoding block headers for the wire. func (h *BlockHeader) BtcEncode(w io.Writer, pver uint32, enc MessageEncoding) error { return writeBlockHeader(w, pver, h) } // Deserialize decodes a block header from r into the receiver using a format // that is suitable for long-term storage such as a database while respecting // the Version field. func (h *BlockHeader) Deserialize(r io.Reader) error { // At the current time, there is no difference between the wire encoding // at protocol version 0 and the stable long-term storage format. As // a result, make use of readBlockHeader. return readBlockHeader(r, 0, h) } // Serialize encodes a block header from r into the receiver using a format // that is suitable for long-term storage such as a database while respecting // the Version field. func (h *BlockHeader) Serialize(w io.Writer) error { // At the current time, there is no difference between the wire encoding // at protocol version 0 and the stable long-term storage format. As // a result, make use of writeBlockHeader. return writeBlockHeader(w, 0, h) } // NewBlockHeader returns a new BlockHeader using the provided version, previous // block hash, merkle root hash, difficulty bits, and nonce used to generate the // block with defaults for the remaining fields. func NewBlockHeader(version int32, prevHash, merkleRootHash *chainhash.Hash, bits uint32, nonce uint32) *BlockHeader { // Limit the timestamp to one second precision since the protocol // doesn't support better. return &BlockHeader{ Version: version, PrevBlock: *prevHash, MerkleRoot: *merkleRootHash, Timestamp: time.Unix(time.Now().Unix(), 0), Bits: bits, Nonce: nonce, } } // readBlockHeader reads a bitcoin block header from r. See Deserialize for // decoding block headers stored to disk, such as in a database, as opposed to // decoding from the wire. func readBlockHeader(r io.Reader, pver uint32, bh *BlockHeader) error { return readElements(r, &bh.Version, &bh.PrevBlock, &bh.MerkleRoot, (*uint32Time)(&bh.Timestamp), &bh.Bits, &bh.Nonce) } // writeBlockHeader writes a bitcoin block header to w. See Serialize for // encoding block headers to be stored to disk, such as in a database, as // opposed to encoding for the wire. func writeBlockHeader(w io.Writer, pver uint32, bh *BlockHeader) error { sec := uint32(bh.Timestamp.Unix()) return writeElements(w, bh.Version, &bh.PrevBlock, &bh.MerkleRoot, sec, bh.Bits, bh.Nonce) } POA consensus algorithm Background of POA generation If you want to use Simplechain to build a private chain with lower transaction costs, lower transaction latency, and higher concurrency, also have full control (meaning lower probability of being attacked). Currently, Simplechain cannot meet the requirements by using PoW. First of all, pow has a 51% attack problem. Malicious miners who exceed 51% of the total network computing power can basically fully control the entire network. Because the chain cannot be changed, the data that has been linked cannot be changed, but malicious miners can also do some DoS attacks to prevent legitimate transactions from being linked, considering that absenteeism with the same creation block can join your network, potential security risks will exist for a long time. Secondly, a large amount of PoW power resource consumption also needs to be considered as follow-up cost. PoS can solve some Pow problems, such as saving power and protecting 51% of attacks to a certain extent (malicious absenteeism will be punished), but there are still deficiencies in control and security considerations, because PoS still allows any eligible absenteeism to join. Features of POA PoA relies on the default authorized nodes (signers) to generate blocks. A new signer can be elected by an authorized signer (voting more than 50%) to join the new signer. Even if a malicious signer exists, it can only attack one of the consecutive blocks (the number is (SIGNER_COUNT / 2) +1). During this period, other signers can vote to kick the malicious signer. You can specify the time when the block is generated. The workflow of POA is as follows Specify a group of initially authorized signers in the creation block. All addresses are stored in the Extra field of the creation block. After mining is started, the group of signers begin to sign and broadcast the generated block. The signature results are saved in the Extra field of the block header. Update the addresses of all currently highly authorized signers in Extra because there are new signers added or kicked out Each height has a signer IN the IN-TURN State and other signers IN the OUT-OF-TURN state. The block signed by the signer IN-TURN will be broadcast immediately, the OUT-OF-TURN signer-signed block will be broadcast after a little random time delay to ensure that the IN-TURN signature block has a higher priority. If a new signer needs to be added, the signer initiates a proposal through the API interface, which uses the block header Coinbase (new signer address) and Nonce(\"0xffffffffffff\") fields are broadcast to other nodes. All authorized signers vote for the new signer. If the affirmative vote exceeds 50% of the total number of signers, they agree to join If an old signer needs to be kicked out, all authorized signers will \"kick out\" the old signer. If the affirmative vote exceeds 50% of the total number of signers, it means they agree to kick out. How to Select POA consensus algorithm in Simplechain Download and generate a new genesis block file, Download Address After the download is complete, run the command Generate genesis block In the process of generating the creation block file, you can choose the consensus algorithm you want. As shown below: "},"15_virtualMache/":{"url":"15_virtualMache/","title":"virtual machine","keywords":"","body":"On Simplechain, you can run the contract deployed on Simplechain to complete the operations that require consensus. Simplechain virtual machine is the executor of intelligent contract code. Therefore, when the smart contract is compiled into a binary file, it is deployed on Simplechain. The user calls the smart contract interface to trigger the execution of the smart contract. EVM executes the code of the smart contract to modify the data (status) on the current blockchain. The modified data will be agreed to ensure consistency. SVMC EVM can be stripped from Simplechain to form an independent module. The interaction between EVM and nodes abstracts the SVMC interface standard. Through the SVMC interface standard, nodes can connect to a variety of virtual machines, not limited to traditional solidity-based virtual machines. The traditional solidity virtual machine is called interpreter in Simplechain. The implementation of the interpreter is mainly explained in the following section. SVMC interface SVMC mainly defines two calling interfaces: Instance interface: the interface that the node calls EVM Callback interface: the interface of the EVM Callback node. EVM itself does not save status data. The node operates EVM through the instance interface. In turn, EVM calls the Callback interface to operate the status of the node. Instance interface Defines the operations of nodes on virtual machines, including creation, destruction, and setting. The interface is defined in evmc_instance(evmc.h) abi_version name version destroy execute set_tracer set_option Callback interface Defines how EVM operates on nodes, mainly reading and writing state and block information. The interface is defined in evmc_context_fn_table(evmc.h). evmc_account_exists_fn account_exists evmc_get_storage_fn get_storage evmc_set_storage_fn set_storage evmc_get_balance_fn get_balance evmc_get_code_size_fn get_code_size evmc_get_code_hash_fn get_code_hash evmc_copy_code_fn copy_code evmc_selfdestruct_fn selfdestruct evmc_call_fn call evmc_get_tx_context_fn get_tx_context evmc_get_block_hash_fn get_block_hash evmc_emit_log_fn emit_log EVM execution EVM instruction ssolidity is the execution language of the contract. solidity is compiled by solc and becomes an EVM instruction similar to assembly. The Interpreter defines a complete set of instructions. After solidity is compiled, a binary file is generated. The binary file is a collection of EVM instructions. The transaction is sent to the node in the form of binary. After the node receives it, it calls EVM to execute these instructions through SVMC. In EVM, the logic of these instructions is simulated with code. Solidity is a stack-based language. When EVM executes binary, it is also called as a stack. Arithmetic instruction example An ADD instruction. The code in EVM is implemented as follows. SP is the pointer of the stack, from the first and second positions on the top of the stack（SP[0]、SP[1]）take out the data, add and write it to the top of the result stack SP SPP[0]。 CASE(ADD) { ON_OP(); updateIOGas(); // pops two items and pushes their sum mod 2^256. m_SPP[0] = m_SP[0] + m_SP[1]; } Jump instruction example The JUMP command realizes the JUMP between binary codes. First from the top of the stack SP[0] Take out the address to be redirected, verify whether it is out of line, and put it in the program counter PC. The next instruction will start from the position pointed by the PC. CASE(JUMP) { ON_OP(); updateIOGas(); m_PC = verifyJumpDest(m_SP[0]); } Example of state read instruction SLOAD can query status data. The general process is from the top of the stackSP[0]take out the key to be accessed, take the key as a parameter, and then adjust the callback function of evmcget_storage()，To query the value of the corresponding key. Then write the read value to the top of the result stack SPP SPP[0]。 CASE(SLOAD) { m_runGas = m_rev >= EVMC_TANGERINE_WHISTLE ? 200 : 50; ON_OP(); updateIOGas(); evmc_uint256be key = toEvmC(m_SP[0]); evmc_uint256be value; m_context->fn_table->get_storage(&value, m_context, &m_message->destination, &key); m_SPP[0] = fromEvmC(value); } Example of state write instruction The SSTORE command can write data to the state of a node. The general process is from the first and second positions at the top of the stack（SP[0]、SP[1]）take out key and value, take key and value as parameters, and call the callback function of evmc set_storage() , write the status of the node. CASE(SSTORE) { ON_OP(); if (m_message->flags & EVMC_STATIC) throwDisallowedStateChange(); static_assert( VMSchedule::sstoreResetGas fn_table->set_storage(m_context, &m_message->destination, &key, &value); if (status == EVMC_STORAGE_ADDED) { // Charge additional amount for added storage item. m_runGas = VMSchedule::sstoreSetGas - VMSchedule::sstoreResetGas; updateIOGas(); } } Contract call instruction example The CALL instruction can CALL another contract based on the address. First, EVM determines that the CALL instruction is called caseCall()，caseCall() usedcaseCallSetup()Take the data from the stack, encapsulate it into msg, and call evmc's callback function as a parameter. Eth is being called backcall()after，Start a new EVM, process the call, and then execute the result of the new EVM bycall()```parameter is returned to the current EVM. The current EVM writes the result to the result stack SSP and the call ends. The logic of contract creation is similar to this logic. CASE(CALL) CASE(CALLCODE) { ON_OP(); if (m_OP == Instruction::DELEGATECALL && m_rev flags & EVMC_STATIC && m_SP[2] != 0) throwDisallowedStateChange(); m_bounce = &VM::caseCall; } BREAK void VM::caseCall() { m_bounce = &VM::interpretCases; evmc_message msg = {}; // Clear the return data buffer. This will not free the memory. m_returnData.clear(); bytesRef output; if (caseCallSetup(msg, output)) { evmc_result result; m_context->fn_table->call(&result, m_context, &msg); m_returnData.assign(result.output_data, result.output_data + result.output_size); bytesConstRef{&m_returnData}.copyTo(output); m_SPP[0] = result.status_code == EVMC_SUCCESS ? 1 : 0; m_io_gas += result.gas_left; if (result.release) result.release(&result); } else { m_SPP[0] = 0; m_io_gas += msg.gas; } ++m_PC; } Summary EVM is a state execution machine. The input is the binary instruction compiled by solidity and the state data of the node. The output is the change of the node state. Simplechain implements compatibility with various virtual machines through EVMC. "},"16_runMechanism/":{"url":"16_runMechanism/","title":"Operating mechanism","keywords":"","body":"Simplechain model description Simplechain is essentially a transaction-based state machine. In computer science, a state machine refers to something that can read a series of inputs and then convert them into a new state. According to Simplechain's state machine, we start with genesis state. There is no transaction generation status in the network. When the transaction is executed, the Genesis state will turn into the final state. At any time, this final state represents the current state of Simplechain. Simplechain has millions of transactions in the state. These transactions are \"grouped\" into a block. A block contains a series of transactions, and each block is linked to its previous block. In order to convert a state to the next state, the transaction must be valid. In order to make a transaction considered effective, it must go through a verification process, which is mining. Mining is a group of nodes (computers) that use their computing resources to create a block containing valid transactions. To add a block to the main chain, a miner must provide this \"proof\" faster than other miners \". The process of verifying each block through a \"proof\" of mathematical mechanism provided by miners is called proof of work. It is proved that miners in a new area will be rewarded with a certain value. What is the reward? Simplechain uses an internal digital token-Sipc as a reward. Every time a miner proves a new block, a new Sipc will be generated and rewarded to the miner. Whenever multiple paths are generated, a \"fork\" will appear. We usually want to avoid forking, because they will destroy the system and force people to choose which chain they believe. In order to determine which path is the most effective and prevent the generation of multiple chains, Simplechain uses a mathematical mechanism called \"GHOST protocol.。 GHOST = Greedy Heaviest Observed Subtree In short, the GHOST Protocol allows us to select a path on which the most calculations are completed. One way to determine the path is to use the block number of the nearest block (leaf block). The block number represents the total number of blocks on the current path (excluding Genesis blocks). The larger the block number is, the longer the path is, indicating that more mining computing power is consumed on this path to reach the leaf block. Using this reasoning can allow us to agree with the authoritative version of the current state. "},"17_unusual.html":{"url":"17_unusual.html","title":"Handle exceptions","keywords":"","body":"An error was reported when calling the contract Possible problems: The common problem is that the contract execution fails. When the contract execution fails, Simplechain prompts that the cause of the error is generally not very intuitive and may not be related to the error. 1.Insufficient tokens and balances in the contract account; 2.Whether the current operating account has permissions; 3.Contract execution failed. spring boot applications use web3j You can directly use the spring boot dependency package that web3j-spring-boot-starter depends on without repeatedly depending on the spring boot package. org.web3j web3j-spring-boot-starter 1.6.0 Does the spring boot application use web3J dependency to report an error The gradle I used in the demo depends on web3j, and there is no problem when the function is completed. In the formal project, the code that maven depends on web3j package is reported as the same, but no specific problem can be found. If you use maven to rely on web3j 3.5.0, an error is reported. If you use web3j 3.6.0, the same error is reported. The error message is as follows: at java.net.URLClassLoader.findClass(URLClassLoader.java:382) ~[na:1.8.0_191] at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_191] at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349) ~[na:1.8.0_191] at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_191] at org.web3j.crypto.Sign.(Sign.java:34) ~[crypto-3.5.0.jar:na] at org.web3j.crypto.ECKeyPair.create(ECKeyPair.java:68) ~[crypto-3.5.0.jar:na] at org.web3j.crypto.Credentials.create(Credentials.java:36) ~[crypto-3.5.0.jar:na] Solution: After troubleshooting, the reason is that the download of some files is incomplete when maven downloads the web3j dependency, and the ec package does not exist, Delete the downloaded web3j dependency package in the maven local repository, download the maven tool, and use the command to clear and install dependencies in the project directory. ->mvn clean ->mvn install Open Idea and refresh the project to compile and run normally. we3j reports an error when \"import ./safeERC20.sol\" is used in the file when compiling the. sol file. The import file cannot be found. The solution is to write the import contract or libary to the current file. "},"18_contract/":{"url":"18_contract/","title":"Smart contract","keywords":"","body":"Simplechain's smart contract is not a common contract in reality, but a piece of program code that exists on the blockchain and can be triggered to execute. These codes implement some predetermined rules, is an \"autonomous proxy\" that exists in the Simplechain execution environment \". Simplechain's account and contract are shown in Figure 1. The intelligent contract design of Simplechain is concise Anyone can develop smart contracts on the Simplechain Blockchain. The code of these smart contracts exists in the account of Simplechain, and the account with code is called the contract account. Correspondingly, an account controlled by a key can be called an external account. The smart contract program of Simplechain runs on the Simplechain virtual machine. The contract account cannot start and run its own smart contract. To run a smart contract, an external account needs to initiate a transaction with the contract account to start the execution of the code in it. A major difference between Simplechain and bitcoin is that Simplechain provides Turing's complete programming language (Solidity) and the corresponding operating environment (EVM). The so-called Turing completeness means that this scripting programming language can run all possible calculations, while bitcoin UTXO models and scripts can only run partial calculations. The most popular intelligent contract language in Simplechain is Solidity, which is similar to classes in object-oriented languages. The contract contains state variables for data persistence and functions that can modify state variables. When a function of another contract instance is called, an EVM function is called. This operation switches the context of the execution, so that the status variable of the previous contract cannot be accessed. "},"19_understandSolidity/":{"url":"19_understandSolidity/","title":"understand Solidity","keywords":"","body":"Solidity源文件结构 源文件中可以包含任意多个合约定义、导入指令和杂注指令。 版本杂注 为了避免未来被可能引入不兼容变更的编译器所编译，源文件可以（也应该）被所谓的版本杂注所注解。我们力图把这类变更做到尽可能小，特别是，我们需要以一种当修改语义时必须同步修改语法的方式引入变更，当然这有时候也难以做到。因此，至少对含重大变更的版本，通读变更日志永远是好办法。这些版本的版本号始终是 0.x.0 或者 x.0.0 的形式。 版本杂注使用如下:: pragma solidity ^0.4.0; 这样，源文件将既不允许低于 0.4.0 版本的编译器编译，也不允许高于（包含） 0.5.0 版本的编译器编译（第二个条件因使用 ^ 被添加）。这种做法的考虑是，编译器在 0.5.0 版本之前不会有重大变更，所以可确保源代码始终按预期被编译。上面例子中不固定编译器的具体版本号，因此编译器的补丁版也可以使用。 可以使用更复杂的规则来指定编译器的版本，表达式遵循 npm 版本语义。 Pragma 是 pragmatic information 的简称，微软 Visual C++ 文档 中译为杂注。Solidity 中沿用 C ，C++ 等中的编译指令概念，用于告知编译器 如何 编译。 ——译者注 导入其他源文件 语法与语义 虽然 Solidity 不知道 \"default export\" 为何物，但是 Solidity 所支持的导入语句，其语法同 JavaScript（从 ES6 起）非常类似。 ES6 即 ECMAScript 6.0，ES6是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布。 ——译者注 在全局层面上，可使用如下格式的导入语句： import \"filename\"; 此语句将从 “filename” 中导入所有的全局符号到当前全局作用域中（不同于 ES6，Solidity 是向后兼容的）。 import * as symbolName from \"filename\"; 创建一个新的全局符号 symbolName，其成员均来自 \"filename\" 中全局符号。 import {symbol1 as alias, symbol2} from \"filename\"; 创建新的全局符号 alias 和 symbol2，分别从 \"filename\" 引用 symbol1 和 symbol2 。 另一种语法不属于 ES6，但或许更简便： import \"filename\" as symbolName; 这条语句等同于 import * as symbolName from \"filename\";。 路径 上文中的 filename 总是会按路径来处理，以 / 作为目录分割符、以 . 标示当前目录、以 .. 表示父目录。 当 . 或 .. 后面跟随的字符是 / 时，它们才能被当做当前目录或父目录。 只有路径以当前目录 . 或父目录 .. 开头时，才能被视为相对路径。 用 import \"./x\" as x; 语句导入当前源文件同目录下的文件 x 。 如果用 import \"x\" as x; 代替，可能会引入不同的文件（在全局 include directory 中）。 最终导入哪个文件取决于编译器（见下文）到底是怎样解析路径的。 通常，目录层次不必严格映射到本地文件系统， 它也可以映射到能通过诸如 ipfs，http 或者 git 发现的资源。 在实际的编译器中使用 当运行编译器时，它不仅能指定如何发现路径的第一个元素，还可指定路径前缀 |remapping|。 例如，github.com/ethereum/dapp-bin/library 会被重映射到 /usr/local/dapp-bin/library ， 此时编译器将从重映射位置读取文件。如果重映射到多个路径，优先尝试重映射路径最长的一个。 这允许将比如 \"\" 被映射到 \"/usr/local/include/solidity\" 来进行“回退重映射”。 同时，这些重映射可取决于上下文，允许你配置要导入的包，比如同一个库的不同版本。 solc: 对于 solc（命令行编译器），这些重映射以 context:prefix=target 形式的参数提供。 其中，context: 和 =target 部分是可选的（此时 target 默认为 prefix ）。 所有重映射的值都是被编译过的常规文件（包括他们的依赖），这个机制完全是向后兼容的（只要文件名不包含 = 或 : ）， 因此这不是一个破坏性修改。 在 content 目录或其子目录中的源码文件中，所有导入语句里以 prefix 开头的导入文件都将被用 target 替换 prefix 来重定向。 举个例子，如果你已克隆 github.com/ethereum/dapp-bin/ 到本地 /usr/local/dapp-bin ， 可在源文件中使用： import \"github.com/ethereum/dapp-bin/library/iterable_mapping.sol\" as it_mapping; 然后运行编译器： solc github.com/ethereum/dapp-bin/=/usr/local/dapp-bin/ source.sol 举个更复杂的例子，假设你依赖了一些使用了非常旧版本的 dapp-bin 的模块。 旧版本的 dapp-bin 已经被 checkout 到 /usr/local/dapp-bin_old ，此时你可使用： solc module1:github.com/ethereum/dapp-bin/=/usr/local/dapp-bin/ \\ module2:github.com/ethereum/dapp-bin/=/usr/local/dapp-bin_old/ \\ source.sol 这样， module2 中的所有导入都指向旧版本，而 module1 中的导入则获取新版本。 注意， solc 只允许包含来自特定目录的文件：它们必须位于显式地指定的源文件目录（或子目录）中，或者重映射的目标目录（或子目录）中。 如果你想直接用绝对路径来包含文件，只需添加重映射 =/。 如果有多个重映射指向一个有效文件，那么具有最长公共前缀的重映射会被选用。 Remix: Remix 提供一个为 github 源代码平台的自动重映射，它将通过网络自动获取文件：比如，你可以使用 import \"github.com/ethereum/dapp-bin/library/iterable_mapping.sol\" as it_mapping; 导入一个 map 迭代器。 未来， Remix 可能支持其他源代码平台。 注释 可以使用单行注释（//）和多行注释（/*...*/） // 这是一个单行注释。 /* 这是一个 多行注释。 */ 此外，有另一种注释称为 natspec 注释，其文档还尚未编写。 它们是用三个反斜杠（///）或双星号开头的块（/** ... */）书写，它们应该直接在函数声明或语句上使用。 可在注释中使用 Doxygen 样式的标签来文档化函数、 标注形式校验通过的条件，和提供一个当用户试图调用一个函数时显示给用户的 确认文本。 在下面的例子中，我们记录了合约的标题、两个入参和两个返回值的说明： pragma solidity ^0.4.0; /** @title 形状计算器。 */ contract shapeCalculator { /** @dev 求矩形表明面积与周长。 * @param w 矩形宽度。 * @param h 矩形高度。 * @return s 求得表面积。 * @return p 求得周长。 */ function rectangle(uint w, uint h) returns (uint s, uint p) { s = w * h; p = 2 * (w + h); } } 合约结构 在 Solidity 中，合约类似于面向对象编程语言中的类。 每个合约中可以包含 状态变量，函数，函数修饰器，事件，结构类型 和 枚举类型的声明，且合约可以从其他合约继承。 状态变量 状态变量是永久地存储在合约存储中的值。 pragma solidity ^0.4.0; contract SimpleStorage { uint storedData; // 状态变量 // ... } 有效的状态变量类型参阅 类型 章节， 对状态变量可见性有可能的选择参阅 可见性和getter函数 。 函数 函数是合约中代码的可执行单元。 pragma solidity ^0.4.0; contract SimpleAuction { function bid() public payable { // 函数 // ... } } 函数调用可发生在合约内部或外部，且函数对其他合约有不同程度的可见性（ 可见性和getter函数）。 函数修饰器 函数修饰器可以用来以声明的方式改良函数语义（参阅合约章节中 函数）。 pragma solidity ^0.4.22; contract Purchase { address public seller; modifier onlySeller() { // 修饰器 require( msg.sender == seller, \"Only seller can call this.\" ); _; } function abort() public onlySeller { // Modifier usage // ... } } 事件 事件是能方便地调用Simplechain虚拟机日志功能的接口。 pragma solidity ^0.4.21; contract SimpleAuction { event HighestBidIncreased(address bidder, uint amount); // 事件 function bid() public payable { // ... emit HighestBidIncreased(msg.sender, msg.value); // 触发事件 } } 有关如何声明事件和如何在 dapp 中使用事件的信息，参阅合约章节中的 事件。 结构类型 结构是可以将几个变量分组的自定义类型（参阅类型章节中的 结构体）。 pragma solidity ^0.4.0; contract Ballot { struct Voter { // 结构 uint weight; bool voted; address delegate; uint vote; } } 枚举类型 枚举可用来创建由一定数量的“常量值”构成的自定义类型（参阅类型章节中的 枚举类型）。 pragma solidity ^0.4.0; contract Purchase { enum State { Created, Locked, Inactive } // 枚举 } 类型 Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要在编译时指定变量的类型（或至少可以推导出变量类型——参考下文的 :ref:type-deduction ）。 Solidity 提供了几种基本类型，可以用来组合出复杂类型。 除此之外，类型之间可以在包含运算符号的表达式中进行交互。 关于各种运算符号，可以参考 :ref:order 。 值类型 以下类型也称为值类型，因为这些类型的变量将始终按值来传递。 也就是说，当这些变量被用作函数参数或者用在赋值语句中时，总会进行值拷贝。 布尔类型 bool ：可能的取值为字面常数值 true 和 false 。 运算符： ! （逻辑非） && （逻辑与， \"and\" ） || （逻辑或， \"or\" ） == （等于） != （不等于） 运算符 || 和 && 都遵循同样的短路（ short-circuiting ）规则。就是说在表达式 f(x) || g(y) 中， 如果 f(x) 的值为 true ，那么 g(y) 就不会被执行，即使会出现一些副作用。 整型 int / uint ：分别表示有符号和无符号的不同位数的整型变量。 支持关键字 uint8 到 uint256 （无符号，从 8 位到 256 位）以及 int8 到 int256，以 8 位为步长递增。 uint 和 int 分别是 uint256 和 int256 的别名。 运算符： 比较运算符： ， ， == ， != ， >= ， > （返回布尔值） 位运算符： & ， | ， ^ （异或）， ~ （位取反） 算数运算符： + ， - ， 一元运算 - ， 一元运算 + ， * ， / ， % （取余） ， ** （幂）， （左移位） ， >> （右移位） 除法总是会截断的（仅被编译为 EVM 中的 DIV 操作码）， 但如果操作数都是 :ref:字面常数（literals） （或者字面常数表达式），则不会截断。 除以零或者模零运算都会引发运行时异常。 移位运算的结果取决于运算符左边的类型。 表达式 x 与 x * 2**y 是等价的， x >> y 与 x / 2**y 是等价的。这意味对一个负数进行移位会导致其符号消失。 按负数位移动会引发运行时异常。 .. warning:: 由有符号整数类型负值右移所产生的结果跟其它语言中所产生的结果是不同的。 在 Solidity 中，右移和除是等价的，因此对一个负数进行右移操作会导致向 0 的取整（截断）。 而在其它语言中， 对负数进行右移类似于（向负无穷）取整。 定长浮点型 Solidity 还没有完全支持定长浮点型。可以声明定长浮点型的变量，但不能给它们赋值或把它们赋值给其他变量。 fixed / ufixed：表示各种大小的有符号和无符号的定长浮点型。 在关键字 ufixedMxN 和 fixedMxN 中，M 表示该类型占用的位数，N 表示可用的小数位数。 M 必须能整除 8，即 8 到 256 位。 N 则可以是从 0 到 80 之间的任意数。 ufixed 和 fixed 分别是 ufixed128x19 和 fixed128x19 的别名。 运算符： 比较运算符：， ， ==， !=， >=， > （返回值是布尔型） 算术运算符：+， -， 一元运算 -， 一元运算 +， *， /， % （取余数） .. note:: 浮点型（在许多语言中的 float 和 double 类型，更准确地说是 IEEE 754 类型）和定长浮点型之间最大的不同点是， 在前者中整数部分和小数部分（小数点后的部分）需要的位数是灵活可变的，而后者中这两部分的长度受到严格的规定。 一般来说，在浮点型中，几乎整个空间都用来表示数字，但只有少数的位来表示小数点的位置。 地址类型 address：地址类型存储一个 20 字节的值（Simplechain地址的大小）。 地址类型也有成员变量，并作为所有合约的基础。 运算符： ， ， ==， !=， >= 和 > 从 0.5.0 版本开始，合约不会从地址类型派生，但仍然可以显式地转换成地址类型。 地址类型成员变量 balance 和 transfer 快速参考，请见 :ref:address_related。 可以使用 balance 属性来查询一个地址的余额， 也可以使用 transfer 函数向一个地址发送 |ether| （以 wei 为单位）： address x = 0x123; address myAddress = this; if (x.balance = 10) x.transfer(10); 如果 x 是一个合约地址，它的代码（更具体来说是它的 fallback 函数，如果有的话）会跟 transfer 函数调用一起执行（这是 EVM 的一个特性，无法阻止）。 如果在执行过程中用光了 gas 或者因为任何原因执行失败，|ether| 交易会被打回，当前的合约也会在终止的同时抛出异常。 send send 是 transfer 的低级版本。如果执行失败，当前的合约不会因为异常而终止，但 send 会返回 false。 在使用 send 的时候会有些风险：如果调用栈深度是 1024 会导致发送失败（这总是可以被调用者强制），如果接收者用光了 gas 也会导致发送失败。所以为了保证 |ether| 发送的安全，一定要检查 send 的返回值，使用 transfer 或者更好的办法：使用一种接收者可以取回资金的模式。 call， callcode 和 delegatecall 此外，为了与不符合 |ABI| 的合约交互，于是就有了可以接受任意类型任意数量参数的 call 函数。 这些参数会被打包到以 32 字节为单位的连续区域中存放。 其中一个例外是当第一个参数被编码成正好 4 个字节的情况。 在这种情况下，这个参数后边不会填充后续参数编码，以允许使用函数签名。 address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2; nameReg.call(\"register\", \"MyName\"); nameReg.call(bytes4(keccak256(\"fun(uint256)\")), a); call 返回的布尔值表明了被调用的函数已经执行完毕（true）或者引发了一个 EVM 异常（false）。 无法访问返回的真实数据（为此我们需要事先知道编码和大小）。 可以使用 .gas() |modifier| 调整提供的 gas 数量: namReg.call.gas(1000000)(\"register\", \"MyName\"); 类似地，也能控制提供的 |ether| 的值 : nameReg.call.value(1 ether)(\"register\", \"MyName\"); 最后一点，这些 |modifier| 可以联合使用。每个修改器出现的顺序不重要 : nameReg.call.gas(1000000).value(1 ether)(\"register\", \"MyName\"); 目前还不能在重载函数中使用 gas 或者 value。一种解决方案是给 gas 和值引入一个特例，并重新检查它们是否在重载的地方出现。 类似地，也可以使用 delegatecall：区别在于只使用给定地址的代码，其它属性（存储，余额，……）都取自当前合约。delegatecall 的目的是使用存储在另外一个合约中的库代码。用户必须确保两个合约中的存储结构都适用于 delegatecall。在 homestead 版本之前，只有一个功能类似但作用有限的 callcode 的函数可用，但它不能获取委托方的 msg.sender 和 msg.value。 这三个函数 call， delegatecall 和 callcode 都是非常低级的函数，应该只把它们当作 最后一招 来使用，因为它们破坏了 Solidity 的类型安全性。 所有合约都继承了地址（address）的成员变量，因此可以使用 this.balance 查询当前合约的余额。 不鼓励使用 callcode，在未来也会将其移除。 这三个函数都属于低级函数，需要谨慎使用。具体来说，任何未知的合约都可能是恶意的。你在调用一个合约的同时就将控制权交给了它，它可以反过来调用你的合约，因此，当调用返回时要为你的状态变量的改变做好准备。 定长字节数组 关键字有：bytes1， bytes2， bytes3， ...， bytes32。byte 是 bytes1 的别名。 运算符： 比较运算符：， ， ==， !=， >=， > （返回布尔型） 位运算符： &， |， ^ （按位异或）， ~ （按位取反）， （左移位）， >> （右移位） 索引访问：如果 x 是 bytesI 类型，那么 x[k] （其中 0 ）返回第 k 个字节（只读）。 该类型可以和作为右操作数的任何整数类型进行移位运算（但返回结果的类型和左操作数类型相同），右操作数表示需要移动的位数。 进行负数位移运算会引发运行时异常。 成员变量： .length 表示这个字节数组的长度（只读）. 可以将 byte[] 当作字节数组使用，但这种方式非常浪费存储空间，准确来说，是在传入调用时，每个元素会浪费 31 字节。 更好地做法是使用 bytes。 变长字节数组 bytes: 变长字节数组，参见 :ref:arrays。它并不是值类型。 string: 变长 UTF-8 编码字符串类型，参见 :ref:arrays。并不是值类型。 地址字面常数（Address Literals） 比如像 0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF 这样的通过了地址校验和测试的十六进制字面常数属于 address 类型。长度在 39 到 41 个数字的，没有通过校验和测试而产生了一个警告的十六进制字面常数视为正常的有理数字面常数。 混合大小写的地址校验和格式定义在 EIP-55中。 有理数和整数字面常数 整数字面常数由范围在 0-9 的一串数字组成，表现成十进制。例如，69 表示数字 69。 Solidity 中是没有八进制的，因此前置 0 是无效的。 十进制小数字面常数带有一个 .，至少在其一边会有一个数字。比如：1.，.1，和 1.3。 科学符号也是支持的，尽管指数必须是整数，但底数可以是小数。比如：2e10， -2e10， 2e-10， 2.5e1。 数值字面常数表达式本身支持任意精度，除非它们被转换成了非字面常数类型（也就是说，当它们出现在非字面常数表达式中时就会发生转换）。 这意味着在数值常量表达式中, 计算不会溢出而除法也不会截断。 例如， (2**800 + 1) - 2**800 的结果是字面常数 1 （属于 uint8 类型），尽管计算的中间结果已经超过了 |evm| 的机器字长度。 此外， .5 * 8 的结果是整型 4 （尽管有非整型参与了计算）。 只要操作数是整型，任意整型支持的运算符都可以被运用在数值字面常数表达式中。 如果两个中的任一个数是小数，则不允许进行位运算。如果指数是小数的话，也不支持幂运算（因为这样可能会得到一个无理数）。 Solidity 对每个有理数都有对应的数值字面常数类型。整数字面常数和有理数字面常数都属于数值字面常数类型。 除此之外，所有的数值字面常数表达式（即只包含数值字面常数和运算符的表达式）都属于数值字面常数类型。 因此数值字面常数表达式 1 + 2 和 2 + 1 的结果跟有理数三的数值字面常数类型相同。 在早期版本中，整数字面常数的除法也会截断，但在现在的版本中，会将结果转换成一个有理数。即 5 / 2 并不等于 2，而是等于 2.5。 数值字面常数表达式只要在非字面常数表达式中使用就会转换成非字面常数类型。在下面的例子中，尽管我们知道 b 的值是一个整数，但 2.5 + a 这部分表达式并不进行类型检查，因此编译不能通过。 uint128 a = 1; uint128 b = 2.5 + a + 0.5; 字符串字面常数 字符串字面常数是指由双引号或单引号引起来的字符串（\"foo\" 或者 'bar'）。 不像在 C 语言中那样带有结束符；\"foo\" 相当于 3 个字节而不是 4 个。 和整数字面常数一样，字符串字面常数的类型也可以发生改变，但它们可以隐式地转换成 bytes1，……，bytes32，如果合适的话，还可以转换成 bytes 以及 string。 字符串字面常数支持转义字符，例如 \\n，\\xNN 和 \\uNNNN。\\xNN 表示一个 16 进制值，最终转换成合适的字节，而 \\uNNNN 表示 Unicode 编码值，最终会转换为 UTF-8 的序列。 十六进制字面常数 十六进制字面常数以关键字 hex 打头，后面紧跟着用单引号或双引号引起来的字符串（例如，hex\"001122FF\"）。 字符串的内容必须是一个十六进制的字符串，它们的值将使用二进制表示。 十六进制字面常数跟字符串字面常数很类似，具有相同的转换规则。 枚举类型 pragma solidity ^0.4.16; contract test { enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill } ActionChoices choice; ActionChoices constant defaultChoice = ActionChoices.GoStraight; function setGoStraight() public { choice = ActionChoices.GoStraight; } // 由于枚举类型不属于 |ABI| 的一部分，因此对于所有来自 Solidity 外部的调用， // \"getChoice\" 的签名会自动被改成 \"getChoice() returns (uint8)\"。 // 整数类型的大小已经足够存储所有枚举类型的值，随着值的个数增加， // 可以逐渐使用 `uint16` 或更大的整数类型。 function getChoice() public view returns (ActionChoices) { return choice; } function getDefaultChoice() public pure returns (uint) { return uint(defaultChoice); } } 函数类型 函数类型是一种表示函数的类型。可以将一个函数赋值给另一个函数类型的变量，也可以将一个函数作为参数进行传递，还能在函数调用中返回函数类型变量。 函数类型有两类：- 内部（internal） 函数和 外部（external） 函数： 内部函数只能在当前合约内被调用（更具体来说，在当前代码块内，包括内部库函数和继承的函数中），因为它们不能在当前合约上下文的外部被执行。 调用一个内部函数是通过跳转到它的入口标签来实现的，就像在当前合约的内部调用一个函数。 外部函数由一个地址和一个函数签名组成，可以通过外部函数调用传递或者返回。 函数类型表示成如下的形式 :: function () {internal|external} [pure|constant|view|payable] [returns ()] 与参数类型相反，返回类型不能为空 —— 如果函数类型不需要返回，则需要删除整个 returns 部分。 函数类型默认是内部函数，因此不需要声明 internal 关键字。 与此相反的是，合约中的函数本身默认是 public 的，只有当它被当做类型名称时，默认才是内部函数。 有两种方法可以访问当前合约中的函数：一种是直接使用它的名字，f ，另一种是使用 this.f 。 前者适用于内部函数，后者适用于外部函数。 如果当函数类型的变量还没有初始化时就调用它的话会引发一个异常。 如果在一个函数被 delete 之后调用它也会发生相同的情况。 如果外部函数类型在 Solidity 的上下文环境以外的地方使用，它们会被视为 function 类型。 该类型将函数地址紧跟其函数标识一起编码为一个 bytes24 类型。。 请注意，当前合约的 public 函数既可以被当作内部函数也可以被当作外部函数使用。 如果想将一个函数当作内部函数使用，就用 f 调用，如果想将其当作外部函数，使用 this.f 。 除此之外，public（或 external）函数也有一个特殊的成员变量称作 selector，可以返回ABI 函数选择器 pragma solidity ^0.4.16; contract Selector { function f() public view returns (bytes4) { return this.f.selector; } } 如果使用内部函数类型的例子:: pragma solidity ^0.4.16; library ArrayUtils { // 内部函数可以在内部库函数中使用， // 因为它们会成为同一代码上下文的一部分 function map(uint[] memory self, function (uint) pure returns (uint) f) internal pure returns (uint[] memory r) { r = new uint[](self.length); for (uint i = 0; i 另外一个使用外部函数类型的例子:: pragma solidity ^0.4.11; contract Oracle { struct Request { bytes data; function(bytes memory) external callback; } Request[] requests; event NewRequest(uint); function query(bytes data, function(bytes memory) external callback) public { requests.push(Request(data, callback)); NewRequest(requests.length - 1); } function reply(uint requestID, bytes response) public { // 这里要验证 reply 来自可信的源 requests[requestID].callback(response); } } contract OracleUser { Oracle constant oracle = Oracle(0x1234567); // 已知的合约 function buySomething() { oracle.query(\"USD\", this.oracleResponse); } function oracleResponse(bytes response) public { require(msg.sender == address(oracle)); // 使用数据 } } Lambda 表达式或者内联函数的引入在计划内，但目前还没支持。 引用类型 比起之前讨论过的值类型，在处理复杂的类型（即占用的空间超过 256 位的类型）时，我们需要更加谨慎。 由于拷贝这些类型变量的开销相当大，我们不得不考虑它的存储位置，是将它们保存在 memory（并不是永久存储）中， 还是 storage（保存状态变量的地方）中。 数据位置 所有的复杂类型，即 数组 和 结构 类型，都有一个额外属性，“数据位置”，说明数据是保存在 memory 中还是 storage 中。根据上下文不同，大多数时候数据有默认的位置，但也可以通过在类型名后增加关键字 storage 或 memory 进行修改。函数参数（包括返回的参数）的数据位置默认是 memory，局部变量的数据位置默认是 storage，状态变量的数据位置强制是 storage （这是显而易见的）。 也存在第三种数据位置， calldata ，这是一块只读的，且不会永久存储的位置，用来存储函数参数。外部函数的参数（非返回参数）的数据位置被强制指定为 calldata ，效果跟 memory 差不多。 数据位置的指定非常重要，因为它们影响着赋值行为： 在 storage 和 memory 之间两两赋值，或者 storage 向状态变量（甚至是从其它状态变量）赋值都会创建一份独立的拷贝。然而状态变量向局部变量赋值时仅仅传递一个引用，而且这个引用总是指向状态变量，因此后者改变的同时前者也会发生改变。另一方面，从一个 memory 存储的引用类型向另一个 memory 存储的引用类型赋值并不会创建拷贝。 pragma solidity ^0.4.0; contract C { uint[] x; // x 的数据存储位置是 storage // memoryArray 的数据存储位置是 memory function f(uint[] memoryArray) public { x = memoryArray; // 将整个数组拷贝到 storage 中，可行 var y = x; // 分配一个指针（其中 y 的数据存储位置是 storage），可行 y[7]; // 返回第 8 个元素，可行 y.length = 2; // 通过 y 修改 x，可行 delete x; // 清除数组，同时修改 y，可行 // 下面的就不可行了；需要在 storage 中创建新的未命名的临时数组， / // 但 storage 是“静态”分配的： // y = memoryArray; // 下面这一行也不可行，因为这会“重置”指针， // 但并没有可以让它指向的合适的存储位置。 // delete y; g(x); // 调用 g 函数，同时移交对 x 的引用 h(x); // 调用 h 函数，同时在 memory 中创建一个独立的临时拷贝 } function g(uint[] storage storageArray) internal {} function h(uint[] memoryArray) public {} } 总结 强制指定的数据位置： 外部函数的参数（不包括返回参数）： calldata 状态变量： storage 默认数据位置： 函数参数（包括返回参数）： memory 所有其它局部变量： storage 数组 数组可以在声明时指定长度，也可以动态调整大小。 对于 storage 的数组来说，元素类型可以是任意的（即元素也可以是数组类型，映射类型或者结构体）。 对于 memory 的数组来说，元素类型不能是映射类型，如果作为 public 函数的参数，它只能是 ABI 类型。 一个元素类型为 T，固定长度为 k 的数组可以声明为 T[k]，而动态数组声明为 T[]。 举个例子，一个长度为 5，元素类型为 uint 的动态数组的数组，应声明为 uint[][5] （注意这里跟其它语言比，数组长度的声明位置是反的）。 要访问第三个动态数组的第二个元素，你应该使用 x[2][1]（数组下标是从 0 开始的，且访问数组时的下标顺序与声明时相反，也就是说，x[2] 是从右边减少了一级）。。 bytes 和 string 类型的变量是特殊的数组。 bytes 类似于 byte[]，但它在 calldata 中会被“紧打包”（译者注：将元素连续地存在一起，不会按每 32 字节一单元的方式来存放）。 string 与 bytes 相同，但（暂时）不允许用长度或索引来访问。 .. note:: 如果想要访问以字节表示的字符串 s，请使用 bytes(s).length / bytes(s)[7] = 'x';。 注意这时你访问的是 UTF-8 形式的低级 bytes 类型，而不是单个的字符。 可以将数组标识为 public，从而让 Solidity 创建一个 getter。 之后必须使用数字下标作为参数来访问 getter。 创建内存数组 可使用 new 关键字在内存中创建变长数组。 与 storage 数组相反的是，你 不能 通过修改成员变量 length 改变 memory 数组的大小。 pragma solidity ^0.4.16; contract C { function f(uint len) public pure { uint[] memory a = new uint[](7); bytes memory b = new bytes(len); // 这里我们有 a.length == 7 以及 b.length == len a[6] = 8; } } 数组字面常数 / 内联数组 数组字面常数是写作表达式形式的数组，并且不会立即赋值给变量。 pragma solidity ^0.4.16; contract C { function f() public pure { g([uint(1), 2, 3]); } function g(uint[3] _data) public pure { // ... } } 数组字面常数是一种定长的 |memory| 数组类型，它的基础类型由其中元素的普通类型决定。 例如，[1, 2, 3] 的类型是 uint8[3] memory，因为其中的每个字面常数的类型都是 uint8。 正因为如此，有必要将上面这个例子中的第一个元素转换成 uint 类型。 目前需要注意的是，定长的 memory 数组并不能赋值给变长的 memory 数组，下面是个反例： // 这段代码并不能编译。 pragma solidity ^0.4.0; contract C { function f() public { // 这一行引发了一个类型错误，因为 unint[3] memory // 不能转换成 uint[] memory。 uint[] x = [uint(1), 3, 4]; } } 已经计划在未来移除这样的限制，但目前数组在 ABI 中传递的问题造成了一些麻烦。 成员 length: 数组有 length 成员变量表示当前数组的长度。动态数组可以在 storage（而不是 memory ）中通过改变成员变量 .length 改变数组大小。并不能通过访问超出当前数组长度的方式实现自动扩展数组的长度。一经创建，memory 数组的大小就是固定的（但却是动态的，也就是说，它依赖于运行时的参数）。 push: 变长的 |storage| 数组以及 bytes 类型（而不是 string 类型）都有一个叫做 push 的成员函数，它用来附加新的元素到数组末尾。这个函数将返回新的数组长度。 在外部函数中目前还不能使用多维数组。 由于 |evm| 的限制，不能通过外部函数调用返回动态的内容。例如，如果通过 web3.js 调用 contract C { function f() returns (uint[]) { ... } } 中的 f 函数，它会返回一些内容，但通过 Solidity 不可以。 目前唯一的变通方法是使用大型的静态数组。 pragma solidity ^0.4.16; contract ArrayContract { uint[2**20] m_aLotOfIntegers; // 注意下面的代码并不是一对动态数组， // 而是一个数组元素为一对变量的动态数组（也就是数组元素为长度为 2 的定长数组的动态数组）。 bool[2][] m_pairsOfFlags; // newPairs 存储在 memory 中 —— 函数参数默认的存储位置 function setAllFlagPairs(bool[2][] newPairs) public { // 向一个 storage 的数组赋值会替代整个数组 m_pairsOfFlags = newPairs; } function setFlagPair(uint index, bool flagA, bool flagB) public { // 访问一个不存在的数组下标会引发一个异常 m_pairsOfFlags[index][0] = flagA; m_pairsOfFlags[index][1] = flagB; } function changeFlagArraySize(uint newSize) public { // 如果 newSize 更小，那么超出的元素会被清除 m_pairsOfFlags.length = newSize; } function clear() public { // 这些代码会将数组全部清空 delete m_pairsOfFlags; delete m_aLotOfIntegers; // 这里也是实现同样的功能 m_pairsOfFlags.length = 0; } bytes m_byteData; function byteArrays(bytes data) public { // 字节的数组（语言意义中的 byte 的复数 ``bytes``）不一样，因为它们不是填充式存储的， // 但可以当作和 \"uint8[]\" 一样对待 m_byteData = data; m_byteData.length += 7; m_byteData[3] = byte(8); delete m_byteData[2]; } function addFlag(bool[2] flag) public returns (uint) { return m_pairsOfFlags.push(flag); } function createMemoryArray(uint size) public pure returns (bytes) { // 使用 `new` 创建动态 memory 数组： uint[2][] memory arrayOfPairs = new uint[2][](size); // 创建一个动态字节数组： bytes memory b = new bytes(200); for (uint i = 0; i 结构体 Solidity 支持通过构造结构体的形式定义新的类型，以下是一个结构体使用的示例： pragma solidity ^0.4.11; contract CrowdFunding { // 定义的新类型包含两个属性。 struct Funder { address addr; uint amount; } struct Campaign { address beneficiary; uint fundingGoal; uint numFunders; uint amount; mapping (uint => Funder) funders; } uint numCampaigns; mapping (uint => Campaign) campaigns; function newCampaign(address beneficiary, uint goal) public returns (uint campaignID) { campaignID = numCampaigns++; // campaignID 作为一个变量返回 // 创建新的结构体示例，存储在 storage 中。我们先不关注映射类型。 campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0); } function contribute(uint campaignID) public payable { Campaign storage c = campaigns[campaignID]; // 以给定的值初始化，创建一个新的临时 memory 结构体， // 并将其拷贝到 storage 中。 // 注意你也可以使用 Funder(msg.sender, msg.value) 来初始化。 c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value}); c.amount += msg.value; } function checkGoalReached(uint campaignID) public returns (bool reached) { Campaign storage c = campaigns[campaignID]; if (c.amount 上面的合约只是一个简化版的众筹合约，但它已经足以让我们理解结构体的基础概念。 结构体类型可以作为元素用在映射和数组中，其自身也可以包含映射和数组作为成员变量。 尽管结构体本身可以作为映射的值类型成员，但它并不能包含自身。这个限制是有必要的，因为结构体的大小必须是有限的。 注意在函数中使用结构体时，一个结构体是如何赋值给一个局部变量（默认存储位置是 storage）的。在这个过程中并没有拷贝这个结构体，而是保存一个引用，所以对局部变量成员的赋值实际上会被写入状态。 当然，你也可以直接访问结构体的成员而不用将其赋值给一个局部变量，就像这样， campaigns[campaignID].amount = 0。 映射 映射类型在声明时的形式为 mapping(_KeyType => _ValueType)。 其中 _KeyType 可以是除了映射、变长数组、合约、枚举以及结构体以外的几乎所有类型。 _ValueType 可以是包括映射类型在内的任何类型。 映射可以视作 哈希表，它们在实际的初始化过程中创建每个可能的 key，并将其映射到字节形式全是零的值：一个类型的默认值。然而下面是映射与哈希表不同的地方： 在映射中，实际上并不存储 key，而是存储它的 keccak256 哈希值，从而便于查询实际的值。 正因为如此，映射是没有长度的，也没有 key 的集合或 value 的集合的概念。只有状态变量（或者在 internal 函数中的对于存储变量的引用）可以使用映射类型。。 可以将映射声明为 public，然后来让 Solidity 创建一个getter。_KeyType 将成为 getter 的必须参数，并且 getter 会返回 _ValueType。_ValueType 也可以是一个映射。这时在使用 getter 时将将需要递归地传入每个 _KeyType 参数。 pragma solidity ^0.4.0; contract MappingExample { mapping(address => uint) public balances; function update(uint newBalance) public { balances[msg.sender] = newBalance; } } contract MappingUser { function f() public returns (uint) { MappingExample m = new MappingExample(); m.update(100); return m.balances(this); } } 映射不支持迭代，但可以在此之上实现一个这样的数据结构。例子可以参考: 可迭代的映射 涉及 LValues 的运算符 如果 a 是一个 LValue（即一个变量或者其它可以被赋值的东西），以下运算符都可以使用简写： a += e 等同于 a = a + e。 其它运算符 -=， *=， /=， %=， |=， &= 以及 ^= 都是如此定义的。 a++ 和 a-- 分别等同于 a += 1 和 a -= 1，但表达式本身的值等于 a 在计算之前的值。 与之相反，--a 和 ++a 虽然最终 a 的结果与之前的表达式相同，但表达式的返回值是计算之后的值。 删除 delete a 的结果是将 a 的类型在初始化时的值赋值给 a。即对于整型变量来说，相当于 a = 0， 但 delete 也适用于数组，对于动态数组来说，是将数组的长度设为 0，而对于静态数组来说，是将数组中的所有元素重置。 如果对象是结构体，则将结构体中的所有属性重置。 delete 对整个映射是无效的（因为映射的键可以是任意的，通常也是未知的）。 因此在你删除一个结构体时，结果将重置所有的非映射属性，这个过程是递归进行的，除非它们是映射。 然而，单个的键及其映射的值是可以被删除的。 理解 delete a 的效果就像是给 a 赋值很重要，换句话说，这相当于在 a 中存储了一个新的对象。 pragma solidity ^0.4.0; contract DeleteExample { uint data; uint[] dataArray; function f() public { uint x = data; delete x; // 将 x 设为 0，并不影响数据 delete data; // 将 data 设为 0，并不影响 x，因为它仍然有个副本 uint[] storage y = dataArray; delete dataArray; // 将 dataArray.length 设为 0，但由于 uint[] 是一个复杂的对象，y 也将受到影响， // 因为它是一个存储位置是 storage 的对象的别名。 // 另一方面：\"delete y\" 是非法的，引用了 storage 对象的局部变量只能由已有的 storage 对象赋值。 } } 基本类型之间的转换 隐式转换 如果一个运算符用在两个不同类型的变量之间，那么编译器将隐式地将其中一个类型转换为另一个类型（不同类型之间的赋值也是一样）。一般来说，只要值类型之间的转换在语义上行得通，而且转换的过程中没有信息丢失，那么隐式转换基本都是可以实现的： uint8 可以转换成 uint16，int128 转换成 int256，但 int8 不能转换成 uint256（因为 uint256 不能涵盖某些值，例如，-1）。更进一步来说，无符号整型可以转换成跟它大小相等或更大的字节类型，但反之不能。任何可以转换成 uint160 的类型都可以转换成 address 类型。 显式转换 如果某些情况下编译器不支持隐式转换，但是你很清楚你要做什么，这种情况可以考虑显式转换。 注意这可能会发生一些无法预料的后果，因此一定要进行测试，确保结果是你想要的！ 下面的示例是将一个 int8 类型的负数转换成 uint： int8 y = -3; uint x = uint(y); 这段代码的最后，x 的值将是 0xfffff..fd （64 个 16 进制字符），因为这是 -3 的 256 位补码形式。 如果一个类型显式转换成更小的类型，相应的高位将被舍弃: uint32 a = 0x12345678; uint16 b = uint16(a); // 此时 b 的值是 0x5678 类型推断 为了方便起见，没有必要每次都精确指定一个变量的类型，编译器会根据分配该变量的第一个表达式的类型自动推断该变量的类型: uint24 x = 0x123; var y = x; 这里 y 的类型将是 uint24。不能对函数参数或者返回参数使用 var。 类型只能从第一次赋值中推断出来，因此以下代码中的循环是无限的，原因是i 的类型是 uint8，而这个类型变量的最大值比 2000 小。for (var i = 0; i 单元和全局变量 sipc单位 sipc单位之间的换算就是在数字后边加上 wei、 finney、 szabo 或 ether 来实现的，如果后面没有单位，缺省为 Wei。例如 2 ether == 2000 finney 的逻辑判断值为 true。 时间单位 秒是缺省时间单位，在时间单位之间，数字后面带有 seconds、 minutes、 hours、 days、 weeks 和 years 的可以进行换算，基本换算关系如下： 1 == 1 seconds 1 minutes == 60 seconds 1 hours == 60 minutes 1 days == 24 hours 1 weeks == 7 days 1 years == 365 days 由于闰秒造成的每年不都是 365 天、每天不都是 24 小时 leap seconds，所以如果你要使用这些单位计算日期和时间，请注意这个问题。因为闰秒是无法预测的，所以需要借助外部的预言机（oracle，是一种链外数据服务，译者注）来对一个确定的日期代码库进行时间矫正。 years 后缀已经不推荐使用了，因为从 0.5.0 版本开始将不再支持。 这些后缀不能直接用在变量后边。如果想用时间单位（例如 days）来将输入变量换算为时间，你可以用如下方式来完成： function f(uint start, uint daysAfter) public { if (now >= start + daysAfter * 1 days) { // ... } } 特殊变量和函数 在全局命名空间中已经存在了（预设了）一些特殊的变量和函数，他们主要用来提供关于区块链的信息或一些通用的工具函数。 .. index:: abi, block, coinbase, difficulty, encode, number, block;number, timestamp, block;timestamp, msg, data, gas, sender, value, now, gas price, origin 区块和交易属性 block.blockhash(uint blockNumber) returns (bytes32)：指定区块的区块哈希——仅可用于最新的 256 个区块且不包括当前区块；而 blocks 从 0.4.22 版本开始已经不推荐使用，由 blockhash(uint blockNumber) 代替 block.coinbase (address): 挖出当前区块的矿工地址 block.difficulty (uint): 当前区块难度 block.gaslimit (uint): 当前区块 gas 限额 block.number (uint): 当前区块号 block.timestamp (uint): 自 unix epoch 起始当前区块以秒计的时间戳 gasleft() returns (uint256)：剩余的 gas msg.data (bytes): 完整的 calldata msg.gas (uint): 剩余 gas - 自 0.4.21 版本开始已经不推荐使用，由 gesleft() 代替 msg.sender (address): 消息发送者（当前调用） msg.sig (bytes4): calldata 的前 4 字节（也就是函数标识符） msg.value (uint): 随消息发送的 wei 的数量 now (uint): 目前区块时间戳（block.timestamp） tx.gasprice (uint): 交易的 gas 价格 tx.origin (address): 交易发起者（完全的调用链） 对于每一个外部函数调用，包括 msg.sender 和 msg.value 在内所有 msg 成员的值都会变化。这里包括对库函数的调用。 不要依赖 block.timestamp、 now 和 blockhash 产生随机数，除非你知道自己在做什么。 时间戳和区块哈希在一定程度上都可能受到挖矿矿工影响。例如，挖矿社区中的恶意矿工可以用某个给定的哈希来运行赌场合约的 payout 函数，而如果他们没收到钱，还可以用一个不同的哈希重新尝试。当前区块的时间戳必须严格大于最后一个区块的时间戳，但这里唯一能确保的只是它会是在权威链上的两个连续区块的时间戳之间的数值。 基于可扩展因素，区块哈希不是对所有区块都有效。你仅仅可以访问最近 256 个区块的哈希，其余的哈希均为零。 ABI 编码函数 abi.encode(...) returns (bytes)：ABI对给定参数进行编码 abi.encodePacked(...) returns (bytes)：对给定参数执行紧打包编码 abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)：ABI对给定参数进行编码，并以给定的函数选择器作为起始的 4 字节数据一起返回 abi.encodeWithSignature(string signature, ...) returns (bytes)：等价于 abi.encodeWithSelector(bytes4(keccak256(signature), ...) 这些编码函数可以用来构造函数调用数据，而不用实际进行调用。此外，keccak256(abi.encodePacked(a, b)) 是更准确的方法来计算在未来版本不推荐使用的 keccak256(a, b)。 更多详情请参考ABI和 紧打包编码。 错误处理 assert(bool condition): 如果条件不满足，则使当前交易没有效果 — 用于检查内部错误。 require(bool condition): 如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误。 require(bool condition, string message): 如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误，可以同时提供一个错误消息。 revert(): 终止运行并撤销状态更改。 revert(string reason): 终止运行并撤销状态更改，可以同时提供一个解释性的字符串。 数学和密码学函数 addmod(uint x, uint y, uint k) returns (uint):计算 (x + y) % k，加法会在任意精度下执行，并且加法的结果即使超过 2**256 也不会被截取。从 0.5.0 版本的编译器开始会加入对 k != 0 的校验（assert）。 mulmod(uint x, uint y, uint k) returns (uint):计算 (x * y) % k，乘法会在任意精度下执行，并且乘法的结果即使超过 2**256 也不会被截取。从 0.5.0 版本的编译器开始会加入对 k != 0 的校验（assert）。 keccak256(...) returns (bytes32): 计算 :ref:(tightly packed) arguments 的 Ethereum-SHA-3 （Keccak-256）哈希。 sha256(...) returns (bytes32):计算 :ref:(tightly packed) arguments 的 SHA-256 哈希。 sha3(...) returns (bytes32):等价于 keccak256。 ripemd160(...) returns (bytes20):计算 :ref:(tightly packed) arguments 的 RIPEMD-160 哈希。 ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address) ：利用椭圆曲线签名恢复与公钥相关的地址，错误返回零值。example usage 上文中的tightly packed是指不会对参数值进行 padding 处理（就是说所有参数值的字节码是连续存放的，译者注），这意味着下边这些调用都是等价的： keccak256(\"ab\", \"c\") keccak256(\"abc\") keccak256(0x616263) keccak256(6382179) keccak256(97, 98, 99) 如果需要 padding，可以使用显式类型转换：keccak256(\"\\x00\\x12\") 和 keccak256(uint16(0x12)) 是一样的。 请注意，常量值会使用存储它们所需要的最少字节数进行打包。例如：keccak256(0) == keccak256(uint8(0))，keccak256(0x12345678) == keccak256(uint32(0x12345678))。 在一个私链上，你很有可能碰到由于 sha256、ripemd160 或者 ecrecover 引起的 Out-of-Gas。原因是因为这些密码学函数在Simplechain虚拟机中以“预编译合约”形式存在的，且在第一次收到消息后才被真正存在（尽管合约代码是EVM中已存在的硬编码）。因此发送到不存在的合约的消息非常昂贵，所以实际的执行会导致 Out-of-Gas 错误。在你实际使用你的合约之前，给每个合约发送一点儿Sipc，比如 1 Wei。这在官方网络或测试网络上不是问题。 地址相关 .balance (uint256):以 Wei 为单位的 :ref:address 的余额。 .transfer(uint256 amount):向 :ref:address 发送数量为 amount 的 Wei，失败时抛出异常，发送 2300 gas 的矿工费，不可调节。 .send(uint256 amount) returns (bool):向 :ref:address 发送数量为 amount 的 Wei，失败时返回 false，发送 2300 gas 的矿工费用，不可调节。 .call(...) returns (bool):发出低级函数 CALL，失败时返回 false，发送所有可用 gas，可调节。 .callcode(...) returns (bool)：发出低级函数 CALLCODE，失败时返回 false，发送所有可用 gas，可调节。 .delegatecall(...) returns (bool):发出低级函数 DELEGATECALL，失败时返回 false，发送所有可用 gas，可调节。 更多信息，参考 :ref:address 部分： 使用 send 有很多危险：如果调用栈深度已经达到 1024（这总是可以由调用者所强制指定），转账会失败；并且如果接收者用光了 gas，转账同样会失败。为了保证以太币转账安全，总是检查 send 的返回值，利用 transfer 或者下面更好的方式： 用这种接收者取回钱的模式。 如果在通过低级函数 delegatecall 发起调用时需要访问存储中的变量，那么这两个合约的存储中的变量定义顺序需要一致，以便被调用的合约代码可以正确地通过变量名访问合约的存储变量。这当然不是指像在高级的库函数调用时所传递的存储变量指针那样的情况。 不鼓励使用 callcode，并且将来它会被移除。 合约相关 this (current contract's type):当前合约，可以明确转换为 :ref:address。 selfdestruct(address recipient):销毁合约，并把余额发送到指定 :ref:address。 suicide(address recipient):与 selfdestruct 等价，但已不推荐使用。 此外，当前合约内的所有函数都可以被直接调用，包括当前函数。 表达式和控制结构 输入参数和输出参数 与 Javascript 一样，函数可能需要参数作为输入;而与 Javascript 和 C 不同的是，它们可能返回任意数量的参数作为输出。 输入参数 输入参数的声明方式与变量相同。但是有一个例外，未使用的参数可以省略参数名。 例如，如果我们希望合约接受有两个整数形参的函数的外部调用，我们会像下面这样写 pragma solidity ^0.4.16; contract Simple { function taker(uint _a, uint _b) public pure { // 用 _a 和 _b 实现相关功能. } } 输出参数 输出参数的声明方式在关键词 returns 之后，与输入参数的声明方式相同。 例如，如果我们需要返回两个结果：两个给定整数的和与积，我们应该写作 pragma solidity ^0.4.16; contract Simple { function arithmetics(uint _a, uint _b) public pure returns (uint o_sum, uint o_product) { o_sum = _a + _b; o_product = _a * _b; } } 输出参数名可以被省略。输出值也可以使用 return 语句指定。 return 语句也可以返回多值，参阅：ref:multi-return。 返回的输出参数被初始化为 0；如果它们没有被显式赋值，它们就会一直为 0。 输入参数和输出参数可以在函数体中用作表达式。因此，它们也可用在等号左边被赋值。 控制结构 JavaScript 中的大部分控制结构在 Solidity 中都是可用的，除了 switch 和 goto。因此 Solidity 中有 if，else，while，do，for，break，continue，return，? : 这些与在 C 或者 JavaScript 中表达相同语义的关键词。 用于表示条件的括号 不可以 被省略，单语句体两边的花括号可以被省略。注意，与 C 和 JavaScript 不同， Solidity 中非布尔类型数值不能转换为布尔类型，因此 if (1) { ... } 的写法在 Solidity 中 无效 。 返回多个值 当一个函数有多个输出参数时， return (v0, v1, ...,vn) 写法可以返回多个值。不过元素的个数必须与输出参数的个数相同。 函数调用 内部函数调用 当前合约中的函数可以直接（“从内部”）调用，也可以递归调用，就像下边这个荒谬的例子一样 pragma solidity ^0.4.16; contract C { function g(uint a) public pure returns (uint ret) { return f(); } function f() internal pure returns (uint ret) { return g(7) + f(); } } 这些函数调用在 EVM 中被解释为简单的跳转。这样做的效果就是当前内存不会被清除，也就是说，通过内部调用在函数之间传递内存引用是非常有效的。 外部函数调用 表达式 this.g(8); 和 c.g(2); （其中 c 是合约实例）也是有效的函数调用，但是这种情况下，函数将会通过一个消息调用来被“外部调用”，而不是直接的跳转。 请注意，不可以在构造函数中通过 this 来调用函数，因为此时真实的合约实例还没有被创建。 如果想要调用其他合约的函数，需要外部调用。对于一个外部调用，所有的函数参数都需要被复制到内存。 当调用其他合约的函数时，随函数调用发送的 Wei 和 gas 的数量可以分别由特定选项 .value() 和 .gas() 指定:: pragma solidity ^0.4.0; contract InfoFeed { function info() public payable returns (uint ret) { return 42; } } contract Consumer { InfoFeed feed; function setFeed(address addr) public { feed = InfoFeed(addr); } function callFeed() public { feed.info.value(10).gas(800)(); } } payable 修饰符要用于修饰 info，否则，.value() 选项将不可用。 注意，表达式 InfoFeed(addr) 进行了一个的显式类型转换，说明”我们知道给定地址的合约类型是 InfoFeed “并且这不会执行构造函数。 显式类型转换需要谨慎处理。绝对不要在一个你不清楚类型的合约上执行函数调用。 我们也可以直接使用 function setFeed(InfoFeed _feed) { feed = _feed; } 。 注意一个事实，feed.info.value(10).gas(800) 只（局部地）设置了与函数调用一起发送的 Wei 值和 gas 的数量，只有最后的圆括号执行了真正的调用。 如果被调函数所在合约不存在（也就是账户中不包含代码）或者被调用合约本身抛出异常或者 gas 用完等，函数调用会抛出异常。 任何与其他合约的交互都会强加潜在危险，尤其是在不能预先知道合约代码的情况下。 当前合约将控制权移交给被调用合约，而被调用合约可能做任何事。即使被调用合约从一个已知父合约继承，继承的合约也只需要有一个正确的接口就可以了。 被调用合约的实现可以完全任意，因此会带来危险。此外，请小心万一它再调用你系统中的其他合约，或者甚至在第一次调用返回之前返回到你的调用合约。 这意味着被调用合约可以通过它自己的函数改变调用合约的状态变量。。一个建议的函数写法是，例如，在你合约中状态变量进行各种变化后再调用外部函数，这样，你的合约就不会轻易被滥用的重入 (reentrancy) 所影响 具名调用和匿名函数参数 如果它们被包含在 {} 中，函数调用参数也可以按照任意顺序由名称给出， 如以下示例中所示。参数列表必须按名称与函数声明中的参数列表相符，但可以按任意顺序排列。 pragma solidity ^0.4.0; contract C { function f(uint key, uint value) public { // ... } function g() public { // 具名参数 f({value: 2, key: 3}); } } 省略函数参数名称 未使用参数的名称（特别是返回参数）可以省略。这些参数仍然存在于堆栈中，但它们无法访问。 pragma solidity ^0.4.16; contract C { // 省略参数名称 function func(uint k, uint) public pure returns(uint) { return k; } } 通过 new 创建合约 使用关键字 new 可以创建一个新合约。待创建合约的完整代码必须事先知道，因此递归的创建依赖是不可能的。 pragma solidity ^0.4.0; contract D { uint x; function D(uint a) public payable { x = a; } } contract C { D d = new D(4); // 将作为合约 C 构造函数的一部分执行 function createD(uint arg) public { D newD = new D(arg); } function createAndEndowD(uint arg, uint amount) public payable { //随合约的创建发送 ether D newD = (new D).value(amount)(arg); } } 如示例中所示，使用 .value（） 选项创建 D 的实例时可以转发 Ether，但是不可能限制 gas 的数量。如果创建失败（可能因为栈溢出，或没有足够的余额或其他问题），会引发异常。 表达式计算顺序 表达式的计算顺序不是特定的（更准确地说，表达式树中某节点的字节点间的计算顺序不是特定的，但它们的结算肯定会在节点自己的结算之前）。该规则只能保证语句按顺序执行，布尔表达式的短路执行。更多相关信息，请参阅：:ref:order。 赋值 解构赋值和返回多值 Solidity 内部允许元组 (tuple) 类��，也就是一个在编译时元素数量固定的对象列表，列表中的元素可以是不同类型的对象。这些元组可以用来同时返回多个数值，也可以用它们来同时给多个新声明的变量或者既存的变量（或通常的 LValues）： pragma solidity >0.4.23 直到 0.4.24 版本，给具有更少的元素数的元组赋值都可以可能的，无论是在左边还是右边（比如在最后空出若干元素）。现在，这已经不推荐了，赋值操作的两边应该具有相同个数的组成元素。 数组和结构体的复杂性 赋值语义对于像数组和结构体这样的非值类型来说会有些复杂。 为状态变量 赋值 经常会创建一个独立副本。另一方面，对局部变量的赋值只会为基本类型（即 32 字节以内的静态类型）创建独立的副本。如果结构体或数组（包括 bytes 和 string）被从状态变量分配给局部变量，局部变量将保留对原始状态变量的引用。对局部变量的第二次赋值不会修改状态变量，只会改变引用。赋值给局部变量的成员（或元素）则 改变 状态变量。 作用域和声明 变量声明后将有默认初始值，其初始值字节表示全部为零。任何类型变量的“默认值”是其对应类型的典型“零状态”。例如， bool 类型的默认值是 false 。 uint 或 int 类型的默认值是 0 。对于静态大小的数组和 bytes1 到 bytes32 ，每个单独的元素将被初始化为与其类型相对应的默认值。 最后，对于动态大小的数组， bytes 和 string 类型，其默认缺省值是一个空数组或字符串。 Solidity 中的作用域规则遵循了 C99（与其他很多语言一样）：变量将会从它们被声明之后可见，直到一对 { } 块的结束。作为一个例外，在 for 循环语句中初始化的变量，其可见性仅维持到 for 循环的结束。 那些定义在代码块之外的变量，比如函数、合约、自定义类型等等，并不会影响它们的作用域特性。这意味着你可以在实际声明状态变量的语句之前就使用它们，并且递归地调用函数。 基于以上的规则，下边的例子不会出现编译警告，因为那两个变量虽然名字一样，但却在不同的作用域里。 pragma solidity >0.4.24; contract C { function minimalScoping() pure public { { uint same2 = 0; } { uint same2 = 0; } } } 作为 C99 作用域规则的特例，请注意在下边的例子里，第一次对 x 的赋值会改变上一层中声明的变量值。如果外层声明的变量被“影子化”（就是说被在内部作用域中由一个同名变量所替代）你会得到一个警告。 pragma solidity >0.4.24; contract C { function f() pure public returns (uint) { uint x = 1; { x = 2; // 这个赋值会影响在外层声明的变量 uint x; } return x; // x has value 2 } } 在 Solidity 0.5.0 之前的版本，作用域规则都沿用了 Javascript 的规则，即一个变量可以声明在函数的任意位置，都可以使他在整个函数范围内可见。而这种规则会从 0.5.0 版本起被打破。从 0.5.0 版本开始，下面例子中的代码段会导致编译错误。 // 这将无法编译通过 pragma solidity >0.4.24; contract C { function f() pure public returns (uint) { x = 2; uint x; return x; } } 错误处理：Assert, Require, Revert and Exceptions Solidity 使用状态恢复异常来处理错误。这种异常将撤消对当前调用（及其所有子调用）中的状态所做的所有更改，并且还向调用者标记错误。 便利函数 assert 和 require 可用于检查条件并在条件不满足时抛出异常。assert 函数只能用于测试内部错误，并检查非变量。 require 函数用于确认条件有效性，例如输入变量，或合约状态变量是否满足条件，或验证外部合约调用返回的值。 如果使用得当，分析工具可以评估你的合约，并标示出那些会使 assert 失败的条件和函数调用。 正常工作的代码不会导致一个 assert 语句的失败；如果这发生了，那就说明出现了一个需要你修复的 bug。 还有另外两种触发异常的方法：revert 函数可以用来标记错误并恢复当前的调用。 revert 调用中包含有关错误的详细信息是可能的，这个消息会被返回给调用者。已经不推荐的关键字 throw 也可以用来替代 revert() （但无法返回错误消息）。 从 0.4.13 版本开始，throw 这个关键字被弃用，并且将来会被逐渐淘汰。 当子调用发生异常时，它们会自动“冒泡”（即重新抛出异常）。这个规则的例外是 send 和低级函数 call ， delegatecall 和 callcode --如果这些函数发生异常，将返回 false ，而不是“冒泡”。 作为 EVM 设计的一部分，如果被调用合约帐户不存在，则低级函数 call ，delegatecall 和 callcode 将返回 success。因此如果需要使用低级函数时，必须在调用之前检查被调用合约是否存在。异常捕获还未实现 在下例中，你可以看到如何轻松使用require检查输入条件以及如何使用assert检查内部错误，注意，你可以给 require 提供一个消息字符串，而 assert 不行。 pragma solidity ^0.4.22; contract Sharer { function sendHalf(address addr) public payable returns (uint balance) { require(msg.value % 2 == 0, \"Even value required.\"); uint balanceBeforeTransfer = this.balance; addr.transfer(msg.value / 2); //由于转移函数在失败时抛出异常并且不能在这里回调，因此我们应该没有办法仍然有一半的钱。 assert(this.balance == balanceBeforeTransfer - msg.value / 2); return this.balance; } } 下列情况将会产生一个 assert 式异常： 如果你访问数组的索引太大或为负数（例如 x[i] 其中 i >= x.length 或 i ）。 如果你访问固定长度 bytesN 的索引太大或为负数。 如果你用零当除数做除法或模运算（例如 5 / 0 或 23 % 0 ）。 如果你移位负数位。 如果你将一个太大或负数值转换为一个枚举类型。 如果你调用内部函数类型的零初始化变量。 如果你调用 assert 的参数（表达式）最终结算为 false。 下列情况将会产生一个 require 式异常： 调用 throw 。 如果你调用 require 的参数（表达式）最终结算为 false 。 如果你通过消息调用调用某个函数，但该函数没有正确结束（它耗尽了 gas，没有匹配函数，或者本身抛出一个异常），上述函数不包括低级别的操作 call ， send ， delegatecall 或者 callcode 。低级操作不会抛出异常，而通过返回 false 来指示失败。 如果你使用 new 关键字创建合约，但合约没有正确创建（请参阅上条有关”未正确完成“的定义）。 如果你对不包含代码的合约执行外部函数调用。 如果你的合约通过一个没有 payable 修饰符的公有函数（包括构造函数和 fallback 函数）接收 Ether。 如果你的合约通过公有 getter 函数接收 Ether 。 如果 .transfer() 失败。 在内部， Solidity 对一个 require 式的异常执行回退操作（指令 0xfd ）并执行一个无效操作（指令 0xfe ）来引发 assert 式异常。在这两种情况下，都会导致 EVM 回退对状态所做的所有更改。回退的原因是不能继续安全地执行，因为没有实现预期的效果。因为我们想保留交易的原子性，所以最安全的做法是回退所有更改并使整个交易（或至少是调用）不产生效果。请注意， assert 式异常消耗了所有可用的调用 gas ，而从 Metropolis 版本起 require 式的异常不会消耗任何 gas。 下边的例子展示了如何在 revert 和 require 中使用错误字符串： pragma solidity ^0.4.22; contract VendingMachine { function buy(uint amount) payable { if (amount > msg.value / 2 ether) revert(\"Not enough Ether provided.\"); // 下边是等价的方法来做同样的检查： require( amount 这里提供的字符串应该是经过 :ref:ABI 编码 之后的，因为它实际上是调用了 Error(string) 函数。在上边的例子里，revert(\"Not enough Ether provided.\"); 会产生如下的十六进制错误返回值： 0x08c379a0 // Error(string) 的函数选择器 0x0000000000000000000000000000000000000000000000000000000000000020 // 数据的偏移量（32） 0x000000000000000000000000000000000000000000000000000000000000001a // 字符串长度（26） 0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // 字符串数据（\"Not enough Ether provided.\" 的 ASCII 编码，26字节） 合约 Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。 创建合约 可以通过Simplechain交易“从外部”或从 Solidity 合约内部创建合约。 一些集成开发环境，例如 Remix, 通过使用一些用户界面元素使创建过程更加流畅。在Simplechain上编程创建合约最好使用 JavaScript API web3.j。现在，我们已经有了一个叫做 web3.eth.Contract 的方法能够更容易的创建合约。 创建合约时，会执行一次构造函数（与合约同名的函数）。构造函数是可选的。只允许有一个构造函数，这意味着不支持重载。 在内部，构造函数参数在合约代码之后通ABI 编码传递，但是如果你使用 web3.js则不必关心这个问题。 如果一个合约想要创建另一个合约，那么创建者必须知晓被创建合约的源代码(和二进制代码)。 这意味着不可能循环创建依赖项。 pragma solidity ^0.4.16; contract OwnedToken { // TokenCreator 是如下定义的合约类型. // 不创建新合约的话，也可以引用它。 TokenCreator creator; address owner; bytes32 name; // 这是注册 creator 和设置名称的构造函数。 function OwnedToken(bytes32 _name) public { // 状态变量通过其名称访问，而不是通过例如 this.owner 的方式访问。 // 这也适用于函数，特别是在构造函数中，你只能像这样（“内部地”）调用它们， // 因为合约本身还不存在。 owner = msg.sender; // 从 `address` 到 `TokenCreator` ，是做显式的类型转换 // 并且假定调用合约的类型是 TokenCreator，没有真正的方法来检查这一点。 creator = TokenCreator(msg.sender); name = _name; } function changeName(bytes32 newName) public { // 只有 creator （即创建当前合约的合约）能够更改名称 —— 因为合约是隐式转换为地址的， // 所以这里的比较是可行的。 if (msg.sender == address(creator)) name = newName; } function transfer(address newOwner) public { // 只有当前所有者才能发送 token。 if (msg.sender != owner) return; // 我们也想询问 creator 是否可以发送。 // 请注意，这里调用了一个下面定义的合约中的函数。 // 如果调用失败（比如，由于 gas 不足），会立即停止执行。 if (creator.isTokenTransferOK(owner, newOwner)) owner = newOwner; } } contract TokenCreator { function createToken(bytes32 name) public returns (OwnedToken tokenAddress) { // 创建一个新的 Token 合约并且返回它的地址。 // 从 JavaScript 方面来说，返回类型是简单的 `address` 类型，因为 // 这是在 ABI 中可用的最接近的类型。 return new OwnedToken(name); } function changeName(OwnedToken tokenAddress, bytes32 name) public { // 同样，`tokenAddress` 的外部类型也是 `address` 。 tokenAddress.changeName(name); } function isTokenTransferOK(address currentOwner, address newOwner) public view returns (bool ok) { // 检查一些任意的情况。 address tokenAddress = msg.sender; return (keccak256(newOwner) & 0xff) == (bytes20(tokenAddress) & 0xff); } } 可见性和 getter 函数 由于 Solidity 有两种函数调用（内部调用不会产生实际的 EVM 调用或称为“消息调用”，而外部调用则会产生一个 EVM 调用），函数和状态变量有四种可见性类型。函数可以指定为 external ，public ，internal 或者 private，默认情况下函数类型为 public。 对于状态变量，不能设置为 external ，默认是 internal 。 external ：外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 f 不能从内部调用（即 f 不起作用，但 this.f() 可以）。 当收到大量数据的时候，外部函数有时候会更有效率。 public ：public 函数是合约接口的一部分，可以在内部或通过消息调用。对于公共状态变量，会自动生成一个 getter 函数（见下面）。 internal ：这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 this 调用。 private ：private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。 合约中的所有内容对外部观察者都是可见的。设置一些 private 类型只能阻止其他合约访问和修改这些信息，但是对于区块链外的整个世界它仍然是可见的。 可见性标识符的定义位置，对于状态变量来说是在类型后面，对于函数是在参数列表和返回关键字中间。 pragma solidity ^0.4.16; contract C { function f(uint a) private pure returns (uint b) { return a + 1; } function setData(uint a) internal { data = a; } uint public data; } 在下面的例子中，D 可以调用 c.getData（） 来获取状态存储中 data 的值，但不能调用 f 。 合约 E 继承自 C ，因此可以调用 compute。 // 下面代码编译错误 pragma solidity ^0.4.0; contract C { uint private data; function f(uint a) private returns(uint b) { return a + 1; } function setData(uint a) public { data = a; } function getData() public returns(uint) { return data; } function compute(uint a, uint b) internal returns (uint) { return a+b; } } contract D { function readData() public { C c = new C(); uint local = c.f(7); // 错误：成员 `f` 不可见 c.setData(3); local = c.getData(); local = c.compute(3, 5); // 错误：成员 `compute` 不可见 } } contract E is C { function g() public { C c = new C(); uint val = compute(3, 5); // 访问内部成员（从继承合约访问父合约成员） } } Getter 函数 编译器自动为所有 public 状态变量创建 getter 函数。对于下面给出的合约，编译器会生成一个名为 data 的函数， 该函数不会接收任何参数并返回一个 uint ，即状态变量 data 的值。可以在声明时完成状态变量的初始化。 pragma solidity ^0.4.0; contract C { uint public data = 42; } contract Caller { C c = new C(); function f() public { uint local = c.data(); } } getter 函数具有外部可见性。如果在内部访问 getter（即没有 this. ），它被认为一个状态变量。 如果它是外部访问的（即用 this. ），它被认为为一个函数。 pragma solidity ^0.4.0; contract C { uint public data; function x() public { data = 3; // 内部访问 uint val = this.data(); // 外部访问 } } 下一个例子稍微复杂一些： pragma solidity ^0.4.0; contract Complex { struct Data { uint a; bytes3 b; mapping (uint => uint) map; } mapping (uint => mapping(bool => Data[])) public data; } 这将会生成以下形式的函数 :: function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) { a = data[arg1][arg2][arg3].a; b = data[arg1][arg2][arg3].b; } 请注意，因为没有好的方法来提供映射的键，所以结构中的映射被省略。 函数 |modifier| 使用 |modifier| 可以轻松改变函数的行为。 例如，它们可以在执行函数之前自动检查某个条件。 |modifier| 是合约的可继承属性， 并可能被派生合约覆盖。 pragma solidity ^0.4.11; contract owned { function owned() public { owner = msg.sender; } address owner; // 这个合约只定义一个修饰器，但并未使用： 它将会在派生合约中用到。 // 修饰器所修饰的函数体会被插入到特殊符号 _; 的位置。 // 这意味着如果是 owner 调用这个函数，则函数会被执行，否则会抛出异常。 modifier onlyOwner { require(msg.sender == owner); _; } } contract mortal is owned { // 这个合约从 `owned` 继承了 `onlyOwner` 修饰符，并将其应用于 `close` 函数， // 只有在合约里保存的 owner 调用 `close` 函数，才会生效。 function close() public onlyOwner { selfdestruct(owner); } } contract priced { // 修改器可以接收参数： modifier costs(uint price) { if (msg.value >= price) { _; } } } contract Register is priced, owned { mapping (address => bool) registeredAddresses; uint price; function Register(uint initialPrice) public { price = initialPrice; } // 在这里也使用关键字 `payable` 非常重要，否则函数会自动拒绝所有发送给它的以太币。 function register() public payable costs(price) { registeredAddresses[msg.sender] = true; } function changePrice(uint _price) public onlyOwner { price = _price; } } contract Mutex { bool locked; modifier noReentrancy() { require(!locked); locked = true; _; locked = false; } // 这个函数受互斥量保护，这意味着 `msg.sender.call` 中的重入调用不能再次调用 `f`。 // `return 7` 语句指定返回值为 7，但修改器中的语句 `locked = false` 仍会执行。 function f() public noReentrancy returns (uint) { require(msg.sender.call()); return 7; } } 如果同一个函数有多个 modifier，它们之间以空格隔开，modifier会依次检查执行。 在早期的 Solidity 版本中，有 |modifier| 的函数，return 语句的行为表现不同。 modifier 或函数体中显式的 return 语句仅仅跳出当前的 modifier 和函数体。 返回变量会被赋值，但整个执行逻辑会从前一个 |modifier| 中的定义的 “_” 之后继续执行。 modifier的参数可以是任意表达式，在此上下文中，所有在函数中可见的符号，在 modifier 中均可见。在 modifier 中引入的符号在函数中不可见（可能被重载改变）。 Constant 状态变量 状态变量可以被声明为 constant。在这种情况下，只能使用那些在编译时有确定值的表达式来给它们赋值。任何通过访问 storage，区块链数据（例如 now, this.balance 或者 block.number）或执行数据（ msg.gas ）或对外部合约的调用来给它们赋值都是不允许的。在内存分配上有边界效应（side-effect）的表达式是允许的，但对其他内存对象产生边界效应的表达式则不行。内建（built-in）函数 keccak256，sha256，ripemd160，ecrecover，addmod 和 mulmod 是允许的（即使他们确实会调用外部合约）。 允许带有边界效应的内存分配器的原因是这将允许构建复杂的对象，比如查找表（lookup-table）。 此功能尚未完全可用。编译器不会为这些变量预留存储，它们的每次出现都会被替换为相应的常量表达式（这将可能被优化器计算为实际的某个值）。不是所有类型的状态变量都支持用 constant 来修饰，当前支持的仅有值类型和字符串。 pragma solidity ^0.4.0; contract C { uint constant x = 32**22 + 8; string constant text = \"abc\"; bytes32 constant myHash = keccak256(\"abc\"); } 函数 View 函数 可以将函数声明为 view 类型，这种情况下要保证不修改状态。 下面的语句被认为是修改状态： 修改状态变量。 产生事件。 创建其它合约。 使用selfdestruct。 通过调用发送以太币。 调用任何没有标记为 view 或者 pure 的函数。 使用低级调用。 使用包含特定操作码的内联汇编。 pragma solidity ^0.4.16; contract C { function f(uint a, uint b) public view returns (uint) { return a * (b + 42) + now; } } constant 是 view 的别名。 Getter 方法被标记为 view。 编译器没有强制 view 方法不能修改状态。 Pure 函数 函数可以声明为 pure ，在这种情况下，承诺不读取或修改状态。除了上面解释的状态修改语句列表之外，以下被认为是从状态中读取： 读取状态变量。 访问 this.balance 或者 .balance。 访问 block，tx， msg 中任意成员 （除 msg.sig 和 msg.data 之外）。 调用任何未标记为 pure 的函数。 使用包含某些操作码的内联汇编。 pragma solidity ^0.4.16; contract C { function f(uint a, uint b) public pure returns (uint) { return a * (b + 42); } } 编译器没有强制 pure 方法不能读取状态。 Fallback 函数 合约可以有一个未命名的函数。这个函数不能有参数也不能有返回值。如果在一个到合约的调用中，没有其他函数与给定的函数标识符匹配（或没有提供调用数据），那么这个函数（fallback 函数）会被执行。 除此之外，每当合约收到以太币（没有任何数据），这个函数就会执行。此外，为了接收以太币，fallback 函数必须标记为 payable。如果不存在这样的函数，则合约不能通过常规交易接收以太币。 在这样的上下文中，通常只有很少的 gas 可以用来完成这个函数调用（准确地说，是 2300 gas），所以使 fallback 函数的调用尽量廉价很重要。请注意，调用 fallback 函数的交易（而不是内部调用）所需的 gas 要高得多，因为每次交易都会额外收取 21000 gas 或更多的费用，用于签名检查等操作。 具体来说，以下操作会消耗比 fallback 函数更多的 gas： 写入存储 创建合约 调用消耗大量 gas 的外部函数 发送以太币 请确保您在部署合约之前彻底测试您的 fallback 函数，以确保执行成本低于 2300 个 gas。 即使 fallback 函数不能有参数，仍然可以使用 msg.data 来获取随调用提供的任何有效数据。 一个没有定义 fallback 函数的合约，直接接收以太币（没有函数调用，即使用 send 或 transfer）会抛出一个异常，并返还以太币（在 Solidity v0.4.0 之前行为会有所不同）。所以如果你想让你的合约接收以太币，必须实现 fallback 函数。 一个没有 payable fallback 函数的合约，可以作为 coinbase transaction （又名 miner block reward ）的接收者或者作为 selfdestruct 的目标来接收以太币。 一个合约不能对这种以太币转移做出反应，因此也不能拒绝它们。这是 EVM 在设计时就决定好的，而且 Solidity 无法绕过这个问题。 这也意味着 this.balance 可以高于合约中实现的一些手工记帐的总和（即在 fallback 函数中更新的累加器）。 pragma solidity ^0.4.0; contract Test { // 发送到这个合约的所有消息都会调用此函数（因为该合约没有其它函数）。 // 向这个合约发送以太币会导致异常，因为 fallback 函数没有 `payable` 修饰符 function() public { x = 1; } uint x; } // 这个合约会保留所有发送给它的以太币，没有办法返还。 contract Sink { function() public payable { } } contract Caller { function callTest(Test test) public { test.call(0xabcdef01); // 不存在的哈希 // 导致 test.x 变成 == 1。 // 以下将不会编译，但如果有人向该合约发送以太币，交易将失败并拒绝以太币。 // test.send(2 ether）; } } 函数重载 合约可以具有多个不同参数的同名函数。这也适用于继承函数。以下示例展示了合约 A 中的重载函数 f。 pragma solidity ^0.4.16; contract A { function f(uint _in) public pure returns (uint out) { out = 1; } function f(uint _in, bytes32 _key) public pure returns (uint out) { out = 2; } } 重载函数也存在于外部接口中。如果两个外部可见函数仅区别于 Solidity 内的类型而不是它们的外部类型则会导致错误。 ```bash // 以下代码无法编译 pragma solidity ^0.4.16; contract A { function f(B _in) public pure returns (B out) { out = _in; } function f(address _in) public pure returns (address out) { out = _in; } } contract B { } 以上两个 f 函数重载都接受了 ABI 的地址类型，虽然它们在 Solidity 中被认为是不同的。 重载解析和参数匹配 通过将当前范围内的函数声明与函数调用中提供的参数相匹配，可以选择重载函数。 如果所有参数都可以隐式地转换为预期类型，则选择函数作为重载候选项。如果一个候选都没有，解析失败。 返回参数不作为重载解析的依据。 pragma solidity ^0.4.16; contract A { function f(uint8 _in) public pure returns (uint8 out) { out = _in; } function f(uint256 _in) public pure returns (uint256 out) { out = _in; } } 调用 f(50) 会导致类型错误，因为 50 既可以被隐式转换为 uint8 也可以被隐式转换为 uint256。另一方面，调用 f(256) 则会解析为 f(uint256) 重载，因为 256 不能隐式转换为 uint8。 事件 事件允许我们方便地使用 EVM 的日志基础设施。我们可以在 dapp 的用户界面中监听事件，EVM 的日志机制可以反过来“调用”用来监听事件的 Javascript 回调函数。 事件在合约中可被继承。当他们被调用时，会使参数被存储到交易的日志中 —— 一种区块链中的特殊数据结构。这些日志与地址相关联，被并入区块链中，只要区块可以访问就一直存在（在 Frontier 和 Homestead 版本中会被永久保存，在 Serenity 版本中可能会改动)。日志和事件在合约内不可直接被访问（甚至是创建日志的合约也不能访问）。 对日志的 SPV（Simplified Payment Verification）证明是可能的，如果一个外部实体提供了一个带有这种证明的合约，它可以检查日志是否真实存在于区块链中。但需要留意的是，由于合约中仅能访问最近的 256 个区块哈希，所以还需要提供区块头信息。 最多三个参数可以接收 indexed 属性，从而使它们可以被搜索：在用户界面上可以使用 indexed 参数的特定值来进行过滤。 如果数组（包括 string 和 bytes）类型被标记为索引项，则它们的 keccak-256 哈希值会被作为 topic 保存。除非你用 anonymous 说明符声明事件，否则事件签名的哈希值是 topic 之一。同时也意味着对于匿名事件无法通过名字来过滤。所有非索引参数都将存储在日志的数据部分中。 索引参数本身不会被保存。你只能搜索它们的值（来确定相应的日志数据是否存在），而不能获取它们的值本身。 pragma solidity ^0.4.0; contract ClientReceipt { event Deposit( address indexed _from, bytes32 indexed _id, uint _value ); function deposit(bytes32 _id) public payable { // 我们可以过滤对 `Deposit` 的调用，从而用 Javascript API 来查明对这个函数的任何调用（甚至是深度嵌套调用）。 Deposit(msg.sender, _id, msg.value); } } 使用 JavaScript API 调用事件的用法如下： var abi = /* abi 由编译器产生 */; var ClientReceipt = web3.eth.contract(abi); var clientReceipt = ClientReceipt.at(\"0x1234...ab67\" /* 地址 */); var event = clientReceipt.Deposit(); // 监视变化 event.watch(function(error, result){ // 结果包括对 `Deposit` 的调用参数在内的各种信息。 if (!error) console.log(result); }); // 或者通过回调立即开始观察 var event = clientReceipt.Deposit(function(error, result) { if (!error) console.log(result); }); 日志的底层接口 通过函数 log0，log1， log2， log3 和 log4 可以访问日志机制的底层接口。logi 接受 i + 1 个 bytes32 类型的参数。其中第一个参数会被用来做为日志的数据部分，其它的会做为 topic。上面的事件调用可以以相同的方式执行。 pragma solidity ^0.4.10; contract C { function f() public payable { bytes32 _id = 0x420042; log3( bytes32(msg.value), bytes32(0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20), bytes32(msg.sender), _id ); } } 其中的长十六进制数的计算方法是 keccak256(\"Deposit(address,hash256,uint256)\")，即事件的签名。 其它学习事件机制的资源 Javascript 文档 事件使用例程 如何在 js 中访问它们 继承 通过复制包括多态的代码，Solidity 支持多重继承。所有的函数调用都是虚拟的，这意味着最远的派生函数会被调用，除非明确给出合约名称。当一个合约从多个合约继承时，在区块链上只有一个合约被创建，所有基类合约的代码被复制到创建的合约中。 总的来说，Solidity 的继承系统与 Python的继承系统，非常相似，特别是多重继承方面。 下面的例子进行了详细的说明。 pragma solidity ^0.4.16; contract owned { function owned() { owner = msg.sender; } address owner; } // 使用 is 从另一个合约派生。派生合约可以访问所有非私有成员，包括内部函数和状态变量， // 但无法通过 this 来外部访问。 contract mortal is owned { function kill() { if (msg.sender == owner) selfdestruct(owner); } } // 这些抽象合约仅用于给编译器提供接口。 // 注意函数没有函数体。 // 如果一个合约没有实现所有函数，则只能用作接口。 contract Config { function lookup(uint id) public returns (address adr); } contract NameReg { function register(bytes32 name) public; function unregister() public; } // 可以多重继承。请注意，owned 也是 mortal 的基类， // 但只有一个 owned 实例（就像 C++ 中的虚拟继承）。 contract named is owned, mortal { function named(bytes32 name) { Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970); NameReg(config.lookup(1)).register(name); } // 函数可以被另一个具有相同名称和相同数量/类型输入的函数重载。 // 如果重载函数有不同类型的输出参数，会导致错误。 // 本地和基于消息的函数调用都会考虑这些重载。 function kill() public { if (msg.sender == owner) { Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970); NameReg(config.lookup(1)).unregister(); // 仍然可以调用特定的重载函数。 mortal.kill(); } } } // 如果构造函数接受参数， // 则需要在声明（合约的构造函数）时提供， // 或在派生合约的构造函数位置以修饰器调用风格提供（见下文）。 contract PriceFeed is owned, mortal, named(\"GoldFeed\") { function updateInfo(uint newInfo) public { if (msg.sender == owner) info = newInfo; } function get() public view returns(uint r) { return info; } uint info; } 注意，在上边的代码中，我们调用 mortal.kill() 来“转发”销毁请求。这样做法是有问题的，在下面的例子中可以看到:: pragma solidity ^0.4.0; contract owned { function owned() public { owner = msg.sender; } address owner; } contract mortal is owned { function kill() public { if (msg.sender == owner) selfdestruct(owner); } } contract Base1 is mortal { function kill() public { /* 清除操作 1 */ mortal.kill(); } } contract Base2 is mortal { function kill() public { /* 清除操作 2 */ mortal.kill(); } } contract Final is Base1, Base2 { } 调用 Final.kill() 时会调用最远的派生重载函数 Base2.kill，但是会绕过 Base1.kill，主要是因为它甚至都不知道 Base1 的存在。解决这个问题的方法是使用 super: pragma solidity ^0.4.0; contract owned { function owned() public { owner = msg.sender; } address owner; } contract mortal is owned { function kill() public { if (msg.sender == owner) selfdestruct(owner); } } contract Base1 is mortal { function kill() public { /* 清除操作 1 */ super.kill(); } } contract Base2 is mortal { function kill() public { /* 清除操作 2 */ super.kill(); } } contract Final is Base1, Base2 { } 如果 Base2 调用 super 的函数，它不会简单在其基类合约上调用该函数。 相反，它在最终的继承关系图谱的下一个基类合约中调用这个函数，所以它会调用 Base1.kill()（注意最终的继承序列是——从最远派生合约开始：Final, Base2, Base1, mortal, ownerd）。在类中使用 super 调用的实际函数在当前类的上下文中是未知的，尽管它的类型是已知的。 这与普通的虚拟方法查找类似。 基类构造函数的参数 派生合约需要提供基类构造函数需要的所有参数。这可以通过两种方式来完成:: pragma solidity ^0.4.0; contract Base { uint x; function Base(uint _x) public { x = _x; } } contract Derived is Base(7) { function Derived(uint _y) Base(_y * _y) public { } } 一种方法直接在继承列表中调用基类构造函数（is Base(7)）。另一种方法是像 |modifier| 使用方法一样，作为派生合约构造函数定义头的一部分，（Base(_y * _y))。如果构造函数参数是常量并且定义或描述了合约的行为，使用第一种方法比较方便。如果基类构造函数的参数依赖于派生合约，那么必须使用第二种方法。如果像这个简单的例子一样，两个地方都用到了，优先使用 |modifier| 风格的参数。 多重继承与线性化 编程语言实现多重继承需要解决几个问题。 一个问题是钻石问题 Solidity 借鉴了 Python 的方式并且使用 C3 线性化 强制一个由基类构成的 DAG（有向无环图）保持一个特定的顺序。 这最终反映为我们所希望的唯一化的结果，但也使某些继承方式变为无效。尤其是，基类在 is 后面的顺序很重要。在下面的代码中，Solidity 会给出“ Linearization of inheritance graph impossible ”这样的错误。 // 以下代码编译出错 pragma solidity ^0.4.0; contract X {} contract A is X {} contract C is A, X {} 代码编译出错的原因是 C 要求 X 重写 A （因为定义的顺序是 A, X ）， 但是 A 本身要求重写 X，无法解决这种冲突。 可以通过一个简单的规则来记忆：以从“最接近的基类”（most base-like）到“最远的继承”（most derived）的顺序来指定所有的基类。 继承有相同名字的不同类型成员 当继承导致一个合约具有相同名字的函数和 |modifier| 时，这会被认为是一个错误。 当事件和 |modifier| 同名，或者函数和事件同名时，同样会被认为是一个错误。 有一种例外情况，状态变量的 getter 可以覆盖一个 public 函数。 抽象合约 合约函数可以缺少实现，如下例所示（请注意函数声明头由 ; 结尾）: pragma solidity ^0.4.0; contract Feline { function utterance() public returns (bytes32); } 这些合约无法成功编译（即使它们除了未实现的函数还包含其他已经实现了的函数），但他们可以用作基类合约:: pragma solidity ^0.4.0; contract Feline { function utterance() public returns (bytes32); } contract Cat is Feline { function utterance() public returns (bytes32) { return \"miaow\"; } } 如果合约继承自抽象合约，并且没有通过重写来实现所有未实现的函数，那么它本身就是抽象的。 接口 接口类似于抽象合约，但是它们不能实现任何函数。还有进一步的限制： 无法继承其他合约或接口。 无法定义构造函数。 无法定义变量。 无法定义结构体 无法定义枚举。 将来可能会解除这里的某些限制。 接口基本上仅限于合约 ABI 可以表示的内容，并且 ABI 和接口之间的转换应该不会丢失任何信息。 接口由它们自己的关键字表示： pragma solidity ^0.4.11; interface Token { function transfer(address recipient, uint amount) public; } 就像继承其他合约一样，合约可以继承接口。 库 库与合约类似，它们只需要在特定的地址部署一次，并且它们的代码可以通过 EVM 的 DELEGATECALL(Homestead 之前使用 CALLCODE 关键字)特性进行重用。这意味着如果库函数被调用，它的代码在调用合约的上下文中执行，即 this 指向调用合约，特别是可以访问调用合约的存储。因为每个库都是一段独立的代码，所以它仅能访问调用合约明确提供的状态变量（否则它就无法通过名字访问这些变量）。因为我们假定库是无状态的，所以如果它们不修改状态（也就是说，如果它们是 view 或者 pure 函数），库函数仅可以通过直接调用来使用（即不使用 DELEGATECALL 关键字），特别是，除非能规避 Solidity 的类型系统，否则是不可能销毁任何库的。 库可以看作是使用他们的合约的隐式的基类合约。虽然它们在继承关系中不会显式可见，但调用库函数与调用显式的基类合约十分类似（如果 L 是库的话，可以使用 L.f() 调用库函数）。此外，就像库是基类合约一样，对所有使用库的合约，库的 internal 函数都是可见的。 当然，需要使用内部调用约定来调用内部函数，这意味着所有内部类型，内存类型都是通过引用而不是复制来传递。为了在 EVM 中实现这些，内部库函数的代码和从其中调用的所有函数都在编译阶段被拉取到调用合约中，然后使用一个 JUMP 调用来代替 DELEGATECALL。 下面的示例说明如何使用库（但也请务必看看 :ref:using for 有一个实现 set 更好的例子）。 pragma solidity ^0.4.16; library Set { // 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。 struct Data { mapping(uint => bool) flags; } // 注意第一个参数是“storage reference”类型，因此在调用中参数传递的只是它的存储地址而不是内容。 // 这是库函数的一个特性。如果该函数可以被视为对象的方法，则习惯称第一个参数为 `self` 。 function insert(Data storage self, uint value) public returns (bool) { if (self.flags[value]) return false; // 已经存在 self.flags[value] = true; return true; } function remove(Data storage self, uint value) public returns (bool) { if (!self.flags[value]) return false; // 不存在 self.flags[value] = false; return true; } function contains(Data storage self, uint value) public view returns (bool) { return self.flags[value]; } } contract C { Set.Data knownValues; function register(uint value) public { // 不需要库的特定实例就可以调用库函数， // 因为当前合约就是“instance”。 require(Set.insert(knownValues, value)); } // 如果我们愿意，我们也可以在这个合约中直接访问 knownValues.flags。 } 当然，你不必按照这种方式去使用库：它们也可以在不定义结构数据类型的情况下使用。函数也不需要任何存储引用参数，库可以出现在任何位置并且可以有多个存储引用参数。 调用 Set.contains，Set.insert 和 Set.remove 都被编译为外部调用（ DELEGATECALL ）。如果使用库，请注意实际执行的是外部函数调用。msg.sender， msg.value 和 this 在调用中将保留它们的值，（在 Homestead 之前，因为使用了 CALLCODE，改变了 msg.sender 和 msg.value)。 以下示例展示了如何在库中使用内存类型和内部函数来实现自定义类型，而无需支付外部函数调用的开销： pragma solidity ^0.4.16; library BigInt { struct bigint { uint[] limbs; } function fromUint(uint x) internal pure returns (bigint r) { r.limbs = new uint[](1); r.limbs[0] = x; } function add(bigint _a, bigint _b) internal pure returns (bigint r) { r.limbs = new uint[](max(_a.limbs.length, _b.limbs.length)); uint carry = 0; for (uint i = 0; i 0)) carry = 1; else carry = 0; } if (carry > 0) { // 太差了，我们需要增加一个 limb uint[] memory newLimbs = new uint[](r.limbs.length + 1); for (i = 0; i b ? a : b; } } contract C { using BigInt for BigInt.bigint; function f() public pure { var x = BigInt.fromUint(7); var y = BigInt.fromUint(uint(-1)); var z = x.add(y); } } 由于编译器无法知道库的部署位置，我们需要通过链接器将这些地址填入最终的字节码中 （请参阅 :ref:commandline-compiler 以了解如何使用命令行编译器来链接字节码）。 如果这些地址没有作为参数传递给编译器，编译后的十六进制代码将包含 __Set______ 形式的占位符（其中 Set 是库的名称）。可以手动填写地址来将那 40 个字符替换为库合约地址的十六进制编码。 与合约相比，库的限制： 没有状态变量 不能够继承或被继承 不能接收以太币 （将来有可能会解除这些限制） 库的调用保护 如果库的代码是通过 CALL 来执行，而不是 DELEGATECALL 或者 CALLCODE 那么执行的结果会被回退，除非是对 view 或者 pure 函数的调用。EVM 没有为合约提供检测是否使用 CALL 的直接方式，但是合约可以使用 ADDRESS 操作码找出正在运行的“位置”。生成的代码通过比较这个地址和构造时的地址来确定调用模式。 更具体地说，库的运行时代码总是从一个 push 指令开始，它在编译时是 20 字节的零。当部署代码运行时，这个常数 被内存中的当前地址替换，修改后的代码存储在合约中。在运行时，这导致部署时地址是第一个被 push 到堆栈上的常数， 对于任何 non-view 和 non-pure 函数，调度器代码都将对比当前地址与这个常数是否一致。 Using For 指令 using A for B; 可用于附加库函数（从库 A）到任何类型（B）。 这些函数将接收到调用它们的对象作为它们的第一个参数（像 Python 的 self 变量）。 using A for *; 的效果是，库 A 中的函数被附加在任意的类型上。在这两种情况下，所有函数都会被附加一个参数，即使它们的第一个参数类型与对象的类型不匹配。 函数调用和重载解析时才会做类型检查。using A for B; 指令仅在当前作用域有效，目前仅限于在当前合约中，后续可能提升到全局范围。通过引入一个模块，不需要再添加代码就可以使用包括库函数在内的数据类型。 让我们用这种方式将libraries中的 set 例子重写:: pragma solidity ^0.4.16; // 这是和之前一样的代码，只是没有注释。 library Set { struct Data { mapping(uint => bool) flags; } function insert(Data storage self, uint value) public returns (bool) { if (self.flags[value]) return false; // 已经存在 self.flags[value] = true; return true; } function remove(Data storage self, uint value) public returns (bool) { if (!self.flags[value]) return false; // 不存在 self.flags[value] = false; return true; } function contains(Data storage self, uint value) public view returns (bool) { return self.flags[value]; } } contract C { using Set for Set.Data; // 这里是关键的修改 Set.Data knownValues; function register(uint value) public { // Here, all variables of type Set.Data have // corresponding member functions. // The following function call is identical to // `Set.insert(knownValues, value)` // 这里， Set.Data 类型的所有变量都有与之相对应的成员函数。 // 下面的函数调用和 `Set.insert(knownValues, value)` 的效果完全相同。 require(knownValues.insert(value)); } } 也可以像这样扩展基本类型: pragma solidity ^0.4.16; library Search { function indexOf(uint[] storage self, uint value) public view returns (uint) { for (uint i = 0; i 注意，所有库调用都是实际的 EVM 函数调用。这意味着如果传递内存或值类型，都将产生一个副本，即使是 self 变量。]使用存储引用变量是唯一不会发生拷贝的情况。 Solidity汇编 Solidity 定义了一种汇编语言，在没有 Solidity 的情况下也可以使用。这种汇编语言也可以嵌入到 Solidity 源代码中当作“内联汇编”使用。 我们从如何使用内联汇编开始，介绍它如何区别于独立汇编语言，然后详细讲述这种汇编语言。 内联汇编 为了实现更细粒度的控制，尤其是为了通过编写库来增强语言，可以利用接近虚拟机的语言将内联汇编与 Solidity 语句结合在一起使用。 由于 EVM 是基于栈的虚拟机，因此通常很难准确地定位栈内插槽（存储位置）的地址，并为操作码提供正确的栈内位置来获取参数。 Solidity 的内联汇编试图通过提供以下特性来解决这个问题以及手工编写汇编代码时可能出现的问题： 函数风格操作码： mul(1, add(2, 3)) 而不是 push1 3 push1 2 add push1 1 mul 汇编局部变量： let x := add(2, 3) let y := mload(0x40) x := add(x, y) 可以访问外部变量： function f(uint x) public { assembly { x := sub(x, 1) } } 标签： let x := 10 repeat: x := sub(x, 1) jumpi(repeat, eq(x, 0)) 循环： for { let i := 0 } lt(i, x) { i := add(i, 1) } { y := mul(2, y) } if 语句： if slt(x, 0) { x := sub(0, x) } switch 语句： switch x case 0 { y := mul(x, 2) } default { y := 0 } 函数调用： function f(x) -> y { switch x case 0 { y := 1 } default { y := mul(x, f(sub(x, 1))) } } 现在我们详细讲解内联汇编语言。 内联汇编是一种在底层访问Simplechain虚拟机的语言。这抛弃了很多 Solidity 提供的重要安全特性。 TODO：写出在内联汇编中作用域规则的细微差别，以及在使用库合约的内部函数时产生的复杂性。此外，还要编写有关编译器定义的符号。 例子 下面例子展示了一个库合约的代码，它可以取得另一个合约的代码，并将其加载到一个 bytes 变量中。 这对于“常规 Solidity”来说是根本不可能的，汇编库合约则可以通过这种方式来增强语言特性。 pragma solidity ^0.4.0; library GetCode { function at(address _addr) public view returns (bytes o_code) { assembly { // 获取代码大小，这需要汇编语言 let size := extcodesize(_addr) // 分配输出字节数组 – 这也可以不用汇编语言来实现 // 通过使用 o_code = new bytes（size） o_code := mload(0x40) // 包括补位在内新的“memory end” mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f)))) // 把长度保存到内存中 mstore(o_code, size) // 实际获取代码，这需要汇编语言 extcodecopy(_addr, add(o_code, 0x20), 0, size) } } } 在优化器无法生成高效代码的情况下，内联汇编也可能更有好处。请注意，由于编译器无法对汇编语句进行相关的检查，所以编写汇编代码肯定更加困难； 因此只有在处理一些相对复杂的问题时才需要使用它，并且你需要明确知道自己要做什么。 pragma solidity ^0.4.16; library VectorSum { // 因为目前的优化器在访问数组时无法移除边界检查， // 所以这个函数的执行效率比较低。 function sumSolidity(uint[] _data) public view returns (uint o_sum) { for (uint i = 0; i 语法 和 Solidity 一样，Assembly 也会解析注释、文字和标识符，所以你可以使用通常的 // 和 /* */ 来进行注释。 内联汇编程序由 assembly { ... } 来标记，在这些大括号内可以使用以下内容（更多详细信息请参阅后面部分）。 字面常数，也就是 0x123、42 或 \"abc\" （不超过 32 个字符的字符串） 操作码（在“instruction style”内），比如 mload sload dup1 sstore，操作码列表请看后面 函数风格操作码，比如 add(1，mlod(0)) 标签，比如 name: 变量声明，比如 let x := 7、let x := add(y, 3) 或者 let x （初始值将被置为 empty(0)） 标识符（标签或者汇编局部变量以及用作内联汇编时的外部变量），比如 jump(name)、3 x add 赋值（在“instruction style”内），比如 3 =: x 函数风格赋值，比如 x := add(y，3) 一些控制局部变量作用域的语句块，比如 {let x := 3 { let y := add(x，1) }} 操作码 参考操作码： 如果一个操作码需要参数（总是来自堆栈顶部），它们会在括号中给出。请注意：参数顺序可以看作是在非函数风格中逆序（下面会解释）。标有 - 的操作码不会向栈中压入（push）数据，标有 * 的操作码有特殊操作，而所有其他操作码都只会将一个数据压入（push）栈中。 用 F、H、B 或 C 标记的操作码代表它们从 Frontier、Homestead、Byzantium 或 Constantinople 开始被引入。Constantinople 目前仍在计划中，所以标记为 C 的指令目前都会导致一个非法指令异常。在下表中，mem[a...b) 表示从位置 a 开始至（不包括）位置 b 的内存字节数，storage[p] 表示位置 p 处的存储内容。 pushi 和 jumpdest 这两个操作码不能直接用。 在语法表中，操作码是作为预定义标识符提供的。 Instruction symbol Bool Explanation stop - F 停止执行，与 return(0,0) 等价 add(x, y) F x + y sub(x, y) F x - y mul(x, y) F x * y div(x, y) F x / y sdiv(x, y) F x / y，以二进制补码作为符号 mod(x, y) F x % y smod(x, y) F x % y，以二进制补码作为符号 exp(x, y) F x 的 y 次幂 not(x) F ~x，对 x 按位取反 lt(x, y) F 如果 x gt(x, y) F 如果 x > y 为 1，否则为 0 slt(x, y) F 如果 x sgt(x, y) F 如果 x > y 为 1，否则为 0，以二进制补码作为符号 eq(x, y) F 如果 x == y 为 1，否则为 0 iszero(x) F 如果 x == 0 为 1，否则为 0 and(x, y) F x 和 y 的按位与 or(x, y) F x 和 y 的按位或 xor(x, y) F x 和 y 的按位异或 byte(n, x) F x 的第 n 个字节，这个索引是从 0 开始的 shl(x, y) C 将 y 逻辑左移 x 位 shr(x, y) C 将 y 逻��右移 x 位 sar(x, y) C 将 y 算术右移 x 位 addmod(x, y, m) F 任意精度的 (x + y) % m mulmod(x, y, m) F 任意精度的 (x * y) % m signextend(i, x) F 对 x 的最低位到第 (i * 8 + 7) 进行符号扩展 keccak256(p, n) F keccak(mem[p...(p + n))) jump(label) - F 跳转到标签 / 代码位置 jumpi(label, cond) - F 如果条件为非零，跳转到标签 pc F 当前代码位置 pop(x) - F 删除（弹出）栈顶的 x 个元素 dup1 ... dup16 F 将栈内第 i 个元素（从栈顶算起）复制到栈顶 swap1 ... swap16 * F 将栈顶元素和其下第 i 个元素互换 mload(p) F mem[p...(p + 32)) mstore(p, v) - F mem[p...(p + 32)) := v mstore8(p, v) - F mem[p] := v & 0xff （仅修改一个字节） sload(p) F storage[p] sstore(p, v) - F storage[p] := v msize F 内存大小，即最大可访问内存索引 gas F 执行可用的 gas address F 当前合约 / 执行上下文的地址 balance(a) F 地址 a 的余额，以 wei 为单位 caller F 调用发起者（不包括 delegatecall） callvalue F 随调用发送的 Wei 的数量 calldataload(p) F 位置 p 的调用数据（32 字节） calldatasize F 调用数据的字节数大小 calldatacopy(t, f, s) - F 从调用数据的位置 f 的拷贝 s 个字节到内存的位置 t codesize F 当前合约 / 执行上下文地址的代码大小 codecopy(t, f, s) - F 从代码的位置 f 开始拷贝 s 个字节到内存的位置 t extcodesize(a) F 地址 a 的代码大小 extcodecopy(a, t, f, s) - F 和 codecopy(t, f, s) 类似，但从地址 a 获取代码 returndatasize B 最后一个 returndata 的大小 returndatacopy(t, f, s) - B 从 returndata 的位置 f 拷贝 s 个字节到内存的位置 t create(v, p, s) F 用 mem[p...(p + s)) 中的代码创建一个新合约、发送 v wei 并返回新地址 create2(v, n, p, s) C 用 mem[p...(p + s)) 中的代码，在地址keccak256( . n . keccak256(mem[p...(p + s)))创建新合约、发送 v wei 并返回新地址上 call(g, a, v, in,insize, out, outsize) F 使用 mem[in...(in + insize)) 作为输入数据，提供 g gas 和 v wei 对地址 a 发起消息调用，输出结果数据保存在 mem[out...(out + outsize))，发生错误（比如 gas 不足）时返回 0，正确结束返回 1 callcode(g, a, v, in,insize, out, outsize) F 与 call 等价，但仅使用地址 a 中的代码 且保持当前合约的执行上下文 delegatecall(g, a, in,insize, out, outsize) F 与 callcode 等价且保留 caller 和 callvalue staticcall(g, a, in,insize, out, outsize) F 与 call(g, a, 0, in, insize, out, outsize) 等价,但不允许状态修改 return(p, s) - F 终止运行，返回 mem[p...(p + s)) 的数据 revert(p, s) - B 终止运行，撤销状态变化，返回 mem[p...(p + s)) 的数据 selfdestruct(a) - F 终止运行，销毁当前合约并且把资金发送到地址 a invalid - F 以无效指令终止运行 log0(p, s) - F 以 mem[p...(p + s)) 的数据产生不带 topic 的日志 log1(p, s, t1) - F 以 mem[p...(p + s)) 的数据和 topic t1 产生日志 log2(p, s, t1, t2) - F 以 mem[p...(p + s)) 的数据和 topic t1、t2 产生日志 log3(p, s, t1, t2, t3) - F 以 mem[p...(p + s)) 的数据和 topic t1、t2、t3 产生日志 log4(p, s, t1, t2, t3, t4) - F 以 mem[p...(p + s)) 的数据和 topic t1、t2、t3 和 t4 产生日志 origin F 交易发起者地址 gasprice F 交易所指定的 gas 价格 blockhash(b) F 区块号 b 的哈希 - 目前仅适用于不包括当前区块的最后 256 个区块 coinbase F 当前的挖矿收益者地址 timestamp F 从当前 epoch 开始的当前区块时间戳（以秒为单位） number F 当前区块号 difficulty F 当前区块难度 gaslimit F 当前区块的 gas 上限 字面常量 你可以直接键入十进制或十六进制符号来作为整型常量使用，这会自动生成相应的 PUSHi 指令。 下面的代码将计算 2 加 3（等于 5），然后计算其与字符串 “abc” 的按位与。字符串在存储时为左对齐，且长度不能超过 32 字节。 assembly { 2 3 add \"abc\" and } 函数风格 你可以像使用字节码那样在操作码之后键入操作码。例如，把 3 与内存位置 0x80 处的数据相加就是 3 0x80 mload add 0x80 mstore 由于通常很难看到某些操作码的实际参数是什么，所以 Solidity 内联汇编还提供了一种“函数风格”表示法，同样功能的代码可以写做 mstore(0x80, add(mload(0x80), 3)) 函数风格表达式内不能使用指令风格的写法，即 1 2 mstore(0x80, add) 是无效汇编语句， 它必须写成 mstore(0x80, add(2, 1)) 这种形式。对于不带参数的操作码，括号可以省略。 注意，在函数风格写法中参数的顺序与指令风格相反。如果使用函数风格写法，第一个参数将会位于栈顶。 访问外部变量和函数 通过简单使用它们名称就可以访问 Solidity 变量和其他标识符。对于内存变量，这会将地址而不是值压入栈中。 存储变量是不同的，因为存储变量的值可能不占用完整的存储槽，因此其“地址”由存储槽和槽内的字节偏移量组成。 为了获取变量 x 所使用的存储槽，你可以使用 x_slot，并用的 x_offset 获取其字节偏移量。 在赋值语句中（见下文），我们甚至可以使用 Solidity 局部变量来赋值。 对于内联汇编而言的外部函数也可以被访问：汇编会将它们的入口标签（带有虚拟函数解析）压入栈中。Solidity 中的调用语义为： 调用者压入 return label、arg1、arg2、...、argn 被调用方返回 ret1、ret2、...、retm 这个特性使用起来还是有点麻烦，因为在调用过程中堆栈偏移量发生了根本变化，因此对局部变量的引用将会出错。 pragma solidity ^0.4.11; contract C { uint b; function f(uint x) public returns (uint r) { assembly { r := mul(x, sload(b_slot)) // 因为偏移量为 0，所以可以忽略 } } } 如果你访问一个实际数据位数小于 256 位的数据类型（比如 uint64、address、bytes16 或 byte），不要对这种类型经过编码后未使用的数据位上的数值做任何假设。尤其是不要假设它们肯定为 0。安全起见，在某个上下文中使用这种数据之前，请一定先将其数据清空为 0，这非常重要：uint32 x = f(); assembly { x := and(x, 0xffffffff) /* now use x */ }要清空有符号类型，你可以使用 signextend 操作码。 标签 标签已经不推荐使用。请使用函数、循环、if 或 switch 语句。 EVM 汇编的另一个问题是 jump 和 jumpi 函数使用绝对地址，这些绝对地址很容易改变。 Solidity 内联汇编提供了标签，以便更容易地使用 jump。注意，标签具有底层特征，使用循环、if 和 switch 指令（参见下文）而不使用标签也能写出高效汇编代码。 以下代码用来计算斐波那契数列中的一个元素。 { let n := calldataload(4) let a := 1 let b := a loop: jumpi(loopend, eq(n, 0)) a add swap1 n := sub(n, 1) jump(loop) loopend: mstore(0, a) return(0, 0x20) } 请注意：只有汇编程序知道当前栈高度时，才能自动访问堆栈变量。如果 jump 源和目标的栈高度不同，访问将失败。 虽然我们可以这么使用 jump，但在这种情况下，你不应该去访问任何栈里的变量（即使是汇编变量）。 此外，栈高度分析器还可以通过操作码（而不是根据控制流）检查代码操作码，因此在下面的情况下，汇编程序对标签 two 处的堆栈高度会产生错误的印象： { let x := 8 jump(two) one: // 这里的栈高度是 2（因为我们压入了 x 和 7）， // 但因为汇编程序是按顺序读取代码的， // 它会认为栈高度是 1。 // 在这里访问栈变量 x 会导致错误。 x := 9 jump(three) two: 7 // 把某个数据压入栈中 jump(one) three: } 汇编局部变量声明 你可以使用 let 关键字来声明只在内联汇编中可见的变量，实际上只在当前的 {...} 块中可见。 下面发生的事情应该是：let 指令将创建一个为变量保留的新数据槽，并在到达块末尾时自动删除。 你需要为变量提供一个初始值，它可以只是 0，但它也可以是一个复杂的函数风格表达式。 pragma solidity ^0.4.16; contract C { function f(uint x) public view returns (uint b) { assembly { let v := add(x, 1) mstore(0x80, v) { let y := add(sload(v), 1) b := y } // y 会在这里被“清除” b := add(b, v) } // v 会在这里被“清除” } } 赋值 可以给汇编局部变量和函数局部变量赋值。请注意：当给指向内存或存储的变量赋值时，你只是更改指针而不是数据。 有两种赋值方式：函数风格和指令风格。对于函数风格赋值（变量 := 值），你需要在函数风格表达式中提供一个值，它恰好可以产生一个栈里的值； 对于指令风格赋值（=: 变量），则仅从栈顶部获取数据。对于这两种方式，冒号均指向变量名称。赋值则是通过用新值替换栈中的变量值来实现的。 { let v := 0 // 作为变量声明的函数风格赋值 let g := add(v, 2) sload(10) =: v // 指令风格的赋值，将 sload(10) 的结果赋给 v } 指令风格的赋值已经不推荐。 If if 语句可以用于有条件地执行代码，且没有“else”部分；如果需要多种选择，你可以考虑使用“switch”（见下文）。 { if eq(value, 0) { revert(0, 0) } } 代码主体的花括号是必需的。 Switch 作为“if/else”的非常初级的版本，你可以使用 switch 语句。它计算表达式的值并与几个常量进行比较。选出与匹配常数对应的分支。 与某些编程语言容易出错的情况不同，控制流不会从一种情形继续执行到下一种情形。我们可以设定一个 fallback 或称为 default 的默认情况。 { let x := 0 switch calldataload(4) case 0 { x := calldataload(0x24) } default { x := calldataload(0x44) } sstore(0, div(x, 2)) } Case 列表里面不需要大括号，但 case 主体需要。 循环 汇编语言支持一个简单的 for-style 循环。For-style 循环有一个头，它包含初始化部分、条件和迭代后处理部分。 条件必须是函数风格表达式，而另外两个部分都是语句块。如果起始部分声明了某个变量，这些变量的作用域将扩展到循环体中（包括条件和迭代后处理部分）。 下面例子是计算某个内存区域中的数值总和。 { let x := 0 for { let i := 0 } lt(i, 0x100) { i := add(i, 0x20) } { x := add(x, mload(i)) } } For 循环也可以写成像 while 循环一样：只需将初始化部分和迭代后处理两部分留空。 { let x := 0 let i := 0 for { } lt(i, 0x100) { } { // while(i 函数 汇编语言允许定义底层函数。底层函数需要从栈中取得它们的参数（和返回 PC），并将结果放入栈中。调用函数的方式与执行函数风格操作码相同。函数可以在任何地方定义，并且在声明它们的语句块中可见。函数内部不能访问在函数之外定义的局部变量。这里没有严格的 return 语句。如果调用会返回多个值的函数，则必须使用 a，b：= f(x) 或 let a，b：= f(x) 的方式把它们赋值到一个元组。 下面例子通过平方和乘法实现了幂运算函数。 { function power(base, exponent) -> result { switch exponent case 0 { result := 1 } case 1 { result := base } default { result := power(mul(base, base), div(exponent, 2)) switch mod(exponent, 2) case 1 { result := mul(base, result) } } } } 注意事项 内联汇编语言可能具有相当高级的外观，但实际上它是非常低级的编程语言。函数调用、循环、if 语句和 switch 语句通过简单的重写规则进行转换， 然后，汇编程序为你做的唯一事情就是重新组织函数风格操作码、管理 jump 标签、计算访问变量的栈高度，还有在到达语句块末尾时删除局部汇编变量的栈数据。 特别是对于最后两种情况，汇编程序仅会按照代码的顺序计算栈的高度，而不一定遵循控制流程；了解这一点非常重要。此外，swap 等操作只会交换栈内的数据，而不是变量位置。 Solidity 惯例 与 EVM 汇编语言相比，Solidity 能够识别小于 256 位的类型，例如 uint24。为了提高效率，大多数算术运算只将它们视为 256 位数字，仅在必要时才清除未使用的数据位，即在将它们写入内存或执行比较之前才会这么做。这意味着，如果从内联汇编中访问这样的变量，你必须先手工清除那些未使用的数据位。 Solidity 以一种非常简单的方式管理内存：在 0x40 的位置有一个“空闲内存指针”。如果你打算分配内存，只需从此处开始使用内存，然后相应地更新指针即可。内存的开头 64 字节可以用来作为临时分配的“暂存空间”。“空闲内存指针”之后的 32 字节位置（即从 0x60 开始的位置）将永远为 0，可以用来初始化空的动态内存数组。 在 Solidity 中，内存数组的元素总是占用 32 个字节的倍数（是的，甚至对于 byte[] 都是这样，只有 bytes 和 string 不是这样）。多维内存数组就是指向内存数组的指针。动态数组的长度存储在数组的第一个槽中，其后才是数组元素。 静态内存数组没有长度字段，但很快就会增加，这是为了可以更好地进行静态数组和动态数组之间的转换，所以请不要依赖这点。 独立汇编 以上内联汇编描述的汇编语言也可以单独使用，实际上，计划是将其用作 Solidity 编译器的中间语言。在这种意义下，它试图实现以下几个目标： 1、即使代码是由 Solidity 的编译器生成的，用它编写的程序应该也是可读的。 2、从汇编到字节码的翻译应该尽可能少地包含“意外”。 3、控制流应该易于检测，以帮助进行形式化验证和优化。 为了实现第一个和最后一个目标，汇编提供了高级结构：如 for 循环、if 语句、switch 语句和函数调用。 应该可以编写不使用明确的 SWAP、DUP、JUMP 和 JUMPI 语句的汇编程序，因为前两个混淆了数据流，而最后两个混淆了控制流。 此外，形式为 mul(add(x, y), 7) 的函数风格语句优于如 7 y x add mul 的指令风格语句，因为在第一种形式中更容易查看哪个操作数用于哪个操作码。 第二个目标是通过采用一种非常规则的方式来将高级高级指令结构便以为字节码。 汇编程序执行的唯一非局部操作是用户自定义标识符（函数、变量、...）的名称查找，它遵循非常简单和固定的作用域规则并从栈中清除局部变量。 作用域：在其中声明的标识符（标签、变量、函数、汇编）仅在声明的语句块中可见（包括当前语句块中的嵌套语句块）。 即使它们在作用范围内，越过函数边界访问局部变量也是非法的。阴影化是禁止的。在声明之前不能访问局部变量，但标签、函数和汇编是可以的。 汇编是特殊的语句块，例如用于返回运行时代码或创建合约等。在子汇编外部的汇编语句块中声明的标示符在子汇编中全都不可见。 如果控制流经过块尾部，则会插入与在当前语句块中声明的局部变量数量相匹配的 pop 指令。无论何时引用局部变量，代码生成器都需要知道在当前栈的相对位置， 因此，需要跟踪当前所谓的栈高度。由于所有在语句块内声明的局部变量都会在语句块结束时被清楚，所以语句块前后的栈高度应该相同。如果情况并非如此，则会发出警告。 使用 switch、for 和函数应该可以编写复杂的代码，而无需手工调用 jump 或 jumpi。这将允许改进的形式化验证和优化更简单地分析控制流程。 此外，如果允许手动跳转，计算栈高度将会更加复杂。栈中所有局部变量的位置都需要明确知晓，否则在语句块结束时就无法自动获得局部变量的引用从而正确地清除它们。 例子： 我们将参考一个从 Solidity 到汇编指令的实例。考虑以下 Solidity 程序的运行时字节码:: pragma solidity ^0.4.16; contract C { function f(uint x) public pure returns (uint y) { y = 1; for (uint i = 0; i 将会生成如下汇编指令:: { mstore(0x40, 0x60) // 保存“空闲内存指针” // 函数选择器 switch div(calldataload(0), exp(2, 226)) case 0xb3de648b { let r := f(calldataload(4)) let ret := $allocate(0x20) mstore(ret, r) return(ret, 0x20) } default { revert(0, 0) } // 内存分配器 function $allocate(size) -> pos { pos := mload(0x40) mstore(0x40, add(pos, size)) } // 合约函数 function f(x) -> y { y := 1 for { let i := 0 } lt(i, x) { i := add(i, 1) } { y := mul(2, y) } } } 汇编语法 解析器任务如下： 将字节流转换为符号流，丢弃 C ++ 风格的注释（对源代码引用存在特殊注释，我们这里不解释它）。 根据下面的语法，将符号流转换为 AST。 注册语句块中定义的标识符（注释到 AST 节点），并注明变量从哪个地方开始可以访问。 汇编词法分析器遵循由 Solidity 自己定义的规则。 空格用于分隔所有符号，它由空格字符、制表符和换行符组成。注释格式是常规的 JavaScript/C++ 风格，并被解释为空格。 Grammar:: AssemblyBlock = '{' AssemblyItem* '}' AssemblyItem = Identifier | AssemblyBlock | AssemblyExpression | AssemblyLocalDefinition | AssemblyAssignment | AssemblyStackAssignment | LabelDefinition | AssemblyIf | AssemblySwitch | AssemblyFunctionDefinition | AssemblyFor | 'break' | 'continue' | SubAssembly AssemblyExpression = AssemblyCall | Identifier | AssemblyLiteral AssemblyLiteral = NumberLiteral | StringLiteral | HexLiteral Identifier = [a-zA-Z_$] [a-zA-Z_0-9]* AssemblyCall = Identifier '(' ( AssemblyExpression ( ',' AssemblyExpression )* )? ')' AssemblyLocalDefinition = 'let' IdentifierOrList ( ':=' AssemblyExpression )? AssemblyAssignment = IdentifierOrList ':=' AssemblyExpression IdentifierOrList = Identifier | '(' IdentifierList ')' IdentifierList = Identifier ( ',' Identifier)* AssemblyStackAssignment = '=:' Identifier LabelDefinition = Identifier ':' AssemblyIf = 'if' AssemblyExpression AssemblyBlock AssemblySwitch = 'switch' AssemblyExpression AssemblyCase* ( 'default' AssemblyBlock )? AssemblyCase = 'case' AssemblyExpression AssemblyBlock AssemblyFunctionDefinition = 'function' Identifier '(' IdentifierList? ')' ( '->' '(' IdentifierList ')' )? AssemblyBlock AssemblyFor = 'for' ( AssemblyBlock | AssemblyExpression ) AssemblyExpression ( AssemblyBlock | AssemblyExpression ) AssemblyBlock SubAssembly = 'assembly' Identifier AssemblyBlock NumberLiteral = HexNumber | DecimalNumber HexLiteral = 'hex' ('\"' ([0-9a-fA-F]{2})* '\"' | '\\'' ([0-9a-fA-F]{2})* '\\'') StringLiteral = '\"' ([^\"\\r\\n\\\\] | '\\\\' .)* '\"' HexNumber = '0x' [0-9a-fA-F]+ DecimalNumber = [0-9]+ "},"20_contractPattern.html":{"url":"20_contractPattern.html","title":"Contract template","keywords":"","body":"Some contract templates of Jin Dian can help developers learn quickly Solidity,and quickly start the development. Create excellent Dapp applications based on Simplechain. Vote The following contract is quite complex, but shows many Solidity functions. It achieved a voting contract. Of course, the main problem of electronic voting is how to distribute the voting rights to the right people and how to prevent manipulation. We will not solve all the problems here, but at least we will show how to conduct delegation voting. At the same time, counting votes is also Automatic and fully transparent 。 Our idea is to create a contract for each (vote) vote and provide short for each option. Then as the creator of the contract-the chairman, he will give each independent address the right to vote. People behind the address can choose to vote by themselves or entrust people they trust to vote. At the end of the voting time，winningProposal() the proposal that received the most votes will be returned. pragma solidity ^0.4.22; /// @title 委托投票 contract Ballot { // 这里声明了一个新的复合类型用于稍后的变量 // 它用来表示一个选民 struct Voter { uint weight; // 计票的权重 bool voted; // 若为真，代表该人已投票 address delegate; // 被委托人 uint vote; // 投票提案的索引 } // 提案的类型 struct Proposal { bytes32 name; // 简称（最长32个字节） uint voteCount; // 得票数 } address public chairperson; // 这声明了一个状态变量，为每个可能的地址存储一个 `Voter`。 mapping(address => Voter) public voters; // 一个 `Proposal` 结构类型的动态数组 Proposal[] public proposals; /// 为 `proposalNames` 中的每个提案，创建一个新的（投票）表决 constructor(bytes32[] proposalNames) public { chairperson = msg.sender; voters[chairperson].weight = 1; //对于提供的每个提案名称， //创建一个新的 Proposal 对象并把它添加到数组的末尾。 for (uint i = 0; i winningVoteCount) { winningVoteCount = proposals[p].voteCount; winningProposal_ = p; } } } // 调用 winningProposal() 函数以获取提案数组中获胜者的索引，并以此返回获胜者的名称 function winnerName() public view returns (bytes32 winnerName_) { winnerName_ = proposals[winningProposal()].name; } } Possible optimization At present, in order to distribute the voting rights to all participants, many transactions need to be executed. Do you have a better idea? Secret bidding (blind auction) In this section, we will show how to easily create a secret bidding contract on Simplechain. We will start from the public auction, everyone can see the bid, and then extend this contract to blind auction contract, The actual bid cannot be seen before the bidding period ends. Simple public auction The general idea of the following simple auction contract is that everyone can send their bids within the bidding period. The bid already contains funds/Ethernet coins to bind bidders to their bids. If the highest bid is raised (it is exceeded by other bidders), the former highest bidder can get her money back. At the end of the bidding period, the beneficiary needs to manually call the contract to receive his money-the contract cannot activate the receipt by itself. pragma solidity ^0.4.22; contract SimpleAuction { // 拍卖的参数。 address public beneficiary; // 时间是unix的绝对时间戳（自1970-01-01以来的秒数） // 或以秒为单位的时间段。 uint public auctionEnd; // 拍卖的当前状态 address public highestBidder; uint public highestBid; //可以取回的之前的出价 mapping(address => uint) pendingReturns; // 拍卖结束后设为 true，将禁止所有的变更 bool ended; // 变更触发的事件 event HighestBidIncreased(address bidder, uint amount); event AuctionEnded(address winner, uint amount); // 以下是所谓的 natspec 注释，可以通过三个斜杠来识别。 // 当用户被要求确认交易时将显示。 /// 以受益者地址 `_beneficiary` 的名义， /// 创建一个简单的拍卖，拍卖时间为 `_biddingTime` 秒。 constructor( uint _biddingTime, address _beneficiary ) public { beneficiary = _beneficiary; auctionEnd = now + _biddingTime; } /// 对拍卖进行出价，具体的出价随交易一起发送。 /// 如果没有在拍卖中胜出，则返还出价。 function bid() public payable { // 参数不是必要的。因为所有的信息已经包含在了交易中。 // 对于能接收以太币的函数，关键字 payable 是必须的。 // 如果拍卖已结束，撤销函数的调用。 require( now highestBid, \"There already is a higher bid.\" ); if (highestBid != 0) { // 返还出价时，简单地直接调用 highestBidder.send(highestBid) 函数， // 是有安全风险的，因为它有可能执行一个非信任合约。 // 更为安全的做法是让接收方自己提取金钱。 pendingReturns[highestBidder] += highestBid; } highestBidder = msg.sender; highestBid = msg.value; emit HighestBidIncreased(msg.sender, msg.value); } /// 取回出价（当该出价已被超越） function withdraw() public returns (bool) { uint amount = pendingReturns[msg.sender]; if (amount > 0) { // 这里很重要，首先要设零值。 // 因为，作为接收调用的一部分， // 接收者可以在 `send` 返回之前，重新调用该函数。 pendingReturns[msg.sender] = 0; if (!msg.sender.send(amount)) { // 这里不需抛出异常，只需重置未付款 pendingReturns[msg.sender] = amount; return false; } } return true; } /// 结束拍卖，并把最高的出价发送给受益人 function auctionEnd() public { // 对于可与其他合约交互的函数（意味着它会调用其他函数或发送以太币）， // 一个好的指导方针是将其结构分为三个阶段： // 1. 检查条件 // 2. 执行动作 (可能会改变条件) // 3. 与其他合约交互 // 如果这些阶段相混合，其他的合约可能会回调当前合约并修改状态， // 或者导致某些效果（比如支付以太币）多次生效。 // 如果合约内调用的函数包含了与外部合约的交互， // 则它也会被认为是与外部合约有交互的。 // 1. 条件 require(now >= auctionEnd, \"Auction not yet ended.\"); require(!ended, \"auctionEnd has already been called.\"); // 2. 生效 ended = true; emit AuctionEnded(highestBidder, highestBid); // 3. 交互 beneficiary.transfer(highestBid); } } Secret auction (blind auction) The previous public auction will then be expanded to a secret auction. The advantage of secret auction is that there will be no time pressure before the bid ends. Secret auction on a transparent computing platform sounds self-contradictory, but cryptography can realize it. In Bidding period ，the bidder did not actually send her bid, but only sent a hash version of the bid. Since it is almost impossible to find two (long enough) values at present and their hash values are equal, tenderers can submit quotations in this way. After the bidding is completed, bidders must disclose their bids: they send their bids unencrypted, and the contract checks whether the hash value of the bid is the same as that provided during the bidding period. Another challenge is how to make the auction work at the same time Binding and secret : The only way to prevent the bidder from not paying after she wins the auction is to let her send out the money together with the bid. However, since the transfer of funds cannot be hidden in Simplechain, anyone can see the transferred funds. The following contract solves this problem by accepting any value greater than the highest bid. Of course, because this can only be checked at the disclosure stage, some bids may be Invalid of， Moreover, this is intentional (together with the high bid, it even provides a clear mark to identify invalid bids): Bidders can confuse competitors by setting several high or low invalid bids. pragma solidity >0.4.23 Bid[]) public bids; address public highestBidder; uint public highestBid; // 可以取回的之前的出价 mapping(address => uint) pendingReturns; event AuctionEnded(address winner, uint highestBid); /// 使用 modifier 可以更便捷的校验函数的入参。 /// `onlyBefore` 会被用于后面的 `bid` 函数： /// 新的函数体是由 modifier 本身的函数体，并用原函数体替换 `_;` 语句来组成的。 modifier onlyBefore(uint _time) { require(now _time); _; } constructor( uint _biddingTime, uint _revealTime, address _beneficiary ) public { beneficiary = _beneficiary; biddingEnd = now + _biddingTime; revealEnd = biddingEnd + _revealTime; } /// 可以通过 `_blindedBid` = keccak256(value, fake, secret) /// 设置一个秘密竞拍。 /// 只有在出价披露阶段被正确披露，已发送的以太币才会被退还。 /// 如果与出价一起发送的以太币至少为 “value” 且 “fake” 不为真，则出价有效。 /// 将 “fake” 设置为 true ，然后发送满足订金金额但又不与出价相同的金额是隐藏实际出价的方法。 /// 同一个地址可以放置多个出价。 function bid(bytes32 _blindedBid) public payable onlyBefore(biddingEnd) { bids[msg.sender].push(Bid({ blindedBid: _blindedBid, deposit: msg.value })); } /// 披露你的秘密竞拍出价。 /// 对于所有正确披露的无效出价以及除最高出价以外的所有出价，你都将获得退款。 function reveal( uint[] _values, bool[] _fake, bytes32[] _secret ) public onlyAfter(biddingEnd) onlyBefore(revealEnd) { uint length = bids[msg.sender].length; require(_values.length == length); require(_fake.length == length); require(_secret.length == length); uint refund; for (uint i = 0; i = value) { if (placeBid(msg.sender, value)) refund -= value; } // 使发送者不可能再次认领同一笔订金 bid.blindedBid = bytes32(0); } msg.sender.transfer(refund); } // 这是一个 \"internal\" 函数， 意味着它只能在本合约（或继承合约）内被调用 function placeBid(address bidder, uint value) internal returns (bool success) { if (value 0) { // 这里很重要，首先要设零值。 // 因为，作为接收调用的一部分， // 接收者可以在 `transfer` 返回之前重新调用该函数。（可查看上面关于‘条件 -> 影响 -> 交互’的标注） pendingReturns[msg.sender] = 0; msg.sender.transfer(amount); } } /// 结束拍卖，并把最高的出价发送给受益人 function auctionEnd() public onlyAfter(revealEnd) { require(!ended); emit AuctionEnded(highestBidder, highestBid); ended = true; beneficiary.transfer(highestBid); } } Secure Remote purchase pragma solidity ^0.4.22; contract Purchase { uint public value; address public seller; address public buyer; enum State { Created, Locked, Inactive } State public state; //确保 `msg.value` 是一个偶数。 //如果它是一个奇数，则它将被截断。 //通过乘法检查它不是奇数。 constructor() public payable { seller = msg.sender; value = msg.value / 2; require((2 * value) == msg.value, \"Value has to be even.\"); } modifier condition(bool _condition) { require(_condition); _; } modifier onlyBuyer() { require( msg.sender == buyer, \"Only buyer can call this.\" ); _; } modifier onlySeller() { require( msg.sender == seller, \"Only seller can call this.\" ); _; } modifier inState(State _state) { require( state == _state, \"Invalid state.\" ); _; } event Aborted(); event PurchaseConfirmed(); event ItemReceived(); ///中止购买并回收以太币。 ///只能在合约被锁定之前由卖家调用。 function abort() public onlySeller inState(State.Created) { emit Aborted(); state = State.Inactive; seller.transfer(address(this).balance); } /// 买家确认购买。 /// 交易必须包含 `2 * value` 个以太币。 /// 以太币会被锁定，直到 confirmReceived 被调用。 function confirmPurchase() public inState(State.Created) condition(msg.value == (2 * value)) payable { emit PurchaseConfirmed(); buyer = msg.sender; state = State.Locked; } /// 确认你（买家）已经收到商品。 /// 这会释放被锁定的以太币。 function confirmReceived() public onlyBuyer inState(State.Locked) { emit ItemReceived(); // 首先修改状态很重要，否则的话，由 `transfer` 所调用的合约可以回调进这里（再次接收以太币）。 state = State.Inactive; // 注意: 这实际上允许买方和卖方阻止退款 - 应该使用取回模式。 buyer.transfer(value); seller.transfer(address(this).balance); } } "},"21_buildTest.html":{"url":"21_buildTest.html","title":"Build Test network","keywords":"","body":"Create a genesis block file Create a new file genesis.json with the following content. { \"config\": { \"chainId\": 100, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"alloc\" : {}, \"coinbase\" : \"0x0000000000000000000000000000000000000000\", \"difficulty\" : \"0x20000\", \"extraData\" : \"\", \"gasLimit\" : \"0x2fefd8\", \"nonce\" : \"0x0000000000000042\", \"mixhash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"timestamp\" : \"0x00\" } Of which chainId the ID of the test network. the ID of the primary network is 1,difficulty for the difficulty of mining, to facilitate the operation of the test network, the difficulty setting is low. Start node 1.Create the storage directory nodedata1 for node one mkdir nodedata1 2.Use genesis.json to initialize the genesis block of node 1 sipe init --datadir nodedata1 genesis.json 3.Start the node and specify the networkid. Ensure that the specified networkid is the same when communicating with the node sipe --datadir nodedata1 --port 30312 --rpc --rpcaddr 127.0.0.1 --rpcport 8541 --networkid 10001 console 4. View the node information in the open console to obtain the node enode > admin.nodeInfo { enode: \"enode://05a9c3bd1f6716a1806e677b8337d4e1eb4b9f57d8f94d11bcf4870fd8d5d943b9591 1a3c51f40714f33a307049d8c0c1a7019a71d099a27c6a939a85a809110@[::]:30312\", id: \"05a9c3bd1f6716a1806e677b8337d4e1eb4b9f57d8f94d11bcf4870fd8d5d943b95911a3c51f4 0714f33a307049d8c0c1a7019a71d099a27c6a939a85a809110\", ip: \"::\", listenAddr: \"[::]:30312\", name: \"Sipe/v1.0.2-stable-0cbf2a41/darwin-amd64/go1.12.1\", ports: { discovery: 30312, listener: 30312 }, protocols: { eth: { config: { chainId: 100, eip150Hash: \"0x0000000000000000000000000000000000000000000000000000000000000000\", eip155Block: 0, eip158Block: 0, homesteadBlock: 0 }, difficulty: 131072, genesis: \"0x5e1fc79cb4ffa4739177b5408045cd5d51c6cf766133f23f7cd72ee1f8d790e0\", head: \"0x5e1fc79cb4ffa4739177b5408045cd5d51c6cf766133f23f7cd72ee1f8d790e0\", network: 10001 }} } 3.Start node 2 1. Create the storage directory nodedata2 for node one mkdir nodedata2 2. Use genesis.json to initialize the genesis block of node 1. sipe init --datadir nodedata2 genesis.json 3. Start the node to ensure that networdid is the same as node one. Note that when configuring bootnodes, replace the enode [::] obtained by node one with the IP address of node one, that is 127.0.0.1 sipe --datadir nodedata2 --port 30313 --rpc --rpcaddr 127.0.0.1 --rpcport 8542 --networkid 10001 --bootnodes \"enode://05a9c3bd1f6716a1806e677b8337d4e1eb4b9f57d8f94d11bcf4870fd8d5d943b9591 1a3c51f40714f33a307049d8c0c1a7019a71d099a27c6a939a85a809110@127.0.0.1:30312\" console 4. View the information of the associated node. If the returned result is not empty, it is confirmed that node 2 and node 1 are successfully connected. > admin.peers [{ caps: [\"eth/63\"], id: \"05a9c3bd1f6716a1806e677b8337d4e1eb4b9f57d8f94d11bcf4870fd8d5d943b95911a3c51f4 0714f33a307049d8c0c1a7019a71d099a27c6a939a85a809110\", name: \"Sipe/v1.0.2-stable-0cbf2a41/darwin-amd64/go1.12.1\", network: { inbound: false, localAddress: \"127.0.0.1:58388\", remoteAddress: \"127.0.0.1:30312\", static: false, trusted: false }, protocols: { eth: { difficulty: 131072, head: \"0x5e1fc79cb4ffa4739177b5408045cd5d51c6cf766133f23f7cd72ee1f8d790e0\", version: 63 } } }] 3.Mining in the test network 1.Create an account on Node 1 and set it as the miner address > personal.newAccount() Passphrase: Repeat passphrase:=\"0x7f53309f95559c52d08f18724c0b24aa758d1953\" > miner.setEtherbase('0x7f53309f95559c52d08f18724c0b24aa758d1953') true 2.Start mining on Node 1 > miner.start() INFO [06-19|10:53:15.918] Updated mining threads threads=0 INFO [06-19|10:53:15.918] Transaction pool price threshold updated price=1000000000 INFO [06-19|10:53:15.918] Starting mining operation null > INFO [06-19|10:53:15.918] Commit new mining work number=1 txs=0 uncles=0 elapsed=207.516μs INFO [06-19|10:53:47.601] Successfully sealed new block number=1 hash=755f08...62e560 INFO [06-19|10:53:47.607] 🔨 mined potential block number=1 hash=755f08...62e560 3.Confirm the synchronization block on Node 2 INFO [06-19|10:53:49.246] Block synchronisation started INFO [06-19|10:53:49.538] Imported new block headers count=2 elapsed=6.482ms number=2 hash=c7c0a9...79db3e ignored=0 INFO [06-19|10:53:49.539] Imported new chain segment blocks=2 txs=0 mgas=0.000 elapsed=766.945μs mgasps=0.000 number=2 hash=c7c0a9...79db3e cache=1.20kB INFO [06-19|10:53:49.556] Imported new state entries count=3 elapsed=90.308μs processed=3 pending=0 retry=0 duplicate=0 unexpected=0 INFO [06-19|10:53:49.601] Fast sync complete, auto disabling INFO [06-19|10:53:59.119] Imported new chain segment blocks=1 txs=0 mgas=0.000 elapsed=1.212ms mgasps=0.000 number=3 hash=6dd8b2...194509 cache=1.81kB 4.Transfer money in the test network 1. Use the console to create another account. > personal.newAccount() Passphrase: Repeat passphrase: \"0xf9143e3b7de8ce91e463e30480f5afe84d3067ba\" 2. Use the password to unlock the account of the transferor before transferring money. > personal.unlockAccount('0x7f53309f95559c52d08f18724c0b24aa758d1953') Unlock account 0x7f53309f95559c52d08f18724c0b24aa758d1953 Passphrase: true 3. Send the transaction for transfer, where from is the transferor, here is the address of the miner, to is the payee, and the value is the transfer amount. > eth.sendTransaction({from:\"0x7f53309f95559c52d08f18724c0b24aa758d1953\",to:\"0xf9143e 3b7de8ce91e463e30480f5afe84d3067ba\",value:web3.toWei(10,\"ether\")}) \"0x5a6fbb3161329ca2591b7ecbcaca8a15a94cac5d402fce929f24504c76b8b7bb\" 4. Confirm receipt. > eth.getBalance('0xf9143e3b7de8ce91e463e30480f5afe84d3067ba') 10000000000000000000 "},"22_sipcApi.html":{"url":"22_sipcApi.html","title":"Sip API","keywords":"","body":"Sipc API method list: web3_clientVersion web3_sha3 net_version net_listening net_peerCount eth_protocolVersion eth_syncing eth_coinbase eth_mining eth_hashrate eth_gasPrice eth_accounts eth_blockNumber eth_getBalance eth_getStorageAt eth_getBlockTransactionCountByHash eth_getBlockTransactionCountByNumb eth_getUncleCountByBlockHash eth_getUncleCountByBlockNumber eth_getCode eth_sign eth_sendTransaction eth_sendRawTransaction eth_call eth_estimateGas eth_getBlockByHash eth_getBlockByNumber eth_getTransactionByNUmber eth_getUncleByBlockHashAndIndex eth_getUncleByBlockNumberAndIndex eth_newFilter eth_newBlockFilter eth_newPendingTransactionFilter eth_uninstallFilter eth_getFilterChanges eth_getFilterLogs eth_getLogs eth_getWork eth_submitWork eth_submitHashrate eth_blockNumber JSON-RPC Endpoint Default JSON-RPC endpoints: Client URL Go http://localhost:8545 Default block parameters The following method has an additional default block parameter: eth_getBalance eth.getCode eth.getTransactionCount eth_getStorageAt eth_call When the request acts on the status of simplechain, the last default block parameter determines the height of the block. The following options can be used for the default block parameters: HEX String -Integer number of blocks String \"earliest\" - The earliest/genesis block String \"latest\" - Newly dug blocks String \"pending\" - For pending status/transactions web3_clientVersion Returns the current client version. Parameter No Return string: Current client version 示例 // Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":68}' //Result { \"id\":67, \"jsonrpc\":\"2.0\", \"result\": \"Mist/v0.9.3/darwin/go1.4.1\" } web3_sha3 Returns the keccak-256 of the given data (not a standardized sha3-256) Parameter string: The data to calculate the SHA3 hash must be (hex string) Return value string: Specifies the SHA3 result of the string. 示例 // Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"web3_sha3\",\"params\":[\"0x68656c6c6f20776f726c64\"],\"id\":64}' //Result { \"id\":64, \"jsonrpc\": \"2.0\", \"result\": \"0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad\" } net_version Returns the ID of the current connection network. Parameter no Return value String: The ID of the current connection network,\"1\": Simplechain mainnet,\"3\": testnet; 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"net_version\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\":67, \"result\": \"3\" } net_listening Returns whether the client is in the listening network connection state. If the client is in the listening state, the system returns true, otherwise return false. Parameter 无 Return value bool: Returns true when the client is listening. Otherwise, false is returned Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"net_listening\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\":\"2.0\", \"id\":67, \"result\":true } net_peerCount Returns the number of nodes currently connected to the client. Parameter No Return value Quantity: Number of connected nodes Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"net_peerCount\",\"params\":[],\"id\":74}' //Response { \"id\":74, \"jsonrpc\": \"2.0\", \"result\": \"0xf\" } eth_protocolVersion Returns the protocol version of simplechain. Parameter no 返回 String The current protocol version of simplechain. 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_protocolVersion\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\":\"2.0\", \"id\":67, \"result\":\"0x40\" } eth_syncing Returns an object that contains data about the synchronization status or false Number parameter No Return value Object|Boolean, synchronization status object or false. The structure of the synchronization object is as follows: startingBlock: QUANTITY - start Block currentBlock: QUANTITY - current block, and eth_blockNumber highestBlock: QUANTITY - maximum estimated block Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_syncing\",\"params\":[],\"id\":1}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": { startingBlock: '0x384', currentBlock: '0x386', highestBlock: '0x454' } } { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": false } eth_coinbase Returns the client miner address. Parameters No Return value Data: 20 bytes - current coinbase address Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_coinbase\",\"params\":[],\"id\":64}' //Response { \"id\":64, \"jsonrpc\": \"2.0\", \"result\": \"0x407d73d8a49eeb85d32cf465507dd71d507100c1\" } eth_mining If the client is mining, return true, otherwise, return false。 Parameter no Return value boolean When the client is mining, it returns true , otherwise, return false . Exaple //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_mining\",\"params\":[],\"id\":71}' //Response { \"id\":71, \"jsonrpc\": \"2.0\", \"result\": true } eth_hashrate Returns the hash rate per second that can be calculated during node mining. Parameter no Return quantity: Hash rate calculated per second Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_hashrate\",\"params\":[],\"id\":71}' //Response { \"jsonrpc\": \"2.0\", \"id\":71, \"result\": \"0x38a\" } eth_gasPrice Returns each current gas price, unit:wei。 parameter no Return value quantity:Integer, wei Is the current unit gas price Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_gasPrice\",\"params\":[],\"id\":73}' //Response { \"jsonrpc\": \"2.0\", \"id\":73, \"result\": \"0x09184e72a000\" // 10000000000000 } eth_accounts Returns the list of addresses held by the client. Parameter no Return string[]:String array, a list of address strings held by the client. Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_accounts\",\"params\":[],\"id\":1}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": [\"0x407d73d8a49eeb85d32cf465507dd71d507100c1\"] } eth_blockNumber Returns the block number (block height) of the latest block. Parameter No Return The integer of the current block number where the client is located. Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1}' //Response { \"jsonrpc\":\"2.0\", \"id\":1, \"result\":\"0x5a0d\" } eth_getBalance Returns the balance of the account at the specified address. Parameter data- 20 bytes, the address of the balance to be checked quantity|tag - Integer block number, or string \"latest\", \"earliest\" or \"pending\" Return quantity:Current balance, unit: wei Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBalance\",\"params\":[\"0x51e766a7f073955c8061073bbba60b10bf12d48a\", \"latest\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0x0234c8a3397aab58\" // 158972490234375000 } eth_getTransactionCount Returns the number of transactions at the specified address. Parameter DATA: 20 bytes, address QUANTITY|TAG Integer block number, or string \"latest\", \"earliest\", or \"pending\" Return QUANTITY The number of transactions sent from the specified address, an integer. Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionCount\",\"params\":[\"0xd79b8287a827e1387e6f0ff6d300fc663e10f592\",\"latest\"],\"id\":1}' //Response { \"jsonrpc\":\"2.0\", \"id\":1, \"result\":\"0x1303\" } // 1 eth_getBlockTransactionCountByHash Returns the number of transactions in a specified block using a hash. Parameter DATA: 20 bytes, address Return QUANTITY The number of transactions in the specified block, integer Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockTransactionCountByHash\",\"params\":[\"0x268343647d0fcf63628446a29959feccf57136dac58fd1c17e0df3babafce3b6\"],\"id\":1}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x2\" } eth_getBlockTransactionCountByNumber Returns the number of transactions in a block that matches a given block number. Parameter QUANTITY|TAG: Integer block number, or string \"earliest\", \"latest\", or \"pending\" Return QUANTITY: • The number of transactions in the specified block. Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockTransactionCountByNumber\",\"params\":[\"0x11c7\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0xa\" } eth_getUncleCountByBlockHash 从与给定块哈希匹配的块中返回叔块数。 参数 QUANTITY DATA, 32 字节，块哈希 返回值 QUANTITY: DATA，指定块的叔数，整数 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getUncleCountByBlockHash\",\"params\":[\"0x58052e3424b8c03643a3cd3595cad1a6104ab195cc78108318699f2bfa429d8f\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0x1\" } eth_getUncleCountByBlockNumber 从与给定块号匹配的块中返回块中的叔块数。 参数 QUANTITY|TAG -区块数, 或者字符串 \"latest\", \"earliest\" or \"pending\" 返回 QUANTITY: DATA，指定块的叔数，整数 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getUncleCountByBlockNumber\",\"params\":[\"0x1bb\"],\"id\":1}' //Response { \"jsonrpc\":\"2.0\", \"id\":1, \"result\":\"0x1\" } eth_getCode 返回指定地址的代码。 参数 string: DATA ,20 字节，地址 string QUANTITY|TAG, 整数块编号，或字符串\"latest\"、\"earliest\" 或\"pending\" 返回 string DATA: 指定地址处的代码 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getCode\",\"params\":[\"0xe558562c906c69787b8fabb6d0efb3f1163a20e4\",\"latest\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0x\" } eth_sign 通过向消息添加前缀，可以将计算出的签名识别为特定于simplechain的签名。这可以防止恶意DAPP在签署任意数据（如事务）并使用签名来冒充受害者时的误用。 注意: 必须先解锁要签名的地址. 参数 DATA 20字节，地址 DATA 要签名的消息 返回值 DATA 数据的签名 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sign\",\"params\":[\"0xb014763d71459855510255647be8cf39b0e82acb\",\"0xdeadbeaf\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0xa3f20717a250c2b0b729b7e5becbff67fdaef7e0699da4de7ca5895b02a170a12d887fd3b17bfdce3481f10bea41f45ba9f709d39ce8325427b57afcfc994cee1b\" } eth_sendTransaction 创建一个新的消息调用交易，如果数据字段中包含代码，则创建一个合约。 参数 from: DATA, 20 字节 - 发送交易的源地址 to: DATA, 20 字节 - 交易的目标地址，当创建新合约时可选 gas: QUANTITY - 交易执行可用 gas 量，可选整数，默认值 90000，未用 gas 将返还。 gasPrice: QUANTITY - gas 价格，可选，默认值:待定(To-Be-Determined) value: QUANTITY - 交易发送的金额，可选整数 data: DATA - 合约的编译代码或被调用方法的签名及编码参数 nonce: QUANTITY - nonce，可选。可以使用同一个 nonce 来重写挂起的交易 返回 DATA:32 字节 - 交易哈希，如果交易还未生效则返回 0 值哈希。当创建合约时，在交易生效后，使用 eth_getTransactionReceipt 调用获取合约地址。 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\", \"params\":[{ \"from\": \"0xb014763d71459855510255647be8cf39b0e82acb\", \"to\": \"0xac49f5e5b9161e0cb42372c90183d8428b060ff1\", \"gas\": \"0x76c0\", \"gasPrice\": \"0x9184e72a000\", \"value\": \"0x9184e72a\", \"data\": \"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675\" }],\"id\":1}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\" } eth_sendRawTransaction 为已签名的交易创建新的消息调用交易或合约创建。 参数 DATA: 签名的交易数据 返回值 DATA: 32字节，交易哈希，如果交易未生效则返回全0哈希。当创建合约时，在交易生效后，使用eth_getTransactionReceipt获取合约地址。 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendRawTransaction\",\"params\":[\"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675\"],\"id\":1}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\" } eth_call 立刻执行一个新的消息调用，无需在区块链上创建交易。 参数 from: DATA, 20 Bytes - 发送交易的原地址，可选 to: DATA, 20 Bytes - 交易目标地址 gas: QUANTITY - 交易可用 gas 量，可选。eth_call 不消耗 gas，但是某些 执行环节需要这个参数 gasPrice: QUANTITY - gas 价格，可选 value: QUANTITY - 交易发送的 sipc 数量，可选 data: DATA - 方法签名和编码参数的哈希，可选 string: QUANTITY|TAG - 整数块编号，或字符串\"latest\"、\"earliest\"或\"pending\" 返回值 result: DATA- 所执行合约的返回值 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_call\",\"params\":[\"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675\" ],\"id\":1}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x\" } eth_estimateGas 执行并估算一个交易需要的gas用量。该次交易不会写入区块链。注意，由于多种原因，例如EVM的机制及节点的性能，估算的数值可能比实际用量大的多。 参数 from: DATA, 20 Bytes - 发送交易的原地址，可选 to: DATA, 20 Bytes - 交易目标地址 gas: QUANTITY - 交易可用 gas 量，可选。eth_call 不消耗 gas，但是某些 执行环节需要这个参数 gasPrice: QUANTITY - gas 价格，可选 value: QUANTITY - 交易发送的 sipc 数量，可选 data: DATA - 方法签名和编码参数的哈希，可选 string: QUANTITY|TAG - 整数块编号，或字符串\"latest\"、\"earliest\"或\"pending\" 返回值 result: QUANTITY - gas用量估算值 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_estimateGas\",\"params\":[{ \"from\": \"0xb014763d71459855510255647be8cf39b0e82acb\", \"to\": \"0xac49f5e5b9161e0cb42372c90183d8428b060ff1\", \"gas\": \"0x76c0\", \"gasPrice\": \"0x9184e72a000\", \"value\": \"0x9184e72a\", \"data\": \"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675\" }],\"id\":1}' //response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x5cec\" // 21000 } eth_getBlockByHash 根据给定的哈希返回有关块的信息。 参数 DATA, 32个字节 - 区块的哈希 Boolean - 如果为true，则返回完整的交易对象，否则仅返回交易哈希 返回值 number: QUANTITY - 块编号，挂起块为 null hash: DATA, 32 Bytes - 块哈希，挂起块为 null parentHash: DATA, 32 Bytes - 父块的哈希 nonce: DATA, 8 Bytes - 生成的 pow 哈希，挂起块为 null sha3Uncles: DATA, 32 Bytes - 块中叔数据的 SHA3 哈希 logsBloom: DATA, 256 Bytes - 块日志的 bloom 过滤器，挂起块为null ansactionsRoot: DATA, 32 Bytes - 块中的交易树根节点 stateRoot: DATA, 32 Bytes - 块最终状态树的根节点 receiptsRoot: DATA, 32 Bytes - 块交易收据树的根节点 miner: DATA, 20 Bytes - 挖矿奖励的接收账户 difficulty: QUANTITY - 块难度，整数 totalDifficulty: QUANTITY - 截止到本块的链上总难度 extraData: DATA - 块额外数据 size: QUANTITY - 本块字节数 gasLimit: QUANTITY - 本块允许的最大 gas 用量 gasUsed: QUANTITY - 本块中所有交易使用的总 gas 用量 timestamp: QUANTITY - 块时间戳 transactions: Array - 交易对象数组，或 32 字节长的交易哈希数组 uncles: Array - 叔哈希数组 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByHash\",\"params\":[\"0xbe024aeab6138b6adffd616314c707e2af8d165f871c8068d1a4a9c38a59c69b\", true],\"id\":1}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": { \"number\": \"0x1b4\", // 436 \"hash\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\", \"parentHash\": \"0x9646252be9520f6e71339a8df9c55e4d7619deeb018d2a3f2d21fc165dde5eb5\", \"nonce\": \"0xe04d296d2460cfb8472af2c5fd05b5a214109c25688d3704aed5484f9a7792f2\", \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\", \"logsBloom\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\", \"transactionsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"stateRoot\": \"0xd5855eb08b3387c0af375e9cdb6acfc05eb8f519e419b874b6ff2ffda7ed1dff\", \"miner\": \"0x4e65fda2159562a496f9f3522f89122a3088497a\", \"difficulty\": \"0x027f07\", // 163591 \"totalDifficulty\": \"0x027f07\", // 163591 \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000 000000000\", \"size\": \"0x027f07\", // 163591 \"gasLimit\": \"0x9f759\", // 653145 \"gasUsed\": \"0x9f759\", // 653145 \"timestamp\": \"0x54e34e8e\" // 1424182926 \"transactions\": [{...},{ ... }] \"uncles\": [\"0x1606e5...\", \"0xd5145a9...\"] } } eth_getBlockByNumber 根据区块数（区块高度）返回有关块的信息。 参数 QUANTITY|TAG 区块数, 或者字符串 \"earliest\", \"latest\" or \"pending\" Boolean - 如果为true，则返回完整的交易对象；如果为false，则仅返回交易的哈希值。 返回 number: QUANTITY - 块编号，挂起块为 null hash: DATA, 32 Bytes - 块哈希，挂起块为 null parentHash: DATA, 32 Bytes - 父块的哈希 nonce: DATA, 8 Bytes - 生成的 pow 哈希，挂起块为 null sha3Uncles: DATA, 32 Bytes - 块中叔数据的 SHA3 哈希 logsBloom: DATA, 256 Bytes - 块日志的 bloom 过滤器，挂起块为null ansactionsRoot: DATA, 32 Bytes - 块中的交易树根节点 stateRoot: DATA, 32 Bytes - 块最终状态树的根节点 receiptsRoot: DATA, 32 Bytes - 块交易收据树的根节点 miner: DATA, 20 Bytes - 挖矿奖励的接收账户 difficulty: QUANTITY - 块难度，整数 totalDifficulty: QUANTITY - 截止到本块的链上总难度 extraData: DATA - 块额外数据 size: QUANTITY - 本块字节数 gasLimit: QUANTITY - 本块允许的最大 gas 用量 gasUsed: QUANTITY - 本块中所有交易使用的总 gas 用量 timestamp: QUANTITY - 块时间戳 transactions: Array - 交易对象数组，或 32 字节长的交易哈希数组 uncles: Array - 叔哈希数组 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"0x6bcd\", true],\"id\":1}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": { \"number\": \"0x1b4\", // 436 \"hash\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\", \"parentHash\": \"0x9646252be9520f6e71339a8df9c55e4d7619deeb018d2a3f2d21fc165dde5eb5\", \"nonce\": \"0xe04d296d2460cfb8472af2c5fd05b5a214109c25688d3704aed5484f9a7792f2\", \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\", \"logsBloom\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\", \"transactionsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"stateRoot\": \"0xd5855eb08b3387c0af375e9cdb6acfc05eb8f519e419b874b6ff2ffda7ed1dff\", \"miner\": \"0x4e65fda2159562a496f9f3522f89122a3088497a\", \"difficulty\": \"0x027f07\", // 163591 \"totalDifficulty\": \"0x027f07\", // 163591 \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000 000000000\", \"size\": \"0x027f07\", // 163591 \"gasLimit\": \"0x9f759\", // 653145 \"gasUsed\": \"0x9f759\", // 653145 \"timestamp\": \"0x54e34e8e\" // 1424182926 \"transactions\": [{...},{ ... }] \"uncles\": [\"0x1606e5...\", \"0xd5145a9...\"] } } eth_getTransactionByHash 返回有关交易哈希请求的交易的信息 参数 DATA, 32个字节 - 交易的哈希 返回 blockHash: DATA, 32 Bytes -此交易所在的区块的哈希。当它还处于待定状态时为null。 blockNumber: QUANTITY - 此交易所在的区块的高度. 当它还处于待定状态时为null。 from: DATA, 20 个字节 -交易发起者的地址。 gas: QUANTITY -交易发起者提供的gas数。 gasPrice: QUANTITY - 发送者提供的gas的价格，以wei为单位。 hash: DATA, 32个字节 -交易的哈希 input: DATA - 随交易一起发送的数据。 nonce: QUANTITY - 发送方在此之前进行的交易数。 to: DATA, 20个字节 -接受者的地址，当交易是一个合约创建的时候，它的值为null。 transactionIndex: QUANTITY - 交易在块中的索引位置的整数。当它为待定状态时为null。 value: QUANTITY - 转账的数额，以wei为单位。 v: QUANTITY - ECDSA recovery id r: DATA, 32 Bytes - ECDSA signature r s: DATA, 32 Bytes - ECDSA signature s 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionByHash\",\"params\":[\"0x8e63b031ac4f3a9c38642d69a86f73368fee539d9351e4eb312b5cfb6cd4f3e6\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"blockHash\": \"0xbe024aeab6138b6adffd616314c707e2af8d165f871c8068d1a4a9c38a59c69b\", \"blockNumber\": \"0x6bcd\", \"from\": \"0xd79b8287a827e1387e6f0ff6d300fc663e10f592\", \"gas\": \"0x5c20\", \"gasPrice\": \"0x218711a00\", \"hash\": \"0x8e63b031ac4f3a9c38642d69a86f73368fee539d9351e4eb312b5cfb6cd4f3e6\", \"input\": \"0xd3182ceafbaf2da3503237a4f60b74e30756e78f310d2b97761c38db06753c99353535363530\", \"nonce\": \"0xecc\", \"to\": \"0xd79b8287a827e1387e6f0ff6d300fc663e10f592\", \"transactionIndex\": \"0x3\", \"value\": \"0xde0b6b3a7640000\", \"v\": \"0x26\", \"r\": \"0x5076aebd122ba56eaa0d40a44ce950ac792851e97e1a4afcf660afbc8d1e625a\", \"s\": \"0x7a7af2b80ccbdce36363b338b96a3f6c96aafa7057ea586a4dae0e30da607747\" } } eth_getTransactionByBlockHashAndIndex 返回指定块内具有指定索引序号的交易。 参数 DATA, 32 字节 - 块哈希 QUANTITY, 交易在块内的索引序号 返回 hash: DATA, 32 字节 - 交易哈希 nonce: QUANTITY - 本次交易之前发送方已经生成的交易数量 blockHash: DATA, 32 字节 - 交易所在块的哈希，对于挂起块，该值为 null blockNumber: QUANTITY - 交易所在块的编号，对于挂起块，该值为 null transactionIndex: QUANTITY - 交易在块中的索引位置，挂起块该值为 null from: DATA, 20 字节 - 交易发送方地址 to: DATA, 20 字节 - 交易接收方地址，对于合约创建交易，该值为 null value: QUANTITY - 发送的 sipc 数量，单位:wei gasPrice: QUANTITY - 发送方提供的 gas 价格，单位:wei gas: QUANTITY - 发送方提供的 gas 可用量 input: DATA - 随交易发送的数据 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionByBlockHashAndIndex\",\"params\":[\"0xbe024aeab6138b6adffd616314c707e2af8d165f871c8068d1a4a9c38a59c69b\", \"0x3\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"blockHash\": \"0xbe024aeab6138b6adffd616314c707e2af8d165f871c8068d1a4a9c38a59c69b\", \"blockNumber\": \"0x6bcd\", \"from\": \"0xd79b8287a827e1387e6f0ff6d300fc663e10f592\", \"gas\": \"0x5c20\", \"gasPrice\": \"0x218711a00\", \"hash\": \"0x8e63b031ac4f3a9c38642d69a86f73368fee539d9351e4eb312b5cfb6cd4f3e6\", \"input\": \"0xd3182ceafbaf2da3503237a4f60b74e30756e78f310d2b97761c38db06753c99353535363530\", \"nonce\": \"0xecc\", \"to\": \"0xd79b8287a827e1387e6f0ff6d300fc663e10f592\", \"transactionIndex\": \"0x3\", \"value\": \"0xde0b6b3a7640000\", \"v\": \"0x26\", \"r\": \"0x5076aebd122ba56eaa0d40a44ce950ac792851e97e1a4afcf660afbc8d1e625a\", \"s\": \"0x7a7af2b80ccbdce36363b338b96a3f6c96aafa7057ea586a4dae0e30da607747\" } } eth_getTransactionByBlockNumberAndIndex 按区块数（区块高度）和交易索引位置返回有关交易的信息。 参数 QUANTITY|TAG - 整数块编号，或字符串\"earliest\"、\"latest\" 或\"pending\" QUANTITY - 交易索引序号 返回值 hash: DATA, 32 字节 - 交易哈希 nonce: QUANTITY - 本次交易之前发送方已经生成的交易数量 blockHash: DATA, 32 字节 - 交易所在块的哈希，对于挂起块，该值为 null blockNumber: QUANTITY - 交易所在块的编号，对于挂起块，该值为 null transactionIndex: QUANTITY - 交易在块中的索引位置，挂起块该值为 null from: DATA, 20 字节 - 交易发送方地址 to: DATA, 20 字节 - 交易接收方地址，对于合约创建交易，该值为 null value: QUANTITY - 发送的 sipc 数量，单位:wei gasPrice: QUANTITY - 发送方提供的 gas 价格，单位:wei gas: QUANTITY - 发送方提供的 gas 可用量 input: DATA - 随交易发送的数据 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionByBlockNumberAndIn dex\",\"params\":[\"0x29c\", \"0x0\"],\"id\":1}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": { \"hash\":\"0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1d105 5b\", \"nonce\":\"0x\", \"blockHash\": \"0xbeab0aa2411b7ab17f30a99d3cb9c6ef2fc5426d6ad6fd9e2a26a6aed1d1055b\", \"blockNumber\": \"0x15df\", // 5599 \"transactionIndex\": \"0x1\", // 1 \"from\":\"0x407d73d8a49eeb85d32cf465507dd71d507100c1\", \"to\":\"0x85h43d8a49eeb85d32cf465507dd71d507100c1\", \"value\":\"0x7f110\", // 520464 \"gas\": \"0x7f110\", // 520464 \"gasPrice\":\"0x09184e72a000\", \"input\":\"0x603880600c6000396000f300603880600c6000396000f3603880600c6000396000f360\", } } eth_getTransactionReceipt 根据交易哈希返回一个交易的收据,注意:收据不可用于待处理的交易。 参数 DATA, 32字节，交易哈希 返回 transactionHash: DATA, 32 字节 - 交易哈希 transactionIndex: QUANTITY - 交易在块内的索引序号 blockHash: DATA, 32 字节 - 交易所在块的哈希 blockNumber: QUANTITY - 交易所在块的编号 from: DATA, 20 字节 - 交易发送方地址 to: DATA, 20 字节 - 交易接收方地址，对于合约创建交易该值为 null cumulativeGasUsed: QUANTITY - 交易所在块消耗的 gas 总量 gasUsed: QUANTITY - 该次交易消耗的 gas 用量 contractAddress: DATA, 20 字节 - 对于合约创建交易，该值为新创建的合 约地址，否则为 null logs: Array - 本次交易生成的日志对象数组 logsBloom: DATA, 256 字节 - bloom 过滤器，轻客户端用来快速提取相关日志 root: DATA 32 字节，后交易状态根(pre Byzantium) status: QUANTITY ，1 (成功) 或 0 (失败) 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionReceipt\",\"params\":[\"0x b903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"],\"id\":1}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": { transactionHash: '0xb903239f8543d04b5dc1ba6579132b143087c68db1b216878640 8fcbce568238', transactionIndex: '0x1', // 1 blockNumber: '0xb', // 11 blockHash: '0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1 d1055b', cumulativeGasUsed: '0x33bc', // 13244 gasUsed: '0x4dc', // 1244 contractAddress: '0xb60e8dd61c5d32be8058bb8eb970870f07233155', // or null, if none was created logs: [{ // logs as returned by getFilterLogs, etc. }, ...], logsBloom: \"0x00...0\", // 256 byte bloom filter status: '0x1' } } eth_getUncleByBlockHashAndIndex 根据哈希和叔块索引位置返回有关块的叔块的信息。 参数 DATA, 32字节,块哈希 QUANTITY, 叔索引位置 返回值 number: QUANTITY - 块编号，挂起块为 null hash: DATA, 32 Bytes - 块哈希，挂起块为 null parentHash: DATA, 32 Bytes - 父块的哈希 nonce: DATA, 8 Bytes - 生成的 pow 哈希，挂起块为 null sha3Uncles: DATA, 32 Bytes - 块中叔数据的 SHA3 哈希 logsBloom: DATA, 256 Bytes - 块日志的 bloom 过滤器，挂起块为null ansactionsRoot: DATA, 32 Bytes - 块中的交易树根节点 stateRoot: DATA, 32 Bytes - 块最终状态树的根节点 receiptsRoot: DATA, 32 Bytes - 块交易收据树的根节点 miner: DATA, 20 Bytes - 挖矿奖励的接收账户 difficulty: QUANTITY - 块难度，整数 totalDifficulty: QUANTITY - 截止到本块的链上总难度 extraData: DATA - 块额外数据 size: QUANTITY - 本块字节数 gasLimit: QUANTITY - 本块允许的最大 gas 用量 gasUsed: QUANTITY - 本块中所有交易使用的总 gas 用量 timestamp: QUANTITY - 块时间戳 transactions: Array - 交易对象数组，或 32 字节长的交易哈希数组 uncles: Array - 叔哈希数组 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getUncleByBlockHashAndIndex\",\"params\":[\"0x58052e3424b8c03643a3cd3595cad1a6104ab195cc78108318699f2bfa429d8f\",'0x0'],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"difficulty\": \"0x267c3\", \"extraData\": \"0xd983010000847369706588676f312e31312e318664617277696e\", \"gasLimit\": \"0x12804\", \"gasUsed\": \"0x0\", \"hash\": \"0x7937f1ac55c87d4fb649c17d0c9411e8837d32e10bf5e8723611120b50154c16\", \"logsBloom\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"miner\": \"0x41da014ee4c2f583ba222344c095a631e739f2f1\", \"mixHash\": \"0xa50630bdd5800368de83fa719373ccceaaf69e56f07d32db11b2069c2af9a611\", \"nonce\": \"0x4f0713dd54bb9301\", \"number\": \"0x1b5\", \"parentHash\": \"0xf2ad2fbdd67936df73c447eabb49965d2bced51df9c1a80545b001600547d81a\", \"receiptsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\", \"size\": \"0x21b\", \"stateRoot\": \"0xbfb096cd9832414ad738ff806dcfb1e48d9836c00d130b723a3bb808098b1099\", \"timestamp\": \"0x5c2e3b64\", \"totalDifficulty\": null, \"transactionsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"uncles\": [] } } 注意: 叔块不包含单独的交易。 eth_getUncleByBlockNumberAndIndex 根据区块数（区块高度）和叔块索引位置返回有关叔块的信息. 参数 QUANTITY|TAG - 整数块编号，或字符串\"earliest\"、\"latest\" 或\"pending\" QUANTITY – 叔块在块内的索引序号 返回 number: QUANTITY - 块编号，挂起块为 null hash: DATA, 32 Bytes - 块哈希，挂起块为 null parentHash: DATA, 32 Bytes - 父块的哈希 nonce: DATA, 8 Bytes - 生成的 pow 哈希，挂起块为 null sha3Uncles: DATA, 32 Bytes - 块中叔数据的 SHA3 哈希 logsBloom: DATA, 256 Bytes - 块日志的 bloom 过滤器，挂起块为null ansactionsRoot: DATA, 32 Bytes - 块中的交易树根节点 stateRoot: DATA, 32 Bytes - 块最终状态树的根节点 receiptsRoot: DATA, 32 Bytes - 块交易收据树的根节点 miner: DATA, 20 Bytes - 挖矿奖励的接收账户 difficulty: QUANTITY - 块难度，整数 totalDifficulty: QUANTITY - 截止到本块的链上总难度 extraData: DATA - 块额外数据 size: QUANTITY - 本块字节数 gasLimit: QUANTITY - 本块允许的最大 gas 用量 gasUsed: QUANTITY - 本块中所有交易使用的总 gas 用量 timestamp: QUANTITY - 块时间戳 transactions: Array - 交易对象数组，或 32 字节长的交易哈希数组 uncles: Array - 叔哈希数组 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getUncleByBlockNumberAndIndex\",\"params\":[\"0x1bb\",\"0x0\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"difficulty\": \"0x267c3\", \"extraData\": \"0xd983010000847369706588676f312e31312e318664617277696e\", \"gasLimit\": \"0x12804\", \"gasUsed\": \"0x0\", \"hash\": \"0x7937f1ac55c87d4fb649c17d0c9411e8837d32e10bf5e8723611120b50154c16\", \"logsBloom\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"miner\": \"0x41da014ee4c2f583ba222344c095a631e739f2f1\", \"mixHash\": \"0xa50630bdd5800368de83fa719373ccceaaf69e56f07d32db11b2069c2af9a611\", \"nonce\": \"0x4f0713dd54bb9301\", \"number\": \"0x1b5\", \"parentHash\": \"0xf2ad2fbdd67936df73c447eabb49965d2bced51df9c1a80545b001600547d81a\", \"receiptsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\", \"size\": \"0x21b\", \"stateRoot\": \"0xbfb096cd9832414ad738ff806dcfb1e48d9836c00d130b723a3bb808098b1099\", \"timestamp\": \"0x5c2e3b64\", \"totalDifficulty\": null, \"transactionsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"uncles\": [] } } 注意: 叔块不包含单独的交易 ------ eth_newFilter 根据过滤器器选项创建过滤器对象，以便在状态更改（日志）时通知。要检查状态是否已更改，请调用eth getfilterchanges。 关于指定主题过滤器的说明: 关于特定主题过滤器的说明:主题是顺序相关的。如果一个交易的日志有主题[A, ，那么将被以下的主题过滤器匹配: []任何主题 [A]先匹配A主题 [null,B]先匹配其他主题，再匹配B主题 [A,B]先匹配A主题，再匹配B主题，最后匹配其他主题 [[A,B][A,B]\"先匹配A主题或B主题，再匹配A主题或B主题,最后匹配其他主题\"] 参数 fromBlock: QUANTITY|TAG - 可选，默认值:\"latest\"。整数块编号，或字符串\"latesr\"表示最后挖出的块，\"pending\"或\"earliest\"用于未挖出的交易。 toBlock: QUANTITY|TAG - 可选，默认值:\"latest\"。整数块编号，或字符串\"latesr\"表示最后挖出的块，\"pending\"或\"earliest\"用于未挖出的交易。 address: DATA|Array, 20 字节 - 可选，合约地址或生成日志的一组地址 topics: Array of DATA, - 可选，32 字节主题数组，每个主题可以是数组或使用 or 选项连接 返回 QUANTITY，过滤器编号 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_newBlockFilter\",\"params\":[],\"id\":73}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0x1\" // 1 } eth_newBlockFilter 在节点中创建一个过滤器，以便当新块生成时进行通知。要检查状态是否变化，请调用eth_getFilterChanges. 参数 无 返回 QUANTITY 过滤器编号 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_newBlockFilter\",\"params\":[],\"id\":73}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0x1\" // 1 } eth_newPendingTransactionFilter 在节点中创建一个过滤器，以便当产生挂起交易时进行通知。要检查状态是否发生变化，请调用eth_getFilterChanges。 参数 无 返回值 QUANTITY, 过滤器编号 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_newPendingTransactionFilter\",\"para ms\":[],\"id\":73}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x1\" // 1 } eth_uninstallFilter 卸载具有指定编号的过滤器。当不在需要监听时，总是需要执行该调用。另外，过滤器如果在一定时间内未接收到eth_getFilterChanges调用会自动超时。 参数 QUANTITY, 过滤器编号 返回 Boolean, 如果成功卸载则返回true,否则返回false 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_uninstallFilter\",\"params\":[\"0xb\"],\"id\":7 3}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": true } eth_getFilterChanges 轮询指定的过滤器，并返回自上次轮询之后新生成的日志数组。 参数 QUANTITY, 过滤器编号 返回值 Array, 日志对象数组，如果没有新生成的日志，则返回空数组。 使用eth_newBlockerFilter创建的过滤器将返回块哈希(32 字节)，例如[\")x3454645634534\"]。 使用eth_newPendingTransactionFilter创建的过滤器将返回交易哈希 (32 字节)，例如[\"0x6345343454645...\"]。 使用eth_newFilter创建的过滤器，日志对象具有如下数参数： removed: TAG - 如果日志已被删除则返回 true，如果是有效日志则返回false logIndex: QUANTITY - 日志在块内的索引序号。对于挂起日志，该值为 null transactionIndex: QUANTITY - 创建日志的交易索引序号，对于挂起日志，该值为 null transactionHash: DATA, 32 字节 - 创建该日志的交易的哈希。对于挂起日志，该值为 null blockHash: DATA, 32 字节 - 该日志所在块的哈希。对于挂起日志，该值为null blockNumber: QUANTITY - 该日志所在块的编号。对于挂起日志，该值为 null address: DATA, 20 字节 - 该日志的源地址 data: DATA - 包含该日志的一个或多个 32 字节无索引参数 topics: Array of DATA -0~4 个 32 字节索引日志参数的数据。在 solidity 中，第一个主题是事件签名，例如 Deposit(address,bytes32,uint256)，除非你声明的是匿名事件 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getFilterChanges\",\"params\":[\"0x16\"],\" id\":73}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": [{ \"logIndex\": \"0x1\", // 1 \"blockNumber\":\"0x1b4\", // 436 \"blockHash\": \"0x8216c5785ac562ff41e2dcfdf5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"transactionHash\": \"0xdf829c5a142f1fccd7d8216c5785ac562ff41e2dcfdf5785ac562f f41e2dcf\", \"transactionIndex\": \"0x0\", // 0 \"address\": \"0x16c5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"data\":\"0x0000000000000000000000000000000000000000000000000000000000000 000\", \"topics\": [\"0x59ebeb90bc63057b6515673c3ecf9438e5058bca0f92585014eced636878c9a5\"] },{... }] } eth_getFilterLogs 返回与给定ID匹配的过滤器的所有日志的数组. 参数 QUANTITY, 过滤器编号 返回 removed: TAG - 如果日志已被删除则返回true，如果是有效日志则返回false logIndex: QUANTITY - 日志在块内的索引序号。对于挂起日志，该值为null transactionIndex: QUANTITY - 创建日志的交易索引序号，对于挂起日志，该值为null transactionHash: DATA, 32 字节 - 创建该日志的交易的哈希。对于挂起日志，该值为null blockHash: DATA, 32 字节 - 该日志所在块的哈希。对于挂起日志，该值为null blockNumber: QUANTITY - 该日志所在块的编号。对于挂起日志，该值为null address: DATA, 20 字节 - 该日志的源地址 data: DATA - 包含该日志的一个或多个32字节无索引参数 topics: Array of DATA -0~4 个 32字节索引日志参数的数据。在 solidity 中，第一个主题是事件签名，例如 Deposit(address,bytes32,uint256)，除非你声明的是匿名事件 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getFilterLogs\",\"params\":[\"0x16\"],\"id\": 74}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": [{ \"logIndex\": \"0x1\", // 1 \"blockNumber\":\"0x1b4\", // 436 \"blockHash\": \"0x8216c5785ac562ff41e2dcfdf5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"transactionHash\": \"0xdf829c5a142f1fccd7d8216c5785ac562ff41e2dcfdf5785ac562f f41e2dcf\", \"transactionIndex\": \"0x0\", // 0 \"address\": \"0x16c5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"data\":\"0x0000000000000000000000000000000000000000000000000000000000000 000\", \"topics\": [\"0x59ebeb90bc63057b6515673c3ecf9438e5058bca0f92585014eced636878c9a5\"] },{... }] } eth_getLogs 返回与给定过滤器对象匹配的所有日志的数组。 参数 fromBlock: QUANTITY|TAG - 可选，默认值:\"latest\"。整数块编号，或字符串\"latesr\"表示最后挖出的块，\"pending\"或\"earliest\"用于未挖出的交易。 toBlock: QUANTITY|TAG - 可选，默认值:\"latest\"。整数块编号，或字符串\"latesr\"表示最后挖出的块，\"pending\"或\"earliest\"用于未挖出的交易。 address: DATA|Array, 20 字节 - 可选，合约地址或生成日志的一组地址 topics: Array of DATA, - 可选，32字节主题数组，每个主题可以是数组或使用or选项连接 返回值 Array, 日志对象数组，如果没有新生成的日志，则返回空数组。 使用eth_newBlockerFilter创建的过滤器将返回块哈希(32 字节)，例如[\")x3454645634534\"]。 使用eth_newPendingTransactionFilter创建的过滤器将返回交易哈希 (32 字节)，例如[\"0x6345343454645...\"]。 使用eth_newFilter创建的过滤器，日志对象具有如下数参数： removed: TAG - 如果日志已被删除则返回 true，如果是有效日志则返回false logIndex: QUANTITY - 日志在块内的索引序号。对于挂起日志，该值为 null transactionIndex: QUANTITY - 创建日志的交易索引序号，对于挂起日志，该值为 null transactionHash: DATA, 32 字节 - 创建该日志的交易的哈希。对于挂起日志，该值为 null blockHash: DATA, 32 字节 - 该日志所在块的哈希。对于挂起日志，该值为null blockNumber: QUANTITY - 该日志所在块的编号。对于挂起日志，该值为 null address: DATA, 20 字节 - 该日志的源地址 data: DATA - 包含该日志的一个或多个 32 字节无索引参数 topics: Array of DATA -0~4 个 32 字节索引日志参数的数据。在 solidity 中，第一个主题是事件签名，例如 Deposit(address,bytes32,uint256)，除非你声明的是匿名事件 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getLogs\",\"params\":[{\"topics\":[\"0x0000 00000000000000000000a94f5374fce5edbc8e2a8697c15331677e6ebf0b\"]}],\"id\":74}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": [{ \"logIndex\": \"0x1\", // 1 \"blockNumber\":\"0x1b4\", // 436 \"blockHash\": \"0x8216c5785ac562ff41e2dcfdf5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"transactionHash\": \"0xdf829c5a142f1fccd7d8216c5785ac562ff41e2dcfdf5785ac562f f41e2dcf\", \"transactionIndex\": \"0x0\", // 0 \"address\": \"0x16c5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"data\":\"0x0000000000000000000000000000000000000000000000000000000000000 000\", \"topics\": [\"0x59ebeb90bc63057b6515673c3ecf9438e5058bca0f92585014eced636878c9a5\"] },{... }] } eth_getWork 返回当前块的哈希、seedhash和要满足的边界条件 参数 无 返回值 DATA, 32 字节 - 当前块头的 pow-hash DATA, 32 字节 - 用于 DAG 的种子哈希 DATA, 32 字节 - 边界条件，目标， 2^256 / difficulty //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getWork\",\"params\":[],\"id\":73}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": [ \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\", \"0x5EED00000000000000000000000000005EED0000000000000000000000000000\", \"0xd1ff1c01710000000000000000000000d1ff1c01710000000000000000000000\" ] } eth_submitWork 用于提交POW解决方案。 参数 DATA, 8 字节 - nonce，64 位 DATA, 32 字节 - 头部的 pow 哈希，256 位  DATA, 32 字节 - 混合摘要，256 位 返回 Boolean, 如果提交的方案有效则返回true，否则返回false //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\", \"method\":\"eth_submitWork\", \"params\":[\"0x000000 0000000001\", \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890a bcdef\", \"0xD1GE5700000000000000000000000000D1GE5700000000000000000000000 000\"],\"id\":73}' //Response { \"id\":73, \"jsonrpc\":\"2.0\", \"result\": true } eth_submitHashrate 用于提交挖矿的哈希速率。 参数 hashRate - 哈希速率，采用 16 进制字符串表示，32 字节 ID, String - 随机 16 进制字符串，32 字节，用于标识客户端的编号 返回 Boolean, 如果提交成功则返回 true，否则返回 false 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\", \"method\":\"eth_submitHashrate\", \"params\":[\"0x000 0000000000000000000000000000000000000000000000000000000500000\", \"0x59daa2 6581d0acd1fce254fb7e85952f4c09d0915afd33d3886cd914bc7d283c\"],\"id\":73}' //Response { \"id\":73, \"jsonrpc\":\"2.0\", \"result\": true } eth_blockNumber 返回最新块的编号。 参数 无 返回值 QUANTITY, 节点当前块编号 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":83}' //Response { \"id\":83, \"jsonrpc\": \"2.0\", \"result\": \"0x4b7\" // 1207 } "},"23_crossChainApi.html":{"url":"23_crossChainApi.html","title":"Cross-chain API","keywords":"","body":"跨链API接口列表 eth_ctxQuery eth_ctxOwner eth_ctxOwnerByPage eth_ctxContent eth_ctxContent eth_getRemoteCtx eth_ctxStats eth_poolStats JSON-RPC Endpoint Default JSON-RPC endpoints: Client URL Go http://localhost:8545 eth_ctxQuery 通过TxHash跨链交易单。 参数 DATA, 32个字节 - 交易的哈希 返回 value: QUANTITY, 交易数额。 ctxId: DATA, 32个字节- 该交易ID。 txHash: DATA 32个字节- 交易的哈希。 from: DATA, 20个字节 -交易发送者的地址 blockHash: DATA, 32个字节- 该交易所在的区块的哈希。 destinationId: QUANTITY - 跨链目的链ID。 destinationValue: QUANTITY, 目的链币种数额 input: DATA, 交易的input数据。 v: Array - 交易多签V值数组。 r: Array - 交易多签R值数组。 s: Array - 交易多签S值数组。 示例 //request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxQuery\",\"params\":[\"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\"],\"id\":67}' //response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } } eth_ctxOwner 通过跨链发起人查询交易列表。 参数 ADDRESS, 20个字节 - 交易的发起地址 返回 local: 本地跨链列表 time: 跨链交易所在区块的时间戳 value: QUANTITY, 交易数额。 ctxId: DATA, 32个字节- 该交易ID。 txHash: DATA 32个字节- 交易的哈希。 from: DATA, 20个字节 -交易发送者的地址 blockHash: DATA, 32个字节- 该交易所在的区块的哈希。 destinationId: QUANTITY - 跨链目的链ID。 destinationValue: QUANTITY, 目的链币种数额 input: DATA, 交易的input数据。 v: Array - 交易多签V值数组。 r: Array - 交易多签R值数组。 s: Array - 交易多签S值数组。 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxOwner\",\"params\":[\"0x3db32cdacb1ba339786403b50568f4915892938a\"],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"local\": { \"221\": [ { \"value\": \"0xde0b6b3a7640000\", \"status\": 0, \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"time\": \"0x5ebb9cd2\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } ] } } } eth_ctxOwnerByPage 通过跨链发起人查询交易列表。 参数 ADDRESS, 20个字节 - 交易的发起地址 PAGESIZE, 每页的交易数量 STARTPAGE, 从第几页开始(初始页为第0页) 返回 data:OBJECT - 本地跨链列表: time: 跨链交易所在区块的时间戳 value: QUANTITY, 交易数额。 ctxId: DATA, 32个字节- 该交易ID。 txHash: DATA 32个字节- 交易的哈希。 from: DATA, 20个字节 -交易发送者的地址 blockHash: DATA, 32个字节- 该交易所在的区块的哈希。 destinationId: QUANTITY - 跨链目的链ID。 destinationValue: QUANTITY, 目的链币种数额 input: DATA, 交易的input数据。 v: Array - 交易多签V值数组。 r: Array - 交易多签R值数组。 s: Array - 交易多签S值数组。 total:QUANTITY - 总交易数量 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxOwner\",\"params\":[\"0x3db32cdacb1ba339786403b50568f4915892938a\"],\"id\":67}' //Respinse { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"data\": { \"221\": [ { \"value\": \"0xde0b6b3a7640000\", \"status\": 0, \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"time\": \"0x5ebb9cd2\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } ] }, \"total\": 1 } } eth_ctxContent 返回当前所有跨链交易单。 参数 无 返回 local - 本地链跨链交易列表 remote - 跨链目的链交易列表 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxContent\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"local\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } ] }, \"remote\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0xf9747951a56fb6392d1c2bddedf5f9cb0f380a43ac7e6345aa2fea73646e14d6\", \"txHash\": \"0x43f6150c0c308d2b5325f4f6f5820f00862a14beb2e961780eec518b4f6497c1\", \"from\": \"0x8029fcfc954ff7be80afd4db9f77f18c8aa1ecbc\", \"blockHash\": \"0x5391c792a14a3ec6be49201dbbf6a023fbb03025e0c600990107276dc3574ff5\", \"destinationId\": \"0xdd\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0xb003\", \"0xb003\" ], \"r\": [ \"0xae8928d14f2d6389803e29d94be0c1a7ef517818cf1a8a2305b282fb9f7cbf68\", \"0xb7d137e78069d4d2ad39940a4d2a82363fbff32920125853c5feef0b87e91cb4\" ], \"s\": [ \"0x7ab9cd7f753f4fc1c89a66df1ef8cf6d3c37aaa678164bb4df3fed8b19fc234f\", \"0x6d36ffed2dcf26278518def89a92e01b74f81e2ff12ecb29b0fc2b49db70566b\" ] } ] } } } eth_ctxContentByPage 分页返回当前所有跨链交易单。 参数 LOCALSIZE, - 本地跨链列表每页条数。 LOCALPAGE, - 本地跨链列表从第几页开始(初始页为第0页)。 REMOTESIZE, - 远端跨链列表每页条数。 REMOTEPAGE, - 远端跨链列表从第几页开始(初始页为第0页)。 返回 local - 本地链跨链交易列表 remote - 跨链目的链交易列表 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxContentByPage\",\"params\":[1,0,1,0],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"local\": { \"data\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } ] }, \"total\": 1 }, \"remote\": { \"data\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0xf9747951a56fb6392d1c2bddedf5f9cb0f380a43ac7e6345aa2fea73646e14d6\", \"txHash\": \"0x43f6150c0c308d2b5325f4f6f5820f00862a14beb2e961780eec518b4f6497c1\", \"from\": \"0x8029fcfc954ff7be80afd4db9f77f18c8aa1ecbc\", \"blockHash\": \"0x5391c792a14a3ec6be49201dbbf6a023fbb03025e0c600990107276dc3574ff5\", \"destinationId\": \"0xdd\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0xb003\", \"0xb003\" ], \"r\": [ \"0xae8928d14f2d6389803e29d94be0c1a7ef517818cf1a8a2305b282fb9f7cbf68\", \"0xb7d137e78069d4d2ad39940a4d2a82363fbff32920125853c5feef0b87e91cb4\" ], \"s\": [ \"0x7ab9cd7f753f4fc1c89a66df1ef8cf6d3c37aaa678164bb4df3fed8b19fc234f\", \"0x6d36ffed2dcf26278518def89a92e01b74f81e2ff12ecb29b0fc2b49db70566b\" ] } ] }, \"total\": 2 } } } eth_getLocalCtx 分页获取本地跨链交易列表。 参数 PAGESIZE, 每页的交易数量 STARTPAGE, 从第几页开始(初始页为第0页) 返回 data:OBJECT - 本地跨链列表: value: QUANTITY, 交易数额。 ctxId: DATA, 32个字节- 该交易ID。 txHash: DATA 32个字节- 交易的哈希。 from: DATA, 20个字节 -交易发送者的地址 blockHash: DATA, 32个字节- 该交易所在的区块的哈希。 destinationId: QUANTITY - 跨链目的链ID。 destinationValue: QUANTITY, 目的链币种数额 input: DATA, 交易的input数据。 v: Array - 交易多签V值数组。 r: Array - 交易多签R值数组。 s: Array - 交易多签S值数组。 total:QUANTITY - 总交易数量 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getLocalCtx\",\"params\":[1,0],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"data\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } ] }, \"total\": 1 } } eth_getRemoteCtx 分页获取本地跨链交易列表。 参数 PAGESIZE, 每页的交易数量 STARTPAGE, 从第几页开始(初始页为第0页) 返回 data:OBJECT - 本地跨链列表: value: QUANTITY, 交易数额。 ctxId: DATA, 32个字节- 该交易ID。 txHash: DATA 32个字节- 交易的哈希。 from: DATA, 20个字节 -交易发送者的地址 blockHash: DATA, 32个字节- 该交易所在的区块的哈希。 destinationId: QUANTITY - 跨链目的链ID。 destinationValue: QUANTITY, 目的链币种数额 input: DATA, 交易的input数据。 v: Array - 交易多签V值数组。 r: Array - 交易多签R值数组。 s: Array - 交易多签S值数组。 total:QUANTITY - 总交易数量 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getRemoteCtx\",\"params\":[1,0],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"data\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0xf9747951a56fb6392d1c2bddedf5f9cb0f380a43ac7e6345aa2fea73646e14d6\", \"txHash\": \"0x43f6150c0c308d2b5325f4f6f5820f00862a14beb2e961780eec518b4f6497c1\", \"from\": \"0x8029fcfc954ff7be80afd4db9f77f18c8aa1ecbc\", \"blockHash\": \"0x5391c792a14a3ec6be49201dbbf6a023fbb03025e0c600990107276dc3574ff5\", \"destinationId\": \"0xdd\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0xb003\", \"0xb003\" ], \"r\": [ \"0xae8928d14f2d6389803e29d94be0c1a7ef517818cf1a8a2305b282fb9f7cbf68\", \"0xb7d137e78069d4d2ad39940a4d2a82363fbff32920125853c5feef0b87e91cb4\" ], \"s\": [ \"0x7ab9cd7f753f4fc1c89a66df1ef8cf6d3c37aaa678164bb4df3fed8b19fc234f\", \"0x6d36ffed2dcf26278518def89a92e01b74f81e2ff12ecb29b0fc2b49db70566b\" ] } ] }, \"total\": 2 } } eth_ctxStats 获取跨链交易条数。 参数 无 返回 local: - 本地跨链条数: remote: - 远程链跨链条数: 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxStats\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"local\": 1, \"remote\": 2 } } eth_poolStats 获取跨链待确认交易池交易条数。 参数 无 返回 pending: - 本地已确认跨链条数: queue: - 远程同步跨链条数: 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_poolStats\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"pending\": 0, \"queue\": 0 } } "},"24_chromeWallet/":{"url":"24_chromeWallet/","title":"SimPlug","keywords":"","body":"Download wallet Download Plug-In wallet download address Decompression Install wallet 1.Open google browser, open the extension program 2.Install the installation package into the extension program 3.Open the wallet after installation 4.Open the wallet and select the main network or test network. If there is already a wallet, import it directly. If there is no account, create an account directly. 5.Create an account and back up the private key to enter your plug-in wallet. Wallet call method Preconditions Applications that need to run the plug-in (hereinafter referred to as developers) determine whether the plug-in is available according to window.hasSimplug. Developers need to place a button with the id \"run_contract_btn\" in the page to trigger the simplug event. Developers need to place a hidden input with the id \"run_contract_data\" in the page to send transaction data to sumpulg. Operation process The user clicks or the script triggers a button with the id \"run_contract_btn. At the same time, developers need to set the input value with id \"run_contract_data\" to the data to be sent. The plug-in automatically wakes up the call transaction. "},"25_sdk/":{"url":"25_sdk/","title":"SDK","keywords":"","body":"SimpleChainblockchain exposes interfaces to the outside world. External business programs can call these interfaces through the SDK provided by SimpleChain. Developers only need to select the SDK of the corresponding language according to the requirements of their own business programs, and use the API provided by the SDK to program, to implement the operation of the blockchain. Docking application Currently, the functions that the SDK interface can implement include (but are not limited to): Contract operation Contract compilation, deployment, and query Transaction sending, chain notification, parameter parsing, and receipt parsing Chain Management Chain status query and chain parameter settings Team member management Permission settings Multi-language SDK Currently, the SDK provided by SimpleChain includes: Java SDK（stable and powerful) Python SDK（simple and protable） Node-js SDK（simple and protable） "},"48_crossChain/":{"url":"48_crossChain/","title":"Cross-chain solution","keywords":"","body":"Free notary mechanism Cross-chain interaction can be divided into homogeneous chain cross-chain and heterogeneous chain cross-chain according to the different underlying technology platforms of the blockchain: security mechanism between homogeneous chains, consensus algorithm, network topology, the block generation validation logic is consistent, and the cross-chain interaction between them is relatively simple. The cross-chain interaction of heterogeneous chains is relatively complex, suchSimplechain using PoW algorithm and EOS using POS consensus algorithm, the composition form of the two blocks and the certainty guarantee mechanism are very different, and the direct cross-chain interaction mechanism is not easy to design. Cross-chain interaction between heterogeneous chains generally requires third-party auxiliary services to assist cross-chain interaction. Therefore, when designing cross-chain solutions, we need to design a set of synthesis Compare the current mainstream cross-chain solutions and the comprehensive performance of cross-chain solutions, and consider the later upgrade of the solution. Simplechain technical team has designed its own cross-chain scheme on the notary mechanism-the free notary mechanism. Why is this cross-chain technical solution selected? In the mode of \"Notary Public\", the single \"notary public\" mechanism operates in a relatively centralized way, because the efficiency requirement of \"notary public\" mechanism is higher than that of decentralization, this leads to obvious black-box risks in a single notary system. But we Simplechain the \"free notary mechanism\" of precisely makes up for the defects of the \"notary\" mechanism. It adds mortgage and corresponding punishment mechanism to the process of selecting trusted nodes in different block chain platforms. If a node does evil, it will be punished accordingly, and the \"notary\" in the network will be automatically replaced by the new notary. Therefore, the free notary mechanism can effectively ensure the complete decentralization, efficiency and safety of the whole cross-chain process. If the main target of the early cross-chain solution was asset transfer, the cross-chain solution of SIPC was not only asset transfer, but also focused on cross-chain infrastructure. It mainly emphasizes that assets can be realized through smart contracts. The cross-chain technology of SIPC is determined to become a high-performance and decentralized cross-chain infrastructure. It also accesses various cross-chain applications and focuses on commercial implementation. This cross-chain solution enables SIPC to have strong advantages in financial fields, Government chains, and enterprise blockchain solutions, helping the SIPC technology ecosystem become a set of industry blockchain solutions. The following is the structure diagram of SimpleChain cross-chain solution: The cross-chain structure includes a notary mechanism. The Master and sub-chains realize efficient communication and cross-chain assets through the notary mechanism. For example, you can write the block header information of the SimpleChain main chain into the block of the SimpleChain sub-chain. The SimpleChain main chain and the SimpleChain sub-chain use the same consensus verification method to achieve communication between the two chains. Through the notary mechanism, a trusted distributed node (notary/node1 or notary/node2) is used to record transactions on the SimpleChain sub-chain to prove that transactions have occurred on the SimpleChain main chain. Cross-chain interaction of assets is realized through communication. Simply speaking, the SimpleChain main chain and the SimpleChain sub-chain use shared-trusted distributed nodes (node1 or node2) as notaries. The SimpleChain main chain and the SimpleChain sub-chain can be trusted indirectly to complete asset exchange. The following figure shows the flow chart of SimpleChain cross-chain transactions: The cross-chain transaction process is as follows: Step 1: subnet User A makes coins to cross-chain transaction contracts. A. You need to pay the TPC to the subnet miner and pre-charge the transaction fee for step 5. Step 2: anchor the miner group synchronization block, identify the transaction chain in step 1, and initiate and complete multiple signatures after the transaction is confirmed to form valid multiple signatures. Step 3: User B receives the multiple signature message in step 2 and sends a transaction order to the cross-chain contract. The order-receiving transaction contains the Multi-sign broadcast information, and the transaction requires B to pay the online handling fee to the master network miner. After the transaction is confirmed, A obtains the main network currency. Step 4: anchor the miner group synchronization block, identify the transaction chain in step 3, and send instructions to the subnet process after the transaction is confirmed. Step 5: After receiving the instruction in step 4, the anchor miner subnet process initiates a transaction to the cross-chain contract and completes multiple signatures in the contract. B obtained after transaction confirmationTPC。 Advantages of \"free and fair man\" mechanism The advantages of the SIPC cross-chain solution are as follows: (1) Decentralization Anchor nodes are distributed in the blockchain distributed network, using multiple signatures to reach a consensus The anchor node group is open to the public. Common nodes can apply to become anchor nodes to provide services for cross-chain transactions; At the same time, cancel the identity qualification and punish the anchor nodes that have been cheated. (2) open and transparent Based on direct transactions on the blockchain, data is open, transparent, traceable, and verifiable; Cross-chain programs are open-source, and the community can spontaneously organize deployment to participate in service competition and support for cross-chain transactions. Blocks are anchored to each other and data across the network is interconnected; Regular statistical analysis to publish business data results of cross-chain transactions (3) easy to operate Cross-chain wallet one-stop management of all assets on the chain; The cross-chain transaction operation of the imitation exchange conforms to the user's habits and has a large user base; To complete a cross-chain transaction, the user only needs one operation; The transaction cost is low, and only 0.01Token is required for a cross-chain transaction; (4) safe and reliable Realize reliable data transmission based on decentralized multiple signature technology; The signature uses an elliptic curve key to sign. Is it a big crack The downtime of some anchor nodes does not affect the normal operation of cross-chain transactions; The interaction between chains is simple and the transaction efficiency is high. (5) strong expandability Cross-chain technology supports many-to-many cross-chain deployment and enables resource intercommunication among multiple chains; Based on this cross-chain technology, the sub-chain can be released infinitely and integrated into the chain ecosystem; Many sub-chain templates adopt mainstream consensus protocols to meet different business needs; "},"26_smallChain.html":{"url":"26_smallChain.html","title":"Subchain template","keywords":"","body":"Deploy DPOS consensus sub-chain network 1. Genesis block { \"config\": { \"chainId\": 10388, \"dpos\": { \"period\": 3, \"epoch\": 300, \"maxSignersCount\": 21, \"minVoterBalance\": 100000000000000000000, \"genesisTimestamp\": 1554004800, \"signers\": [ \"3d50e12fa9c76e4e517cd4ace1b36c453e6a9bcd\", \"f97df7fe5e064a9fe4b996141c2d9fb8a3e2b53e\", \"ef90068860527015097cd031bd2425cb90985a40\" ], \"pbft\": false, \"voterReward\": true } }, \"nonce\": \"0x0\", \"timestamp\": \"0x5ca03b40\", \"extraData\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"gasLimit\": \"0x47b760\", \"difficulty\": \"0x1\", \"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"alloc\": { \"3d50e12fa9c76e4e517cd4ace1b36c453e6a9bcd\": { \"balance\": \"0x21e19e0c9bab2400000\" }, \"ef90068860527015097cd031bd2425cb90985a40\": { \"balance\": \"0x21e19e0c9bab2400000\" }, \"f97df7fe5e064a9fe4b996141c2d9fb8a3e2b53e\": { \"balance\": \"0x21e19e0c9bab2400000\" } }, \"number\": \"0x0\", \"gasUsed\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\" } period dpos block-out interval, in seconds epoch How many blocks are there in the dpos interval to regularly clear the votes (after clearing, the voters need to re-initiate the voting transaction) maxSignersCount Maximum number of producers allowed for dpos minVoterBalance The minimum amount of votes allowed by dpos. Unit: Wei voterReward Whether dpos voters can get rewards (if enabled, voters can also get dividends when producers issue blocks) genesisTimestamp dpos allows the initial block output time, and calculates the subsequent block output time and the producer based on this time. signers dpos initial producer list pbft Whether dpos uses pbft to confirm each block after each round of block output alloc dpos initial producer mortgage vote amount 2. Sub-chain initialization process Method 1. Use sipe to initialize 1.Create or import a producer account ```shell script sipe --datadir=dposdata account new 2.Write the created or imported producer address into genesis.json, and write the initial voting amount at the same time (refer to 1. genesis block) 3.Initialize sub-chain nodes ```shell script sipe --datadir=dposdata --role=subchain init genesis.json Method 2. Use the consensus tool to initialize the cluster with one click in cmd/consensus run under directoryinit_dpos.sh ```shell script cd cmd/consensus ./init_dpos.sh --numNodes 3 + `numNodes` Number of cluster nodes generated After initialization is completed `cmd/consensus/dposdata` create corresponding node files under the Directory ### 3. Sub-chain startup process 1. Startup node ```bash sipe --datadir=dposdata --mine --etherbase= --unlock= --password= --port=30303 --role=subchain --v5disc Connect to other nodes sipe --datadir=dposdata --mine --etherbase= --unlock= --password= --port=30304 --role=subchain --v5disc --bootnodesv5={enode1} --bootnodesv4={enode1} 4. Votes and proposals 4.1 initiate voting transaction > eth.sendTransaction({from:\"\",to:\"\",value:0,data:web3.toHex(\"dpos:1:event:vote\")}) 4.2 initiate the cancellation of voting transaction > eth.sendTransaction({from:\"\",to:\"\",value:0,data:web3.toHex(\"dpos:1:event:devote\")}) 4.3 initiate a proposal to change miner rewards Change the miner block reward ratio666‰ > eth.sendTransaction({from:\"\",to:\"\",value:0,data:web3.toHex(\"dpos:1:event:proposal:proposal_type:3:mrpt:666\")}) 4.4 initiate a proposal to change the minimum allowed vote limit Change the minimum allowed vote limit 10 ether > eth.sendTransaction({from:\"\",to:\"\",value:0,data:web3.toHex(\"dpos:1:event:proposal:proposal_type:6:mvb:10\")}) 4.5 pass or oppose the proposal yes through the proposal,no objection proposal > eth.sendTransaction({from:\"\",to:\"\",value:0,data:web3.toHex(\"dpos:1:event:declare:hash::decision:yes\")}) 5. View consensus status > dpos.getSnapshot() candidates Miner candidate list confirmedNumber Confirmed block height historyHash The block hash of the last two rounds of block output, which is used to calculate the block output order of the producer in the new round. minerReward The reward percentage of each block producer, if enabled voterReward , the rest is the reward of voters signers List producers and block order punished List the punishment information of each producer for not releasing blocks on time tally List the total votes of each candidate votes List voting information voters The height of the block where the voters vote proposals Proposal list Deploy PBFT consensus sub-chain network 1. Genesis block { \"config\": { \"chainId\": 10388, \"istanbul\": { \"epoch\": 30000, \"policy\": 0 } }, \"nonce\": \"0x0\", \"timestamp\": \"0x0\", \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000000000000f843f83f941c46d10e91eafaac430718df3658b1a496b827bd94b67ee9395542b227c99941eb4168e3f3c6502dd8949d6510b637970085962c908c69e63e9d36a36cb480c0\", \"gasLimit\": \"0xe0000000\", \"difficulty\": \"0x1\", \"mixHash\": \"0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"alloc\": {}, \"number\": \"0x0\", \"gasUsed\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\" } epoch How many blocks are there at pbft intervals to regularly clear votes policy The polling method of pbft proposer: 0 is roundRobin (replaced in order), and 1 is sticky (if the proposer is not wrong, do not replace the proposer) mixHash pbft block shall mixhash specified as 0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365 extraData header.extra calculated by the initial pbft producer alloc pbft does not have a block reward currently, so tokens need to be allocated in advance. 2. Sub-chain initialization process Method 1. Use sipe to initialize 1.Create or import a producer account ```shell script sipe --datadir=pbftdata account new 2.Use the consensus tool to generate extraData and write it to genesis.json (refer to 1. genesis block) ```shell script cd cmd/consensus ./init_pbft.sh --numNodes 1 --validator 3.Initialize sub-chain nodes ```shell script sipe --datadir=pbftdata --role=subchain init genesis.json 4.Write the node's nodekey to pbftdata/static-nodes.json (the nodekey public key is the producer public key) #### Method 2. Use the consensus tool to initialize the cluster with one click Run init_pbft.sh in the cmd/consensus Directory ```bash cd cmd/consensus ./init_pbft.sh --numNodes 3 --ip 127.0.0.1 127.0.0.2 127.0.0.3 --port 21001 21002 21003 numNodes Number of cluster nodes generated ip List of ip addresses of the specified node (the default ip address is 127.0.0.1) port The list of ports for the specified node. The default port is 21001 ~ 2100x, and x is numNodes. After initialization is completedcmd/consensus/pbftdataCreate corresponding node files under the Directory 3. Sub-chain startup process sipe --datadir=pbftdata --istanbul.requesttimeout=10000 --istanbul.blockperiod=5 --syncmode=full --mine --minerthreads=1 --port=21001 --role=subchain port Must be consistent with the enode configured in static-nodes.json istanbul.requesttimeout The expiration time of each view in milliseconds. The default value is 10000. istanbul.blockperiod pbft block output interval, in seconds, the default value is 1 4.View consensus status ```shell script istanbul.getSnapshot() ``` validators pbft Block producer list votes Votes for adding or removing validators tally Total voting situation Deploy RAFT consensus sub-chain network 1. Genesis block { \"config\": { \"chainId\": 10, \"raft\": true }, \"nonce\": \"0x0\", \"timestamp\": \"0x0\", \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"gasLimit\": \"0xe0000000\", \"difficulty\": \"0x0\", \"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"alloc\": { \"1e69ebb349e802e25c7eb3b41adb6d18a4ae8591\": { \"balance\": \"0x21e19e0c9bab2400000\" }, \"73ce1d55593827ab5a680e750e347bf57485a511\": { \"balance\": \"0x21e19e0c9bab2400000\" }, \"b8564a5657fa7dc51605b58f271b5bafad93b984\": { \"balance\": \"0x21e19e0c9bab2400000\" } }, \"number\": \"0x0\", \"gasUsed\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\" } raft true indicates the use of raft consensus alloc The raft consensus packages blocks only when a transaction exists. Therefore, tokens need to be allocated in advance. 2. Sub-chain initialization process Method 1. Use sipe to initialize 1.Create or import a producer account sipe --datadir=raftdata account new 2.Initialize sub-chain nodes sipe --datadir=raftdata --role=subchain init genesis.json 4.nodekey Write raftdata/static-nodes.json (The nodekey public key is the producer public key) Method 2. Use the consensus tool to initialize the cluster with one click under cmd/consensuRun under the Directorinit_pbft.sh cd cmd/consensus ./init_raft.sh --numNodes 3 --ip 127.0.0.1 127.0.0.2 127.0.0.3 --port 21001 21002 21003 --raftport 50401 50402 50403 numNodes Number of cluster nodes generated ip List of ip addresses of the specified node (the default ip address is 127.0.0.1) port The list of ports for the specified node. The default port is 21001 ~ 2100x, and x is numNodes. raftport List of raft communication ports for the specified node (the default port is 50401 ~ 5040x, and x is numNodes) After initialization, the corresponding node file is created in the cmd/consensus/raftdata directory. 3. Sub-chain startup process sipe --datadir=raftdata --raft --port=21001 --raftport=50401 --role=subchain port Must be consistent with the enode configured in static-nodes.json raft Use raft mode raftport raft port number, which must be consistent with the enode configured in static-nodes.json 4.View consensus status > istanbul.getSnapshot() validators pbft Block producer list votes Votes for adding or removing validators tally Total voting situation "},"49_crossChainOrder/":{"url":"49_crossChainOrder/","title":"Cross-chain process","keywords":"","body":"Simplechain is a hybrid public chain with a master and sub-chain architecture. Cross-platform migration of assets between different chains involves cross-chain operations. The following is a detailed cross-chain process: Download ChainBox Download the corresponding according to your mobile device system ChainBox Installation package, keep your private key after registering your wallet. Find the wallet address and copy the wallet address. As shown below: Get test assets Turn on the tap, tap address: Test network faucet Enter the wallet address copied in the previous step into the tap, and you can receive the test currency. As shown below: Cross-chain transactions Cross-chain entry Open the wallet and enter the homepage. All the coins and their discount of the wallet in the chain ecosystem are displayed in the wallet assets (as shown in the following figure) Click a wallet asset (TEST) to enter the main chain transaction page (as shown in the following figure) Click the \"cross-chain\" button in the above figure to enter the transaction pair selection interface (as shown in the following figure). Only one transaction pair is provided here. Click SUB enter the cross-chain trading market. The cross-chain list in the following figure shows the orders between the main chain and the sub-chain. The red unit price records the orders sent from the main chain to the sub-chain, and the green unit price records the orders sent from the sub-chain to the main chain. The cross-chain list is arranged by unit price from high to low. For more records, click the Tab page. receive transaction andSend transaction listQuery and display. The current delegation page displays the cross-chain transaction orders that the current account participates in. Click all you can display all commissioned orders and historical cross-chain transactions. Order receiving: Click to receive an order in the red wirebox above to clinch a cross-chain transaction. This transaction means that you sell one TEST and get 10 SUB at the unit price of 0.1SUB/TEST. See the following figure After entering the wallet password, click \"confirm\" to send out an on-chain transaction. The transaction can be completed after the transaction is confirmed (about 6 minutes). Click \"all\"-> \"history\" to see the cross-chain transaction records that have just been closed, as shown in the following figure: View transaction details in the browser View cross-Chain records: View transaction details: Browser view details: Returning to the homepage of the wallet, I found that the SUB-chain coins have increased by 10 SUB-chains, and the handling fee is 0.001 TEST, which is far less than the handling fee rate of 0.2% of that of ordinary exchanges. Billing Click the \"issue\" button in the cross-chain trading market to enter the issue process. Click \"next\", enter the password and click \"confirm\". After the transaction is sent successfully and the transaction is confirmed (about 3 minutes), we can find that a new record has been added to the current delegation page of the account. At this moment, all users in the network can query the delegation, indicates that the order is issued successfully. User'sTESTReduce 1 related orders Select the commission record above and click \"withdraw order\" to enter the withdraw order process. Enter the password and click \"confirm\" to send the transaction. After the transaction is confirmed (about 6 minutes). The user delegation list is empty, and a new withdraw record is added to the history. Back to the home page, the TEST that has just been reduced has also returned. "},"27_dappFlow/":{"url":"27_dappFlow/","title":"Dapp process carding","keywords":"","body":"The Dapp development case is to develop a public-benefit crowdfunding project based on Simplechain. The following is a review of the development process of the entire crowdfunding project. Write a contract and test it in remix Download and Install remix , and try to write the contract method. And conduct tests. Create an empty project for React The empty project of The React creation mainly contains two commands. First, install create-react-app This command: install create-react-app It installs the directory on which your node depends and creates the project: ./create-react-app After creating a project, you can use the following command to initialize the project: npm run start Create a comple.js file Create the compile.js file and install the solc compiler. The command is as follows: npm install solc After solc is installed, you can call solc.com pile(sourceCode,1) to compile the source code. After compilation, export the compiled bytecode (bytecode),interface. Create a js file To build an interface, call web3, and interact with the blockchain, you need to use the js method. Therefore, you need to create multiple js files in this step. The following figure shows the specific js file to be created: Initiate contract function The function of initiating a contract mainly has two specific logics to implement. One is to write specific methods in interaction, and the other is to complete the call in CreateFundingTab. Initiate and participate in crowdfunding There are three main implementation functions of initiating and participating in crowdfunding. One is as follows: Pass a callback function onItemClick to CardList in the main interface to return the details of the contract clicked by the user. Pass to MyCard in CardList In MyCard, when onClick is triggered, the onItemClick is called and the corresponding detail is returned. The address of the contract and the supported amount can be obtained through the above three-step method. The second is to write specific methods in interaction, and the last is to complete the call in CreatorFundingTab. The figure is as follows: "},"28_editor.html":{"url":"28_editor.html","title":"translater","keywords":"","body":"Remix 推荐使用 Remix 来开发简单合约和快速学习 Solidity。 Remix 可在线使用，而无需安装任何东西。如果你想离线使用，可按 https://github.com/ethereum/browser-solidity/tree/gh-pages 的页面说明下载 zip 文件来使用。 该页面有进一步详细说明如何安装 Solidity 命令行编译器到你计算机上。如果你刚好要处理大型合约，或者需要更多的编译选项，那么你应该选择使用命令行编译器 solc。 npm / Node.js 使用 npm 可以便捷地安装Solidity编译器solcjs。但该 solcjs 程序的功能相对于本页下面的所有其他选项都要少。在commandline-compiler 一章中，我们假定你使用的是完整功能的编译器。 所以，如果你是从 npm 安装 solcjs ，就此打住，直接跳到 solc-js去了解。 注意: solc-js 项目是利用 Emscripten 从 C++ 版的 solc 跨平台编译为 JavaScript 的，因此，可在 JavaScript 项目中使用 solcjs（如同 Remix）。 具体介绍请参考 solc-js 代码库。 npm install -g solc 在命令行中，使用 solcjs 而非 solc 。solcjs 的命令行选项同 solc 和一些工具（如 geth )是不兼容的，因此不要期望 solcjs 能像 solc 一样工作。 Docker 我们为编译器提供了最新的docker构建。 stable 仓库里的是已发布的版本，nightly仓库则是在开发分支中的带有不稳定变更的版本。 docker run ethereum/solc:stable solc --version 目前，docker 镜像只含有 solc 的可执行程序，因此你需要额外的工作去把源代码和输出目录连接起来。 二进制包 可在 solidity/releases 下载 Solidity 的二进制安装包。 对于 Ubuntu ，我们也提供 PPAs 。通过以下命令，可获取最新的稳定版本： sudo add-apt-repository ppa:ethereum/ethereum sudo apt-get update sudo apt-get install solc 当然，你也可安装尝鲜的开发者版本： sudo add-apt-repository ppa:ethereum/ethereum sudo add-apt-repository ppa:ethereum/ethereum-dev sudo apt-get update sudo apt-get install solc 同时，也提供可安装 所有支持的Linux版本 下的 snap package 。通过以下命令，可获取最新的稳定版本： sudo snap install solc 或者，如果你想测试 develop 分支下的最新变更，可通过如下方式安装开发者版本： sudo snap install solc --edge 同样，Arch Linux 也有提供安装包，但仅限于最新的开发者版本： pacman -S solidity 在写本文时，Homebrew 上还没有提供预构建的二进制包（因为我们从 Jenkins 迁移到了 TravisCI ）。 我们将尽快提供 homebrew 下的二进制安装包，但至少从源码构建的方式还是行得通的： brew update brew upgrade brew tap ethereum/ethereum brew install solidity 如果你需要特定版本的 Solidity ，你需要从 Github 上安装一个 Homebrew formula 你可查阅 solidity.rb commits on Github 的提交记录，去寻找包含 solidity.rb 文件改动的特殊提交。然后使用 brew 进行安装： brew unlink solidity # Install 0.4.8 brew install https://raw.githubusercontent.com/ethereum/homebrew-ethereum/77cce03da9f289e5a3ffe579840d3c5dc0a62717/solidity.rb Gentoo Linux 下也提供了安装包，可使用 emerge 进行安装： emerge dev-lang/solidity 从源代码编译 克隆代码库 执行以下命令，克隆源代码： git clone --recursive https://github.com/ethereum/solidity.git cd solidity 如果你想参与 Solidity 的开发, 你可分叉 Solidity 源码库后，用你个人的分叉库作为第二远程源： cd solidity git remote add personal git@github.com:[username]/solidity.git Solidity 有 Git 子模块，需确保完全加载它们： git submodule update --init --recursive 先决条件 - macOS 在 macOS 中，需确保有安装最新版的 Xcode， Xcode 包含 Clang C++ 编译器， 而 Xcode IDE 和其他苹果开发工具是 OSX 下编译 C++ 应用所必须的。如果你是第一次安装 Xcode 或者刚好更新了 Xcode 新版本，则在使用命令行构建前，需同意 Xcode 的使用协议： sudo xcodebuild -license accept Solidity 在 OS X 下构建，必须 安装Homebrew 包管理器来安装依赖。 如果你想从头开始，这里是卸载Homebrew的方法 先决条件 - Windows 在Windows下构建Solidity，需下载的依赖软件包： 软件 备注 Git for Windows_ C从Github上获取源码的命令行工具 CMake_ 跨平台构建文件生成器 Visual Studio 2017 Build Tools_ C++ 编译器 Visual Studio 2017_ (Optional) C++ 编译器和开发环境 如果你已经有了 IDE，仅需要编译器和相关的库，你可以安装 Visual Studio 2017 Build Tools。 Visual Studio 2017 提供了 IDE 以及必要的编译器和库。所以如果你还没有一个 IDE 并且想要开发 Solidity，那么 Visual Studio 2017 将是一个可以使你获得所有工具的简单选择。 这里是一个在 Visual Studio 2017 Build Tools 或 Visual Studio 2017 中应该安装的组件列表： Visual Studio C++ core features VC++ 2017 v141 toolset (x86,x64) Windows Universal CRT SDK Windows 8.1 SDK C++/CLI support 外部依赖 在 macOS、Windows和其他 Linux 发行版上，有一个脚本可以“一键”安装所需的外部依赖库。本来是需要人工参与的多步操作，现在只需一行命令: ./scripts/install_deps.sh Windows 下执行： scripts\\install_deps.bat 命令行构建 确保你已安装外部依赖（见上面） Solidity 使用 CMake 来配置构建。Linux、macOS 和其他 Unix系统上的构建方式都差不多： mkdir build cd build cmake .. && make 也有更简单的： #note: 将安装 solc 和 soltest 到 usr/local/bin 目录 ./scripts/build.sh 对于 Windows 执行： mkdir build cd build cmake -G \"Visual Studio 15 2017 Win64\" .. 这组指令的最后一句，会在 build 目录下创建一个 solidity.sln 文件，双击后，默认会使用 Visual Studio 打开。我们建议在VS上创建 RelWithDebugInfo 配置文件。 或者用命令创建： cmake --build . --config RelWithDebInfo CMake参数 如果你对 CMake 命令选项有兴趣，可执行 cmake .. -LH 进行查看。 版本号字符串详解 Solidity 版本名包含四部分： 版本号 预发布版本号，通常为 develop.YYYY.MM.DD 或者 nightly.YYYY.MM.DD 以 commit.GITHASH 格式展示的提交号 由若干条平台、编译器详细信息构成的平台标识 如果本地有修改，则 commit 部分有后缀 .mod。 这些部分按照 Semver 的要求来组合， Solidity 预发布版本号等价于 Semver 预发布版本号， Solidity 提交号和平台标识则组成 Semver 的构建元数据。 发行版样例：0.4.8+commit.60cc1668.Emscripten.clang. 预发布版样例： 0.4.9-nightly.2017.1.17+commit.6ecb4aa3.Emscripten.clang 版本信息详情 在版本发布之后，补丁版本号会增加，因为我们假定只有补丁级别的变更会在之后发生。当变更被合并后，版本应该根据semver和变更的剧烈程度进行调整。最后，发行版本总是与当前每日构建版本的版本号一致，但没有 prerelease 指示符。 例如： 0.4.0 版本发布 从现在开始，每晚构建为 0.4.1 版本 引入非破坏性变更 —— 不改变版本号 引入破坏性变更 —— 版本跳跃到 0.5.0 0.5.0 版本发布 该方式与version pragma一起运行良好。 "},"29_writeContract/":{"url":"29_writeContract/","title":"Write contract","keywords":"","body":"一. Project code management Project code base 二. Single crowdfunding contract implementation 1.Create empty contract CrowFunding Enter the item catalog and create the file basicFunding.sol And add the following code: pragma solidity ^0.4.24; contractCrowFunding { } 2.Basic attributes (state variables) State variable Type use creator address Project Initiation, responsible for contract creation, expense application, expense execution projectName string Name of the crowdfunding item supportBalance uint Crowdfunding holding amount targetBalance uint Crowdfunding project bid raising amount endTime uint Crowdfunding is cut off. If the amount of crowdfunding cannot be raised at this time, crowdfunding fails. 3.Constructor implementation pragma solidity ^0.4.24; contract CrowFunding { address public creator; // 发起人 string public projectName; // 项目名称 uint public supportBalance; // 参与众筹金额 uint public targetBalance; // 众筹目标金额 uint public endTime; // 众筹截止时间 constructor(string _projectName, uint _supportBalance, uint _targetBalance, uin t _durationInSeconds) public { creator = msg.sender; projectName = _projectName; supportBalance = _supportBalance; targetBalance = _targetBalance; //传递进来剩余的秒数，比如若众筹30天，则传入：30天 * 24小时 * 60分 * 60秒 = 2592000 endTime = now + _durationInSeconds; //2592000 } } Test 4.Participate in crowdfunding Implementation Add participant attributes address[] public investors; //people who participate in crowdfunding, namely investors Participating in crowdfunding means transferring money to the contract and adding the participants' addresses to the collection. The code is as follows: function invest() public payable { require(investorExistMap[msg.sender] == false);//每个人只能参与一次 require(msg.value == supportBalance); // 支持固定金额 investors.push(msg.sender); // 添加到众筹人数组中 investorExistMap[msg.sender] = true; // 标记当前账户为参与人 } In order to quickly verify whether an account is in an array of participants, we provide a mapping(address=>bool)to mark mapping the feature is that all keys exist by default, but the default value isfalse，if it does not exist, return false,we use the user address key,set the value true,to complete the index, mapping is a linear index, than using for loop traversal investors arrays are efficient and economical, so you need to add the following attributes: mapping(address => bool) public investorExistMap; //标记一个人是否参与了当前众筹 test Test, please operate in digital order after deployment Refund for crowdfunding failure (implementation) Refund means that all the money raised will be returned to investors one by one. Two auxiliary functions are added at the same time to facilitate testing. //众筹失败，退款 function drawBack() public { for (uint i = 0 ; i Test Cost request (implementation) Define structure If crowdfunding is successful and the project is started, a fee needs to be pointed out, which needs to include the following information: Purpose: What to buy? Cost: How much does it cost? Merchant address: from whom? Number of votes approved at present: how many people approve, more than half of them approve the expenditure Current status of this expense application: current status of this application: completed? To be approved? On behalf of the implementation? Mark the set of people who have voted: mapping(address =>bool), a mark set of people in favor, to prevent one person from voting for many times. Define the structure code based on the analysis: struct Request { string purpose; //买什么？ uint cost; //需要多少钱？ address shopAddress; // 向谁购买？ uint voteCount; // 多少人赞成了，超半数则批准支出 mapping(address => bool) investorVotedMap; //赞成人的标记集合，防止一人重复投票多次 RequestStatus status; //这个申请的当前状态：投票中？已批准？已完成？ } Define an enumeration to describe the application status: enum RequestStatus {Voting,Approved,Completed} Definition method This function is relatively simple. Create a new request structure and add it to the array. The code is as follows: Request[] public requests; //请求可能有多个，所以定义一个数组 function createRequest(string _purpose, uint _cost, address _shopAddress) public { Request memory request = Request({ purpose : _purpose, cost : _cost, shopAddress : _shopAddress, voteCount : 0, status : RequestStatus.Voting }); requests.push(request); //将新的请求添加至数组中 } Test In createRequest add parameters in: \"小胖子减肥\", 100, \"0xca35b7d915458ef540ade6068dfe2f44e8fa733c\" Search for the 0th request in the request, as shown in the following figure: Approval of payment application Implementation After the project Party initiates the application, it will be approved by the crowdfunding personnel, if the investors do not support it. Ignore it. The default value is false (not supported). If you want to support it, you need to perform an approval action. That is, modify the status of the data of the application structure, including: Check whether this person has voted. If not, vote is allowed. Otherwise, exit. voteCount data plus 1. Set the value of this voter's re-investorVotedMap mapping to true. The code is as follows: //批准⽀付申请 function approveRequest(uint256 index) public { // 1. 检验这个⼈是否投过票，若未投过，则允许投票，反之退出 // 2. voteCount数据加1。 // 3. 将该投票⼈在investorVotedMap映射中的值设置为true。 //⾸先要确保是参与众筹的⼈，否则⽆权投票 require(investExitMapping[msg.sender]); //根据索引找到特定的请求 Request storage req = requests[index]; //确保没有投过票，⼈⼿⼀票 require(req.investorVotedMap[msg.sender] == false); //如果已经完成，或者已经获得批准了，就不⽤投票了，当前投票不会影响决策。 require(req.status == RequestStatus.Voting); //⽀持票数加1 req.voteCount += 1; //标记为已投票 req.investorVotedMap[msg.sender] = true; if (req.voteCount * 2 > investors.length) { req.status == RequestStatus.Approved; } } Test View the request after approval, and the voteCount becomes 1 Complete expense request Implementation When more than half of the votes are voted, if the expenses are approved, the expenses can be executed by the project Party, or by the project Party, or by the contract automatically. We choose to execute it manually, because it is possible that the project Party changes and pays attention to it, and there is no need to purchase on the right side of the plan, so we transfer the rights to the project party. This function mainly does two things: 1.If the number of votes exceeds half, the transfer will be executed. 2.Update the status of the request Coding are as follows: function finalizeRequest(uint256 index) public onlyManager{ // 这个函数主要做两件事： // 1. 票数过半，则执⾏转账。 // 2. 更新request的状态。 Request storage req = requests[index]; //合约⾦额充⾜才可以执⾏ require(address(this).balance >= req.cost); //赞成⼈数过半 require(req.voteCount * 2 > investors.length); //转账 req.shopAddress.transfer(req.cost); //更新请求状态为已完成 req.status = RequestStatus.Completed; } Test Three people invest, one is in favor, two are against, and the execution of payment fails. Two people agree, the execution of the payment is successful To fully implement smart contracts, several methods need to be implemented and the mutual calling of contract methods. These can be learned directly from the source code. But the contract writing and testing are now in the above several basic methods. "},"30_frontRealize/":{"url":"30_frontRealize/","title":"Front-end development","keywords":"","body":"Initialize React project The front end is developed based on the React framework, so we first initialize the project. Initialize the project create-react-app funding-eth-react Streamline projects For the lottery project, only App.js and index.js are left under src, and the corresponding code is adjusted. import React, { Component } from 'react'; class App extends Component { render() { return ( Hello World ); } } export default App; Execute the following command: npm start Install dependency libraries npm install --save web3 npm install --save semantic-ui-react npm install --save semantic-ui-css Reference web3.js Implementation Create a folder named utils under src and create the file getWeb3.js internally import Web3 from 'web3'; let web3; if (typeof window.web3 !== 'undefined') { console.log('found injected web3'); web3 = new Web3(window.web3.currentProvider); } else { console.log('found local web3'); web3 = new Web3('http://localhost:7545'); } export default web3; Call crowdfunding contracts Deploy Funding to Simplechain test network Obtain the contract address: 0x8ff3a13157f1a0aa99beb84d393f1aac4dd470e3 Call Funding contract ABI Obtain a contract instance First, create the directory sipc under src and create the file contracts.js. The ABI format is in json format. You can copy the ABI to the address bar of the browser and format it into a row and then copy it back to save space. import web3 from '../utils/getWeb3'; //将ABI添加到这里 const fundingFactoryABI = [ { \"constant\": true, \"inputs\": [], \"name\": \"platformProv ider\", \"outputs\": [ { \"name\": \"\", \"type\": \"address\" } ], \"payable\": false, \"stateMu tability\": \"view\", \"type\": \"function\" }, { \"constant\": true, \"inputs\": [], \"name\": \"getInvestorFunding\", \"outputs\": [ { \"name\": \"\", \"type\": \"address[]\" } ], \"payable\" : false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": true, \"inpu ts\": [], \"name\": \"getCreatorFunding\", \"outputs\": [ { \"name\": \"\", \"type\": \"address[]\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constan t\": true, \"inputs\": [], \"name\": \"getAllFunding\", \"outputs\": [ { \"name\": \"\", \"type\": \"address[]\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": true, \"inputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"name\": \"crow FundingArray\", \"outputs\": [ { \"name\": \"\", \"type\": \"address\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": true, \"inputs\": [ { \"name\": \"\", \"type\": \"address\" }, { \"name\": \"\", \"type\": \"uint256\" } ], \"name\": \"crea torFundingMap\", \"outputs\": [ { \"name\": \"\", \"type\": \"address\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": false, \"inputs\": [ { \"name\": \"_projectName\", \"type\": \"string\" }, { \"name\": \"_supportMoney\", \"type\": \"uin t256\" }, { \"name\": \"_goalMoney\", \"type\": \"uint256\" }, { \"name\": \"_duration\", \"type\" : \"uint256\" } ], \"name\": \"createFunding\", \"outputs\": [], \"payable\": false, \"stateMu tability\": \"nonpayable\", \"type\": \"function\" }, { \"inputs\": [], \"payable\": false, \"s tateMutability\": \"nonpayable\", \"type\": \"constructor\" } ]; const fundingFactoryAddress = '0x8ff3a13157f1a0aa99beb84d393f1aac4dd470e3'; //创建fundingFactory合约实例 let fundingFactoryContract = new web3.eth.Contract(fundingFactoryABI, fundingFactor yAddress); let contracts = { fundingFactoryContract, } export default contracts; There are many modules in the whole front-end development. In the following interface development step diagram, we can see that the whole interface includes the crowdfunding I initiated, all the crowdfunding, and the crowdfunding I participated in and other modules. As shown below: The preceding steps have already implemented the basic framework of the entire front-end page and the contract call case. The development of other modules is similar to the preceding steps. No more detailed introduction, you can directly view the source code to learn. "},"31_mining.html":{"url":"31_mining.html","title":"sipc mining","keywords":"","body":"Mining is a way to obtain sipc and also a link to participate in the bottom layer of Simplechain ecology. Currently, there are 3 mining pools that support Simplechain mining. They are: Matpool Dxpool Simpool At present, the main types of mining machines that can mine are SimpleNode X1, as shown below: Purchase link: https://www.suanli.com/ "},"32_miningPool/":{"url":"32_miningPool/","title":"MinePool access","keywords":"","body":"Sipc currently supports three mining pools for mining, which are: Matpool Dxpool Simpool Simpool mining tutorial Mining method Method 1： Register an account for mining in Simpool, the official website of the mining pool; Method 2： Use simpleNode(V1.0.0 version) to connect to the mining pool for mining. Simpool mining Mine pool registration Register the mine pool account (do not enter the account name in Chinese); Account registration address: https://simpool.sipc.vip/enroll Enter account management to set the payment address (otherwise the system cannot make coins). Link mining pool mining: Special attention: name is followed by the miner user name, the best format is the account name. xxx (Miner name does not have Chinese) or directly the account name It is very important which account the miner belongs to, and the income is distributed according to the payment address under the corresponding account name. Download the files required by the GPU The address is here：https://github.com/simplechain-org/gpuminer/releases （Be sure to download the latest version, the latest version is more efficient! The latest version is 1.0.4） Decompress the modified file After downloading the compressed file, decompress it into a folder, as shown in the following figure: Click in, find the file start.bat, and edit it with Notepad: —— gpuplatform 1 choose card A for mining; —— gpuplatform 2 choose N card for mining; —— gpuplatform 3 choose hybrid multi-card mining. After modification, save it and turn it off. Double-click start.bat to link the mine pool. Screenshot after success: After accessing the mine pool, you can log on to your mine pool account on the mine pool official website to view your income. SimpleNode(V1.0.0 version) mining pool mining SimpleNode download address: https://www.simplechain.com/ , select the corresponding version to install according to your system, and start the application after the installation is successful Specific mining steps: Start SimpleNode, click the \"start mining\" button in the upper right corner, and the mining method pop-up window app. Mining method: Select \"mining pool mining\" in the popup window of mining method \"; Miner name: if you have not registered a Simpool account, you need to click the \"Click register\" button on the right side of the miner name to go to the Simpool registration page. After the registration is successful, return to the previous SimpleNode mining page; if you have registered a Simpool account, enter the miner name directly in the miner name editing box (Miner name does not contain Chinese) Graphics card type: select the type of graphics card, according to your computer's graphics card to choose (wrong choice, mining has no computing power) Special attention: When you register an account or add an account in Simpool, the account name must not be in Chinese. Miner name, the best format is the account name. xxx (account name is the account name in the Simpool) or directly the account name It is very important which account the miner belongs to, and the income is distributed according to the payment address under the corresponding account name. Click the OK button to mine. You can click view revenue in the upper right corner to view your revenue. "},"33_gpuMining/":{"url":"33_gpuMining/","title":"GPU Mining","keywords":"","body":"Window version Note: This GPU mining only supports linking mining pools SImpool address：https://simpool.vip GPU mining address：http://suo.im/5E6IrE Mining pool registration process: Step 1: register a mine pool account (the user name is preferably in English); Step 2: Enter account settings; Step 3: Design the payment address in the Personal Center (otherwise the system can't make coins); Special attention: The account name is very important. The name must be followed by the account user name after the mine pool. Download the files required by the GPU Download address: https://github.com/simplechain-org/gpuminer/releases（Be sure to download the latest version, the latest version is more efficient! The latest version is 1.0.3) Decompress the modified file Decompress the compressed file into a folder. Click in, find the file start.bat, and edit it with Notepad: After the modification, double-click start.bat to link the mine pool. The screenshot after the modification is successful: After accessing the mine pool, you can log on to your mine pool account on each mine pool official website to view your income. Mac version SimpleChain official GPU mining tutorial (MAC) Note: This GPU mining only supports linking mining pools Simpool website：https://simpool.vip Download the software required for GPU mining：http://suo.im/5E6IrE Mining pool registration process: Step 1: register a mine pool account (the user name is preferably in English); Step 2: Enter account settings; Step 3: Design the payment address in the Personal Center (otherwise the system can't make coins); Special attention The account name is very important. The name must be followed by the account user name after the mine pool. Download the files required by the GPU Download address：hhttp://suo.im/5E6IrE Decompress the modified file Decompress the compressed file into a file and put it on the desktop: Then open the command line mode and find the terminal and terminal in the utility tool: First cd desktop enter the desktop (the file you just downloaded is on the desktop by default), and then obtain the permission to operate the file you just downloaded, chmod +x gpuminer (If the file is on the desktop, you can paste it!): After obtaining the permission, enter the command to start the file: ./gpuminer –server simpool.vip:8801 –name abc(118.31.45.65:8801是矿池地址，每个矿池的地址不一样，abc是账户名称,一定填自己账户。)运行成功后： "},"34_SimPool/":{"url":"34_SimPool/","title":"Simpool Mining","keywords":"","body":"Simpool mining tutorial Mining method Mode 1 :: register an account for mining in Simpool, the official website of the mining pool. Mode 2:: use simpleNode(V1.0.0 version) to connect to the mining pool for mining. Mine pool registration Register the mine pool account (do not enter the account name in Chinese); Account registration address: https://simpool.sipc.vip/enroll Enter account management to set the payment address (otherwise the system cannot make coins). Link mining pool mining Special attention: name is followed by the miner user name, the best format is the account name. xxx (Miner name does not have Chinese) or directly the account name It is very important which account the miner belongs to, and the income is distributed according to the payment address under the corresponding account name. Download the files required by the GPU The address is here: https://github.com/simplechain-org/gpuminer/releases（Be sure to download the latest version, the latest version is more efficient!最新版本是1.0.4） Decompress the modified file Download the compressed file and decompress it into a folder. Click in, find the file start.bat, and edit it with Notepad: -gpuplatform 1 Select Card A for mining; -gpuplatform 2 choose N card for mining; -gpuplatform 3 select hybrid multi-card mining. After modification, save it and turn it off. Double-click start.bat to link the mine pool and take a screenshot. After accessing the mine pool, you can log on to your mine pool account on the mine pool official website to view your income. SimpleNode（V1.0.0 version）mining pool mining SimpleNode download address：https://www.simplechain.com/，select the corresponding version to install according to your system, and start the application after the installation is successful. Specific mining steps: 一. Start SimpleNode, click the \"start mining\" button in the upper right corner, and the mining method pop-up window appears 二. Mining method selection: Mining method: Select \"mining pool mining\" in the popup window of mining method \"; Miner name: if you have not registered a Simpool account, you need to click the \"Click register\" button on the right side of the miner name to go to the Simpool registration page. After the registration is successful, return to the previous SimpleNode mining page; if you have registered a Simpool account, enter the miner name directly in the miner name editing box (Miner name does not contain Chinese) Graphics card type: select the type of graphics card, according to your computer's graphics card to choose (wrong choice, mining has no computing power) Special attention: When you register an account or add an account in Simpool, the account name must not be in Chinese. Miner name, the best format is the account name. xxx (account name is the account name in the Simpool) or directly the account name It is very important which account the miner belongs to, and the income is distributed according to the payment address under the corresponding account name. 三. Click the OK button to mine. You can click view revenue in the upper right corner to view your revenue "},"35_SimpleNode_x1/":{"url":"35_SimpleNode_x1/","title":"SimpleNode x1 Mining","keywords":"","body":"当拿到矿机之后，需要完成以下三步，就可以让矿机运转起来，挖出收益！ 准备SimpleNode软件 安装矿机驱动（Windows系统需要安装，MacOS和Linux无需安装） 加入官方矿池Simpool,开始挖矿！ 准备SimpleNode软件 到SimpleChain官网（www.simplechain.com），找到SimpleNode，根据您的电脑系统下载相应版本的安装程序 打开SimpleNode安装程序，根据提示完成安装 完成安装后，运行SimpleNode 数据同步完成后，请根据提示新建账户或者导入已有账户。创建账户之后请做好备份，保证您的资金安全！ 安装矿机驱动 Windows系统需要安装，MacOS和Linux无需安装 创建好账户后，在SimpleNode软件中选择“矿机挖矿”后面的“Solo挖矿”或者“矿池挖矿”，弹出提示框，点击 “矿机驱动”蓝色字样，自动下载矿机驱动安装包。 矿机驱动安装包为压缩文件，请解压文件。解压文件后点击”stmicroel_virtual_131_64”应用程序开始安装矿机驱动。 根据安装向导提示，完成矿机驱动的安装。 开始挖矿！ 驱动安装完成后，插入矿机，重新到SimpleNode软件中选择“矿机挖矿”后面的“Solo挖矿”或者“矿池挖矿”，即可开始矿机挖矿、盆满钵满之旅！ 推荐使用“矿池挖矿”方式，加入官方矿池Simpool，收益更多！选择这种方式需要到官方矿池Simpool注册账户。 点击“矿机挖矿“后面的”矿池挖矿“，点击蓝色字样”点击注册“进入官方矿池Simpool注册页面 根据提示完成Simpool账号注册 注册成功后，在左侧导航栏找到“账户管理”，点击进入 点击右上角的“新增挖矿账户”；需要您输入“账户名称”和“SIPC支付地址” 账户名称：支持英文大小写字母及数字（不支持汉字哦！） SIPC支付地址：该地址即为挖矿收益的接收地址，请填写自己的SIPC钱包账户地址 您的钱包账户地址，可以在SimpleNode里面查看；如果您有在使用官方推出的Chainbox钱包和sipc.vip数字资源平台，也可以填入其中您的地址（注意：请正确填入您本人的、支持SIPC的地址，挖矿收益将会打到该地址！） 在Simpool中的操作完成后，回到SimpleNode软件，重新点击“矿机挖矿”后面的“矿池挖矿”，填入矿工名（矿工名即为刚刚在Simpool新增挖矿账户时填写的“账户名称”），点击确认后，点击确认后，挖矿就开始了（矿机的蓝色灯呈闪烁状态）！ "},"36_SIPC.html":{"url":"36_SIPC.html","title":"SIPC.VIP","keywords":"","body":"After getting the mining machine, you need to complete the following three steps to make the mining machine run and dig out the benefits! Prepare SimpleNode software Install the miner driver (Windows system needs to be installed, MacOS and Linux do not need to be installed) Join the official Mine pool Simpool,start mining! Prepare SimpleNode software Go to the official website of SimpleChain (www.simplechain.com), find SimpleNode, and download the corresponding version of the installer according to your computer system. Open SimpleNode installer and follow the prompts to complete the installation. After the installation, run SimpleNode After data synchronization is complete, follow the prompts to create an account or import an existing account. After creating an account, please make a backup to ensure the security of your funds! Install mining machine driver Windows system needs to be installed, MacOS and Linux do not need to be installed After creating the account, select \"Solo mining\" or \"mining pool mining\" after \"mining machine mining\" in SimpleNode software, and a prompt box will pop up. Click the blue word \"mining machine driver, automatically download the mining machine driver installation package. The miner driver installation package is a compressed file, please decompress the file. Decompress the file and click the \"stmicroel_virtual_131_64\" application to start installing the miner driver. Complete the installation of the driver of the mining machine according to the instructions of the installation wizard. Start Mining! After the installation of the driver is completed, insert the mining machine, and choose \"Solo mining\" or \"mining pool mining\" after \"mining machine mining\" in SimpleNode software again, then you can start the mining machine mining and a journey full of money! We recommend that you use the \"mining pool\" method to add the official mining pool Simpool，more benefits! To select this method, you need to register an account in the official mine pool Simpool. Click \"mining pool mining\" behind \"mining machine mining\", click \"blue\", click \"register\" to enter the registration page of the official mining pool Simpool Complete the Simpool account registration as prompted After the registration is successful, find \"account management\" in the left-side navigation pane and click to enter Click \"Add mining account\" in the upper right corner; You need to enter \"account name\" and \"SIPC payment address\" Account name: English uppercase letters and numbers are supported (Chinese characters are not supported!) SIPC payment address: This address is the receiving address of mining revenue. Please fill in your SIPC Wallet account address. Your Wallet account address can be viewed in SimpleNode; If you are using the official Chainbox wallet and sipc.vip digital resource platform, you can also fill in your address (note: Please fill in your own address that supports SIPC correctly, and the mining revenue will be transferred to this address!) After completing the operation in Simpool, return to SimpleNode software and click \"mining pool mining\" after \"mining machine mining\" again \", fill in the miner name (the miner name is the\" account name \"you just filled in when adding a mining account in Simpool), click OK, click OK, mining begins (the blue light of the mining machine is flashing)! "},"37_wallet/":{"url":"37_wallet/","title":"Sipc","keywords":"","body":" Open SimplechainWebsite,and then drop down to find the SimpleNode module, as shown in the following figure: Currently, there are three versions of the full-node wallet:windows,Mac OS, Linux。Download the corresponding version according to your computer (server) system, and follow the installation steps after downloading. The following is an example of Apple Computer: download Mac OS After unzipping the file, you can see the logo of the wallet. Then click open, as shown in the following figure: After opening the wallet, you will see the prompt on the wallet page:正在链接节点，as shown below: After connecting the node, we can see the desktop wallet prompt 正在同步区块数据。Click 跳过，you can directly enter the wallet. As shown below: After entering the wallet, if you have already used the wallet, you can choose to import the account, if this is the first time you use the wallet. You need to clickCreate Account，as shown below: If Select import account，there are three ways to import wallet, which arekeystore文件导入, keystore明文导入，私钥导入。You can import according to your own private key. If you use SimpleNode for the first time, you must create an account. Just set your own wallet 密码以及确认密码，the wallet is successfully created after confirmation. After successful creation, we can see the Wallet account address to prevent the wallet from being lost due to forgetting the password. So should 立即备份.As shown below： What I click here is 备份私钥，you can also choose to back up the keystore file. Then you can see the private key information of our backup. Then click open SimpleNode, then enter the wallet. After entering the wallet, you can see the total number of sipcs, the current synchronization block height, and the wallet address. Click the collection code to receive the SIPC, as shown in the following figure: Of course, it can also be used for transfer, click transaction on the transfer page, enter the corresponding recipient's address and transfer the number of SIPC. And adjust the Gas fee, then transfer the money. As shown below: "},"38_ChainBox/":{"url":"38_ChainBox/","title":"ChainBox","keywords":"","body":"Download ChainBox wallet Apple Android installation address: https://www.simplechain.com/download Or scan the QR code below to download. After the IOS installation is complete, please: 打开设置———通用———设备管理———Broadway International Sp . z.o.o———信任应用———回到桌面打开钱包APP———创建注册。 Create a registered wallet First enter the wallet name (both in Chinese and English), then enter the wallet password (at least 8 digits, including numbers and letters), then Gou Xuan the protocol, and finally click create wallet, the wallet is created. Wallet created successfully Backup wallet: write down the auxiliary words. Next, assist to verify whether the auxiliary words are correct or not (the auxiliary words can only be screenshots and cannot be copied). Enter the auxiliary words in sequence and confirm. --- Create successfully and jump to the wallet page If you want to enter the wallet page quickly -- Optional, jump to the wallet page directly without backup in the upper right corner --- back up the wallet in the wallet settings next time (it is strongly recommended to back up the wallet first) Import wallet (function key in upper left corner to enter) If you have ever downloaded a ChainBox wallet and created a wallet, you can choose to import your wallet. You can import it in any way, such as mnemonic words, official wallet (keystore), private key, and then reset the password. Wallet list (function key in upper left corner to enter) You can see at a glance the wallet assets and wallet addresses of multiple wallets that you have created or imported. You can also select a wallet you imported or created in the wallet overview. Wallet settings (function key in upper left corner to enter) You can change the wallet name and password; If you need to export the wallet, you can export the private key, keystore, and backup memo in the wallet settings. If you have extra wallet, you can also delete it from the bottom of the wallet settings if you want to delete it. Transfer/Collection (function key in the upper left corner to enter) Click SIPC in the wallet to enter the details page: transfer/Collection Click transfer: ordinary transfer/offline transfer (additional remarks the Data in the advanced transfer options is transfer notes, which are generally not written because of the significant increase in the gas fee of the note information) Ordinary transfer (hot wallet function): Fill in the address, quantity and miner fee of the other party. Enter the password next. Offline transfer (cold wallet function): Fill in transfer address, account Collection Address, transfer quantity and miner fee. General purpose: Contact/Message Center/check for updates (function key in the upper left corner to enter) Contact person: add common transfer address to facilitate the second transfer. Message Center: you can see the summary of transfer and collection information. Check for updates: Check for updates to the latest wallet version "},"39_blockBrowser/":{"url":"39_blockBrowser/","title":"Explore","keywords":"","body":"Visit the browser: Browser Address Open the Blockchain browser and switch to the Main NetWork or Test NetWork as needed. As shown below: Block search Information about all blocks-from Genesis blocks to all current blocks-can be found on this page, including the block height, its previous block, and the corresponding byte size. Transaction search You can search for transaction records on this page. You can find the information with the sending transaction address and receiving address, the number of sipcs transmitted, the block height of the transaction record, the corresponding hash and the production time. You can also use the search bar to find specific transactions for hashes. View uncle block On this page, you can view the height of each block, the block height corresponding to its uncle block, the block time, and the rewards of packaged miners and miners. As shown below: Verification contract If you want to verify the contract, enter the contract address to be verified, and select the contract compiler type and compiler version to verify the contract. As shown below: List of verified contracts Click the verify contract list to view the information of 20 verified contracts. The information shows the contract address, contract name, compiler, version, account balance, verification time, etc! There are three verification methods for contract verification: Single file verification method Multi-file authentication method Json file validation method Single file verification pragma solidity ^0.5.12; contract PayALL{ event PayLog(address name,uint reward); event PayLog2(address name); constructor() public payable{ } function() external payable{ emit PayLog(msg.sender, msg.value); } function setMethd() public payable { emit PayLog2(msg.sender); } } Paste source code: After the verification is passed： Multi-file verification Because in the contract writing process, the dependency of the file can refer to another file. // test1.sol文件 pragma solidity ^0.5.17; contract Hello { uint value; function hello() public pure returns(string memory){ return \"hello world_1\"; } function set(uint x) public { value = x; } } // test2.sol文件 pragma solidity ^0.5.17; import {Hello} from \"./test1.sol\" ; contract Test2 is Hello { function test() public pure returns(string memory){ return Hello.hello(); } } Execution result: This type of authentication is used for multi-file authentication. The verification method is as follows to obtain the deployed contract address: 0x6e1ace6e6cf09a4ab096f272cfc029c0a1d883ac Optimizationit refers to the number of contract compilation times. The number of optimized times is selected for contract deployment. Therefore, the corresponding number of times must be selected for verification. By default, no optimization is performed. Constructor Arguments ABI-encoded indicates whether the contract has construction parameters. The construction parameters are generated during deployment. You do not need to fill in the construction parameters for verification. Contract Library Address When it comes to library contracts, ordinary contracts are not filled in. Details of this type of verification will be added later. View verification successful Multi-file contract source code after current verification The source code is displayed in json format, including two file source codes. Json file validation: The Json file verification method is relatively copied. You need to know the compilation parameters of solidity. solidity compiles the json file passed by the user, provided that the json file meets the compilation requirements. Json file： { \"language\": \"Solidity\", \"sources\": { \"myFile.sol\": { \"content\": \"pragma solidity ^0.5.12;contract Multiply7 { event Print(uint); event CjLog(address, uint); uint public a ; uint public b ; constructor (uint _a, uint _b) public { a = _a; b = _b; } function multiply(uint input1) public view returns (uint) { return input1 * 6 + a + b; } function multiplyplus(uint input1, uint input2) public returns (uint) { emit Print(input1 * 6 * input2); emit CjLog(msg.sender, a+b); return input1 * 6 * input2 + a + b; }}\" } }, \"settings\": { \"metadata\": { \"useLiteralContent\": true }, \"outputSelection\": { \"*\": { \"*\": [ \"*\" ], \"\": [ \"ast\" ] } } } } Library contract verification First of all, understand what is a library contract Browser support library the contract verification of the library,Library during the deployment process, contracts are deployed in sequence and nested. All contracts are deployed with multiple contracts (including library libraries inside the contracts, which are deployed together) and multiple hash records are generated. Contract source code: /** *Submitted for verification at Etherscan.io on 2020-02-27 */ pragma solidity ^0.6.0; library SetHFG { // 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。 struct Data { mapping(uint => bool) flags; } // 注意第一个参数是“storage reference”类型，因此在调用中参数传递的只是它的存储地址而不是内容。 // 这是库函数的一个特性。如果该函数可以被视为对象的方法，则习惯称第一个参数为 `self` 。 function insert(Data storage self, uint value) public returns (bool) { if (self.flags[value]) return false; // 已经存在 self.flags[value] = true; Acc.hi(); return true; } the following is the deployment record: CHU as the main contract: 0x1c622ed2035acc8514259788caafb3cf69d9bbe3 The contract address of the Library is: Bcc：0x0da8bd0dd96f78ac6e155b2d5e9fb6d15ca89fad Fcc：0x7b05897e605a3878d3511069924d750ef3954da5 Acc：0x13a6cb372333394caa8ea0e5876a4a52167a95ce SetHFG: 0x5386710eb4d02b41e7a253d3ebb00ca8795c930f Verification way and single-file same, as shown below: Verification passed "},"40_tradePlateform.html":{"url":"40_tradePlateform.html","title":"Exchange docking","keywords":"","body":"Build SimpleChain nodes docker build Obtain an image: docker pull simplechain/sipe:latest Enable RPC docker run -it -p 8545:8545 -p 30312:30312 simplechain/sipe --rpc --rpcaddr \"0.0.0.0\" You can run the following command to check whether your node is successfully started: curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":68}' Source code construction 前期准备:Go 语言环境(1.10 或以上版本)、C 语言编译器 1.Download SimpleChain You can clone a project locally through git or download directly from the https://github.com/simplechain-org/go- simplechain page. git clone https://github.com/simplechain-org/go-simplechain.git 2.Install sipe 1.Enter the go-simplechain root directory. cd go-simplechain 2.Use the make tool to install sipe. make sipe >>> /usr/local/go/bin/go install -ldflags -X main.gitCommit=9d73f67e1dc5587a95f52c13fee93be6434b42ac -s -v ./cmd/sipe github.com/simplechain-org/go-simplechain/core ... github.com/simplechain-org/go-simplechain/cmd/sipe Done building. Run \"/Users/yuanchao/go/src/github.com/simplechain-org/go-simplechain/build/bin/sipe\" to launch sipe. When the above output appears on the terminal, the make execution is successful. In this case, the sipe executable file is generated in the go-simplechain/build/bin directory. You can move it to any directory or add it to environment variables to facilitate the running of sipe programs. Start sipe 1.Create a folder for storing node data, if not mkdir chaindata 2.Start the sipe Master network node Enable the RPC service and specify the RPC listening address as 127.0.0.1, Port 8545 . The node data storage directory is chaindata ./sipe --rpc --rpcaddr 127.0.0.1 --rpcport 8545 --datadir chaindata When an output similar to the following appears, the startup is successful and the SimpleChain master Network block is synchronized. INFO [06-19|09:35:01.481] Maximum peer count ETH=25 LES=0 total=25 INFO [06-19|09:35:01.492] Starting peer-to-peer node instance=Sipe/v1.0.2-stable-0cbf2a41/darwin-amd64/go1.12.1 ... INFO [06-19|09:35:33.700] Block synchronisation started INFO [06-19|09:35:36.756] Imported new block headers count=192\\ elapsed=22.273ms number=192 hash=bb758a...bea1b6 ignored=0 Community node rpc address and port number: 47.110.48.207:8545 Test: //Request curl -X POST 47.110.48.207:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":68}' //Response { \"jsonrpc\": \"2.0\", \"id\": 68, \"result\": \"Sipe/v1.1.0-stable-0800d402/linux-amd64/go1.14.1\" } Connect to the SimpleChain node Create a sipc.js file and write the following code: const config = require('../../config') //节点服务器的配置信息 const Web3 = require('web3') module.exports = new Web3(config.uri) Create SimpleChain wallet service Now we are entering the development phase of the core features of Simplechain wallet service. Create a new Simplechain account The exchange and payment gateway need to generate a new address for the customer so that the user can recharge the service or pay for the product. Generate an unused sipc Address is the basic requirement of any digital asset service, so let's take a look at the specific implementation. First, create a command.js where we subscribe to messages in the queue. It mainly includes the following steps: Connect to the command topic and listen to the new create_account command When a new create_account command is received, a new key pair is created and stored in the password library. The account_created topic that generates the account_created message and sends it to the queue. The code is as follows: const web3 = require(\"./ethereum\") /** * Create a new ethereum address and return the address */ async function create_account(meta = {}) { // generate the address const account = await web3.eth.accounts.create() // disable checksum when storing the address const address = account.address.toLowerCase() // save the public address in Redis without any transactions received yet await redis.setAsync(`eth:address:public:${address}`, JSON.stringify({})) // Store the private key in a vault. // For demo purposes we use the same Redis instance, but this should be changed in production await redis.setAsync(`eth:address:private:${address}`, account.privateKey) return Object.assign({}, meta, {address: account.address}) } module.exports.listen_to_commands = listen_to_commands Handle new transactions We haven't finished our wallet yet. When the address we created receives the user's recharge, it should be notified. To this end, the web3 client of Simplechain provides the newBlockHeaders subscription mechanism. In addition, if our service goes down accidentally, the service will miss the blocks produced during the downtime. Therefore, we also need to check whether the wallet has been synchronized to the latest blocks on the network. Create sync_blocks.js file, write the following code: const web3 = require('./ethereum') /** * Sync blocks and start listening for new blocks * @param {Number} current_block_number - The last block processed * @param {Object} opts - A list of options with callbacks for events */ async function sync_blocks(current_block_number, opts) { // first sync the wallet to the latest block let latest_block_number = await web3.eth.getBlockNumber() let synced_block_number = await sync_to_block(current_block_number, latest_block_number, opts) // subscribe to new blocks web3.eth.subscribe('newBlockHeaders', (error, result) => error && console.log(error)) .on(\"data\", async function(blockHeader) { return await process_block(blockHeader.number, opts) }) return synced_block_number } // Load all data about the given block and call the callbacks if defined async function process_block(block_hash_or_id, opts) { // load block information by id or hash const block = await web3.eth.getBlock(block_hash_or_id, true) // call the onTransactions callback if defined opts.onTransactions ? opts.onTransactions(block.transactions) : null; // call the onBlock callback if defined opts.onBlock ? opts.onBlock(block_hash_or_id) : null; return block } // Traverse all unprocessed blocks between the current index and the lastest block number async function sync_to_block(index, latest, opts) { if (index >= latest) { return index; } await process_block(index + 1, opts) return await sync_to_block(index + 1, latest, opts) } module.exports = sync_blocks In the preceding code, we synchronize the latest block processed by the wallet service to the current latest block in the blockchain. Once we synchronize to the latest block, we begin to subscribe to the new Block event. For each block, we execute the following callback function to process the block header and the transaction list in the block: onTransactions onBlock Generally, the following processing steps are included: 监听新区块，获取区块中的全部交易 过滤掉与钱包地址无关的交易 将每个相关的交易都发往队列 将地址上的资金归集到安全的存储 更新已处理的区块编号 The final code is as follows: const web3 = require(\"web3\") //调用web3 const redis = require('./redis') //调用redis数据库，将区块数据获取下来存入redis数据库中 const queue = require('./queue') //调用消息队列 const sync_blocks = require('./sync_blocks') //同步区块 /** * Start syncing blocks and listen for new transactions on the blockchain */ async function start_syncing_blocks() { // start from the last block number processed or 0 (you can use the current block before deploying for the first time) let last_block_number = await redis.getAsync('eth:last-block') last_block_number = last_block_number || 0 // start syncing blocks sync_blocks(last_block_number, { // for every new block update the latest block value in redis onBlock: update_block_head, // for new transactions check each transaction and see if it's new onTransactions: async (transactions) => { for (let i in transactions) { await process_transaction(transactions[i]) } } }) } // save the lastest block on redis async function update_block_head(head) { return await redis.setAsync('eth:last-block', head) } // process a new transaction async function process_transaction(transaction) { const address = transaction.to.toLowerCase() const amount_in_ether = web3.utils.fromWei(transaction.value) // check if the receiving address has been generated by our wallet const watched_address = await redis.existsAsync(`eth:address:public:${address}`) if (watched_address !== 1) { return false } // then check if it's a new transaction that should be taken into account const transaction_exists = await redis.existsAsync(`eth:address:public:${address}`) if (transaction_exists === 1) { return false } // update the list of transactions for that address const data = await redis.getAsync(`eth:address:public:${address}`) let addr_data = JSON.parse(data) addr_data[transaction.hash] = { value: amount_in_ether } await redis.setAsync(`eth:address:public:${address}`, JSON.stringify(addr_data)) await redis.setAsync(`eth:transaction:${transaction.hash}`, transaction) // move funds to the cold wallet address // const cold_txid = await move_to_cold_storage(address, amount_in_ether) // send notification to the kafka server await queue_producer.send('transaction', [{ txid: transaction.hash, value: amount_in_ether, to: transaction.to, from: transaction.from, //cold_txid: cold_txid, }]) return true } module.exports = start_syncing_blocks Summary We have completed the design and implementation of Simplechain wallet service of the exchange. This service can also be improved from the following aspects: Add error handling Add command type Transaction Signature and transaction broadcast Deployment Contract "},"41_commityProduct.html":{"url":"41_commityProduct.html","title":"Community Project","keywords":"","body":"Simplechain, as an open-source community project, has long been supported by many community developers. The following are some excellent projects contributed by community development: SDK Java-SDK Python-SDK JavaScript-SDK Google plug-in wallet Plug-In wallet download and usage tutorial "},"42_commityActity.html":{"url":"42_commityActity.html","title":"Community Activity","keywords":"","body":"Hello! Welcome to Simplechain technology community, thank you for your support to Simplechain! Our community activities and incentive plans will be updated quarterly, please continue to pay attention. Participate in SimpleChain open source co-construction Welcome to join the Simplechain open source community. You can join the community in the following ways: Participate in code or document contribution： Fork，fork the project to your Github account; Clone，clone the project to the local development environment; Hack，hacking code or documents (create a new branch to complete the update); Push，push the committed branch to the remote Github account; PR，create a new pull request to complete the contribution; 文档， • write a document library, organize basic tools to use related documents; Participate in technical community sermon 文稿征集: Original articles related to Simplechain and successfully published the above in the Channel. 技术短视频: Clip short videos about Simplechain and publish them on relevant platforms. 社区节点搭建:Create a Simplechain node and expose the IP address and port number to the public for community developers to use directly. 活跃技术社区:Guide topics in the technology community and activate the atmosphere of the technology community (such as Weibo Super Talk) Community project contribution There are mainly two forms of contribution to participating in community projects; Developers can choose their own development based on Simplechain. There is no need to communicate with the official, and there is no incentive for this. It is purely a personal behavior of community developers and has nothing to do with the Simplechain technology community. Developers think that a certain basic tool is necessary for the development of Simplechain, but it is not yet available. It can be fed back to the person in charge of the technical community, and the technical personnel think it is necessary after evaluation. Then it can be developed, and developers will also get certain token incentives. Community Task BUG Hunter Find the bug of Simplechain and submit it on github. After it is evaluated and confirmed by the core team, different rewards will be given according to the severity of the bug. Landing expert Enterprise landing Responsible for the cooperation between SimpleChain and enterprises, mainly responsible for the promotion and explanation of SimpleChain technology and implementation cases. Cooperation with enterprises and technical support work in the later cooperation process. After being evaluated by Simplechain foundation to reach the standard, it will receive rich bonus. Government Cooperation Connect Simplechain to cooperate with government projects and be responsible for communicating with the government. Provide SimpleChain-based blockchain training for government personnel and achieve government cooperation. After being evaluated by Simplechain foundation to reach the standard, it will receive rich bonus. Community KOL The SimpleChain technology community has been recruiting KOL for a long time. Developers are welcome to actively participate in the technology ecosystem of SimpleChian. Certain incentives will be given every quarter according to personal performance. The main work of community KOL is as follows: Organization developers, developed based on SimpleChain, and provided technical support. And the follow-up and promotion of the later project. Build a developer community, share technologies related to SimpleChain, and activate the community atmosphere. And developer relationship maintenance. Publish technical articles and technical videos. Become a content creator and output. "},"43_commityEnters/":{"url":"43_commityEnters/","title":"Community Entrance","keywords":"","body":"SimpleChain is a community-led and open-source public underlying blockchain platform. It is created by an open-source working group established by SimpleChain Foundation and members of the technology community. Simplechain resource list Github home page Technical documentation Deep Analysis Series Contribution code Feedback problem Application Case Collection Join the Simlechain community "},"44_case.html":{"url":"44_case.html","title":"Landing case","keywords":"","body":"SimpleChain（SIPC）is a public chain with the design concept of \"simple blockchain, mutual promotion and win-win. As a revolutionary blockchain application infrastructure design, blockchain supports the underlying consensus-POW algorithm of the main chain. Sub-chains support multiple consensus and performance requirements to ensure stable and safe operation, so as to meet the rich business application scenarios. The systematic tool module provides a simple configuration, deployment, and development environment for various application scenarios to implement simple blockchain. SimpleChain is exploring a broader space for blockchain applications and has made great achievements in multiple fields such as judicial registration, cultural copyright, game entertainment, and scenario payment. Since the launch of Simplechain's main network, community developers have made joint efforts. More and more applications are developed based on Simplechain. Here are some detailed implementation cases. Judicial deposit: As the first sub-chain of judicial field based on SimpleChain underlying technology, the exclusive technical support security network of \"The first case of Block Chain certificate storage in China\" is the security chain, in addition to reaching cooperation with several law firms and judicial authentication institutions, it has also established close contact with the three major domestic internet courts and the first Internet notary office in China, and its 5.0 version of the evaluation report of China Standard Institute will be released soon; Cultural copyright： In addition to the sub-chain security network (security chain) providing \"block chain +\" certificate storage services for domestic cultural media companies such as rights protection Knights, haojubang, and Babbitt, it has also reached deep cooperation with one-stop novel reading and copyright investment platform fun; Game Entertainment GWC, an overseas game platform, has established a system based on credit rating and quality rating of the game industry on SimpleChain. Participants can score the game and its production team to obtain corresponding game operation dividends; Philanthropy: The SimpleChain team and the entrepreneurship team of Zhejiang University have jointly created the world's first blockchain intelligent coffee machine, which has been successively put into shared office space, independent start-up companies and other places. Its system supports SIPC payment, without centralized payment tools such as WeChat and Alipay, you can enjoy the most convenient blockchain payment method. Philanthropy: SimplecChain, following the donation tracing platform of the digital Qin science and technology security network, donated more than ten thousand pieces of protective clothing to Wuhan Jiuzhou tongrenshou Hall nursing home, the Second Affiliated Hospital of Zhejiang University Medical College and other institutions to support front-line medical staff. Through the blockchain technology, the whole process of the circulation process and time node of donated goods and materials is recorded, recorded and tracked, providing the whole process of blockchain solutions for charitable donations in the epidemic situation. At the same time, it also reached a strategic cooperation agreement with Bithelp's global digital public welfare platform and jointly launched public welfare fund-raising activities. Social E-Commerce： SimpleChain helps boutique social e-commerce platforms build the \"blockchain + social e-commerce\" model all over the world, which connects the ecological relationships among platform merchants, e-commerce platforms, and community users, and changes the previous platform centralization model, the three-party interest ecology will be re-integrated. They will participate in the whole interest chain together and exist as an equal relationship. Asset encryption: SimpleChain cooperates with Keystore to promote the development of blockchain technology and applications. The two parties cooperate in the fields of asset trusteeship, node services, and market expansion, and jointly expand the enterprise-level encrypted asset service market. "},"45_faq.html":{"url":"45_faq.html","title":"FAQ","keywords":"","body":"Mine pool related issues 1.What should I fill in the receiving address? We recommend that you fill in the SIPC wallet address, because you have the private key of the currency, which is more secure. 2.What coins can SimPool dig ? Currently, SIPC mining is supported. 3. How to mine ？ The general steps are: register an account-create a mining account-configure a computer-view revenue. For specific steps, see SIPC mining tutorial. 4. How high is my computing power? The actual computing power after connecting the mining pool for mining is not necessarily equal to the nominal computing power, and the specific computing power displayed by the mining pool is the standard. 5. Why is my income decreasing? First confirm the following points: (1) whether the mining equipment operates normally; (2) whether the mining configuration is correct; (3) whether the network connection is normal; (4) whether the difficulty of mining changes (if the difficulty changes, the profit will fluctuate); And with the increase of mining equipment and the increase of the whole network computing power, the difficulty of mining will increase, the mining revenue of a single device will gradually decrease. 5. When will the daily income be settled? The hourly settlement is conducted once every hour, and then the coin is made at 12 a.m. the specific calculation method of personal income (per hour) is as follows: Mining pool revenue = average computing power of the mining pool/computing power of the whole network * The number of SIPC output per day of the whole network + super-fast revenue; Personal income = total personal acceptance/total network acceptance * mine pool income; 6. Why is the network unstable sometimes? Sometimes there will be technical adjustments, which are not stable, but generally can be solved in 30 to 2 hours. There may also be attacks, attacks against bitcoin networks, there are also attacks against mine pool servers. If it is a personal network problem, you need personal debugging to solve it or seek help from the network operator. 7. What if the computing power drops? Please check the following questions first: (1) whether the mining equipment operates normally; (2) whether the mining configuration is correct; (3) whether the network connection is normal; After the above troubleshooting, the computational power still decreases. Please find customer service in the Simpool group to solve the problem. 8. What is workload? What is the network difficulty? The workload refers to the contribution of the miner to the computing power for digging new blocks. The network difficulty refers to the computing difficulty of the whole network explosion block, which is dynamically adjusted according to the total computing power of all miners. 9. What are the settlement methods for the mine pool? At present, the mining pool adopts the PPLNS settlement method (full name: Pay Per Last N Shares), which means \"Pay the income according to the past N Shares\". This means that once all miners find a block, they will distribute the currency in the block according to the proportion of shares each person contributes. 10. Will the revenue be lost if the collection address is not set? If you do not fill in the receiving address, your revenue will be temporarily stored in the Simpool account. After you set the address, we will pay you the income after the address takes effect. 11. When using SimpleNode wallet to select mining pool for mining, how to set the parameters of advanced graphics card? Known video card tuning parameters: (1) NVIDIA GTX-750-Ti gpuplatform=2, memsize=1999, globalworksize=10240, localworksize=512, lookupgap=4 (2) AMD Ellesmere RX 570 gpuplatform=1, memsize=2048, globalworksize=8000, localworksize=64, lookupgap=2 (3) GeForce GT 1030 gpuplatform=2, memsize=2048, globalworksize=4096, localworksize=64, lookupgap=4 gpuplatform: AMD graphics card fill in 1, NVIDIA graphics card fill in 2 memsize: Filter graphics cards that are not less than the video memory capacity (default 2048MB), NVIDIA GTX-750-Ti video memory is 1999MB globalworksize: The parallel computing item is generally a multiple of 1024, and the maximum can not be greater than the Max work item sizes of the graphics card. However, when adjusting, AMD's RX570 setting 8000 has the highest efficiency. localworksize: The work item of each graphics card calculation unit is generally 64/128/256/512. globalworksize/localworksize cannot be greater than the Max work group size supported by the graphics card. lookupgap: This value is finally adjusted. The value range is 1/2/4/8. The default value is 2. Adjust the performance between video memory and video memory. When it is equal to 1, the memory used is the most. Based on this, 1/2 is used when it is equal to 2, and 1/8 is used when it is equal to 8. SimpleNode X1 1.Can an account be associated with several more mining machines？ Yes, as long as the power supply of the mining machine is guaranteed to be sufficient, multiple mining machines can be connected in series on one computer. If the Solo mining method is used, the profit will be directly transferred to the mining account address; If you use the mining pool mining method, the profit is transferred to the account address associated with the miner. 2.How to check the status of each mining machine after connecting multiple mining machines? If multiple mining machines are mining at the same time, click the small arrow behind \"stop mining\" on SimpleNode software to view the status of each mining machine. 3.How many mining machines can the network and computer at home drag at most? The network bandwidth has little impact on the mining machine, as long as the SimpleNode can be connected to the Simpool mining pool; As long as the power supply of the mining machine is guaranteed to be sufficient, each computer can be connected with multiple mining machines, generally, it can support about 2-3 sets at most; Additional external power supply is required. "},"46_supportOnline/":{"url":"46_supportOnline/","title":"Online technical support","keywords":"","body":"Developer Telegram Community: Technical support: "}}