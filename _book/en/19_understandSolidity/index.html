
<!DOCTYPE HTML>
<html lang="en" >
    <head>
        <meta charset="UTF-8">
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <title>understand Solidity Â· Simplechain Documentation</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="GitBook 3.2.3">
        
        
        
    
    <link rel="stylesheet" href="../../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-search-pro/search.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-language-picker/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-anchors/plugin.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../20_contractPattern.html" />
    
    
    <link rel="prev" href="../18_contract/" />
    

    </head>
    <body>
        
<div class="book">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="Type to search" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Quick Start</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../1_quickStart.html">
            
                <a href="../1_quickStart.html">
            
                    
                    Quick Start
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="../2_BuildNode/">
            
                <a href="../2_BuildNode/">
            
                    
                    Build Node
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Sipc Coin Negotiate</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../47_techniqueLanguage.html">
            
                <a href="../47_techniqueLanguage.html">
            
                    
                    Technical Manual
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="../3_sipcCoin.html">
            
                <a href="../3_sipcCoin.html">
            
                    
                    Sipc Coin
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="../4_PublishCoin/">
            
                <a href="../4_PublishCoin/">
            
                    
                    Publish Coin
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Basic Data Struct</li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="../5_concoct.html">
            
                <a href="../5_concoct.html">
            
                    
                    Deploy
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2" data-path="../6_genesis/">
            
                <a href="../6_genesis/">
            
                    
                    Genesis Block
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.3" data-path="../7_account.html">
            
                <a href="../7_account.html">
            
                    
                    Account
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.4" data-path="../8_transaction/">
            
                <a href="../8_transaction/">
            
                    
                    Transaction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.5" data-path="../9_block/">
            
                <a href="../9_block/">
            
                    
                    Block
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.6" data-path="../10_transactionReceipt/">
            
                <a href="../10_transactionReceipt/">
            
                    
                    Transaction Receipt
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Construct</li>
        
        
    
        <li class="chapter " data-level="5.1" data-path="../11_constructDesign/">
            
                <a href="../11_constructDesign/">
            
                    
                    Structure Design
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.2" data-path="../12_structAndStore/">
            
                <a href="../12_structAndStore/">
            
                    
                    Data Struct and 
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="5.3" data-path="../50_togetherStep.html">
            
                <a href="../50_togetherStep.html">
            
                    
                    Data Synchronize
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Underlying Core Technology</li>
        
        
    
        <li class="chapter " data-level="6.1" data-path="../13_p2pNetwork.html">
            
                <a href="../13_p2pNetwork.html">
            
                    
                    p2p network
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.2" data-path="../14_consensus/">
            
                <a href="../14_consensus/">
            
                    
                    Consensus mechanism
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.3" data-path="../15_virtualMache/">
            
                <a href="../15_virtualMache/">
            
                    
                    virtual machine
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.4" data-path="../16_runMechanism/">
            
                <a href="../16_runMechanism/">
            
                    
                    Operating mechanism
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="6.5" data-path="../17_unusual.html">
            
                <a href="../17_unusual.html">
            
                    
                    Handle exceptions
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Smart contract</li>
        
        
    
        <li class="chapter " data-level="7.1" data-path="../18_contract/">
            
                <a href="../18_contract/">
            
                    
                    Smart contract
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="7.2" data-path="./">
            
                <a href="./">
            
                    
                    understand Solidity
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="7.3" data-path="../20_contractPattern.html">
            
                <a href="../20_contractPattern.html">
            
                    
                    Contract template
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Developer tools</li>
        
        
    
        <li class="chapter " data-level="8.1" data-path="../21_buildTest.html">
            
                <a href="../21_buildTest.html">
            
                    
                    Build Test network
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="8.2" data-path="../22_sipcApi.html">
            
                <a href="../22_sipcApi.html">
            
                    
                    Sip API
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="8.3" data-path="../23_crossChainApi.html">
            
                <a href="../23_crossChainApi.html">
            
                    
                    Cross-chain API
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="8.4" data-path="../24_chromeWallet/">
            
                <a href="../24_chromeWallet/">
            
                    
                    SimPlug
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="8.5" data-path="../25_sdk/">
            
                <a href="../25_sdk/">
            
                    
                    SDK
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Cross-chain</li>
        
        
    
        <li class="chapter " data-level="9.1" data-path="../48_crossChain/">
            
                <a href="../48_crossChain/">
            
                    
                    Cross-chain solution
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="9.2" data-path="../26_smallChain.html">
            
                <a href="../26_smallChain.html">
            
                    
                    Subchain template
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="9.3" data-path="../49_crossChainOrder/">
            
                <a href="../49_crossChainOrder/">
            
                    
                    Cross-chain process
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Dapp develop</li>
        
        
    
        <li class="chapter " data-level="10.1" data-path="../27_dappFlow/">
            
                <a href="../27_dappFlow/">
            
                    
                    Dapp process carding
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="10.2" data-path="../28_editor.html">
            
                <a href="../28_editor.html">
            
                    
                    translater
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="10.3" data-path="../29_writeContract/">
            
                <a href="../29_writeContract/">
            
                    
                    Write contract
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="10.4" data-path="../30_frontRealize/">
            
                <a href="../30_frontRealize/">
            
                    
                    Front-end development
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Mining</li>
        
        
    
        <li class="chapter " data-level="11.1" data-path="../31_mining.html">
            
                <a href="../31_mining.html">
            
                    
                    sipc mining
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="11.2" data-path="../32_miningPool/">
            
                <a href="../32_miningPool/">
            
                    
                    MinePool access
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="11.3" data-path="../33_gpuMining/">
            
                <a href="../33_gpuMining/">
            
                    
                    GPU Mining
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="11.4" data-path="../34_SimPool/">
            
                <a href="../34_SimPool/">
            
                    
                    Simpool Mining
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="11.5" data-path="../35_SimpleNode_x1/">
            
                <a href="../35_SimpleNode_x1/">
            
                    
                    SimpleNode x1 Mining
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Client</li>
        
        
    
        <li class="chapter " data-level="12.1" data-path="../36_SIPC.html">
            
                <a href="../36_SIPC.html">
            
                    
                    SIPC.VIP
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="12.2" data-path="../37_wallet/">
            
                <a href="../37_wallet/">
            
                    
                    Sipc
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="12.3" data-path="../38_ChainBox/">
            
                <a href="../38_ChainBox/">
            
                    
                    ChainBox
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="12.4" data-path="../39_blockBrowser/">
            
                <a href="../39_blockBrowser/">
            
                    
                    Explore
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Ecology</li>
        
        
    
        <li class="chapter " data-level="13.1" data-path="../40_tradePlateform.html">
            
                <a href="../40_tradePlateform.html">
            
                    
                    Exchange docking
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="13.2" data-path="../41_commityProduct.html">
            
                <a href="../41_commityProduct.html">
            
                    
                    Community Project
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="13.3" data-path="../42_commityActity.html">
            
                <a href="../42_commityActity.html">
            
                    
                    Community Activity
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="13.4" data-path="../43_commityEnters/">
            
                <a href="../43_commityEnters/">
            
                    
                    Community Entrance
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Landing scheme</li>
        
        
    
        <li class="chapter " data-level="14.1" data-path="../44_case.html">
            
                <a href="../44_case.html">
            
                    
                    Landing case
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">Other</li>
        
        
    
        <li class="chapter " data-level="15.1" data-path="../45_faq.html">
            
                <a href="../45_faq.html">
            
                    
                    FAQ
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="15.2" data-path="../46_supportOnline/">
            
                <a href="../46_supportOnline/">
            
                    
                    Online technical support
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://www.gitbook.com" target="blank" class="gitbook-link">
            Published with GitBook
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >understand Solidity</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h2 id="solidity-source-file-structure"><a name="solidity-source-file-structure" class="plugin-anchor" href="#solidity-source-file-structure"><i class="fa fa-link" aria-hidden="true"></i></a>Solidity Source File structure</h2>
<p>The source file can contain any number of contract definitions, import instructions, and miscellaneous instructions.</p>
<h3 id="version-miscellaneous-note"><a name="version-miscellaneous-note" class="plugin-anchor" href="#version-miscellaneous-note"><i class="fa fa-link" aria-hidden="true"></i></a>Version miscellaneous note</h3>
<p>To avoid being compiled by compilers that may introduce incompatible changes in the future, the source file can (and should) be annotated by so-called version annotations. We try to make such changes as small as possible. In particular, we need to introduce changes in a way that syntax must be modified synchronously when modifying semantics. Of course, this is sometimes difficult to do. Therefore, it is always a good way to read through the change log for versions with major changes at least. The versions of these versions are always <code>0.x.0</code> Or <code>x.0.0</code> The form.</p>
<p>Version miscellaneous notes are used as follows::</p>
<pre><code class="lang-sh">pragma solidity ^0.4.0;
</code></pre>
<p>In this way, the source file does not allow compiler compilation earlier than Version <code>0.4.0</code> or higher than (including) <code>0.5.0</code> Compiler compilation of the version (the second condition is due to the use ^ Added). The consideration of this approach is that the compiler will not have major changes before version <code>0.5.0</code>, so it can ensure that the source code is always compiled as expected. In the preceding example, the specific version number of the compiler is not fixed, so the compiler patch version can also be used.</p>
<p>You can use more complex rules to specify the compiler version and the expression follows <a href="https://docs.npmjs.com/misc/semver" target="_blank">npm</a> version semantics.</p>
<blockquote>
<p> Pragma &#x662F; pragmatic information &#x7684;&#x7B80;&#x79F0;&#xFF0C;&#x5FAE;&#x8F6F; Visual C++ <a href="https://msdn.microsoft.com/zh-cn/library/d9x1s805.aspx" target="_blank">&#x6587;&#x6863;</a> &#x4E2D;&#x8BD1;&#x4E3A;&#x6742;&#x6CE8;&#x3002;Solidity &#x4E2D;&#x6CBF;&#x7528; C &#xFF0C;C++ &#x7B49;&#x4E2D;&#x7684;&#x7F16;&#x8BD1;&#x6307;&#x4EE4;&#x6982;&#x5FF5;&#xFF0C;&#x7528;&#x4E8E;&#x544A;&#x77E5;&#x7F16;&#x8BD1;&#x5668; <strong>&#x5982;&#x4F55;</strong> &#x7F16;&#x8BD1;&#x3002;  &#x2014;&#x2014;&#x8BD1;&#x8005;&#x6CE8;</p>
</blockquote>
<h3 id="import-other-source-files"><a name="import-other-source-files" class="plugin-anchor" href="#import-other-source-files"><i class="fa fa-link" aria-hidden="true"></i></a>Import other source files</h3>
<h4 id="grammar-and-semantics"><a name="grammar-and-semantics" class="plugin-anchor" href="#grammar-and-semantics"><i class="fa fa-link" aria-hidden="true"></i></a>Grammar and semantics</h4>
<p>Although Solidity does not know what &quot;default export&quot; is, the syntax of import statements supported by Solidity is very similar to JavaScript (starting from ES6).</p>
<blockquote>
<p>ES6 &#x5373; ECMAScript 6.0&#xFF0C;ES6&#x662F; JavaScript &#x8BED;&#x8A00;&#x7684;&#x4E0B;&#x4E00;&#x4EE3;&#x6807;&#x51C6;&#xFF0C;&#x5DF2;&#x7ECF;&#x5728; 2015 &#x5E74; 6 &#x6708;&#x6B63;&#x5F0F;&#x53D1;&#x5E03;&#x3002; &#x2014;&#x2014;&#x8BD1;&#x8005;&#x6CE8;</p>
</blockquote>
<p>At the global level, you can use import statements in the following format&#xFF1A;</p>
<pre><code class="lang-sh">  import <span class="hljs-string">&quot;filename&quot;</span>;
</code></pre>
<p>This statement imports all global symbols from &quot;filename&quot; into the current global scope (unlike ES6,Solidity is backward compatible).</p>
<pre><code class="lang-sh">  import * as symbolName from <span class="hljs-string">&quot;filename&quot;</span>;
</code></pre>
<p>Create a new global symbol <code>symbolName</code> , whose members are all from <code>filename</code> Global symbol in.</p>
<pre><code class="lang-sh">  import {symbol1 as <span class="hljs-built_in">alias</span>, symbol2} from <span class="hljs-string">&quot;filename&quot;</span>;
</code></pre>
<p>Create a new global symbol <code>alias</code> And <code>symbol2</code>&#xFF0C;respectively from <code>&quot;filename&quot;</code> reference <code>symbol1</code> and <code>symbol2</code> &#x3002;</p>
<p>Another syntax does not belong to ES6, but may be simpler:</p>
<pre><code class="lang-sh">  import <span class="hljs-string">&quot;filename&quot;</span> as symbolName;
</code></pre>
<p>This statement is equivalent <code>import * as symbolName from &quot;filename&quot;;</code>&#x3002;</p>
<h4 id="path"><a name="path" class="plugin-anchor" href="#path"><i class="fa fa-link" aria-hidden="true"></i></a>Path</h4>
<p>The filename mentioned above is always processed by path <code>/</code> as a directory separator, <code>.</code> mark the current directory <code>..</code> Indicates the parent directory. 
When <code>.</code> or <code>..</code> the following characters are <code>/</code> they can be treated as the current directory or parent directory.
Only the path to the current directory <code>.</code> or parent directory <code>..</code> at the beginning, it can be regarded as a relative path.</p>
<p>For <code>import &quot;./x&quot; as x</code> statement to import files under the same directory as the current source file <code>x</code> &#x3002;
If used <code>import &quot;x&quot; as x;</code> instead, different files may be introduced (in the global <code>include directory</code> Medium).</p>
<p>The final file to be imported depends on how the compiler (see below) parses the path.Generally, directory levels do not need to be strictly mapped to local file systems,It can also be mapped to resources that can be discovered through ipfs,http, or git.</p>
<h4 id="use-in-actual-compilers"><a name="use-in-actual-compilers" class="plugin-anchor" href="#use-in-actual-compilers"><i class="fa fa-link" aria-hidden="true"></i></a>Use in actual compilers</h4>
<p>When running the compiler, it can specify not only how to discover the first element of the path, but also the path prefix|remapping|&#x3002;
For example&#xFF0C;<code>github.com/ethereum/dapp-bin/library</code> will be replayed to shoot <code>/usr/local/dapp-bin/library</code> &#xFF0C;
The compiler reads the file from the remapping location. If multiple paths are remapped, the longest path is remapped first.
This allows <code>&quot;&quot;</code> be mapped <code>&quot;/usr/local/include/solidity&quot;</code> to perform &quot;rollback and remapping.
At the same time, these remaps depend on the context, allowing you to configure the packages to be imported, such as different versions of the same library.</p>
<p><strong>solc</strong>:</p>
<p>For solc&#xFF08;command line compiler&#xFF09;&#xFF0C;these remaps are based on <code>context:prefix=target</code> parameters in the form are provided.
among them&#xFF0C;<code>context:</code> and  <code>=target</code> parts are optional&#xFF08;the target is prefix by default&#xFF09;&#x3002;
All remapping values are compiled regular files (including their dependencies), and this mechanism is completely backward compatible&#xFF08;as long as the file name does not contain <code>=</code> or <code>:</code>&#xFF09;&#xFF0C;Therefore, this is not a destructive modification.</p>
<p>in <code>content</code> source code files in the directory or its subdirectories, all import statements <code>prefix</code> Import files starting with will be used <code>target</code> Replacement <code>prefix</code> To redirect.</p>
<p>For example, if you have cloned <code>github.com/ethereum/dapp-bin/</code> to local <code>/usr/local/dapp-bin</code> &#xFF0C;
used int the source file:</p>
<pre><code class="lang-sh">  import <span class="hljs-string">&quot;github.com/ethereum/dapp-bin/library/iterable_mapping.sol&quot;</span> as it_mapping;
</code></pre>
<p>Then run the compiler:</p>
<pre><code class="lang-sh">  solc github.com/ethereum/dapp-bin/=/usr/<span class="hljs-built_in">local</span>/dapp-bin/ source.sol
</code></pre>
<p>For a more complex example, suppose you rely on some modules that use a very old version of dapp-bin.
The old version of dapp-bin has been checked out <code>/usr/local/dapp-bin_old</code> , at this time you can use:</p>
<pre><code class="lang-sh">  solc module1:github.com/ethereum/dapp-bin/=/usr/<span class="hljs-built_in">local</span>/dapp-bin/ \
  module2:github.com/ethereum/dapp-bin/=/usr/<span class="hljs-built_in">local</span>/dapp-bin_old/ \
  source.sol
</code></pre>
<p>In this way, <code>module2</code> all imports in point to the old version, and <code>module1</code> import in to obtain the new version.</p>
<p>Note that solc only allows files from a specific directory: they must be located in a explicitly specified source file directory (or subdirectory), or in a remapped target Directory (or subdirectory).</p>
<p>If you want to include files directly with an absolute path, just add a remapping <code>=/</code> .</p>
<p>If multiple remappings point to a valid file, the remapping with the longest common prefix is selected.</p>
<p><strong>Remix</strong>:</p>
<p><a href="https://remix.ethereum.org/" target="_blank">Remix</a> Provides an automatic remapping for the github source code platform, which automatically obtains files through the network: for example, you can use <code>import &quot;github.com/ethereum/dapp-bin/library/iterable_mapping.sol&quot; as it_mapping;</code> import a map iterator.</p>
<p>In the future, Remix may support other source code platforms.</p>
<h3 id="annotation"><a name="annotation" class="plugin-anchor" href="#annotation"><i class="fa fa-link" aria-hidden="true"></i></a>Annotation</h3>
<p>you can use a single of comments&#xFF08;<code>//</code>&#xFF09;and multiple lines of comments&#xFF08;<code>/*...*/</code>&#xFF09;</p>
<pre><code class="lang-sh">
  // &#x8FD9;&#x662F;&#x4E00;&#x4E2A;&#x5355;&#x884C;&#x6CE8;&#x91CA;&#x3002;

  /*
  &#x8FD9;&#x662F;&#x4E00;&#x4E2A;
  &#x591A;&#x884C;&#x6CE8;&#x91CA;&#x3002;
  */
</code></pre>
<p>In addition, there is another annotation called natspec annotation, and its documentation has not yet been compiled.
They use three backslashes&#xFF08;<code>///</code>&#xFF09;or a block beginning with a double star&#xFF08;<code>/** ... */</code>&#xFF09;writing, they should be used directly on function declarations or statements.
Can be used in comments <a href="https://en.wikipedia.org/wiki/Doxygen" target="_blank">Doxygen</a> style labels to document functions,
The condition for passing the label form verification, and provide a condition that is displayed to the user when the user attempts to call a function <strong>Confirmation text</strong>.</p>
<p>In the following example, we record the contract title, two input parameters, and two return values:</p>
<pre><code class="lang-sh">
  pragma solidity ^0.4.0;

  /** @title &#x5F62;&#x72B6;&#x8BA1;&#x7B97;&#x5668;&#x3002; */
  contract shapeCalculator {
      /** @dev &#x6C42;&#x77E9;&#x5F62;&#x8868;&#x660E;&#x9762;&#x79EF;&#x4E0E;&#x5468;&#x957F;&#x3002;
      * @param w &#x77E9;&#x5F62;&#x5BBD;&#x5EA6;&#x3002;
      * @param h &#x77E9;&#x5F62;&#x9AD8;&#x5EA6;&#x3002;
      * @<span class="hljs-built_in">return</span> s &#x6C42;&#x5F97;&#x8868;&#x9762;&#x79EF;&#x3002;
      * @<span class="hljs-built_in">return</span> p &#x6C42;&#x5F97;&#x5468;&#x957F;&#x3002;
      */
      <span class="hljs-keyword">function</span> rectangle(uint w, uint h) returns (uint s, uint p) {
          s = w * h;
          p = 2 * (w + h);
      }
  }
</code></pre>
<h2 id="contract-structure"><a name="contract-structure" class="plugin-anchor" href="#contract-structure"><i class="fa fa-link" aria-hidden="true"></i></a>Contract structure</h2>
<p>In Solidity, contracts are similar to classes in object-oriented programming languages.
Each contract can contain <code>&#x72B6;&#x6001;&#x53D8;&#x91CF;</code>&#xFF0C;<code>&#x51FD;&#x6570;</code>&#xFF0C;<code>&#x51FD;&#x6570;&#x4FEE;&#x9970;&#x5668;</code>&#xFF0C;<code>&#x4E8B;&#x4EF6;</code>&#xFF0C;<code>&#x7ED3;&#x6784;&#x7C7B;&#x578B;</code> and <code>&#x679A;&#x4E3E;&#x7C7B;&#x578B;</code> the contract can be inherited from other contracts.</p>
<h3 id="state-variable"><a name="state-variable" class="plugin-anchor" href="#state-variable"><i class="fa fa-link" aria-hidden="true"></i></a>State variable</h3>
<p>State variables are values permanently stored in contract storage.</p>
<pre><code class="lang-sh">    pragma solidity ^0.4.0;

    contract SimpleStorage {
        uint storedData; // &#x72B6;&#x6001;&#x53D8;&#x91CF;
        // ...
    }
</code></pre>
<p>Valid state variable types see <code>type</code> chapters, Possible options for state variable visibility see <code>&#x53EF;&#x89C1;&#x6027;&#x548C;getter&#x51FD;&#x6570;</code> &#x3002;</p>
<h3 id="function"><a name="function" class="plugin-anchor" href="#function"><i class="fa fa-link" aria-hidden="true"></i></a>Function</h3>
<p>A function is the executable unit of the code in a contract.</p>
<pre><code class="lang-sh">    pragma solidity ^0.4.0;

    contract SimpleAuction {
        <span class="hljs-keyword">function</span> bid() public payable { // &#x51FD;&#x6570;
            // ...
        }
    }
</code></pre>
<p><code>&#x51FD;&#x6570;&#x8C03;&#x7528;</code> can occur inside or outside the contract, and the function has different degrees of visibility to other contracts&#xFF08; <code>&#x53EF;&#x89C1;&#x6027;&#x548C;getter&#x51FD;&#x6570;</code>&#xFF09;&#x3002; </p>
<h3 id="function-modifier"><a name="function-modifier" class="plugin-anchor" href="#function-modifier"><i class="fa fa-link" aria-hidden="true"></i></a>Function modifier</h3>
<p>Function modifiers can be used to improve function semantics in a declarative manner (see contract section <code>function</code> ).</p>
<pre><code class="lang-sh">    pragma solidity ^0.4.22;

    contract Purchase {
        address public seller;

        modifier <span class="hljs-function"><span class="hljs-title">onlySeller</span></span>() { // &#x4FEE;&#x9970;&#x5668;
            require(
                msg.sender == seller,
                <span class="hljs-string">&quot;Only seller can call this.&quot;</span>
            );
            _;
        }

        <span class="hljs-keyword">function</span> abort() public onlySeller { // Modifier usage
            // ...
        }
    }
</code></pre>
<h3 id="event"><a name="event" class="plugin-anchor" href="#event"><i class="fa fa-link" aria-hidden="true"></i></a>Event</h3>
<p>Events are interfaces that can easily call the log function of Simplechain virtual machines.</p>
<pre><code class="lang-sh">
    pragma solidity ^0.4.21;
    contract SimpleAuction {
        event HighestBidIncreased(address bidder, uint amount); // &#x4E8B;&#x4EF6;

        <span class="hljs-keyword">function</span> bid() public payable {
            // ...
            emit HighestBidIncreased(msg.sender, msg.value); // &#x89E6;&#x53D1;&#x4E8B;&#x4EF6;
        }
    }
</code></pre>
<p>For information on how to declare events and how to use events in dapp see contracts <code>event</code>&#x3002;</p>
<h3 id="structure-type"><a name="structure-type" class="plugin-anchor" href="#structure-type"><i class="fa fa-link" aria-hidden="true"></i></a>Structure type</h3>
<p>Structure is a custom type that can Group several variables (see type section <code>structure</code>&#xFF09;&#x3002;</p>
<pre><code class="lang-sh">
    pragma solidity ^0.4.0;

    contract Ballot {
        struct Voter { // &#x7ED3;&#x6784;
            uint weight;
            bool voted;
            address delegate;
            uint vote;
        }
    }
</code></pre>
<h3 id="enumeration-type"><a name="enumeration-type" class="plugin-anchor" href="#enumeration-type"><i class="fa fa-link" aria-hidden="true"></i></a>Enumeration type</h3>
<p>Enumeration can be used to create a custom type consisting of a certain number of constant values&#xFF08;see type chapter <code>Enumeration type</code>&#xFF09;&#x3002; </p>
<pre><code class="lang-sh">
    pragma solidity ^0.4.0;

    contract Purchase {
        enum State { Created, Locked, Inactive } // &#x679A;&#x4E3E;
    }
</code></pre>
<h2 id="type"><a name="type" class="plugin-anchor" href="#type"><i class="fa fa-link" aria-hidden="true"></i></a>Type</h2>
<p>Solidity is a static type language, which means each variable (state variable and local variable) you need to specify the type of the variable at compile time (or at least you can deduce the variable type).
Solidity provides several basic types that can be used to combine complex types.</p>
<p>In addition, types can interact in expressions containing operator symbols.</p>
<h3 id="value-type"><a name="value-type" class="plugin-anchor" href="#value-type"><i class="fa fa-link" aria-hidden="true"></i></a>Value type</h3>
<p>The following types are also called value types because variables of these types are always passed by value.
That is, when these variables are used as function parameters or in assignment statements, values are always copied.</p>
<h3 id="boolean-type"><a name="boolean-type" class="plugin-anchor" href="#boolean-type"><i class="fa fa-link" aria-hidden="true"></i></a>Boolean type</h3>
<p><code>bool</code> &#xFF1A;the possible value is a literal constant value <code>true</code> and <code>false</code> &#x3002;</p>
<p>Operator:</p>
<ul>
<li><code>!</code> &#xFF08;logical no&#xFF09;</li>
<li><code>&amp;&amp;</code> &#xFF08;logic and&#xFF0C; &quot;and&quot; &#xFF09;</li>
<li><code>||</code> &#xFF08;logic or&#xFF0C; &quot;or&quot; &#xFF09;</li>
<li><code>==</code> &#xFF08;equal to&#xFF09;</li>
<li><code>!=</code> &#xFF08;not equal to&#xFF09;</li>
</ul>
<p>Operator <code>||</code> and <code>&amp;&amp;</code> all follow the same short-counterfeiting rule. that means in the expression <code>f(x) || g(y)</code> middle&#xFF0C;
If <code>f(x)</code> Value of  <code>true</code> &#xFF0C;then <code>g(y)</code> will not be executed even if there are some side effects.</p>
<h3 id="integer"><a name="integer" class="plugin-anchor" href="#integer"><i class="fa fa-link" aria-hidden="true"></i></a>Integer</h3>
<p><code>int</code> / <code>uint</code> &#xFF1A;integer variables representing different numbers of signed and unsigned digits respectively.
Supported keywords <code>uint8</code> to <code>uint256</code> &#xFF08;unsigned, from 8 bits to 256 bits&#xFF09;and <code>int8</code> to <code>int256</code>&#xFF0C;<code>8</code> bit is the step increment.
<code>uint</code> and <code>int</code> respectively <code>uint256</code> and <code>int256</code> the alias.</p>
<p>Operator:</p>
<ul>
<li>Comparison operator: <code>&lt;=</code> &#xFF0C; <code>&lt;</code> &#xFF0C; <code>==</code> &#xFF0C; <code>!=</code> &#xFF0C; <code>&gt;=</code> &#xFF0C; <code>&gt;</code> &#xFF08;return a boolean value&#xFF09;</li>
<li>bit operator&#xFF1A; <code>&amp;</code> &#xFF0C; <code>|</code> &#xFF0C; <code>^</code> &#xFF08;different or&#xFF09;&#xFF0C; <code>~</code> &#xFF08;reverse bit&#xFF09;</li>
<li>Arithmetic operator:&#xFF1A; <code>+</code> &#xFF0C; <code>-</code> &#xFF0C; unary operation <code>-</code> &#xFF0C; unary operation <code>+</code> &#xFF0C; <code>*</code> &#xFF0C; <code>/</code> &#xFF0C; <code>%</code> &#xFF08;Surplus&#xFF09; &#xFF0C; <code>**</code> &#xFF08;Power&#xFF09;&#xFF0C; <code>&lt;&lt;</code> &#xFF08;Left Shift&#xFF09; &#xFF0C; <code>&gt;&gt;</code> &#xFF08;Right Shift&#xFF09;</li>
</ul>
<p>Division is always truncated&#xFF08;only compiled as in EVM <code>DIV`` Operation Code&#xFF09;&#xFF0C;
But if all the operands are</code>&#x5B57;&#x9762;&#x5E38;&#x6570;&#xFF08;literals)`(Or literal constant expression), it will not be truncated.</p>
<p>Dividing by zero or modulo zero will cause runtime exceptions.</p>
<p>The result of the shift operation depends on the type to the left of the operator.
expression <code>x &lt;&lt; y</code> and <code>x * 2**y</code> is equivalent,
<code>x &gt;&gt; y</code> &#x4E0E; <code>x / 2**y</code> Is equivalent. This means that shifting a negative number will cause its symbol to disappear.</p>
<p>.. warning::
   The result generated by the right shift of the negative value of the signed integer type is different from that produced in other languages.
In Solidity, the right shift and division are equivalent, so the right shift of a negative number will result in the rounded (truncated) to 0.
In other languages, moving the negative number to the right is similar to Rounding (to the negative infinity).</p>
<h3 id="fixed-length-floating-point-type"><a name="fixed-length-floating-point-type" class="plugin-anchor" href="#fixed-length-floating-point-type"><i class="fa fa-link" aria-hidden="true"></i></a>Fixed-length floating point type</h3>
<blockquote>
<p>Solidity does not fully support the fixed-length floating point type. You can declare floating-point variables of fixed length, but you cannot assign them or assign them to other variables.</p>
</blockquote>
<p><code>fixed</code> / <code>ufixed</code>&#xFF1A;indicates signed and unsigned fixed-length floating point types of various sizes.
In keywords <code>ufixedMxN</code> and <code>fixedMxN</code> Middle&#xFF0C;<code>M</code> Indicates the number of digits occupied by this type,<code>N</code> Indicates the number of available decimal places.
<code>M</code> Must be able to divide exactly 8, that is, 8 to 256 bits.
<code>N</code> It can be any number from 0 to 80.
<code>ufixed</code> and <code>fixed</code> fixed <code>ufixed128x19</code> and <code>fixed128x19</code> alias&#x3002;</p>
<p>Operator&#xFF1A;</p>
<ul>
<li>Comparison operator&#xFF1A;<code>&lt;=</code>&#xFF0C; <code>&lt;</code>&#xFF0C; <code>==</code>&#xFF0C; <code>!=</code>&#xFF0C; <code>&gt;=</code>&#xFF0C; <code>&gt;</code> &#xFF08;return value is boolean&#xFF09;</li>
<li>Arithmetic operator&#xFF1A;<code>+</code>&#xFF0C; <code>-</code>&#xFF0C; unary operation <code>-</code>&#xFF0C; unary operation <code>+</code>&#xFF0C; <code>*</code>&#xFF0C; <code>/</code>&#xFF0C; <code>%</code> &#xFF08;take the remainder&#xFF09;</li>
</ul>
<p>.. note::
   Floating point type (in many languages <code>float</code> And <code>double</code> The biggest difference between type, more precisely IEEE 754 type) and fixed-length floating point type is, In the former, the number of digits required for the integral part and the decimal part (the part after the decimal point) is flexible and variable, while the length of these two parts in the latter is strictly regulated. Generally speaking, in the floating point type, almost the whole space is used to represent numbers, but only a few bits represent the position of decimal point.</p>
<h3 id="address-type"><a name="address-type" class="plugin-anchor" href="#address-type"><i class="fa fa-link" aria-hidden="true"></i></a>Address type</h3>
<p><code>address</code>&#xFF1A;The address type stores a 20-byte value (the size of the Simplechain address).
The address type also has member variables and serves as the basis for all contracts.</p>
<p>Operator&#xFF1A;</p>
<ul>
<li><code>&lt;=</code>&#xFF0C; <code>&lt;</code>&#xFF0C; <code>==</code>&#xFF0C; <code>!=</code>&#xFF0C; <code>&gt;=</code> and <code>&gt;</code></li>
</ul>
<blockquote>
<p> Starting from version 0.5.0, the contract does not derive from the address type, but can still be explicitly converted to the address type.</p>
</blockquote>
<p>Address type member variable</p>
<ul>
<li><code>balance</code> &#x548C; <code>transfer</code></li>
</ul>
<p>can used <code>balance</code> property to query the balance of an address,
can also used <code>transfer</code> function sends | ether | (in wei) to an address:</p>
<pre><code class="lang-bash">address x = 0x123;
address myAddress = this;
<span class="hljs-keyword">if</span> (x.balance &lt; 10 &amp;&amp; myAddress.balance &gt;= 10) x.transfer(10);
</code></pre>
<blockquote>
<p>If <code>x</code> is a contract address, its code (more specifically, its fallback function, if any) and <code>transfer</code> Function calls are executed together (this is a feature of EVM and cannot be prevented).
If gas is used up in the execution process or the execution fails for any reason, the | ether | Transaction will be called back, and the current contract will also throw an exception at the same time of termination.</p>
</blockquote>
<ul>
<li><code>send</code></li>
</ul>
<p><code>send</code> is <code>transfer</code> the low-level version. If execution fails, the current contract will not be terminated due to exceptions, <code>send</code> &#x4F1A;&#x8FD4;&#x56DE; <code>false</code>.</p>
<blockquote>
<p>In use <code>send</code> there are some risks&#xFF1A;if the call stack depth is 1024, it will lead to sending failure (which can always be forced by the caller), and if the receiver uses up gas, it will also lead to sending failure. Therefore, in order to ensure the security of | ether | Sending, you must check <code>send</code> the return value of, using <code>transfer</code> or a better way: Use a mode in which the receiver can retrieve funds.</p>
</blockquote>
<ul>
<li><code>call</code>&#xFF0C; <code>callcode</code> and <code>delegatecall</code></li>
</ul>
<p>In addition, in order to interact with contracts that do not conform to | ABI |, there are contracts that can accept any type and any number of parameters call Function. These parameters are packaged into a continuous area of 32 bytes. One exception is when the first parameter is encoded into exactly 4 bytes. In this case, this parameter is not followed by subsequent parameter encoding to allow the use of function signatures.</p>
<pre><code class="lang-bash">    address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2;
    nameReg.call(<span class="hljs-string">&quot;register&quot;</span>, <span class="hljs-string">&quot;MyName&quot;</span>);
    nameReg.call(bytes4(keccak256(<span class="hljs-string">&quot;fun(uint256)&quot;</span>)), a);
</code></pre>
<p><code>call</code> The returned Boolean value indicates that the called function has been executed&#xFF08;<code>true</code>&#xFF09;or an EVM exception is thrown&#xFF08;<code>false</code>&#xFF09;&#x3002;
The real data returned cannot be accessed (for this we need to know the encoding and size in advance).</p>
<p>Can be used <code>.gas()</code> | modifier | Adjust the quantity of gas provided:</p>
<pre><code>namReg.call.gas(1000000)(&quot;register&quot;, &quot;MyName&quot;);
</code></pre><p>Similarly, the value of | ether | Provided can also be controlled:</p>
<pre><code class="lang-bash">   nameReg.call.value(1 ether)(<span class="hljs-string">&quot;register&quot;</span>, <span class="hljs-string">&quot;MyName&quot;</span>);
</code></pre>
<p>Finally, these | modifier | Can be used together. The order in which each modifier appears is not important:</p>
<pre><code class="lang-bash">   nameReg.call.gas(1000000).value(1 ether)(<span class="hljs-string">&quot;register&quot;</span>, <span class="hljs-string">&quot;MyName&quot;</span>);
</code></pre>
<p>gas or value cannot be used in overloaded functions at present. One solution is to introduce a special case to gas and values and re-check whether they appear at heavy loads.</p>
<p>Similarly, it can also be used <code>delegatecall</code>&#xFF1A;The difference is that only the code of the given address is used, and other attributes (storage, balance,&#x2026;) All are taken from the current contract. <code>delegatecall</code> the purpose is to use the library code stored in another contract. You must ensure that the storage structures in both contracts apply to delegatecall. Before the homestead version, there was only one with similar functions but limited functions <code>callcode</code> the function of is available, but it cannot obtain the entrusting party&apos;s <code>msg.sender</code> and <code>msg.value</code>&#x3002;</p>
<p>These three functions <code>call</code>&#xFF0C; <code>delegatecall</code> and <code>callcode</code> they are all very low-level functions and should only be regarded Last move To use, because they undermine the type security of Solidity.</p>
<blockquote>
<p>All contracts inherit the member variable of address, so it can be used <code>this.balance</code> query the balance of the current contract.</p>
<p>Use is not encouraged <code>callcode</code>&#xFF0C;it will also be removed in the future.</p>
<p>These three functions are all low-level functions and need to be used with caution. Specifically, any unknown contract can be malicious. When you call a contract, you give control to it. It can call your contract in turn. Therefore, when the call returns, be prepared for changes in your state variables.</p>
</blockquote>
<h3 id="fixed-length-byte-array"><a name="fixed-length-byte-array" class="plugin-anchor" href="#fixed-length-byte-array"><i class="fa fa-link" aria-hidden="true"></i></a>Fixed-length byte array</h3>
<p>Keywords: <code>bytes1</code>&#xFF0C; <code>bytes2</code>&#xFF0C; <code>bytes3</code>&#xFF0C; ...&#xFF0C; <code>bytes32</code>&#xFF0C;<code>byte</code> is <code>bytes1</code> alias&#x3002;</p>
<p>Operator&#xFF1A;</p>
<ul>
<li>Comparison operator: <code>&lt;=</code>&#xFF0C; <code>&lt;</code>&#xFF0C; <code>==</code>&#xFF0C; <code>!=</code>&#xFF0C; <code>&gt;=</code>&#xFF0C; <code>&gt;</code> &#xFF08;return boolean&#xFF09;</li>
<li>Bit operator: <code>&amp;</code>&#xFF0C; <code>|</code>&#xFF0C; <code>^</code> &#xFF08;bit or&#xFF09;&#xFF0C; <code>~</code> &#xFF08;reverse by position&#xFF09;&#xFF0C; <code>&lt;&lt;</code> &#xFF08;left shift&#xFF09;&#xFF0C; <code>&gt;&gt;</code> &#xFF08;right shift&#xFF09;</li>
<li>Index access: if <code>x</code> is <code>bytesI</code> type&#xFF0C;then <code>x[k]</code> &#xFF08;Among them <code>0 &lt;= k &lt; I</code>&#xFF09; return  <code>k</code> bytes&#xFF08;read-only&#xFF09;&#x3002;</li>
</ul>
<p>This type can be shifted to any integer type as the right operand (but the returned result type is the same as the left operand type), and the right operand indicates the number of digits to be moved.
A negative displacement operation will cause a runtime exception.</p>
<p>Member variables:</p>
<ul>
<li><code>.length</code> indicates the length of the byte array (read-only).</li>
</ul>
<blockquote>
<p>Can put <code>byte[]</code> it is used as a byte array, but this method wastes a lot of storage space. To be exact, each element wastes 31 bytes when calling in. A better approach is to use <code>bytes</code>&#x3002;</p>
</blockquote>
<h3 id="variable-length-byte-array"><a name="variable-length-byte-array" class="plugin-anchor" href="#variable-length-byte-array"><i class="fa fa-link" aria-hidden="true"></i></a>Variable length byte array</h3>
<p><code>bytes</code>: Variable length byte array&#xFF0C;It is not a value type.
<code>string</code>: Variable length UTF-8 encoding string type, It is not a value type.</p>
<h3 id="address-literal-constant&#xFF08;address-literals&#xFF09;"><a name="address-literal-constant&#xFF08;address-literals&#xFF09;" class="plugin-anchor" href="#address-literal-constant&#xFF08;address-literals&#xFF09;"><i class="fa fa-link" aria-hidden="true"></i></a>Address literal constant&#xFF08;Address Literals&#xFF09;</h3>
<p>For example <code>0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF</code> such hexadecimal literal constants that pass the address checksum test belong <code>address</code> type. The hexadecimal literal constant, which is 39 to 41 numbers in length and fails to pass the checksum test and generates a warning, is regarded as a normal rational literal constant.</p>
<blockquote>
<p>Mixed case address checksum format is defined in <a href="https://github.com/ethereum/EIPs/blob/master/EIPS/eip-55.md" target="_blank">EIP-55</a>medium.</p>
</blockquote>
<h3 id="literal-constants-of-rational-numbers-and-integers"><a name="literal-constants-of-rational-numbers-and-integers" class="plugin-anchor" href="#literal-constants-of-rational-numbers-and-integers"><i class="fa fa-link" aria-hidden="true"></i></a>Literal constants of rational numbers and integers</h3>
<p>The literal constant of an integer consists of a string of numbers ranging from 0 to 9 and is expressed as decimal. For example, <code>69</code> Indicates the number 69. <code>Solidity</code> There is no octal in, so the pre -0 is invalid.</p>
<p>Decimal face constant with one <code>.</code>&#xFF0C;at least there will be a number on one side. For example:<code>1.</code>&#xFF0C;<code>.1</code>&#xFF0C;and <code>1.3</code>&#x3002;</p>
<p>Scientific symbols are also supported. Although the index must be an integer, the base number can be a decimal. For example:<code>2e10</code>&#xFF0C; <code>-2e10</code>&#xFF0C; <code>2e-10</code>&#xFF0C; <code>2.5e1</code>&#x3002;</p>
<p>Numeric literal constant expressions themselves support arbitrary precision unless they are converted to non-literal constant types (that is, conversion occurs when they appear in non-literal constant expressions). This means that in numerical constant expressions, calculations do not overflow and division does not truncate.</p>
<p>For example&#xFF0C; <code>(2**800 + 1) - 2**800</code> result is a literal constant <code>1</code> &#xFF08;belong <code>uint8</code> type&#xFF09;&#xFF0C;although the intermediate result of the calculation has exceeded the machine word length of |evm| . In addition, <code>.5 * 8</code> result is integer <code>4</code> &#xFF08;Although there are non-integers involved in the calculation&#xFF09;.</p>
<p>As long as the operands are integers, operators supported by any integer can be applied to literal constant expressions of numerical values.
If either of the two numbers is a decimal, bit operation is not allowed. If the index is a decimal, power operation is not supported (because this may result in an irrational number).</p>
<blockquote>
<p>Solidity has a corresponding literal constant type for each rational number. Integer literal constant and rational number literal constant both belong to the type of numerical literal constant. In addition, all numerical literal constant expressions (expressions containing only numerical literal constants and operators) belong to the type of numerical literal constants.
Therefore, the literal constant expression of the numerical value <code>1 + 2</code> And <code>2 + 1</code> The result is the same as the literal constant type of the value of rational number three.</p>
<p>In earlier versions, the division of the literal constant of an integer was also truncated, but in current versions, the result was converted into a rational number. That <code>5 / 2</code> Not equal <code>2</code> , but equal <code>2.5</code> .</p>
<p>A numeric literal constant expression is converted to a non-literal constant type as long as it is used in a non-literal constant expression. In the following example, although we know <code>b</code> The value of is an integer, <code>2.5 + a</code> This part of the expression does not perform type check, so compilation cannot pass.</p>
</blockquote>
<pre><code class="lang-sh">
    uint128 a = 1;
    uint128 b = 2.5 + a + 0.5;
</code></pre>
<h3 id="string-literal-constant"><a name="string-literal-constant" class="plugin-anchor" href="#string-literal-constant"><i class="fa fa-link" aria-hidden="true"></i></a>String literal constant</h3>
<p>The literal constant of a string refers to a string caused by double quotation marks or single quotation marks&#xFF08;<code>&quot;foo&quot;</code> or <code>&apos;bar&apos;</code>&#xFF09;&#x3002;
Not like having an ending character in C language;<code>&quot;foo&quot;</code> it is equivalent to 3 bytes instead of 4.
Like integer literal constants, the types of string literal constants can also be changed, but they can be converted <code>bytes1</code>&#xFF0C;&#x2026;&#x2026;&#xFF0C;<code>bytes32</code>&#xFF0C;if appropriate, it can also be converted <code>bytes</code> and <code>string</code>&#x3002;</p>
<p>String literal constants support escape characters, such <code>\n</code>&#xFF0C;<code>\xNN</code> and <code>\uNNNN</code>&#x3002;<code>\xNN</code> represents a hexadecimal value, which is finally converted into an appropriate byte, and<code>\uNNNN</code> indicates the Unicode encoded value, which is eventually converted to a sequence of UTF-8.</p>
<h3 id="hexadecimal-literal-constant"><a name="hexadecimal-literal-constant" class="plugin-anchor" href="#hexadecimal-literal-constant"><i class="fa fa-link" aria-hidden="true"></i></a>Hexadecimal literal constant</h3>
<p>Hexadecimal literal constants use keywords<code>hex</code> a string that starts with single or double quotation marks (for example, hex &quot;001122FF&quot; ).
the content of the string must be a hexadecimal string, and their values will be represented in binary.</p>
<p>Hexadecimal literal constants are similar to string literal constants and have the same conversion rules.</p>
<h3 id="enumeration-type"><a name="enumeration-type" class="plugin-anchor" href="#enumeration-type"><i class="fa fa-link" aria-hidden="true"></i></a>Enumeration type</h3>
<pre><code class="lang-sh">
    pragma solidity ^0.4.16;

    contract <span class="hljs-built_in">test</span> {
        enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }
        ActionChoices choice;
        ActionChoices constant defaultChoice = ActionChoices.GoStraight;

        <span class="hljs-keyword">function</span> <span class="hljs-built_in">set</span>GoStraight() public {
            choice = ActionChoices.GoStraight;
        }

        // &#x7531;&#x4E8E;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x4E0D;&#x5C5E;&#x4E8E; |ABI| &#x7684;&#x4E00;&#x90E8;&#x5206;&#xFF0C;&#x56E0;&#x6B64;&#x5BF9;&#x4E8E;&#x6240;&#x6709;&#x6765;&#x81EA; Solidity &#x5916;&#x90E8;&#x7684;&#x8C03;&#x7528;&#xFF0C;
        // <span class="hljs-string">&quot;getChoice&quot;</span> &#x7684;&#x7B7E;&#x540D;&#x4F1A;&#x81EA;&#x52A8;&#x88AB;&#x6539;&#x6210; <span class="hljs-string">&quot;getChoice() returns (uint8)&quot;</span>&#x3002;
        // &#x6574;&#x6570;&#x7C7B;&#x578B;&#x7684;&#x5927;&#x5C0F;&#x5DF2;&#x7ECF;&#x8DB3;&#x591F;&#x5B58;&#x50A8;&#x6240;&#x6709;&#x679A;&#x4E3E;&#x7C7B;&#x578B;&#x7684;&#x503C;&#xFF0C;&#x968F;&#x7740;&#x503C;&#x7684;&#x4E2A;&#x6570;&#x589E;&#x52A0;&#xFF0C;
        // &#x53EF;&#x4EE5;&#x9010;&#x6E10;&#x4F7F;&#x7528; `uint16` &#x6216;&#x66F4;&#x5927;&#x7684;&#x6574;&#x6570;&#x7C7B;&#x578B;&#x3002;
        <span class="hljs-keyword">function</span> getChoice() public view returns (ActionChoices) {
            <span class="hljs-built_in">return</span> choice;
        }

        <span class="hljs-keyword">function</span> getDefaultChoice() public pure returns (uint) {
            <span class="hljs-built_in">return</span> uint(defaultChoice);
        }
    }
</code></pre>
<h3 id="function-type"><a name="function-type" class="plugin-anchor" href="#function-type"><i class="fa fa-link" aria-hidden="true"></i></a>Function type</h3>
<p>A function type is a type that represents a function. You can assign a function to a variable of another function type, pass a function as a parameter, and return a function type variable in a function call. There are two types of functions:- internal (internal) Function sum external (external) Function:</p>
<p>Internal functions can only be called within the current contract (more specifically, within the current code block, including internal library functions and inherited functions), because they cannot be executed outside the current contract context. Calling an internal function is implemented by redirecting to its entry label, just like calling a function inside the current contract.</p>
<p>An external function consists of an address and a function signature, which can be passed or returned by calling an external function.</p>
<p>The function type is expressed as follows:</p>
<pre><code class="lang-bash"><span class="hljs-keyword">function</span> (&lt;parameter types&gt;) {internal|external} [pure|constant|view|payable] [returns (&lt;<span class="hljs-built_in">return</span> types&gt;)]
</code></pre>
<p>Contrary to the parameter type, the return type cannot be empty-if the function type does not need to return, you need to delete the entire <code>returns</code> Part.</p>
<p>The function type is an internal function by default, so it does not need to be declared <code>internal</code> keywords.
On the contrary, the function itself in the contract is public by default, and it is an internal function by default only when it is regarded as a type name.</p>
<p>There are two ways to access the function in the current contract: one is to use its name directly<code>f</code> &#xFF0C;other is to use <code>this.f</code> &#x3002;
The former applies to internal functions, while the latter applies to external functions.</p>
<p>An exception is thrown if a function type variable is called before initialization.
If in a function is <code>delete</code> same situation occurs after calling it.</p>
<p>If external function types are used outside the context environment of Solidity, they are considered <code>function</code> Type.
This type encodes the function address along with its function identifier as one <code>bytes24</code> Type.</p>
<p>Note that the public function of the current contract can be used either as an internal function or as an external function.
If you want to use a function as an internal function, use <code>f</code> Call, if you want to use it as an external function, use <code>this.f</code> .</p>
<p>In addition, the public (or external) function also has a special member variable called <code>selector</code> , can return<code>ABI function selector</code></p>
<pre><code class="lang-bash">    pragma solidity ^0.4.16;

    contract Selector {
      <span class="hljs-keyword">function</span> f() public view returns (bytes4) {
        <span class="hljs-built_in">return</span> this.f.selector;
      }
    }
</code></pre>
<p>If use an example of an internal function type:</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.16;

    library ArrayUtils {
      // &#x5185;&#x90E8;&#x51FD;&#x6570;&#x53EF;&#x4EE5;&#x5728;&#x5185;&#x90E8;&#x5E93;&#x51FD;&#x6570;&#x4E2D;&#x4F7F;&#x7528;&#xFF0C;
      // &#x56E0;&#x4E3A;&#x5B83;&#x4EEC;&#x4F1A;&#x6210;&#x4E3A;&#x540C;&#x4E00;&#x4EE3;&#x7801;&#x4E0A;&#x4E0B;&#x6587;&#x7684;&#x4E00;&#x90E8;&#x5206;
      <span class="hljs-keyword">function</span> map(uint[] memory self, <span class="hljs-keyword">function</span> (uint) pure returns (uint) f)
        internal
        pure
        returns (uint[] memory r)
      {
        r = new uint[](self.length);
        <span class="hljs-keyword">for</span> (uint i = 0; i &lt; self.length; i++) {
          r[i] = f(self[i]);
        }
      }
      <span class="hljs-keyword">function</span> reduce(
        uint[] memory self,
        <span class="hljs-keyword">function</span> (uint, uint) pure returns (uint) f
      )
        internal
        pure
        returns (uint r)
      {
        r = self[0];
        <span class="hljs-keyword">for</span> (uint i = 1; i &lt; self.length; i++) {
          r = f(r, self[i]);
        }
      }
      <span class="hljs-keyword">function</span> range(uint length) internal pure returns (uint[] memory r) {
        r = new uint[](length);
        <span class="hljs-keyword">for</span> (uint i = 0; i &lt; r.length; i++) {
          r[i] = i;
        }
      }
    }

    contract Pyramid {
      using ArrayUtils <span class="hljs-keyword">for</span> *;
      <span class="hljs-keyword">function</span> pyramid(uint l) public pure returns (uint) {
        <span class="hljs-built_in">return</span> ArrayUtils.range(l).map(square).reduce(sum);
      }
      <span class="hljs-keyword">function</span> square(uint x) internal pure returns (uint) {
        <span class="hljs-built_in">return</span> x * x;
      }
      <span class="hljs-keyword">function</span> sum(uint x, uint y) internal pure returns (uint) {
        <span class="hljs-built_in">return</span> x + y;
      }
    }
</code></pre>
<p>Another example of using an external function type:</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.11;

    contract Oracle {
      struct Request {
        bytes data;
        <span class="hljs-keyword">function</span>(bytes memory) external callback;
      }
      Request[] requests;
      event NewRequest(uint);
      <span class="hljs-keyword">function</span> query(bytes data, <span class="hljs-keyword">function</span>(bytes memory) external callback) public {
        requests.push(Request(data, callback));
        NewRequest(requests.length - 1);
      }
      <span class="hljs-keyword">function</span> reply(uint requestID, bytes response) public {
        // &#x8FD9;&#x91CC;&#x8981;&#x9A8C;&#x8BC1; reply &#x6765;&#x81EA;&#x53EF;&#x4FE1;&#x7684;&#x6E90;
        requests[requestID].callback(response);
      }
    }

    contract OracleUser {
      Oracle constant oracle = Oracle(0x1234567); // &#x5DF2;&#x77E5;&#x7684;&#x5408;&#x7EA6;
      <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">buySomething</span></span>() {
        oracle.query(<span class="hljs-string">&quot;USD&quot;</span>, this.oracleResponse);
      }
      <span class="hljs-keyword">function</span> oracleResponse(bytes response) public {
        require(msg.sender == address(oracle));
        // &#x4F7F;&#x7528;&#x6570;&#x636E;
      }
    }
</code></pre>
<blockquote>
<p> The introduction of Lambda expressions or inline functions is planned, but is not currently supported.</p>
</blockquote>
<h3 id="reference-type"><a name="reference-type" class="plugin-anchor" href="#reference-type"><i class="fa fa-link" aria-hidden="true"></i></a>Reference type</h3>
<p>Compared with the value types discussed before, we need to be more cautious when dealing with complex types (that is, types that occupy more than 256 bits of space).
Since the overhead of copying these type variables is considerable, we have to consider its storage location and save them in <code>memory</code> (Not permanent storage), Or <code>storage</code> Where state variables are saved.</p>
<h3 id="data-location"><a name="data-location" class="plugin-anchor" href="#data-location"><i class="fa fa-link" aria-hidden="true"></i></a>Data Location</h3>
<p>All complex types, namely Array And Structure Type, all have an additional attribute, &quot;data location&quot;, indicating that the data is saved in <code>memory</code> Medium or storage Medium. Depending on the context, most of the time the data has a default location, but you can also add keywords after the type name. storage Or <code>memory</code> Modify. By default, the data location of function parameters (including returned parameters) is <code>memory</code> , the default data location of the local variable is <code>storage</code> , the data location of the state variable is forced to be <code>storage</code> (This is obvious).</p>
<p>There is also a third data location, <code>calldata</code> , this is a read-only and not permanently stored location, used to store function parameters. The data location of external function parameters (non-return parameters) is forcibly specified <code>calldata</code> , effect and <code>memory</code> Almost.</p>
<p>The designation of data locations is very important because they affect assignment behavior:</p>
<p>In <code>storage</code> And <code>memory</code> Assign values between two pairs, or <code>storage</code> Assigning values to state variables (even from other state variables) creates an independent copy. However, when a state variable assigns a value to a local variable, it only passes a reference, and this reference always points to a state variable, so the latter changes while the former changes. On the other hand, from one <code>memory</code> The reference type of the storage to another <code>memory</code> The reference type assignment of the storage does not create a copy.</p>
<pre><code class="lang-sh">
    pragma solidity ^0.4.0;

    contract C {
        uint[] x; // x &#x7684;&#x6570;&#x636E;&#x5B58;&#x50A8;&#x4F4D;&#x7F6E;&#x662F; storage

        // memoryArray &#x7684;&#x6570;&#x636E;&#x5B58;&#x50A8;&#x4F4D;&#x7F6E;&#x662F; memory
        <span class="hljs-keyword">function</span> f(uint[] memoryArray) public {
            x = memoryArray; // &#x5C06;&#x6574;&#x4E2A;&#x6570;&#x7EC4;&#x62F7;&#x8D1D;&#x5230; storage &#x4E2D;&#xFF0C;&#x53EF;&#x884C;
            var y = x;  // &#x5206;&#x914D;&#x4E00;&#x4E2A;&#x6307;&#x9488;&#xFF08;&#x5176;&#x4E2D; y &#x7684;&#x6570;&#x636E;&#x5B58;&#x50A8;&#x4F4D;&#x7F6E;&#x662F; storage&#xFF09;&#xFF0C;&#x53EF;&#x884C;
            y[7]; // &#x8FD4;&#x56DE;&#x7B2C; 8 &#x4E2A;&#x5143;&#x7D20;&#xFF0C;&#x53EF;&#x884C;
            y.length = 2; // &#x901A;&#x8FC7; y &#x4FEE;&#x6539; x&#xFF0C;&#x53EF;&#x884C;
            delete x; // &#x6E05;&#x9664;&#x6570;&#x7EC4;&#xFF0C;&#x540C;&#x65F6;&#x4FEE;&#x6539; y&#xFF0C;&#x53EF;&#x884C;
            // &#x4E0B;&#x9762;&#x7684;&#x5C31;&#x4E0D;&#x53EF;&#x884C;&#x4E86;&#xFF1B;&#x9700;&#x8981;&#x5728; storage &#x4E2D;&#x521B;&#x5EFA;&#x65B0;&#x7684;&#x672A;&#x547D;&#x540D;&#x7684;&#x4E34;&#x65F6;&#x6570;&#x7EC4;&#xFF0C; /
            // &#x4F46; storage &#x662F;&#x201C;&#x9759;&#x6001;&#x201D;&#x5206;&#x914D;&#x7684;&#xFF1A;
            // y = memoryArray;
            // &#x4E0B;&#x9762;&#x8FD9;&#x4E00;&#x884C;&#x4E5F;&#x4E0D;&#x53EF;&#x884C;&#xFF0C;&#x56E0;&#x4E3A;&#x8FD9;&#x4F1A;&#x201C;&#x91CD;&#x7F6E;&#x201D;&#x6307;&#x9488;&#xFF0C;
            // &#x4F46;&#x5E76;&#x6CA1;&#x6709;&#x53EF;&#x4EE5;&#x8BA9;&#x5B83;&#x6307;&#x5411;&#x7684;&#x5408;&#x9002;&#x7684;&#x5B58;&#x50A8;&#x4F4D;&#x7F6E;&#x3002;
            // delete y;

            g(x); // &#x8C03;&#x7528; g &#x51FD;&#x6570;&#xFF0C;&#x540C;&#x65F6;&#x79FB;&#x4EA4;&#x5BF9; x &#x7684;&#x5F15;&#x7528;
            h(x); // &#x8C03;&#x7528; h &#x51FD;&#x6570;&#xFF0C;&#x540C;&#x65F6;&#x5728; memory &#x4E2D;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x72EC;&#x7ACB;&#x7684;&#x4E34;&#x65F6;&#x62F7;&#x8D1D;
        }

        <span class="hljs-keyword">function</span> g(uint[] storage storageArray) internal {}
        <span class="hljs-keyword">function</span> h(uint[] memoryArray) public {}
    }
</code></pre>
<p><strong>Summary</strong></p>
<p>Force the specified data location:</p>
<ul>
<li>Parameters of external functions (excluding return parameters): calldata</li>
<li>Status variable: storage</li>
</ul>
<p>Default data location:</p>
<ul>
<li>Function parameters (including return parameters): memory</li>
<li>All other local variables: storage</li>
</ul>
<h4 id="array"><a name="array" class="plugin-anchor" href="#array"><i class="fa fa-link" aria-hidden="true"></i></a>Array</h4>
<p>An array can be declared with a length specified or dynamically resized.
for <code>storage</code> element type can be arbitrary (that is, the element can also be an array type, mapping type, or structure).
for <code>memory</code> The element type cannot be a mapping type. If it is a parameter of the public function, it can only be a ABI type.</p>
<p>An element type is <code>T</code>&#xFF0C;fixed length is<code>k</code> the array of can be declared <code>T[k]</code>&#xFF0C;while the dynamic array is declared <code>T[]</code>.
For example, a length of 5 and an element type <code>uint</code> array of the dynamic array of, should be declared <code>uint[][5]</code> &#xFF08;Note that compared with other languages, the declared position of array length is reversed).
To access the second element of the third dynamic array, you should use x[2]<a href="the%20array%20subscript%20starts%20from%200,%20and%20the%20subscript%20order%20when%20accessing%20the%20array%20is%20opposite%20to%20that%20when%20declaring,%20that%20is,%20x[2]%20is%20reduced%20by%20one%20level%20from%20the%20right">1</a>.</p>
<p><code>bytes</code> and <code>string</code> variables of type are special arrays.
<code>bytes</code> similar  <code>byte[]</code>&#xFF0C;but it will be &quot;tightly packaged&quot; in calldata (Translator&apos;s note: elements are continuously stored together and will not be stored in a unit per 32 bytes).
<code>string</code> and <code>bytes</code> Same, but (temporarily) access with length or index is not allowed.</p>
<p>.. note::
    If you want to access a string in bytes <code>s</code>&#xFF0C;please use<code>bytes(s).length</code> / <code>bytes(s)[7] = &apos;x&apos;;</code>&#x3002;
    Note that you are accessing low-level bytes in the form of UTF-8 instead of a single character.</p>
<p>You can identify an array <code>public</code>&#xFF0C;so that Solidity can create a <code>getter</code>.
After that, you must use the digital subscript as a parameter to access getter.</p>
<p><strong>Create a memory array</strong></p>
<p>Available <code>new</code> keyword creates a variable length array in memory.
and <code>storage</code> opposite of the array is that you Can&apos;t By modifying member variables <code>length</code> change <code>memory</code> size of array</p>
<pre><code class="lang-sh">
    pragma solidity ^0.4.16;

    contract C {
        <span class="hljs-keyword">function</span> f(uint len) public pure {
            uint[] memory a = new uint[](7);
            bytes memory b = new bytes(len);
            // &#x8FD9;&#x91CC;&#x6211;&#x4EEC;&#x6709; a.length == 7 &#x4EE5;&#x53CA; b.length == len
            a[6] = 8;
        }
    }
</code></pre>
<p><strong>Array literal constant/inline array</strong></p>
<p>The literal constant of an array is an array in the form of writing expressions and is not immediately assigned to a variable.</p>
<pre><code class="lang-sh">
    pragma solidity ^0.4.16;

    contract C {
        <span class="hljs-keyword">function</span> f() public pure {
            g([uint(1), 2, 3]);
        }
        <span class="hljs-keyword">function</span> g(uint[3] _data) public pure {
            // ...
        }
    }
</code></pre>
<p>The literal constant of an array is a fixed-length | memory | Array type. Its basic type is determined by the common type of elements in the array. For example&#xFF0C;<code>[1, 2, 3]</code> type of is <code>uint8[3] memory</code>&#xFF0C;because the type of each literal constant is <code>uint8</code>&#x3002;
Because of this, it is necessary to convert the first element in the above example <code>uint</code> type.
At present, it should be noted that the fixed length <code>memory</code> An array cannot be assigned to a longer <code>memory</code> Array, the following is a counter example:</p>
<pre><code class="lang-sh">    // &#x8FD9;&#x6BB5;&#x4EE3;&#x7801;&#x5E76;&#x4E0D;&#x80FD;&#x7F16;&#x8BD1;&#x3002;

    pragma solidity ^0.4.0;

    contract C {
        <span class="hljs-keyword">function</span> f() public {
            // &#x8FD9;&#x4E00;&#x884C;&#x5F15;&#x53D1;&#x4E86;&#x4E00;&#x4E2A;&#x7C7B;&#x578B;&#x9519;&#x8BEF;&#xFF0C;&#x56E0;&#x4E3A; unint[3] memory
            // &#x4E0D;&#x80FD;&#x8F6C;&#x6362;&#x6210; uint[] memory&#x3002;
            uint[] x = [uint(1), 3, 4];
        }
    }
</code></pre>
<p>Such restrictions have been planned to be removed in the future, but the current array is ABI The problem of transmission in caused some trouble.</p>
<h4 id="members"><a name="members" class="plugin-anchor" href="#members"><i class="fa fa-link" aria-hidden="true"></i></a>Members</h4>
<p><strong>length</strong>:</p>
<p>Array has <code>length</code> member variable indicates the length of the current array. Dynamic arrays can be in <code>storage</code>&#xFF08;not <code>memory</code> &#xFF09;by changing member variables <code>.length</code> Change the array size. You cannot automatically extend the length of an array by accessing the length of the current array. Once created, <code>memory</code> The size of the array is fixed (but dynamic, that is, it depends on runtime parameters).</p>
<p><strong>push</strong>:</p>
<p>Variable length | storage | Array and bytes Type (not <code>string</code> Type) all have one called push The member function of, which is used to attach new elements to the end of the array. This function returns the new array length.</p>
<blockquote>
<p> Multidimensional arrays are not currently available in external functions.</p>
<p> Due to the limitation of | evm |, dynamic content cannot be returned through external function calls. For example, if you call web3.js <code>contract C { function f() returns (uint[]) { ... } }</code> In <code>f</code> Function&#xFF0C;which returns some content&#xFF0C;but cannot be achieved through Solidity.</p>
</blockquote>
<p>At present, the only alternative is to use large static arrays.</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.16;

    contract ArrayContract {
        uint[2**20] m_aLotOfIntegers;
        // &#x6CE8;&#x610F;&#x4E0B;&#x9762;&#x7684;&#x4EE3;&#x7801;&#x5E76;&#x4E0D;&#x662F;&#x4E00;&#x5BF9;&#x52A8;&#x6001;&#x6570;&#x7EC4;&#xFF0C;
        // &#x800C;&#x662F;&#x4E00;&#x4E2A;&#x6570;&#x7EC4;&#x5143;&#x7D20;&#x4E3A;&#x4E00;&#x5BF9;&#x53D8;&#x91CF;&#x7684;&#x52A8;&#x6001;&#x6570;&#x7EC4;&#xFF08;&#x4E5F;&#x5C31;&#x662F;&#x6570;&#x7EC4;&#x5143;&#x7D20;&#x4E3A;&#x957F;&#x5EA6;&#x4E3A; 2 &#x7684;&#x5B9A;&#x957F;&#x6570;&#x7EC4;&#x7684;&#x52A8;&#x6001;&#x6570;&#x7EC4;&#xFF09;&#x3002;
        bool[2][] m_pairsOfFlags;
        // newPairs &#x5B58;&#x50A8;&#x5728; memory &#x4E2D; &#x2014;&#x2014; &#x51FD;&#x6570;&#x53C2;&#x6570;&#x9ED8;&#x8BA4;&#x7684;&#x5B58;&#x50A8;&#x4F4D;&#x7F6E;

        <span class="hljs-keyword">function</span> <span class="hljs-built_in">set</span>AllFlagPairs(bool[2][] newPairs) public {
            // &#x5411;&#x4E00;&#x4E2A; storage &#x7684;&#x6570;&#x7EC4;&#x8D4B;&#x503C;&#x4F1A;&#x66FF;&#x4EE3;&#x6574;&#x4E2A;&#x6570;&#x7EC4;
            m_pairsOfFlags = newPairs;
        }

        <span class="hljs-keyword">function</span> <span class="hljs-built_in">set</span>FlagPair(uint index, bool flagA, bool flagB) public {
            // &#x8BBF;&#x95EE;&#x4E00;&#x4E2A;&#x4E0D;&#x5B58;&#x5728;&#x7684;&#x6570;&#x7EC4;&#x4E0B;&#x6807;&#x4F1A;&#x5F15;&#x53D1;&#x4E00;&#x4E2A;&#x5F02;&#x5E38;
            m_pairsOfFlags[index][0] = flagA;
            m_pairsOfFlags[index][1] = flagB;
        }

        <span class="hljs-keyword">function</span> changeFlagArraySize(uint newSize) public {
            // &#x5982;&#x679C; newSize &#x66F4;&#x5C0F;&#xFF0C;&#x90A3;&#x4E48;&#x8D85;&#x51FA;&#x7684;&#x5143;&#x7D20;&#x4F1A;&#x88AB;&#x6E05;&#x9664;
            m_pairsOfFlags.length = newSize;
        }

        <span class="hljs-keyword">function</span> clear() public {
            // &#x8FD9;&#x4E9B;&#x4EE3;&#x7801;&#x4F1A;&#x5C06;&#x6570;&#x7EC4;&#x5168;&#x90E8;&#x6E05;&#x7A7A;
            delete m_pairsOfFlags;
            delete m_aLotOfIntegers;
            // &#x8FD9;&#x91CC;&#x4E5F;&#x662F;&#x5B9E;&#x73B0;&#x540C;&#x6837;&#x7684;&#x529F;&#x80FD;
            m_pairsOfFlags.length = 0;
        }

        bytes m_byteData;

        <span class="hljs-keyword">function</span> byteArrays(bytes data) public {
            // &#x5B57;&#x8282;&#x7684;&#x6570;&#x7EC4;&#xFF08;&#x8BED;&#x8A00;&#x610F;&#x4E49;&#x4E2D;&#x7684; byte &#x7684;&#x590D;&#x6570; ``bytes``&#xFF09;&#x4E0D;&#x4E00;&#x6837;&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x4EEC;&#x4E0D;&#x662F;&#x586B;&#x5145;&#x5F0F;&#x5B58;&#x50A8;&#x7684;&#xFF0C;
            // &#x4F46;&#x53EF;&#x4EE5;&#x5F53;&#x4F5C;&#x548C; <span class="hljs-string">&quot;uint8[]&quot;</span> &#x4E00;&#x6837;&#x5BF9;&#x5F85;
            m_byteData = data;
            m_byteData.length += 7;
            m_byteData[3] = byte(8);
            delete m_byteData[2];
        }

        <span class="hljs-keyword">function</span> addFlag(bool[2] flag) public returns (uint) {
            <span class="hljs-built_in">return</span> m_pairsOfFlags.push(flag);
        }

        <span class="hljs-keyword">function</span> createMemoryArray(uint size) public pure returns (bytes) {
            // &#x4F7F;&#x7528; `new` &#x521B;&#x5EFA;&#x52A8;&#x6001; memory &#x6570;&#x7EC4;&#xFF1A;
            uint[2][] memory arrayOfPairs = new uint[2][](size);
            // &#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x52A8;&#x6001;&#x5B57;&#x8282;&#x6570;&#x7EC4;&#xFF1A;
            bytes memory b = new bytes(200);
            <span class="hljs-keyword">for</span> (uint i = 0; i &lt; b.length; i++)
                b[i] = byte(i);
            <span class="hljs-built_in">return</span> b;
        }
    }
</code></pre>
<h3 id="structure"><a name="structure" class="plugin-anchor" href="#structure"><i class="fa fa-link" aria-hidden="true"></i></a>Structure</h3>
<p>Solidity supports defining new types by constructing structures. The following is an example of how a structure is used:</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.11;

    contract CrowdFunding {
        // &#x5B9A;&#x4E49;&#x7684;&#x65B0;&#x7C7B;&#x578B;&#x5305;&#x542B;&#x4E24;&#x4E2A;&#x5C5E;&#x6027;&#x3002;
        struct Funder {
            address addr;
            uint amount;
        }

        struct Campaign {
            address beneficiary;
            uint fundingGoal;
            uint numFunders;
            uint amount;
            mapping (uint =&gt; Funder) funders;
        }

        uint numCampaigns;
        mapping (uint =&gt; Campaign) campaigns;

        <span class="hljs-keyword">function</span> newCampaign(address beneficiary, uint goal) public returns (uint campaignID) {
            campaignID = numCampaigns++; // campaignID &#x4F5C;&#x4E3A;&#x4E00;&#x4E2A;&#x53D8;&#x91CF;&#x8FD4;&#x56DE;
            // &#x521B;&#x5EFA;&#x65B0;&#x7684;&#x7ED3;&#x6784;&#x4F53;&#x793A;&#x4F8B;&#xFF0C;&#x5B58;&#x50A8;&#x5728; storage &#x4E2D;&#x3002;&#x6211;&#x4EEC;&#x5148;&#x4E0D;&#x5173;&#x6CE8;&#x6620;&#x5C04;&#x7C7B;&#x578B;&#x3002;
            campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0);
        }

        <span class="hljs-keyword">function</span> contribute(uint campaignID) public payable {
            Campaign storage c = campaigns[campaignID];
            // &#x4EE5;&#x7ED9;&#x5B9A;&#x7684;&#x503C;&#x521D;&#x59CB;&#x5316;&#xFF0C;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x4E34;&#x65F6; memory &#x7ED3;&#x6784;&#x4F53;&#xFF0C;
            // &#x5E76;&#x5C06;&#x5176;&#x62F7;&#x8D1D;&#x5230; storage &#x4E2D;&#x3002;
            // &#x6CE8;&#x610F;&#x4F60;&#x4E5F;&#x53EF;&#x4EE5;&#x4F7F;&#x7528; Funder(msg.sender, msg.value) &#x6765;&#x521D;&#x59CB;&#x5316;&#x3002;
            c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value});
            c.amount += msg.value;
        }

        <span class="hljs-keyword">function</span> checkGoalReached(uint campaignID) public returns (bool reached) {
            Campaign storage c = campaigns[campaignID];
            <span class="hljs-keyword">if</span> (c.amount &lt; c.fundingGoal)
                <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;
            uint amount = c.amount;
            c.amount = 0;
            c.beneficiary.transfer(amount);
            <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;
        }
    }
</code></pre>
<p>The above contract is just a simplified version of crowdfunding contract, but it is enough to let us understand the basic concept of structure.
Structure types can be used as elements in mappings and arrays, and can also contain mappings and arrays as member variables.</p>
<p>Although the structure itself can be a mapping value type member, it cannot contain itself. This restriction is necessary because the size of the structure must be limited.</p>
<p>Note how a structure is assigned to a local variable when a structure is used in a function (the default storage location is storage ). In this process, the structure is not copied, but a reference is saved, so the assignment of local variable members is actually written into the state.</p>
<p>Of course, you can also directly access the members of the structure without assigning it to a local variable, like this, <code>campaigns[campaignID].amount = 0</code>&#x3002;</p>
<h4 id="mapping"><a name="mapping" class="plugin-anchor" href="#mapping"><i class="fa fa-link" aria-hidden="true"></i></a>Mapping</h4>
<p>The mapping type is declared in the form <code>mapping(_KeyType =&gt; _ValueType)</code>&#x3002;
Of which <code>_KeyType</code> it can be almost all types except mappings, variable-length arrays, contracts, enumerations, and structures.
<code>_ValueType</code> it can be any type including the mapping type.</p>
<p>Mapping can be treated <a href="https://en.wikipedia.org/wiki/Hash_table" target="_blank">&#x54C8;&#x5E0C;&#x8868;</a>&#xFF0C;they create each possible key in the actual initialization process and map it to a value whose byte form is all zero: a type <code>&#x9ED8;&#x8BA4;&#x503C;</code>&#x3002;However, the following is where the mapping differs from the hash table:</p>
<p>In the mapping, it does not actually store the key, but stores its <code>keccak256</code> Hash value, so that it is easy to query the actual value.
Because of this, mapping has no length, nor the concept of a set of keys or values. Only state variables (or references to storage variables in internal functions) can use mapping types.</p>
<p>You can declare the mapping <code>public</code>&#xFF0C;and then let Solidity create a <code>getter</code>&#x3002;<code>_KeyType</code> Will become a required parameter for getter, and getter will return <code>_ValueType</code>&#x3002;<code>_ValueType</code> It can also be a mapping. When getter is used, each  <code>_KeyType</code> parameters.</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.0;

    contract MappingExample {
        mapping(address =&gt; uint) public balances;

        <span class="hljs-keyword">function</span> update(uint newBalance) public {
            balances[msg.sender] = newBalance;
        }
    }

    contract MappingUser {
        <span class="hljs-keyword">function</span> f() public returns (uint) {
            MappingExample m = new MappingExample();
            m.update(100);
            <span class="hljs-built_in">return</span> m.balances(this);
        }
    }
</code></pre>
<blockquote>
<p> Mapping does not support iteration, but such a data structure can be implemented on top of it. For example, see: <a href="https://github.com/ethereum/dapp-bin/blob/master/library/iterable_mapping.sol" target="_blank">Iterable mapping</a></p>
</blockquote>
<h4 id="operators-involving-lvalues"><a name="operators-involving-lvalues" class="plugin-anchor" href="#operators-involving-lvalues"><i class="fa fa-link" aria-hidden="true"></i></a>Operators involving LValues</h4>
<p>If <code>a</code> is an LValue (that is, a variable or other things that can be assigned values), and the following operators can be used in shorthand:</p>
<p><code>a += e</code> equivalent <code>a = a + e</code>.  Other operators <code>-=</code>&#xFF0C; <code>*=</code>&#xFF0C; <code>/=</code>&#xFF0C; <code>%=</code>&#xFF0C; <code>|=</code>&#xFF0C; <code>&amp;=</code> and  <code>^=</code> they are all defined in this way.
<code>a++</code> and <code>a--</code> respectively equivalent <code>a += 1</code> and <code>a -= 1</code>&#xFF0C;But the value of the expression itself is equal <code>a</code> value before the calculation.
On the contrary, <code>--a</code> and <code>++a</code> although eventuall <code>a</code> result of is the same as that of the previous expression, but the return value of the expression is the value after calculation.</p>
<h3 id="delete"><a name="delete" class="plugin-anchor" href="#delete"><i class="fa fa-link" aria-hidden="true"></i></a>Delete</h3>
<p><code>delete a</code> result of is <code>a</code> value of the type during initialization is assigned <code>a</code>. That is for integer variables, equivalent <code>a = 0</code>&#xFF0C;
However, delete is also applicable to Arrays. For dynamic arrays, the length of the array is set to 0, while for static arrays, all elements in the array are reset. If the object is a structure, all properties in the structure are reset.</p>
<p><code>delete</code> It is invalid for the entire mapping because the mapping key can be arbitrary and usually unknown. Therefore, when you delete a structure, the result will reset all non-mapping attributes. This process is recursive unless they are mapped. However, individual keys and their mapped values can be deleted.</p>
<p>Understand<code>delete a</code> effect is like giving <code>a</code> assignment is very important, in other words, this is equivalent to in <code>a</code> new object is stored in.</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.0;

    contract DeleteExample {
        uint data;
        uint[] dataArray;

        <span class="hljs-keyword">function</span> f() public {
            uint x = data;
            delete x; // &#x5C06; x &#x8BBE;&#x4E3A; 0&#xFF0C;&#x5E76;&#x4E0D;&#x5F71;&#x54CD;&#x6570;&#x636E;
            delete data; // &#x5C06; data &#x8BBE;&#x4E3A; 0&#xFF0C;&#x5E76;&#x4E0D;&#x5F71;&#x54CD; x&#xFF0C;&#x56E0;&#x4E3A;&#x5B83;&#x4ECD;&#x7136;&#x6709;&#x4E2A;&#x526F;&#x672C;
            uint[] storage y = dataArray;
            delete dataArray; 
            // &#x5C06; dataArray.length &#x8BBE;&#x4E3A; 0&#xFF0C;&#x4F46;&#x7531;&#x4E8E; uint[] &#x662F;&#x4E00;&#x4E2A;&#x590D;&#x6742;&#x7684;&#x5BF9;&#x8C61;&#xFF0C;y &#x4E5F;&#x5C06;&#x53D7;&#x5230;&#x5F71;&#x54CD;&#xFF0C;
            // &#x56E0;&#x4E3A;&#x5B83;&#x662F;&#x4E00;&#x4E2A;&#x5B58;&#x50A8;&#x4F4D;&#x7F6E;&#x662F; storage &#x7684;&#x5BF9;&#x8C61;&#x7684;&#x522B;&#x540D;&#x3002;
            // &#x53E6;&#x4E00;&#x65B9;&#x9762;&#xFF1A;<span class="hljs-string">&quot;delete y&quot;</span> &#x662F;&#x975E;&#x6CD5;&#x7684;&#xFF0C;&#x5F15;&#x7528;&#x4E86; storage &#x5BF9;&#x8C61;&#x7684;&#x5C40;&#x90E8;&#x53D8;&#x91CF;&#x53EA;&#x80FD;&#x7531;&#x5DF2;&#x6709;&#x7684; storage &#x5BF9;&#x8C61;&#x8D4B;&#x503C;&#x3002;
        }
    }
</code></pre>
<h3 id="conversion-between-basic-types"><a name="conversion-between-basic-types" class="plugin-anchor" href="#conversion-between-basic-types"><i class="fa fa-link" aria-hidden="true"></i></a>Conversion between Basic types</h3>
<h4 id="implicit-conversion"><a name="implicit-conversion" class="plugin-anchor" href="#implicit-conversion"><i class="fa fa-link" aria-hidden="true"></i></a>Implicit conversion</h4>
<p>If an operator is used between two different types of variables, the compiler will implicitly convert one type to another (so is the assignment between different types). Generally speaking, as long as the conversion between value types is semantic and there is no information loss during the conversion process, implicit conversion is basically achievable:</p>
<p><code>uint8</code>can be converted <code>uint16</code>&#xFF0C;<code>int128</code> convert <code>int256</code>&#xFF0C;but <code>int8</code> cannot convert <code>uint256</code>&#xFF08;because <code>uint256</code> Some values cannot be covered, for example,<code>-1</code>&#xFF09;. furthermore, an unsigned integer can be converted to a byte type of the same size or larger as it, but vice versa. Any can be converted uint160 type of can be converted address type.</p>
<h4 id="explicit-conversion"><a name="explicit-conversion" class="plugin-anchor" href="#explicit-conversion"><i class="fa fa-link" aria-hidden="true"></i></a>Explicit conversion</h4>
<p>In some cases, if the compiler does not support implicit conversion, but you know what you want to do, explicit conversion can be considered. Note that this may have some unexpected consequences, so be sure to test and make sure the results are what you want! the following example is int8 Convert a negative number of the type uint :</p>
<pre><code class="lang-bash">int8 y = -3;
uint x = uint(y);
</code></pre>
<p>At the end of this code&#xFF0C;<code>x</code> value of will be <code>0xfffff..fd</code> &#xFF08;64 hexadecimal characters&#xFF09;&#xFF0C;because this is the 256-bit complement form of -3.</p>
<p>If a type is explicitly converted to a smaller type, the corresponding high order will be discarded:</p>
<pre><code class="lang-bash">uint32 a = 0x12345678;
uint16 b = uint16(a); // &#x6B64;&#x65F6; b &#x7684;&#x503C;&#x662F; 0x5678
</code></pre>
<h4 id="type-inference"><a name="type-inference" class="plugin-anchor" href="#type-inference"><i class="fa fa-link" aria-hidden="true"></i></a>Type inference</h4>
<p>For convenience, it is not necessary to specify the type of a variable precisely every time. The compiler automatically infers the type of the variable based on the type of the first expression that assigns the variable:</p>
<pre><code class="lang-bash">uint24 x = 0x123;
var y = x;
</code></pre>
<p>Here <code>y</code> The type of will be <code>uint24</code> . Cannot be used for function parameters or return parameters var .</p>
<blockquote>
<p>The type can only be inferred from the first assignment, so the loop in the following code is infinite because i The type of IS uint8 , and the maximum value ratio of this type of variable <code>2000</code> Small.<code>for (var i = 0; i &lt; 2000; i++) { ... }</code></p>
</blockquote>
<h2 id="unit-and-global-variables"><a name="unit-and-global-variables" class="plugin-anchor" href="#unit-and-global-variables"><i class="fa fa-link" aria-hidden="true"></i></a>Unit and global variables</h2>
<h3 id="sipc-unit"><a name="sipc-unit" class="plugin-anchor" href="#sipc-unit"><i class="fa fa-link" aria-hidden="true"></i></a>sipc unit</h3>
<p>The conversion between sipc units is to add after the number <code>wei</code>&#x3001; <code>finney</code>&#x3001; <code>szabo</code> or <code>ether</code> to implement, if there is no unit behind, the default is Wei. For example <code>2 ether == 2000 finney</code> logical judgment value of IS <code>true</code>&#x3002;</p>
<h3 id="time-unit"><a name="time-unit" class="plugin-anchor" href="#time-unit"><i class="fa fa-link" aria-hidden="true"></i></a>Time Unit</h3>
<p>Seconds is the default time unit, between time units, followed by numbers <code>seconds</code>&#x3001; <code>minutes</code>&#x3001; <code>hours</code>&#x3001; <code>days</code>&#x3001; <code>weeks</code> and <code>years</code> Can be converted, the basic conversion relationship is as follows:</p>
<ul>
<li><code>1 == 1 seconds</code></li>
<li><code>1 minutes == 60 seconds</code></li>
<li><code>1 hours == 60 minutes</code></li>
<li><code>1 days == 24 hours</code></li>
<li><code>1 weeks == 7 days</code></li>
<li><code>1 years == 365 days</code></li>
</ul>
<p>It is not 365 days a year and not 24 hours a day due to leap seconds <a href="https://en.wikipedia.org/wiki/Leap_second" target="_blank">leap seconds</a>&#xFF0C;so if you want to use these units to calculate the date and time, please pay attention to this problem. Because leap seconds cannot be predicted, an external prediction machine (oracle, an out-of-chain data service, noted by the translator) is required to correct the time of a certain date code base.</p>
<blockquote>
<p><code>years</code> Suffix is no longer recommended because it will no longer be supported from version 0.5.0.</p>
</blockquote>
<p>These suffixes cannot be used directly behind variables. If you want to convert the input variable to time in a unit of time (for example, days), you can do this as follows:</p>
<pre><code class="lang-sh">    <span class="hljs-keyword">function</span> f(uint start, uint daysAfter) public {
        <span class="hljs-keyword">if</span> (now &gt;= start + daysAfter * 1 days) {
            // ...
        }
    }
</code></pre>
<h3 id="special-variables-and-functions"><a name="special-variables-and-functions" class="plugin-anchor" href="#special-variables-and-functions"><i class="fa fa-link" aria-hidden="true"></i></a>Special variables and functions</h3>
<p>Some special variables and functions already exist (by default) in the global namespace, which are mainly used to provide information about the block chain or some common tool functions.</p>
<p>.. index:: abi, block, coinbase, difficulty, encode, number, block;number, timestamp, block;timestamp, msg, data, gas, sender, value, now, gas price, origin</p>
<h4 id="block-and-transaction-attributes"><a name="block-and-transaction-attributes" class="plugin-anchor" href="#block-and-transaction-attributes"><i class="fa fa-link" aria-hidden="true"></i></a>Block and transaction attributes</h4>
<ul>
<li><code>block.blockhash(uint blockNumber) returns (bytes32)</code>&#xFF1A;The block hash of the specified block-can only be used for the latest 256 blocks, excluding the current block. blocks are not recommended since version 0.4.22 <code>blockhash(uint blockNumber)</code> replace</li>
<li><code>block.coinbase</code> (<code>address</code>): dig out the miner address of the current block</li>
<li><code>block.difficulty</code> (<code>uint</code>): current block difficulty</li>
<li><code>block.gaslimit</code> (<code>uint</code>): current block gas limit</li>
<li><code>block.number</code> (<code>uint</code>): current block number</li>
<li><code>block.timestamp</code> (<code>uint</code>): the timestamp in seconds of the current block starting from the unix azone.</li>
<li><code>gasleft() returns (uint256)</code>&#xFF1A;the remaining gas</li>
<li><code>msg.data</code> (<code>bytes</code>): complete calldata</li>
<li><code>msg.gas</code> (<code>uint</code>): residual gas-is not recommended since version 0.4.21, <code>gesleft()</code> replace</li>
<li><code>msg.sender</code> (<code>address</code>): Message sender (current call)</li>
<li><code>msg.sig</code> (<code>bytes4</code>): cthe first 4 bytes of calldata (that is, the function identifier)</li>
<li><code>msg.value</code> (<code>uint</code>): The number of wei sent with the message</li>
<li><code>now</code> (<code>uint</code>): current block timestamp&#xFF08;<code>block.timestamp</code>&#xFF09;</li>
<li><code>tx.gasprice</code> (<code>uint</code>): The gas price of the transaction</li>
<li><code>tx.origin</code> (<code>address</code>): transaction initiator (full call chain)</li>
</ul>
<blockquote>
<p> For each <code>External function</code> call, including <code>msg.sender</code> and <code>msg.value</code> all included <code>msg</code> The value of the member changes. This includes calls to library functions.</p>
<p> Do not rely on <code>block.timestamp</code>&#x3001; <code>now</code> and <code>blockhash</code> generate random numbers unless you know what you are doing. The timestamp and block Hash may be affected by miners to some extent. For example, malicious miners in the mining community can use a given hash to run the payout function of casino contracts, and if they do not receive money, they can also try again with a different hash. The timestamp of the current block must be strictly greater than that of the last block. However, the only thing that can be ensured here is the value between the timestamps of the two consecutive blocks on the authoritative chain.</p>
<p> Based on the scalability factor, the block hash is not valid for all blocks. You can only access the hashes of the last 256 blocks, and the remaining hashes are zero.</p>
</blockquote>
<h3 id="abi-coding-function"><a name="abi-coding-function" class="plugin-anchor" href="#abi-coding-function"><i class="fa fa-link" aria-hidden="true"></i></a>ABI coding function</h3>
<ul>
<li><code>abi.encode(...) returns (bytes)</code>&#xFF1A;<code>ABI</code>encode the given parameters</li>
<li><code>abi.encodePacked(...) returns (bytes)</code>&#xFF1A;execute the given parameter<code>&#x7D27;&#x6253;&#x5305;&#x7F16;&#x7801;</code></li>
<li><code>abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)</code>&#xFF1A;<code>ABI</code> encode the given parameter and return the 4-byte data starting with the given function selector.</li>
<li><code>abi.encodeWithSignature(string signature, ...) returns (bytes)</code>:equivalent <code>abi.encodeWithSelector(bytes4(keccak256(signature), ...)</code></li>
</ul>
<blockquote>
<p>These encoding functions can be used to construct function call data without actually calling. In addition, <code>keccak256(abi.encodePacked(a, b))</code> is a more accurate method to calculate what is not recommended in future versions<code>keccak256(a, b)</code>&#x3002;</p>
</blockquote>
<p>For more details, see <code>ABI</code> and <code>&#x7D27;&#x6253;&#x5305;&#x7F16;&#x7801;</code>&#x3002;</p>
<h4 id="error-handling"><a name="error-handling" class="plugin-anchor" href="#error-handling"><i class="fa fa-link" aria-hidden="true"></i></a>Error handling</h4>
<p><code>assert(bool condition)</code>: If the conditions are not met, the current transaction is ineffective-used to check for internal errors.</p>
<p><code>require(bool condition)</code>: Revoke state changes if conditions are not met-used to check for errors caused by input or external components.</p>
<p><code>require(bool condition, string message)</code>: Revoke state changes if conditions are not met-used to check for errors caused by input or external components, an error message can be provided at the same time.</p>
<p><code>revert()</code>: Terminate the operation and cancel the status change.</p>
<p><code>revert(string reason)</code>: Terminating the operation and canceling state changes can provide an explanatory string at the same time.</p>
<h4 id="mathematical-and-cryptographic-functions"><a name="mathematical-and-cryptographic-functions" class="plugin-anchor" href="#mathematical-and-cryptographic-functions"><i class="fa fa-link" aria-hidden="true"></i></a>Mathematical and cryptographic functions</h4>
<p><code>addmod(uint x, uint y, uint k) returns (uint)</code>:calculation <code>(x + y) % k</code>&#xFF0C;addition will be executed at any precision, and even if the result of addition exceeds <code>2**256</code> it will not be intercepted. Starting from the compiler version 0.5.0 <code>k != 0</code> verify&#xFF08;assert&#xFF09;&#x3002;</p>
<p><code>mulmod(uint x, uint y, uint k) returns (uint)</code>:calculation <code>(x * y) % k</code>&#xFF0C;multiplication is executed at any precision, and even if the result of multiplication exceeds <code>2**256</code> it will not be intercepted. Starting from the compiler version 0.5.0 <code>k != 0</code> verify&#xFF08;assert&#xFF09;&#x3002;</p>
<p><code>keccak256(...) returns (bytes32)</code>: calculation :ref:<code>(tightly packed) arguments &lt;abi_packed_mode&gt;</code>  Ethereum-SHA-3 &#xFF08;Keccak-256&#xFF09;hash&#x3002;</p>
<p><code>sha256(...) returns (bytes32)</code>:calculation :ref:<code>(tightly packed) arguments &lt;abi_packed_mode&gt;</code>  SHA-256 hash&#x3002;</p>
<p><code>sha3(...) returns (bytes32)</code>:equivalent to keccak256&#x3002;</p>
<p><code>ripemd160(...) returns (bytes20)</code>:calculation :ref:<code>(tightly packed) arguments &lt;abi_packed_mode&gt;</code>  RIPEMD-160 hash&#x3002;</p>
<p><code>ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)</code> Use the elliptic curve signature to restore the address related to the public key. An error returns a zero value. <a href="https://ethereum.stackexchange.com/q/1777/222" target="_blank">example usage</a></p>
<p>Above <code>tightly packed</code> does not perform parameter values <code>padding</code> processing (that is, the bytecode of all parameter values is stored continuously, translator&apos;s note), which means that the following calls are equivalent:</p>
<pre><code>keccak256(&quot;ab&quot;, &quot;c&quot;)
keccak256(&quot;abc&quot;)
keccak256(0x616263)
keccak256(6382179)
keccak256(97, 98, 99)
</code></pre><p>If padding is required, you can use explicit type conversion: <code>keccak256(&quot;\x00\x12&quot;)</code> and <code>keccak256(uint16(0x12))</code> it&apos;s the same.</p>
<p>Note that constant values are packaged using the minimum number of bytes required to store them. For example&#xFF1A;<code>keccak256(0) == keccak256(uint8(0))</code>&#xFF0C;<code>keccak256(0x12345678) == keccak256(uint32(0x12345678))</code>&#x3002;</p>
<p>On a private chain, you are likely to encounter <code>sha256</code>&#x3001;<code>ripemd160</code> or <code>ecrecover</code> caused by Out-of-Gas. The reason is that these cryptographic functions exist in the form of &quot;precompiled contracts&quot; in Simplechain virtual machines, and it does not really exist until the first time you receive the message (although the contract code is a hard code already existing in EVM). Therefore, messages sent to non-existent contracts are very expensive, so actual execution will lead to Out-of-Gas errors. Before you actually use your contract, send a little Sipc to each contract, such as 1 Wei. This is not a problem on the official network or test network.</p>
<h4 id="address-related"><a name="address-related" class="plugin-anchor" href="#address-related"><i class="fa fa-link" aria-hidden="true"></i></a>Address-related</h4>
<p><code>&lt;address&gt;.balance</code> (<code>uint256</code>):in Wei :ref:<code>address</code> balance</p>
<p><code>&lt;address&gt;.transfer(uint256 amount)</code>:to :ref:<code>address</code> if the number of Wei sent is the amount, an exception is thrown when the error occurs. The miner fee for sending 2300 gas cannot be adjusted.</p>
<p><code>&lt;address&gt;.send(uint256 amount) returns (bool)</code>:to :ref:<code>address</code> the number of Wei sent is amount. If the number fails, the system returns <code>false</code>&#xFF0C;miner&apos;s fee for sending 2300 gas cannot be adjusted.</p>
<p><code>&lt;address&gt;.call(...) returns (bool)</code>:issue low-level functions <code>CALL</code>&#xFF0C;if it fails, return <code>false</code>&#xFF0C;send all available gas, adjustable.</p>
<p><code>&lt;address&gt;.callcode(...) returns (bool)</code>&#xFF1A;issue low-level functions <code>CALLCODE</code>&#xFF0C;if it fails, return <code>false</code> , send all available gas, adjustable.</p>
<p><code>&lt;address&gt;.delegatecall(...) returns (bool)</code>:issue low-level functions <code>DELEGATECALL</code>&#xFF0C;if it fails, return <code>false</code>&#xFF0C;send all available gas,adjustable.</p>
<blockquote>
<p>There are many dangers when using send: if the call stack depth has reached 1024 (which can always be forcibly specified by the caller), the transfer will fail; And if the receiver uses up the gas, the transfer will also fail. In order to ensure the security of Ethernet currency transfer, always check <code>send</code> The return value of, using <code>transfer</code> Or the following is a better way: use this mode of receiving money back.</p>
<p> If you need to access the variables in the storage when you use the low-level function delegatecall to initiate a call, the variables in the storage of the two contracts must be defined in the same order, so that the called contract code can correctly access the contract&apos;s storage variables through the variable name. Of course, this does not refer to the situation like the stored variable pointer passed when an advanced library function is called.</p>
<p> Use is not encouraged <code>callcode</code> , and it will be removed in the future.</p>
</blockquote>
<p>Contract-related</p>
<p><code>this</code> (current contract&apos;s type):current contract, which can be explicitly converted to <code>address</code>&#x3002;</p>
<p><code>selfdestruct(address recipient)</code>:destroy the contract and send the balance to the specified <code>address</code>&#x3002;</p>
<p><code>suicide(address recipient)</code>:equivalent to selfdestruct, but not recommended.</p>
<p>In addition, all functions in the current contract can be called directly, including the current function.</p>
<h2 id="expression-and-control-structure"><a name="expression-and-control-structure" class="plugin-anchor" href="#expression-and-control-structure"><i class="fa fa-link" aria-hidden="true"></i></a>Expression and control structure</h2>
<h3 id="input-and-output-parameters"><a name="input-and-output-parameters" class="plugin-anchor" href="#input-and-output-parameters"><i class="fa fa-link" aria-hidden="true"></i></a>Input and output parameters</h3>
<p>Like Javascript, functions may require parameters as input; Unlike Javascript and C, they may return any number of parameters as output.</p>
<h4 id="input-parameters"><a name="input-parameters" class="plugin-anchor" href="#input-parameters"><i class="fa fa-link" aria-hidden="true"></i></a>Input parameters</h4>
<p>Input parameters are declared in the same way as variables. However, one exception is that unused parameters can omit parameter names.
For example, if we want the contract to accept external calls to functions with two integer parameters, we will write as follows</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.16;

    contract Simple {
        <span class="hljs-keyword">function</span> taker(uint _a, uint _b) public pure {
            // &#x7528; _a &#x548C; _b &#x5B9E;&#x73B0;&#x76F8;&#x5173;&#x529F;&#x80FD;.
        }
    }
</code></pre>
<h4 id="output-parameters"><a name="output-parameters" class="plugin-anchor" href="#output-parameters"><i class="fa fa-link" aria-hidden="true"></i></a>Output parameters</h4>
<p>The declaration method of the output parameter is in the keyword returns After that, the declaration method is the same as that of the input parameters.
For example, if we need to return two results: the sum and product of two given integers, we should write</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.16;

    contract Simple {
        <span class="hljs-keyword">function</span> arithmetics(uint _a, uint _b)
            public
            pure
            returns (uint o_sum, uint o_product)
        {
            o_sum = _a + _b;
            o_product = _a * _b;
        }
    }
</code></pre>
<p>The output parameter name can be omitted. The output value can also be used <code>return</code> Statement specifies.
return Statement can also return multiple values, The returned output parameters are initialized to 0; If they are not explicitly assigned, they are always 0.</p>
<p>Input and output parameters can be used as expressions in function bodies. Therefore, they can also be assigned to the left of the equal sign.</p>
<h3 id="control-structure"><a name="control-structure" class="plugin-anchor" href="#control-structure"><i class="fa fa-link" aria-hidden="true"></i></a>Control Structure</h3>
<p>Most control structures in JavaScript are available in Solidity, <code>switch</code> And <code>goto</code> . Therefore, there are <code>if</code>&#xFF0C;<code>else</code>&#xFF0C;<code>while</code>&#xFF0C;<code>do</code>&#xFF0C;<code>for</code>&#xFF0C;<code>break</code>&#xFF0C;<code>continue</code>&#xFF0C;<code>return</code>&#xFF0C;<code>? :</code> these keywords express the same semantics as in C or JavaScript.</p>
<p>Brackets used to represent conditions No. If it is omitted, the braces on both sides of the single statement body can be omitted. Note that unlike C and JavaScript, non-Boolean values in Solidity cannot be converted to Boolean types, so <code>if (1) { ... }</code> write in Solidity in Invalid .</p>
<h3 id="returns-multiple-values"><a name="returns-multiple-values" class="plugin-anchor" href="#returns-multiple-values"><i class="fa fa-link" aria-hidden="true"></i></a>Returns multiple values</h3>
<p>When a function has multiple output parameters, <code>return (v0, v1, ...,vn)</code> you can return multiple values. However, the number of elements must be the same as the number of output parameters.</p>
<h3 id="function-call"><a name="function-call" class="plugin-anchor" href="#function-call"><i class="fa fa-link" aria-hidden="true"></i></a>Function call</h3>
<h4 id="internal-function-call"><a name="internal-function-call" class="plugin-anchor" href="#internal-function-call"><i class="fa fa-link" aria-hidden="true"></i></a>Internal function call</h4>
<p>The functions in the current contract can be called directly (&quot;from inside&quot;) or recursively, just like the ridiculous example below.</p>
<pre><code class="lang-bash">
    pragma solidity ^0.4.16;

    contract C {
        <span class="hljs-keyword">function</span> g(uint a) public pure returns (uint ret) { <span class="hljs-built_in">return</span> f(); }
        <span class="hljs-keyword">function</span> f() internal pure returns (uint ret) { <span class="hljs-built_in">return</span> g(7) + f(); }
    }
</code></pre>
<p>These function calls are interpreted as simple redirection in EVM. The effect of this is that the current memory will not be cleared, that is, passing memory references between functions through internal calls is very effective.</p>
<h4 id="external-function-call"><a name="external-function-call" class="plugin-anchor" href="#external-function-call"><i class="fa fa-link" aria-hidden="true"></i></a>External function call</h4>
<p>Expression <code>this.g(8);</code> and <code>c.g(2);</code> &#xFF08;among them <code>c</code> is a contract instance&#xFF09;is also a valid function call, but in this case, the function will be &quot;called externally&quot; through a message call, rather than directly jump. Note that this function cannot be called in the constructor because the real contract instance has not been created yet.</p>
<p>If you want to call functions of other contracts, you need to call them externally. For an external call, all function parameters need to be copied to memory.</p>
<p>When calling functions of other contracts, the number of Wei and gas sent along with the function call can be determined by specific options respectively .value() And .gas() Specify:</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.0;

    contract InfoFeed {
        <span class="hljs-keyword">function</span> info() public payable returns (uint ret) { <span class="hljs-built_in">return</span> 42; }
    }

    contract Consumer {
        InfoFeed feed;
        <span class="hljs-keyword">function</span> <span class="hljs-built_in">set</span>Feed(address addr) public { feed = InfoFeed(addr); }
        <span class="hljs-keyword">function</span> callFeed() public { feed.info.value(10).gas(800)(); }
    }
</code></pre>
<p><code>payable</code> modifiers should be used for Modifiers <code>info</code>&#xFF0C;otherwise&#xFF0C;<code>.value()</code> options will not be available.</p>
<p>Note, expression <code>InfoFeed(addr)</code> an explicit type conversion was performed, indicating that &quot;we know that the contract type for a given address is <code>InfoFeed</code> &#x201C;and this will not execute the constructor. Explicit type conversion requires caution. Never execute a function call on a contract that you do not know the type.</p>
<p>We can also use it directly <code>function setFeed(InfoFeed _feed) { feed = _feed; }</code> &#x3002;
pay attention to a fact&#xFF0C;<code>feed.info.value(10).gas(800)</code> only (partially) the number of Wei values and gas values sent together with the function call is set, and only the final parentheses execute the real call. if the contract where the function is called does not exist (that is, the account does not contain code) or the called contract itself throws an exception or gas runs out, the function call throws an exception.</p>
<blockquote>
<p>   Any interaction with other contracts will impose potential dangers, especially when the contract code cannot be known in advance.
The current contract transfers control to the invoked contract, and the invoked contract may do anything. Even if the called contract is inherited from a known parent contract, the inherited contract only needs to have a correct interface.
The implementation of the called contract can be completely arbitrary, thus bringing danger. In addition, be careful in case it calls other contracts in your system again, or even returns your call contract before the first call returns.
This means that the called contract can change the state variables of the called contract through its own functions.. A suggested function writing method is, for example, calling external functions after various changes have been made to the state variables in your contract, so that your contract will not be easily abused reentrancy (reentrancy) affected</p>
</blockquote>
<h3 id="named-calls-and-anonymous-function-parameters"><a name="named-calls-and-anonymous-function-parameters" class="plugin-anchor" href="#named-calls-and-anonymous-function-parameters"><i class="fa fa-link" aria-hidden="true"></i></a>Named calls and anonymous function parameters</h3>
<p>If they are included in <code>{}</code> Function call parameters can also be given by name in any order,
As shown in the following example. The parameter list must match the parameter list in the function declaration by name, but can be arranged in any order.</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.0;

    contract C {
        <span class="hljs-keyword">function</span> f(uint key, uint value) public {
            // ...
        }

        <span class="hljs-keyword">function</span> g() public {
            // &#x5177;&#x540D;&#x53C2;&#x6570;
            f({value: 2, key: 3});
        }
    }
</code></pre>
<h3 id="omit-the-function-parameter-name"><a name="omit-the-function-parameter-name" class="plugin-anchor" href="#omit-the-function-parameter-name"><i class="fa fa-link" aria-hidden="true"></i></a>Omit the function parameter name</h3>
<p>Names of unused parameters (especially returned parameters) can be omitted. These parameters still exist in the stack, but they cannot be accessed.</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.16;

    contract C {
        // &#x7701;&#x7565;&#x53C2;&#x6570;&#x540D;&#x79F0;
        <span class="hljs-keyword">function</span> func(uint k, uint) public pure returns(uint) {
            <span class="hljs-built_in">return</span> k;
        }
    }
</code></pre>
<h3 id="&#x901A;pass-new-create-a-contract"><a name="&#x901A;pass-new-create-a-contract" class="plugin-anchor" href="#&#x901A;pass-new-create-a-contract"><i class="fa fa-link" aria-hidden="true"></i></a>&#x901A;Pass <code>new</code> Create a contract</h3>
<p>Use keywords new You can create a new contract. The complete code of the contract to be created must be known in advance, so recursive dependency creation is impossible.</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.0;

    contract D {
        uint x;
        <span class="hljs-keyword">function</span> D(uint a) public payable {
            x = a;
        }
    }

    contract C {
        D d = new D(4); // &#x5C06;&#x4F5C;&#x4E3A;&#x5408;&#x7EA6; C &#x6784;&#x9020;&#x51FD;&#x6570;&#x7684;&#x4E00;&#x90E8;&#x5206;&#x6267;&#x884C;

        <span class="hljs-keyword">function</span> createD(uint arg) public {
            D newD = new D(arg);
        }

        <span class="hljs-keyword">function</span> createAndEndowD(uint arg, uint amount) public payable {
            //&#x968F;&#x5408;&#x7EA6;&#x7684;&#x521B;&#x5EFA;&#x53D1;&#x9001; ether
            D newD = (new D).value(amount)(arg);
        }
    }
</code></pre>
<p>&#x5982;As shown in the example, use <code>.value&#xFF08;&#xFF09;</code> Option creation <code>D</code> The Ether can be forwarded to the instance, but it is impossible to limit the amount of gas. If the creation fails (possibly because of Stack Overflow, or insufficient balance or other problems), an exception is thrown.</p>
<h3 id="expression-calculation-order"><a name="expression-calculation-order" class="plugin-anchor" href="#expression-calculation-order"><i class="fa fa-link" aria-hidden="true"></i></a>Expression Calculation order</h3>
<p>The order of expression calculation is not specific (more precisely, the order of calculation between byte points of a node in the expression tree is not specific, but their settlement will certainly be before the node&apos;s own settlement). This rule can only ensure that the statements are executed in sequence and the short circuit of Boolean expressions is executed. For more information&#x3002;</p>
<h3 id="assignment"><a name="assignment" class="plugin-anchor" href="#assignment"><i class="fa fa-link" aria-hidden="true"></i></a>Assignment</h3>
<h4 id="deconstruct-assignment-and-return-multiple-values"><a name="deconstruct-assignment-and-return-multiple-values" class="plugin-anchor" href="#deconstruct-assignment-and-return-multiple-values"><i class="fa fa-link" aria-hidden="true"></i></a>Deconstruct assignment and return multiple values</h4>
<p>Solidity internally allows tuple class&#xFF0C;which is a list of objects with a fixed number of elements at compile time. The elements in the list can be different types of objects. These tuples can be used to return multiple values at the same time, or they can be used to simultaneously give multiple newly declared variables or existing variables (or common LValues):</p>
<pre><code class="lang-bash">
    pragma solidity &gt;0.4.23 &lt;0.5.0;

    contract C {
        uint[] data;

        <span class="hljs-keyword">function</span> f() public pure returns (uint, bool, uint) {
            <span class="hljs-built_in">return</span> (7, <span class="hljs-literal">true</span>, 2);
        }

        <span class="hljs-keyword">function</span> g() public {
            //&#x57FA;&#x4E8E;&#x8FD4;&#x56DE;&#x7684;&#x5143;&#x7EC4;&#x6765;&#x58F0;&#x660E;&#x53D8;&#x91CF;&#x5E76;&#x8D4B;&#x503C;
            (uint x, bool b, uint y) = f();
            //&#x4EA4;&#x6362;&#x4E24;&#x4E2A;&#x503C;&#x7684;&#x901A;&#x7528;&#x7A8D;&#x95E8;&#x2014;&#x2014;&#x4F46;&#x4E0D;&#x9002;&#x7528;&#x4E8E;&#x975E;&#x503C;&#x7C7B;&#x578B;&#x7684;&#x5B58;&#x50A8; (storage) &#x53D8;&#x91CF;&#x3002;
            (x, y) = (y, x);
            //&#x5143;&#x7EC4;&#x7684;&#x672B;&#x5C3E;&#x5143;&#x7D20;&#x53EF;&#x4EE5;&#x7701;&#x7565;&#xFF08;&#x8FD9;&#x4E5F;&#x9002;&#x7528;&#x4E8E;&#x53D8;&#x91CF;&#x58F0;&#x660E;&#xFF09;&#x3002;
            (data.length,,) = f(); // &#x5C06;&#x957F;&#x5EA6;&#x8BBE;&#x7F6E;&#x4E3A; 7
            //&#x7701;&#x7565;&#x5143;&#x7EC4;&#x4E2D;&#x672B;&#x5C3E;&#x5143;&#x7D20;&#x7684;&#x5199;&#x6CD5;&#xFF0C;&#x4EC5;&#x53EF;&#x4EE5;&#x5728;&#x8D4B;&#x503C;&#x64CD;&#x4F5C;&#x7684;&#x5DE6;&#x4FA7;&#x4F7F;&#x7528;&#xFF0C;&#x9664;&#x4E86;&#x8FD9;&#x4E2A;&#x4F8B;&#x5916;&#xFF1A;
            (x,) = (1,);
            //(1,) &#x662F;&#x6307;&#x5B9A;&#x5355;&#x5143;&#x7D20;&#x5143;&#x7EC4;&#x7684;&#x552F;&#x4E00;&#x65B9;&#x6CD5;&#xFF0C;&#x56E0;&#x4E3A; (1)
            //&#x76F8;&#x5F53;&#x4E8E; 1&#x3002;
        }
    }
</code></pre>
<blockquote>
<p>Until version 0.4.24, it is possible to assign values to tuples with fewer elements, whether on the left or on the right (for example, several elements are left at the end). Now, this is not recommended. Both sides of the assignment operation should have the same number of constituent elements.</p>
</blockquote>
<h3 id="complexity-of-arrays-and-structures"><a name="complexity-of-arrays-and-structures" class="plugin-anchor" href="#complexity-of-arrays-and-structures"><i class="fa fa-link" aria-hidden="true"></i></a>Complexity of arrays and structures</h3>
<p>Assignment semantics is somewhat complicated for non-value types such as arrays and structures.
Is a state variable Assignment A standalone copy is often created. On the other hand, the assignment of local variables only creates an independent copy for the basic type (that is, the static type within 32 bytes). If a structure or array (including <code>bytes</code> And <code>string</code> ) is assigned from the state variable to the local variable, the local variable will retain the reference to the original state variable. The second assignment to a local variable does not modify the state variable, but only changes the reference. If a member or element is assigned to a local variable Change State variables.</p>
<h3 id="scope-and-declaration"><a name="scope-and-declaration" class="plugin-anchor" href="#scope-and-declaration"><i class="fa fa-link" aria-hidden="true"></i></a>Scope and declaration</h3>
<p>A variable is declared with a default initial value, whose initial value bytes indicate all zero. The default value of any type variable is the typical zero state of its corresponding type &quot;. For example, <code>bool</code> default value of the type is <code>false</code> . <code>uint</code> or <code>int</code> default value of the type is <code>0</code>. For static size arrays and <code>bytes1</code>  to <code>bytes32</code> &#xFF0C;each individual element will be initialized to the default value corresponding to its type.
Finally, for an array of dynamic size. <code>bytes</code> and <code>string</code> type&#xFF0C;default default value is an empty array or string.</p>
<p>Scope rules in Solidity follow C99 (like many other languages): variables will be visible after they are declared until a pair <code>{ }</code> The end of the block. As an exception, the visibility of variables initialized in the for loop statement is maintained only until the end of the for loop.</p>
<p>Variables defined outside code blocks, such as functions, contracts, and custom types, do not affect their scope properties. This means that you can use state variables before actually declaring statements and call functions recursively.</p>
<p>Based on the above rules, compilation warnings will not appear in the following example, because the two variables have the same name but are in different scopes.</p>
<pre><code class="lang-bash">
    pragma solidity &gt;0.4.24;
    contract C {
        <span class="hljs-keyword">function</span> minimalScoping() pure public {
            {
                uint same2 = 0;
            }

            {
                uint same2 = 0;
            }
        }
    }
</code></pre>
<p>As a special case of a C99 scope rule, note that in the following example, for the first time <code>x</code> assignment of changes the variable values declared in the previous layer. If the variables declared outside are &quot;shadowed&quot; (that is, replaced by a variable with the same name in the internal scope), you will receive a warning.</p>
<pre><code class="lang-bash">    pragma solidity &gt;0.4.24;
    contract C {
        <span class="hljs-keyword">function</span> f() pure public returns (uint) {
            uint x = 1;
            {
                x = 2; // &#x8FD9;&#x4E2A;&#x8D4B;&#x503C;&#x4F1A;&#x5F71;&#x54CD;&#x5728;&#x5916;&#x5C42;&#x58F0;&#x660E;&#x7684;&#x53D8;&#x91CF;
                uint x;
            }
            <span class="hljs-built_in">return</span> x; // x has value 2
        }
    }
</code></pre>
<blockquote>
<p> Earlier than Solidity 0.5.0, Javascript rules were used for scope rules. That is, a variable can be declared anywhere in the function and can be visible throughout the function. This rule will be broken from version 0.5.0. Starting with version 0.5.0, the code segment in the following example will cause compilation errors.</p>
</blockquote>
<pre><code class="lang-bash">
    // &#x8FD9;&#x5C06;&#x65E0;&#x6CD5;&#x7F16;&#x8BD1;&#x901A;&#x8FC7;

    pragma solidity &gt;0.4.24;
    contract C {
        <span class="hljs-keyword">function</span> f() pure public returns (uint) {
            x = 2;
            uint x;
            <span class="hljs-built_in">return</span> x;
        }
    }
</code></pre>
<h3 id="error-handling&#xFF1A;assert-require-revert-and-exceptions"><a name="error-handling&#xFF1A;assert-require-revert-and-exceptions" class="plugin-anchor" href="#error-handling&#xFF1A;assert-require-revert-and-exceptions"><i class="fa fa-link" aria-hidden="true"></i></a>Error handling&#xFF1A;Assert, Require, Revert and Exceptions</h3>
<p>Solidity uses status recovery exceptions to handle errors. This exception cancels all changes made to the status of the current call and all its sub-calls and marks the caller with an error. Convenience function <code>assert</code> and <code>require</code> can be used to check conditions and throw exceptions when conditions are not met. <code>assert</code> functions can only be used to test internal errors and check non-variables.</p>
<p><code>require</code> function is used to confirm condition validity, such as input variable, or contract status variable meets the condition, or to verify the value returned by external contract call. If used properly, the analysis tool can evaluate your contract and mark those that will <code>assert</code> Failed conditions and function calls. Normal code does not cause an assert statement to fail. If this happens, a bug that you need to fix appears.</p>
<p>There are two other ways to trigger an exception: <code>revert</code> functions can be used to mark errors and restore the current call.
<code>revert</code> It is possible that the call contains detailed information about the error, and this message is returned to the caller. Keywords that are not recommended <code>throw</code> can also be used to replace <code>revert()</code> &#xFF08;but unable to return an error message.&#xFF09;.</p>
<blockquote>
<p>Starting from version <code>0.4.13</code>, throw this keyword has been abandoned and will be gradually eliminated in the future.</p>
</blockquote>
<p>When a sub-call exception occurs, they automatically &quot;bubble&quot; (that is, throw an exception again). The exception to this rule is <code>send</code> and low-level functions <code>call</code> &#xFF0C; <code>delegatecall</code> and <code>callcode</code> -- If these functions are abnormal, false is returned instead of bubbling &quot;.</p>
<blockquote>
<p> As part of the EVM design, if the called contract account does not exist, the low-level function <code>call</code> , <code>delegatecall</code> And <code>callcode</code> success is returned. Therefore, if you need to use low-level functions, you must check whether the called contract exists before calling. Exception capture has not been implemented</p>
</blockquote>
<p>In the following example, you can see how to use it easily <code>require</code> Check input conditions and how to use them <code>assert</code> Check for internal errors. Note that you can give <code>require</code> Provides a message string, and <code>assert</code> No.</p>
<pre><code class="lang-bash">
    pragma solidity ^0.4.22;

    contract Sharer {
        <span class="hljs-keyword">function</span> sendHalf(address addr) public payable returns (uint balance) {
            require(msg.value % 2 == 0, <span class="hljs-string">&quot;Even value required.&quot;</span>);
            uint balanceBeforeTransfer = this.balance;
            addr.transfer(msg.value / 2);
            //&#x7531;&#x4E8E;&#x8F6C;&#x79FB;&#x51FD;&#x6570;&#x5728;&#x5931;&#x8D25;&#x65F6;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x5E76;&#x4E14;&#x4E0D;&#x80FD;&#x5728;&#x8FD9;&#x91CC;&#x56DE;&#x8C03;&#xFF0C;&#x56E0;&#x6B64;&#x6211;&#x4EEC;&#x5E94;&#x8BE5;&#x6CA1;&#x6709;&#x529E;&#x6CD5;&#x4ECD;&#x7136;&#x6709;&#x4E00;&#x534A;&#x7684;&#x94B1;&#x3002;
            assert(this.balance == balanceBeforeTransfer - msg.value / 2);
            <span class="hljs-built_in">return</span> this.balance;
        }
    }
</code></pre>
<p>One of the following situations will be generated <code>assert</code> Type exception:</p>
<ul>
<li>If the index of the array you access is too large or negative&#xFF08;for example <code>x[i]</code> of which <code>i &gt;= x.length</code> or <code>i &lt; 0</code>&#xFF09;&#x3002;</li>
<li>If you access a fixed length <code>bytesN</code> index of is too large or negative.</li>
<li>If you use zero as a divisor for division or modulo&#xFF08;for example <code>5 / 0</code> or <code>23 % 0</code> &#xFF09;&#x3002;</li>
<li>If you shift negative digits.</li>
<li>If you convert a too large or negative value to an enumeration type.</li>
<li>If you call a zero-initialization variable of the internal function type.</li>
<li>If you call <code>assert</code> final settlement of the parameter (expression) is false.</li>
</ul>
<p>One of the following situations will be generated <code>require</code> type exception:</p>
<ul>
<li>call <code>throw</code> &#x3002;</li>
<li>If you call <code>require</code> final settlement of the parameter (expression) is <code>false</code> &#x3002;</li>
<li>If you call a function through a message, but the function does not end correctly (it runs out of gas, does not match the function, or throws an exception itself), the above function does not include low-level operations. <code>call</code> &#xFF0C; <code>send</code> &#xFF0C; <code>delegatecall</code> or <code>callcode</code> . A low-level operation does not throw an exception but returns false To indicate <code>failure</code>.</li>
<li>If you use <code>new</code> Keyword creates a contract, but the contract was not created correctly (see the definition of &quot;not completed correctly&quot; in the above article).</li>
<li>If you execute an external function call on a contract that does not contain code.</li>
<li>If your contract passes one payable Public functions of modifiers (including constructors and fallback functions) receive Ether.</li>
<li>If your contract receives Ether through the public getter function.</li>
<li>If .transfer() Failed.</li>
</ul>
<p>Internally, Solidity for a <code>require</code> abnormal execution rollback operation (instruction <code>0xfd</code> ) and execute an invalid operation (instruction <code>0xfe</code> ) to trigger assert Abnormal formula. In both cases, EVM will roll back all changes made to the state. The reason for the rollback is that it cannot continue to be safely executed because the expected effect has not been achieved. Because we want to retain the atomicity of the transaction, the safest way is to roll back all changes and make the entire transaction (or at least called) ineffective. Please note, assert The type exception consumes all available call gas, and from the Metropolis version require The abnormality of the formula will not consume any gas.</p>
<p>The following example shows how to use error strings in Invocation and require:</p>
<pre><code class="lang-bash">
    pragma solidity ^0.4.22;

    contract VendingMachine {
        <span class="hljs-keyword">function</span> buy(uint amount) payable {
            <span class="hljs-keyword">if</span> (amount &gt; msg.value / 2 ether)
                revert(<span class="hljs-string">&quot;Not enough Ether provided.&quot;</span>);
            // &#x4E0B;&#x8FB9;&#x662F;&#x7B49;&#x4EF7;&#x7684;&#x65B9;&#x6CD5;&#x6765;&#x505A;&#x540C;&#x6837;&#x7684;&#x68C0;&#x67E5;&#xFF1A;
            require(
                amount &lt;= msg.value / 2 ether,
                <span class="hljs-string">&quot;Not enough Ether provided.&quot;</span>
            );
            // &#x6267;&#x884C;&#x8D2D;&#x4E70;&#x64CD;&#x4F5C;
        }
    }
</code></pre>
<p>The string provided here should go through:<code>ABI &#x7F16;&#x7801;</code> later, because it is actually called <code>Error(string)</code> function. In the above example,<code>revert(&quot;Not enough Ether provided.&quot;);</code> following hexadecimal error return value is generated:</p>
<ul>
<li>0x08c379a0                                                         // Error(string) function selector</li>
<li>0x0000000000000000000000000000000000000000000000000000000000000020 // data offset&#xFF08;32&#xFF09;</li>
<li>0x000000000000000000000000000000000000000000000000000000000000001a // string length&#xFF08;26&#xFF09;</li>
<li>0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // string data&#xFF08;ASCII encoding of &quot;Not enough Ether provided.&quot;, 26 bytes&#xFF09;</li>
</ul>
<h2 id="contract"><a name="contract" class="plugin-anchor" href="#contract"><i class="fa fa-link" aria-hidden="true"></i></a>Contract</h2>
<p><code>Solidity</code> Contracts are similar to classes in object-oriented languages. The contract contains state variables for data persistence and functions that can modify state variables. When a function of another contract instance is called, an EVM function is called. This operation switches the context of the execution, so that the status variable of the previous contract cannot be accessed.</p>
<h3 id="create-a-contract"><a name="create-a-contract" class="plugin-anchor" href="#create-a-contract"><i class="fa fa-link" aria-hidden="true"></i></a>Create a contract</h3>
<p>You can create contracts &quot;from outside&quot; through Simplechain transactions or from inside Solidity contracts.</p>
<p>Some integrated development environments, such <a href="https://remix.ethereum.org/" target="_blank">Remix</a>, through the use of some user interface elements to make the creation process more smooth. You &apos;d better use JavaScript API to create a contract by programming on Simplechain <a href="https://github.com/ethereum/web3.js" target="_blank">web3.j</a>. Now, we already have one called <a href="https://web3js.readthedocs.io/en/1.0/web3-eth-contract.html#new-contract" target="_blank">web3.eth.Contract</a> method can make it easier to create a contract.</p>
<p>When a contract is created, the constructor (a function with the same name as the contract) is executed once. The constructor is optional. Only one constructor is allowed, which means overloading is not supported.</p>
<p>Internally, the constructor parameters are passed after the contract code <code>ABI code</code> pass, but if you use<code>web3.js</code>there is no need to care about this problem.</p>
<p>If a contract wants to create another contract, the creator must know the source code (and binary code) of the contract to be created.
This means that it is impossible to create dependencies cyclically.</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.16;

    contract OwnedToken {
        // TokenCreator &#x662F;&#x5982;&#x4E0B;&#x5B9A;&#x4E49;&#x7684;&#x5408;&#x7EA6;&#x7C7B;&#x578B;.
        // &#x4E0D;&#x521B;&#x5EFA;&#x65B0;&#x5408;&#x7EA6;&#x7684;&#x8BDD;&#xFF0C;&#x4E5F;&#x53EF;&#x4EE5;&#x5F15;&#x7528;&#x5B83;&#x3002;
        TokenCreator creator;
        address owner;
        bytes32 name;

        // &#x8FD9;&#x662F;&#x6CE8;&#x518C; creator &#x548C;&#x8BBE;&#x7F6E;&#x540D;&#x79F0;&#x7684;&#x6784;&#x9020;&#x51FD;&#x6570;&#x3002;
        <span class="hljs-keyword">function</span> OwnedToken(bytes32 _name) public {
            // &#x72B6;&#x6001;&#x53D8;&#x91CF;&#x901A;&#x8FC7;&#x5176;&#x540D;&#x79F0;&#x8BBF;&#x95EE;&#xFF0C;&#x800C;&#x4E0D;&#x662F;&#x901A;&#x8FC7;&#x4F8B;&#x5982; this.owner &#x7684;&#x65B9;&#x5F0F;&#x8BBF;&#x95EE;&#x3002;
            // &#x8FD9;&#x4E5F;&#x9002;&#x7528;&#x4E8E;&#x51FD;&#x6570;&#xFF0C;&#x7279;&#x522B;&#x662F;&#x5728;&#x6784;&#x9020;&#x51FD;&#x6570;&#x4E2D;&#xFF0C;&#x4F60;&#x53EA;&#x80FD;&#x50CF;&#x8FD9;&#x6837;&#xFF08;&#x201C;&#x5185;&#x90E8;&#x5730;&#x201D;&#xFF09;&#x8C03;&#x7528;&#x5B83;&#x4EEC;&#xFF0C;
            // &#x56E0;&#x4E3A;&#x5408;&#x7EA6;&#x672C;&#x8EAB;&#x8FD8;&#x4E0D;&#x5B58;&#x5728;&#x3002;
            owner = msg.sender;
            // &#x4ECE; `address` &#x5230; `TokenCreator` &#xFF0C;&#x662F;&#x505A;&#x663E;&#x5F0F;&#x7684;&#x7C7B;&#x578B;&#x8F6C;&#x6362;
            // &#x5E76;&#x4E14;&#x5047;&#x5B9A;&#x8C03;&#x7528;&#x5408;&#x7EA6;&#x7684;&#x7C7B;&#x578B;&#x662F; TokenCreator&#xFF0C;&#x6CA1;&#x6709;&#x771F;&#x6B63;&#x7684;&#x65B9;&#x6CD5;&#x6765;&#x68C0;&#x67E5;&#x8FD9;&#x4E00;&#x70B9;&#x3002;
            creator = TokenCreator(msg.sender);
            name = _name;
        }

        <span class="hljs-keyword">function</span> changeName(bytes32 newName) public {
            // &#x53EA;&#x6709; creator &#xFF08;&#x5373;&#x521B;&#x5EFA;&#x5F53;&#x524D;&#x5408;&#x7EA6;&#x7684;&#x5408;&#x7EA6;&#xFF09;&#x80FD;&#x591F;&#x66F4;&#x6539;&#x540D;&#x79F0; &#x2014;&#x2014; &#x56E0;&#x4E3A;&#x5408;&#x7EA6;&#x662F;&#x9690;&#x5F0F;&#x8F6C;&#x6362;&#x4E3A;&#x5730;&#x5740;&#x7684;&#xFF0C;
            // &#x6240;&#x4EE5;&#x8FD9;&#x91CC;&#x7684;&#x6BD4;&#x8F83;&#x662F;&#x53EF;&#x884C;&#x7684;&#x3002;
            <span class="hljs-keyword">if</span> (msg.sender == address(creator))
                name = newName;
        }

        <span class="hljs-keyword">function</span> transfer(address newOwner) public {
            // &#x53EA;&#x6709;&#x5F53;&#x524D;&#x6240;&#x6709;&#x8005;&#x624D;&#x80FD;&#x53D1;&#x9001; token&#x3002;
            <span class="hljs-keyword">if</span> (msg.sender != owner) <span class="hljs-built_in">return</span>;
            // &#x6211;&#x4EEC;&#x4E5F;&#x60F3;&#x8BE2;&#x95EE; creator &#x662F;&#x5426;&#x53EF;&#x4EE5;&#x53D1;&#x9001;&#x3002;
            // &#x8BF7;&#x6CE8;&#x610F;&#xFF0C;&#x8FD9;&#x91CC;&#x8C03;&#x7528;&#x4E86;&#x4E00;&#x4E2A;&#x4E0B;&#x9762;&#x5B9A;&#x4E49;&#x7684;&#x5408;&#x7EA6;&#x4E2D;&#x7684;&#x51FD;&#x6570;&#x3002;
            // &#x5982;&#x679C;&#x8C03;&#x7528;&#x5931;&#x8D25;&#xFF08;&#x6BD4;&#x5982;&#xFF0C;&#x7531;&#x4E8E; gas &#x4E0D;&#x8DB3;&#xFF09;&#xFF0C;&#x4F1A;&#x7ACB;&#x5373;&#x505C;&#x6B62;&#x6267;&#x884C;&#x3002;
            <span class="hljs-keyword">if</span> (creator.isTokenTransferOK(owner, newOwner))
                owner = newOwner;
        }
    }

    contract TokenCreator {
        <span class="hljs-keyword">function</span> createToken(bytes32 name)
           public
           returns (OwnedToken tokenAddress)
        {
            // &#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x7684; Token &#x5408;&#x7EA6;&#x5E76;&#x4E14;&#x8FD4;&#x56DE;&#x5B83;&#x7684;&#x5730;&#x5740;&#x3002;
            // &#x4ECE; JavaScript &#x65B9;&#x9762;&#x6765;&#x8BF4;&#xFF0C;&#x8FD4;&#x56DE;&#x7C7B;&#x578B;&#x662F;&#x7B80;&#x5355;&#x7684; `address` &#x7C7B;&#x578B;&#xFF0C;&#x56E0;&#x4E3A;
            // &#x8FD9;&#x662F;&#x5728; ABI &#x4E2D;&#x53EF;&#x7528;&#x7684;&#x6700;&#x63A5;&#x8FD1;&#x7684;&#x7C7B;&#x578B;&#x3002;
            <span class="hljs-built_in">return</span> new OwnedToken(name);
        }

        <span class="hljs-keyword">function</span> changeName(OwnedToken tokenAddress, bytes32 name)  public {
            // &#x540C;&#x6837;&#xFF0C;`tokenAddress` &#x7684;&#x5916;&#x90E8;&#x7C7B;&#x578B;&#x4E5F;&#x662F; `address` &#x3002;
            tokenAddress.changeName(name);
        }

        <span class="hljs-keyword">function</span> isTokenTransferOK(address currentOwner, address newOwner)
            public
            view
            returns (bool ok)
        {
            // &#x68C0;&#x67E5;&#x4E00;&#x4E9B;&#x4EFB;&#x610F;&#x7684;&#x60C5;&#x51B5;&#x3002;
            address tokenAddress = msg.sender;
            <span class="hljs-built_in">return</span> (keccak256(newOwner) &amp; 0xff) == (bytes20(tokenAddress) &amp; 0xff);
        }
    }
</code></pre>
<h3 id="visibility-and-getter-functions"><a name="visibility-and-getter-functions" class="plugin-anchor" href="#visibility-and-getter-functions"><i class="fa fa-link" aria-hidden="true"></i></a>Visibility and getter functions</h3>
<p>Because Solidity has two kinds of function calls (internal calls do not generate actual EVM calls or &quot;message calls&quot;, while external calls generate an EVM call), functions and state variables have four visibility types. Function can be specified <code>external</code> &#xFF0C;<code>public</code> &#xFF0C;<code>internal</code> or <code>private</code>&#xFF0C;by default , function type is <code>public</code>&#x3002;
For state variables, cannot be set <code>external</code> &#xFF0C;default is <code>internal</code> &#x3002;</p>
<ul>
<li><code>external</code> &#xFF1A;As part of the contract interface, the external function means that we can call it from other contracts and transactions.
  An external function <code>f</code> cannot be called from inside (that is f It doesn&apos;t work, this.f() Yes). When a large amount of data is received, external functions are sometimes more efficient.</li>
<li><code>public</code> &#xFF1A;The public function is part of the contract interface and can be called internally or through messages. For common state variables, a getter function is automatically generated (see below).</li>
<li><code>internal</code> &#xFF1A;these functions and state variables can only be internal access (I .e. access from inside the current contract or from contracts derived from it), and are not used <code>this</code> Call.
<code>private</code> &#xFF1A;private functions and state variables are only used in contracts that currently define them and cannot be used by derived contracts.</li>
</ul>
<blockquote>
<p>All content in the contract is visible to external observers. Set some <code>private</code> The type can only prevent other contracts from accessing and modifying this information, but it is still visible for the whole world outside the blockchain.</p>
</blockquote>
<p>The definition position of the visibility identifier. For a state variable, it is after the type. For a function, it is between the parameter list and the returned keyword.</p>
<pre><code class="lang-bash">pragma solidity ^0.4.16;

contract C {
    <span class="hljs-keyword">function</span> f(uint a) private pure returns (uint b) { <span class="hljs-built_in">return</span> a + 1; }
    <span class="hljs-keyword">function</span> <span class="hljs-built_in">set</span>Data(uint a) internal { data = a; }
    uint public data;
}
</code></pre>
<p>In the following example, <code>D</code> Can be called <code>c.getData&#xFF08;&#xFF09;</code> to obtain status storage data But cannot call <code>f</code> .
Contract <code>E</code> Inherited from <code>C</code> , so it can be called compute .</p>
<pre><code class="lang-bash">    // &#x4E0B;&#x9762;&#x4EE3;&#x7801;&#x7F16;&#x8BD1;&#x9519;&#x8BEF;

    pragma solidity ^0.4.0;

    contract C {
        uint private data;

        <span class="hljs-keyword">function</span> f(uint a) private returns(uint b) { <span class="hljs-built_in">return</span> a + 1; }
        <span class="hljs-keyword">function</span> <span class="hljs-built_in">set</span>Data(uint a) public { data = a; }
        <span class="hljs-keyword">function</span> getData() public returns(uint) { <span class="hljs-built_in">return</span> data; }
        <span class="hljs-keyword">function</span> compute(uint a, uint b) internal returns (uint) { <span class="hljs-built_in">return</span> a+b; }
    }

    contract D {
        <span class="hljs-keyword">function</span> <span class="hljs-built_in">read</span>Data() public {
            C c = new C();
            uint <span class="hljs-built_in">local</span> = c.f(7); // &#x9519;&#x8BEF;&#xFF1A;&#x6210;&#x5458; `f` &#x4E0D;&#x53EF;&#x89C1;
            c.setData(3);
            <span class="hljs-built_in">local</span> = c.getData();
            <span class="hljs-built_in">local</span> = c.compute(3, 5); // &#x9519;&#x8BEF;&#xFF1A;&#x6210;&#x5458; `compute` &#x4E0D;&#x53EF;&#x89C1;
        }
    }

    contract E is C {
        <span class="hljs-keyword">function</span> g() public {
            C c = new C();
            uint val = compute(3, 5); // &#x8BBF;&#x95EE;&#x5185;&#x90E8;&#x6210;&#x5458;&#xFF08;&#x4ECE;&#x7EE7;&#x627F;&#x5408;&#x7EA6;&#x8BBF;&#x95EE;&#x7236;&#x5408;&#x7EA6;&#x6210;&#x5458;&#xFF09;
        }
    }
</code></pre>
<h4 id="getter-function"><a name="getter-function" class="plugin-anchor" href="#getter-function"><i class="fa fa-link" aria-hidden="true"></i></a>Getter function</h4>
<p>The compiler automatically for all Public State variables create getter functions. For the contract given below, the compiler generates a contract named data The function, This function does not receive any parameters and returns a uint , that is, the state variable data The value. You can complete the initialization of the state variable at the time of declaration.</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.0;

    contract C {
        uint public data = 42;
    }

    contract Caller {
        C c = new C();
        <span class="hljs-keyword">function</span> f() public {
            uint <span class="hljs-built_in">local</span> = c.data();
        }
    }
</code></pre>
<p>The getter function has external visibility. If getter is accessed internally (that is, none this. ), it is considered a state variable.
If it is externally accessed (that is, use this. ), it is considered as a function.</p>
<pre><code class="lang-bash">
    pragma solidity ^0.4.0;

    contract C {
        uint public data;
        <span class="hljs-keyword">function</span> x() public {
            data = 3; // &#x5185;&#x90E8;&#x8BBF;&#x95EE;
            uint val = this.data(); // &#x5916;&#x90E8;&#x8BBF;&#x95EE;
        }
    }
</code></pre>
<p>The next example is slightly more complicated:</p>
<pre><code class="lang-bash">
    pragma solidity ^0.4.0;

    contract Complex {
        struct Data {
            uint a;
            bytes3 b;
            mapping (uint =&gt; uint) map;
        }
        mapping (uint =&gt; mapping(bool =&gt; Data[])) public data;
    }
</code></pre>
<p>This generates a function in the following form:</p>
<pre><code class="lang-bash"><span class="hljs-keyword">function</span> data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) {
    a = data[arg1][arg2][arg3].a;
    b = data[arg1][arg2][arg3].b;
}
</code></pre>
<p>Note that because there is no good method to provide the keys for mapping, the mapping in the structure is omitted.</p>
<h4 id="function-modifier"><a name="function-modifier" class="plugin-anchor" href="#function-modifier"><i class="fa fa-link" aria-hidden="true"></i></a>Function |modifier|</h4>
<p>Use | modifier | To easily change the behavior of the function. For example, they can automatically check a condition before executing a function.
| modifier | Is an inheritable property of the contract,
And may be overwritten by derived contracts.</p>
<pre><code class="lang-bash">
    pragma solidity ^0.4.11;

    contract owned {
        <span class="hljs-keyword">function</span> owned() public { owner = msg.sender; }
        address owner;

        // &#x8FD9;&#x4E2A;&#x5408;&#x7EA6;&#x53EA;&#x5B9A;&#x4E49;&#x4E00;&#x4E2A;&#x4FEE;&#x9970;&#x5668;&#xFF0C;&#x4F46;&#x5E76;&#x672A;&#x4F7F;&#x7528;&#xFF1A; &#x5B83;&#x5C06;&#x4F1A;&#x5728;&#x6D3E;&#x751F;&#x5408;&#x7EA6;&#x4E2D;&#x7528;&#x5230;&#x3002;
        // &#x4FEE;&#x9970;&#x5668;&#x6240;&#x4FEE;&#x9970;&#x7684;&#x51FD;&#x6570;&#x4F53;&#x4F1A;&#x88AB;&#x63D2;&#x5165;&#x5230;&#x7279;&#x6B8A;&#x7B26;&#x53F7; _; &#x7684;&#x4F4D;&#x7F6E;&#x3002;
        // &#x8FD9;&#x610F;&#x5473;&#x7740;&#x5982;&#x679C;&#x662F; owner &#x8C03;&#x7528;&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#xFF0C;&#x5219;&#x51FD;&#x6570;&#x4F1A;&#x88AB;&#x6267;&#x884C;&#xFF0C;&#x5426;&#x5219;&#x4F1A;&#x629B;&#x51FA;&#x5F02;&#x5E38;&#x3002;
        modifier onlyOwner {
            require(msg.sender == owner);
            _;
        }
    }

    contract mortal is owned {
        // &#x8FD9;&#x4E2A;&#x5408;&#x7EA6;&#x4ECE; `owned` &#x7EE7;&#x627F;&#x4E86; `onlyOwner` &#x4FEE;&#x9970;&#x7B26;&#xFF0C;&#x5E76;&#x5C06;&#x5176;&#x5E94;&#x7528;&#x4E8E; `close` &#x51FD;&#x6570;&#xFF0C;
        // &#x53EA;&#x6709;&#x5728;&#x5408;&#x7EA6;&#x91CC;&#x4FDD;&#x5B58;&#x7684; owner &#x8C03;&#x7528; `close` &#x51FD;&#x6570;&#xFF0C;&#x624D;&#x4F1A;&#x751F;&#x6548;&#x3002;
        <span class="hljs-keyword">function</span> close() public onlyOwner {
            selfdestruct(owner);
        }
    }

    contract priced {
        // &#x4FEE;&#x6539;&#x5668;&#x53EF;&#x4EE5;&#x63A5;&#x6536;&#x53C2;&#x6570;&#xFF1A;
        modifier costs(uint price) {
            <span class="hljs-keyword">if</span> (msg.value &gt;= price) {
                _;
            }
        }
    }

    contract Register is priced, owned {
        mapping (address =&gt; bool) registeredAddresses;
        uint price;

        <span class="hljs-keyword">function</span> Register(uint initialPrice) public { price = initialPrice; }

        // &#x5728;&#x8FD9;&#x91CC;&#x4E5F;&#x4F7F;&#x7528;&#x5173;&#x952E;&#x5B57; `payable` &#x975E;&#x5E38;&#x91CD;&#x8981;&#xFF0C;&#x5426;&#x5219;&#x51FD;&#x6570;&#x4F1A;&#x81EA;&#x52A8;&#x62D2;&#x7EDD;&#x6240;&#x6709;&#x53D1;&#x9001;&#x7ED9;&#x5B83;&#x7684;&#x4EE5;&#x592A;&#x5E01;&#x3002;
        <span class="hljs-keyword">function</span> register() public payable costs(price) {
            registeredAddresses[msg.sender] = <span class="hljs-literal">true</span>;
        }

        <span class="hljs-keyword">function</span> changePrice(uint _price) public onlyOwner {
            price = _price;
        }
    }

    contract Mutex {
        bool locked;
        modifier <span class="hljs-function"><span class="hljs-title">noReentrancy</span></span>() {
            require(!locked);
            locked = <span class="hljs-literal">true</span>;
            _;
            locked = <span class="hljs-literal">false</span>;
        }

        // &#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x53D7;&#x4E92;&#x65A5;&#x91CF;&#x4FDD;&#x62A4;&#xFF0C;&#x8FD9;&#x610F;&#x5473;&#x7740; `msg.sender.call` &#x4E2D;&#x7684;&#x91CD;&#x5165;&#x8C03;&#x7528;&#x4E0D;&#x80FD;&#x518D;&#x6B21;&#x8C03;&#x7528;  `f`&#x3002;
        // `<span class="hljs-built_in">return</span> 7` &#x8BED;&#x53E5;&#x6307;&#x5B9A;&#x8FD4;&#x56DE;&#x503C;&#x4E3A; 7&#xFF0C;&#x4F46;&#x4FEE;&#x6539;&#x5668;&#x4E2D;&#x7684;&#x8BED;&#x53E5; `locked = <span class="hljs-literal">false</span>` &#x4ECD;&#x4F1A;&#x6267;&#x884C;&#x3002;
        <span class="hljs-keyword">function</span> f() public noReentrancy returns (uint) {
            require(msg.sender.call());
            <span class="hljs-built_in">return</span> 7;
        }
    }
</code></pre>
<p>If the same function has multiple <code>modifier</code> , they are separated by spaces, <code>modifier</code> Checks the execution in sequence.</p>
<blockquote>
<p>In earlier versions of Solidity, there were functions of | modifier |, <code>return</code> behavior of the statement is different.</p>
</blockquote>
<p><code>modifier</code> or the explicit return statement in the function body only jumps out of the current <code>modifier</code> and fucntion bodies. returned variable is assigned a value, but the entire execution logic continues after the &quot;_&quot; defined in the previous | modifier |.</p>
<p><code>modifier</code>parameter of can be any expression, in this context, all symbols visible in the function&#xFF0C;in <code>modifier</code> all visible. in <code>modifier</code> symbols introduced in are invisible in the function (may be overloaded).</p>
<h3 id="constant-state-variable"><a name="constant-state-variable" class="plugin-anchor" href="#constant-state-variable"><i class="fa fa-link" aria-hidden="true"></i></a>Constant state variable</h3>
<p>Status variables can be declared <code>constant</code> . In this case, only expressions that determine values at compile time can be used to assign values to them. Any blockchain data (such <code>now</code> , <code>this.balance</code> Or <code>block.number</code> ) or execution data ( <code>msg.gas</code> ) or calls to external contracts to assign values to them are not allowed. There is a boundary effect on memory allocation ( <code>side-effect</code> ) expressions are allowed, but expressions that produce boundary effects on other memory objects are not allowed. built-in function <code>keccak256</code> , <code>sha256</code> , <code>ripemd160</code> , <code>ecrecover</code> , <code>addmod</code> and <code>mulmod</code> is allowed (even if they do invoke external contracts).</p>
<p>The reason why memory allocators with boundary effects are allowed is that this will allow the construction of complex objects, such as lookup-table.
This feature is not fully available. The compiler does not reserve storage for these variables, and each time they appear, they are replaced with the corresponding constant expression (which may be calculated by the optimizer as an actual value). Not all types of state variables support constant modification. Currently, only value types and strings are supported.</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.0;

    contract C {
        uint constant x = 32**22 + 8;
        string constant text = <span class="hljs-string">&quot;abc&quot;</span>;
        bytes32 constant myHash = keccak256(<span class="hljs-string">&quot;abc&quot;</span>);
    }
</code></pre>
<h3 id="function"><a name="function" class="plugin-anchor" href="#function"><i class="fa fa-link" aria-hidden="true"></i></a>Function</h3>
<h4 id="view-function"><a name="view-function" class="plugin-anchor" href="#view-function"><i class="fa fa-link" aria-hidden="true"></i></a>View function</h4>
<p>You can declare a function <code>view</code> type, in this case, make sure that the state is not modified.</p>
<p>The following statement is considered to modify the state:</p>
<ul>
<li>Modify the status variable.</li>
<li><code>generate an event</code>&#x3002;</li>
<li><code>create smart contract</code>&#x3002;</li>
<li>use <code>selfdestruct</code>&#x3002;</li>
<li>send Sipc coins by calling&#x3002;</li>
<li>Call any that is not marked <code>view</code> Or <code>pure</code> The function.</li>
<li>Use low-level calls.</li>
<li>Use an inline assembly that contains specific opcodes.</li>
</ul>
<pre><code class="lang-bash">    pragma solidity ^0.4.16;

    contract C {
        <span class="hljs-keyword">function</span> f(uint a, uint b) public view returns (uint) {
            <span class="hljs-built_in">return</span> a * (b + 42) + now;
        }
    }
</code></pre>
<blockquote>
<p> <code>constant</code> is <code>view</code> alias&#x3002;</p>
<p> The Getter method is marked <code>view</code>&#x3002;</p>
<p> The compiler does not force <code>view</code> method cannot modify the status.</p>
</blockquote>
<h4 id="pure-function"><a name="pure-function" class="plugin-anchor" href="#pure-function"><i class="fa fa-link" aria-hidden="true"></i></a>Pure function</h4>
<p>Functions can be declared <code>pure</code> , in this case, promise not to read or modify the status. In addition to the list of state modification statements explained above, the following is considered to be read from the state:</p>
<ul>
<li>Read status variables.</li>
<li>Access <code>this.balance</code> or <code>&lt;address&gt;.balance</code>&#x3002;</li>
<li>Access <code>block</code>&#xFF0C;<code>tx</code>&#xFF0C; <code>msg</code> any member in &#xFF08;beside <code>msg.sig</code> and <code>msg.data</code> outside).</li>
<li>Call any not marked <code>pure</code> function.</li>
<li>Use an inline assembly that contains certain opcodes.</li>
</ul>
<pre><code class="lang-bash">    pragma solidity ^0.4.16;

    contract C {
        <span class="hljs-keyword">function</span> f(uint a, uint b) public pure returns (uint) {
            <span class="hljs-built_in">return</span> a * (b + 42);
        }
    }
</code></pre>
<blockquote>
<p> The compiler does not force pure method cannot read the status.</p>
</blockquote>
<h4 id="fallback-function"><a name="fallback-function" class="plugin-anchor" href="#fallback-function"><i class="fa fa-link" aria-hidden="true"></i></a>Fallback function</h4>
<p>A contract can have an unnamed function. This function cannot have parameters or return values. If no other function matches the given function identifier (or no call data is provided) in a contract call, the function (fallback function) will be executed.</p>
<p>In addition, this function will be executed every time the contract receives Sipc coins (without any data). In addition, the fallback function must be marked payable . If such a function does not exist, the contract cannot receive Sipc coins through regular transactions.</p>
<p>In this context, usually only a few gas can be used to complete this function call (to be exact, 2300 gas), so it is important to make the call of fallback function as cheap as possible. Note that the gas required for transactions calling the fallback function (rather than internal calls) is much higher, because an additional 21000 gas or more is charged for each transaction for signature check and other operations.</p>
<p>Specifically, the following operations consume more gas than the fallback function:</p>
<ul>
<li>Write storage</li>
<li>Create a contract</li>
<li>Call external functions that consume a lot of gas</li>
<li>Send Sipc coins</li>
</ul>
<p>Make sure that you thoroughly test your fallback function before deploying the contract to ensure that the execution cost is less than 2300 gas.</p>
<blockquote>
<p> Even if the fallback function cannot have parameters, it can still be used <code>msg.data</code> to obtain any valid data provided with the call.</p>
<p> A contract that does not define a fallback function directly receives ether coins (no function call, that is, use <code>send</code> Or <code>transfer</code> ) throws an exception and returns the ether coin (the behavior will be different before Solidity v0.4.0). Therefore, if you want your contract to receive Ether coins, you must implement the fallback function.</p>
<p> A contract without the payable fallback function can be used coinbase transaction (Also known miner block reward ) the recipient or selfdestruct The target to receive sipc coins.</p>
<p> A contract cannot respond to this ether transfer, so it cannot refuse them either. This is determined by EVM when designing, and Solidity cannot bypass this problem.</p>
<p> This also means <code>this.balance</code> can be higher than the sum of some manual accounting implemented in the contract (that is, the accumulator updated in the fallback function).</p>
</blockquote>
<pre><code class="lang-bash">
    pragma solidity ^0.4.0;

    contract Test {
        // &#x53D1;&#x9001;&#x5230;&#x8FD9;&#x4E2A;&#x5408;&#x7EA6;&#x7684;&#x6240;&#x6709;&#x6D88;&#x606F;&#x90FD;&#x4F1A;&#x8C03;&#x7528;&#x6B64;&#x51FD;&#x6570;&#xFF08;&#x56E0;&#x4E3A;&#x8BE5;&#x5408;&#x7EA6;&#x6CA1;&#x6709;&#x5176;&#x5B83;&#x51FD;&#x6570;&#xFF09;&#x3002;
        // &#x5411;&#x8FD9;&#x4E2A;&#x5408;&#x7EA6;&#x53D1;&#x9001;&#x4EE5;&#x592A;&#x5E01;&#x4F1A;&#x5BFC;&#x81F4;&#x5F02;&#x5E38;&#xFF0C;&#x56E0;&#x4E3A; fallback &#x51FD;&#x6570;&#x6CA1;&#x6709; `payable` &#x4FEE;&#x9970;&#x7B26;
        <span class="hljs-keyword">function</span>() public { x = 1; }
        uint x;
    }
    // &#x8FD9;&#x4E2A;&#x5408;&#x7EA6;&#x4F1A;&#x4FDD;&#x7559;&#x6240;&#x6709;&#x53D1;&#x9001;&#x7ED9;&#x5B83;&#x7684;&#x4EE5;&#x592A;&#x5E01;&#xFF0C;&#x6CA1;&#x6709;&#x529E;&#x6CD5;&#x8FD4;&#x8FD8;&#x3002;
    contract Sink {
        <span class="hljs-keyword">function</span>() public payable { }
    }
    contract Caller {
        <span class="hljs-keyword">function</span> callTest(Test <span class="hljs-built_in">test</span>) public {
            test.call(0xabcdef01); // &#x4E0D;&#x5B58;&#x5728;&#x7684;&#x54C8;&#x5E0C;
            // &#x5BFC;&#x81F4; test.x &#x53D8;&#x6210; == 1&#x3002;
            // &#x4EE5;&#x4E0B;&#x5C06;&#x4E0D;&#x4F1A;&#x7F16;&#x8BD1;&#xFF0C;&#x4F46;&#x5982;&#x679C;&#x6709;&#x4EBA;&#x5411;&#x8BE5;&#x5408;&#x7EA6;&#x53D1;&#x9001;&#x4EE5;&#x592A;&#x5E01;&#xFF0C;&#x4EA4;&#x6613;&#x5C06;&#x5931;&#x8D25;&#x5E76;&#x62D2;&#x7EDD;&#x4EE5;&#x592A;&#x5E01;&#x3002;
            // test.send(2 ether&#xFF09;;
        }
    }
</code></pre>
<h4 id="function-overload"><a name="function-overload" class="plugin-anchor" href="#function-overload"><i class="fa fa-link" aria-hidden="true"></i></a>Function overload</h4>
<p>A contract can have functions with the same name with multiple different parameters. This also applies to inheritance functions. The following example shows the contract <code>A</code> Overloaded functions in <code>f</code> .</p>
<pre><code class="lang-bash">
    pragma solidity ^0.4.16;

    contract A {
        <span class="hljs-keyword">function</span> f(uint _<span class="hljs-keyword">in</span>) public pure returns (uint out) {
            out = 1;
        }

        <span class="hljs-keyword">function</span> f(uint _<span class="hljs-keyword">in</span>, bytes32 _key) public pure returns (uint out) {
            out = 2;
        }
    }

The above two `f` Function overloads accept ABI address types, although they are considered different <span class="hljs-keyword">in</span> Solidity.

```bash
    // &#x4EE5;&#x4E0B;&#x4EE3;&#x7801;&#x65E0;&#x6CD5;&#x7F16;&#x8BD1;
    pragma solidity ^0.4.16;

    contract A {
        <span class="hljs-keyword">function</span> f(B _<span class="hljs-keyword">in</span>) public pure returns (B out) {
            out = _<span class="hljs-keyword">in</span>;
        }

        <span class="hljs-keyword">function</span> f(address _<span class="hljs-keyword">in</span>) public pure returns (address out) {
            out = _<span class="hljs-keyword">in</span>;
        }
    }

    contract B {
    }
</code></pre>
<p>The above two <code>f</code> Function overloads accept ABI address types, although they are considered different in Solidity.</p>
<h4 id="overloaded-parsing-and-parameter-matching"><a name="overloaded-parsing-and-parameter-matching" class="plugin-anchor" href="#overloaded-parsing-and-parameter-matching"><i class="fa fa-link" aria-hidden="true"></i></a>Overloaded parsing and parameter matching</h4>
<p>You can choose to reload the function by matching the function declarations in the current range with the parameters provided in the function call.
If all parameters can be implicitly converted to the expected type, the function is selected as the overload candidate. If none of the candidates exist, the parsing fails.</p>
<blockquote>
<p> The returned parameter is not used as the basis for overload resolution.</p>
</blockquote>
<pre><code class="lang-bash">    pragma solidity ^0.4.16;

    contract A {
        <span class="hljs-keyword">function</span> f(uint8 _<span class="hljs-keyword">in</span>) public pure returns (uint8 out) {
            out = _<span class="hljs-keyword">in</span>;
        }

        <span class="hljs-keyword">function</span> f(uint256 _<span class="hljs-keyword">in</span>) public pure returns (uint256 out) {
            out = _<span class="hljs-keyword">in</span>;
        }
    }
</code></pre>
<p>Call <code>f(50)</code> causes type errors because <code>50</code> can be implicitly converted <code>uint8</code> can also be implicitly converted <code>uint256</code> on the other hand, call<code>f(256)</code> parses <code>f(uint256)</code> overload&#xFF0C;because <code>256</code> cannot be implicitly converted <code>uint8</code>&#x3002;</p>
<h3 id="event"><a name="event" class="plugin-anchor" href="#event"><i class="fa fa-link" aria-hidden="true"></i></a>Event</h3>
<p>Events allow us to easily use the log infrastructure of EVM. We can listen to events in the user interface of dapp, and the log mechanism of EVM can in turn &quot;call&quot; the Javascript callback function used to listen to events.</p>
<p>Events can be inherited in the contract. When they are called, parameters are stored in transaction logs-a special data structure in the blockchain. These logs are associated with the address and incorporated into the blockchain. They exist as long as the block is accessible (they are permanently saved in Frontier and Homestead versions and may be changed in Serenity versions). Logs and events cannot be directly accessed within the contract (even the contract for creating logs cannot be accessed).</p>
<p>The Simplified Payment Verification of logs is possible. If an external entity provides a contract with this proof, it can check whether the logs actually exist in the blockchain. However, it should be noted that only the latest 256 block hashes can be accessed in the contract, so the block header information needs to be provided.</p>
<p>A maximum of three parameters can be received <code>indexed</code> Property so that they can be searched: specific values of indexed parameters can be used for filtering on the user interface.</p>
<p>If the array (including <code>string</code> And <code>bytes</code> ) type is marked as index item, their keccak-256 hash values are saved as topic. Unless you use anonymous The descriptor declares an event. Otherwise, the hash value of the event signature is one of the topics. It also means that <code>anonymous</code> events cannot be filtered by names. All non-index parameters are stored in the data section of the log.</p>
<blockquote>
<p> The index parameters themselves are not saved. You can only search for their values (to determine whether the corresponding log data exists), not their values themselves.</p>
</blockquote>
<pre><code class="lang-bash">
    pragma solidity ^0.4.0;

    contract ClientReceipt {
        event Deposit(
            address indexed _from,
            bytes32 indexed _id,
            uint _value
        );

        <span class="hljs-keyword">function</span> deposit(bytes32 _id) public payable {
            // &#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x8FC7;&#x6EE4;&#x5BF9; `Deposit` &#x7684;&#x8C03;&#x7528;&#xFF0C;&#x4ECE;&#x800C;&#x7528; Javascript API &#x6765;&#x67E5;&#x660E;&#x5BF9;&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x7684;&#x4EFB;&#x4F55;&#x8C03;&#x7528;&#xFF08;&#x751A;&#x81F3;&#x662F;&#x6DF1;&#x5EA6;&#x5D4C;&#x5957;&#x8C03;&#x7528;&#xFF09;&#x3002;
            Deposit(msg.sender, _id, msg.value);
        }
    }
</code></pre>
<p>Use JavaScript APIs to call events as follows:</p>
<pre><code class="lang-bash">
    var abi = /* abi &#x7531;&#x7F16;&#x8BD1;&#x5668;&#x4EA7;&#x751F; */;
    var ClientReceipt = web3.eth.contract(abi);
    var clientReceipt = ClientReceipt.at(<span class="hljs-string">&quot;0x1234...ab67&quot;</span> /* &#x5730;&#x5740; */);

    var event = clientReceipt.Deposit();

    // &#x76D1;&#x89C6;&#x53D8;&#x5316;
    event.watch(<span class="hljs-keyword">function</span>(error, result){
        // &#x7ED3;&#x679C;&#x5305;&#x62EC;&#x5BF9; `Deposit` &#x7684;&#x8C03;&#x7528;&#x53C2;&#x6570;&#x5728;&#x5185;&#x7684;&#x5404;&#x79CD;&#x4FE1;&#x606F;&#x3002;
        <span class="hljs-keyword">if</span> (!error)
            console.log(result);
    });

    // &#x6216;&#x8005;&#x901A;&#x8FC7;&#x56DE;&#x8C03;&#x7ACB;&#x5373;&#x5F00;&#x59CB;&#x89C2;&#x5BDF;
    var event = clientReceipt.Deposit(<span class="hljs-keyword">function</span>(error, result) {
        <span class="hljs-keyword">if</span> (!error)
            console.log(result);
    });
</code></pre>
<h4 id="the-underlying-interface-of-the-log"><a name="the-underlying-interface-of-the-log" class="plugin-anchor" href="#the-underlying-interface-of-the-log"><i class="fa fa-link" aria-hidden="true"></i></a>The underlying interface of the log</h4>
<p>through function <code>log0</code>&#xFF0C;<code>log1</code>&#xFF0C; <code>log2</code>&#xFF0C; <code>log3</code> and <code>log4</code> you can access the underlying interface of the log mechanism. <code>logi</code>  accept <code>i + 1</code> a <code>bytes32</code> parameter of the type. The first parameter is used as the data part of the log, and the others are used as the topic. The preceding event calls can be executed in the same way.</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.10;

    contract C {
        <span class="hljs-keyword">function</span> f() public payable {
            bytes32 _id = 0x420042;
            <span class="hljs-built_in">log</span>3(
                bytes32(msg.value),
                bytes32(0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20),
                bytes32(msg.sender),
                _id
            );
        }
    }
</code></pre>
<p>The calculation method of the long hexadecimal number is <code>keccak256(&quot;Deposit(address,hash256,uint256)&quot;)</code>&#xFF0C;that is, the signature of the event.</p>
<h4 id="resources-for-other-learning-event-mechanisms"><a name="resources-for-other-learning-event-mechanisms" class="plugin-anchor" href="#resources-for-other-learning-event-mechanisms"><i class="fa fa-link" aria-hidden="true"></i></a>Resources for other learning event mechanisms</h4>
<ul>
<li><a href="https://github.com/ethereum/wiki/wiki/JavaScript-API#contract-events" target="_blank">Javascript documentation</a></li>
<li><a href="https://github.com/debris/smart-exchange/blob/master/lib/contracts/SmartExchange.sol" target="_blank">event usage routine</a></li>
<li><a href="https://github.com/debris/smart-exchange/blob/master/lib/exchange_transactions.js" target="_blank">How to access them in js</a></li>
</ul>
<h3 id="inheritance"><a name="inheritance" class="plugin-anchor" href="#inheritance"><i class="fa fa-link" aria-hidden="true"></i></a>Inheritance</h3>
<p>Solidity supports multiple inheritance by copying code that includes polymorphism. All function calls are virtual, which means that the farthest derived function will be called unless the contract name is explicitly given. When a contract is inherited from multiple contracts, only one contract is created on the blockchain, and the code of all base-class contracts is copied to the created contract.</p>
<p>In general, Solidity&apos;s inheritance system and <a href="https://docs.python.org/3/tutorial/classes.html#inheritance" target="_blank">Python inherutance system</a>&#xFF0C;very similar, especially in terms of multiple inheritance.</p>
<p>The following example is described in detail.</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.16;

    contract owned {
        <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">owned</span></span>() { owner = msg.sender; }
        address owner;
    }

    // &#x4F7F;&#x7528; is &#x4ECE;&#x53E6;&#x4E00;&#x4E2A;&#x5408;&#x7EA6;&#x6D3E;&#x751F;&#x3002;&#x6D3E;&#x751F;&#x5408;&#x7EA6;&#x53EF;&#x4EE5;&#x8BBF;&#x95EE;&#x6240;&#x6709;&#x975E;&#x79C1;&#x6709;&#x6210;&#x5458;&#xFF0C;&#x5305;&#x62EC;&#x5185;&#x90E8;&#x51FD;&#x6570;&#x548C;&#x72B6;&#x6001;&#x53D8;&#x91CF;&#xFF0C;
    // &#x4F46;&#x65E0;&#x6CD5;&#x901A;&#x8FC7; this &#x6765;&#x5916;&#x90E8;&#x8BBF;&#x95EE;&#x3002;
    contract mortal is owned {
        <span class="hljs-keyword">function</span> <span class="hljs-function"><span class="hljs-title">kill</span></span>() {
            <span class="hljs-keyword">if</span> (msg.sender == owner) selfdestruct(owner);
        }
    }

    // &#x8FD9;&#x4E9B;&#x62BD;&#x8C61;&#x5408;&#x7EA6;&#x4EC5;&#x7528;&#x4E8E;&#x7ED9;&#x7F16;&#x8BD1;&#x5668;&#x63D0;&#x4F9B;&#x63A5;&#x53E3;&#x3002;
    // &#x6CE8;&#x610F;&#x51FD;&#x6570;&#x6CA1;&#x6709;&#x51FD;&#x6570;&#x4F53;&#x3002;
    // &#x5982;&#x679C;&#x4E00;&#x4E2A;&#x5408;&#x7EA6;&#x6CA1;&#x6709;&#x5B9E;&#x73B0;&#x6240;&#x6709;&#x51FD;&#x6570;&#xFF0C;&#x5219;&#x53EA;&#x80FD;&#x7528;&#x4F5C;&#x63A5;&#x53E3;&#x3002;
    contract Config {
        <span class="hljs-keyword">function</span> lookup(uint id) public returns (address adr);
    }

    contract NameReg {
        <span class="hljs-keyword">function</span> register(bytes32 name) public;
        <span class="hljs-keyword">function</span> unregister() public;
     }

    // &#x53EF;&#x4EE5;&#x591A;&#x91CD;&#x7EE7;&#x627F;&#x3002;&#x8BF7;&#x6CE8;&#x610F;&#xFF0C;owned &#x4E5F;&#x662F; mortal &#x7684;&#x57FA;&#x7C7B;&#xFF0C;
    // &#x4F46;&#x53EA;&#x6709;&#x4E00;&#x4E2A; owned &#x5B9E;&#x4F8B;&#xFF08;&#x5C31;&#x50CF; C++ &#x4E2D;&#x7684;&#x865A;&#x62DF;&#x7EE7;&#x627F;&#xFF09;&#x3002;
    contract named is owned, mortal {
        <span class="hljs-keyword">function</span> named(bytes32 name) {
            Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
            NameReg(config.lookup(1)).register(name);
        }

        // &#x51FD;&#x6570;&#x53EF;&#x4EE5;&#x88AB;&#x53E6;&#x4E00;&#x4E2A;&#x5177;&#x6709;&#x76F8;&#x540C;&#x540D;&#x79F0;&#x548C;&#x76F8;&#x540C;&#x6570;&#x91CF;/&#x7C7B;&#x578B;&#x8F93;&#x5165;&#x7684;&#x51FD;&#x6570;&#x91CD;&#x8F7D;&#x3002;
        // &#x5982;&#x679C;&#x91CD;&#x8F7D;&#x51FD;&#x6570;&#x6709;&#x4E0D;&#x540C;&#x7C7B;&#x578B;&#x7684;&#x8F93;&#x51FA;&#x53C2;&#x6570;&#xFF0C;&#x4F1A;&#x5BFC;&#x81F4;&#x9519;&#x8BEF;&#x3002;
        // &#x672C;&#x5730;&#x548C;&#x57FA;&#x4E8E;&#x6D88;&#x606F;&#x7684;&#x51FD;&#x6570;&#x8C03;&#x7528;&#x90FD;&#x4F1A;&#x8003;&#x8651;&#x8FD9;&#x4E9B;&#x91CD;&#x8F7D;&#x3002;
        <span class="hljs-keyword">function</span> <span class="hljs-built_in">kill</span>() public {
            <span class="hljs-keyword">if</span> (msg.sender == owner) {
                Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);
                NameReg(config.lookup(1)).unregister();
                // &#x4ECD;&#x7136;&#x53EF;&#x4EE5;&#x8C03;&#x7528;&#x7279;&#x5B9A;&#x7684;&#x91CD;&#x8F7D;&#x51FD;&#x6570;&#x3002;
                mortal.kill();
            }
        }
    }

    // &#x5982;&#x679C;&#x6784;&#x9020;&#x51FD;&#x6570;&#x63A5;&#x53D7;&#x53C2;&#x6570;&#xFF0C;
    // &#x5219;&#x9700;&#x8981;&#x5728;&#x58F0;&#x660E;&#xFF08;&#x5408;&#x7EA6;&#x7684;&#x6784;&#x9020;&#x51FD;&#x6570;&#xFF09;&#x65F6;&#x63D0;&#x4F9B;&#xFF0C;
    // &#x6216;&#x5728;&#x6D3E;&#x751F;&#x5408;&#x7EA6;&#x7684;&#x6784;&#x9020;&#x51FD;&#x6570;&#x4F4D;&#x7F6E;&#x4EE5;&#x4FEE;&#x9970;&#x5668;&#x8C03;&#x7528;&#x98CE;&#x683C;&#x63D0;&#x4F9B;&#xFF08;&#x89C1;&#x4E0B;&#x6587;&#xFF09;&#x3002;
    contract PriceFeed is owned, mortal, named(<span class="hljs-string">&quot;GoldFeed&quot;</span>) {
       <span class="hljs-keyword">function</span> updateInfo(uint newInfo) public {
          <span class="hljs-keyword">if</span> (msg.sender == owner) info = newInfo;
       }

       <span class="hljs-keyword">function</span> get() public view returns(uint r) { <span class="hljs-built_in">return</span> info; }

       uint info;
    }
</code></pre>
<p>Note that in the above code, we call <code>mortal.kill()</code> To &quot;forward&quot; the destruction request. This approach is problematic, as shown in the following example:</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.0;

    contract owned {
        <span class="hljs-keyword">function</span> owned() public { owner = msg.sender; }
        address owner;
    }

    contract mortal is owned {
        <span class="hljs-keyword">function</span> <span class="hljs-built_in">kill</span>() public {
            <span class="hljs-keyword">if</span> (msg.sender == owner) selfdestruct(owner);
        }
    }

    contract Base1 is mortal {
        <span class="hljs-keyword">function</span> <span class="hljs-built_in">kill</span>() public { /* &#x6E05;&#x9664;&#x64CD;&#x4F5C; 1 */ mortal.kill(); }
    }

    contract Base2 is mortal {
        <span class="hljs-keyword">function</span> <span class="hljs-built_in">kill</span>() public { /* &#x6E05;&#x9664;&#x64CD;&#x4F5C; 2 */ mortal.kill(); }
    }

    contract Final is Base1, Base2 {
    }
</code></pre>
<p>Call <code>Final.kill()</code> farthest derived overloaded function is called <code>Base2.kill</code>&#xFF0C;but it will bypass <code>Base1.kill</code>&#xFF0C;mainly because it doesn&apos;t even know <code>Base1</code> existence. the way to solve this problem is to use <code>super</code>:</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.0;

    contract owned {
        <span class="hljs-keyword">function</span> owned() public { owner = msg.sender; }
        address owner;
    }

    contract mortal is owned {
        <span class="hljs-keyword">function</span> <span class="hljs-built_in">kill</span>() public {
            <span class="hljs-keyword">if</span> (msg.sender == owner) selfdestruct(owner);
        }
    }

    contract Base1 is mortal {
        <span class="hljs-keyword">function</span> <span class="hljs-built_in">kill</span>() public { /* &#x6E05;&#x9664;&#x64CD;&#x4F5C; 1 */ super.kill(); }
    }


    contract Base2 is mortal {
        <span class="hljs-keyword">function</span> <span class="hljs-built_in">kill</span>() public { /* &#x6E05;&#x9664;&#x64CD;&#x4F5C; 2 */ super.kill(); }
    }

    contract Final is Base1, Base2 {
    }
</code></pre>
<p>If <code>Base2</code> call <code>super</code> it does not simply call the function on its base class contract.
On the contrary, it calls this function in the next base class contract of the final inheritance relation graph, so it calls <code>Base1.kill()</code> (Note that the Final inheritance sequence is -- starting from the farthest derived contract: Final, Base2, Base1, epoch, ownerd). The actual function called using super in the class is unknown in the context of the current class although its type is known.
This is similar to a common virtual method to find.</p>
<h3 id="parameters-of-the-base-class-constructor"><a name="parameters-of-the-base-class-constructor" class="plugin-anchor" href="#parameters-of-the-base-class-constructor"><i class="fa fa-link" aria-hidden="true"></i></a>Parameters of the base class constructor</h3>
<p>The derived contract needs to provide all the parameters required by the base class constructor. this can be done in two ways:</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.0;

    contract Base {
        uint x;
        <span class="hljs-keyword">function</span> Base(uint _x) public { x = _x; }
    }

    contract Derived is Base(7) {
        <span class="hljs-keyword">function</span> Derived(uint _y) Base(_y * _y) public {
        }
    }
</code></pre>
<p>One method directly calls the base class constructor in the inheritance list&#xFF08;<code>is Base(7)</code>&#xFF09;another method is like the | modifier | Usage method, as part of the derived contract constructor definition header&#xFF08;<code>Base(_y * _y)</code>). If the constructor parameter is a constant and defines or describes the behavior of the contract, it is more convenient to use the first method. If the parameters of the base class constructor depend on the derived contract, the second method must be used. If, like this simple example, both parts are used, the | modifier | Style parameter is preferred.</p>
<h3 id="multiple-inheritance-and-linearization"><a name="multiple-inheritance-and-linearization" class="plugin-anchor" href="#multiple-inheritance-and-linearization"><i class="fa fa-link" aria-hidden="true"></i></a>Multiple inheritance and linearization</h3>
<p>Several problems need to be solved for programming languages to implement multiple inheritance.
One problem is<a href="https://en.wikipedia.org/wiki/Multiple_inheritance#The_diamond_problem" target="_blank">Diamond problem</a>
Solidity uses Python as a reference and uses <a href="https://en.wikipedia.org/wiki/C3_linearization" target="_blank">C3 &#x7EBF;&#x6027;&#x5316;</a> forces a DAG (directed acyclic graph) composed of the base class to maintain a specific order. This is finally reflected as the unique result we hope, but it also makes some inheritance methods invalid. In particular, the base class in is The following order is very important. In the following code, Solidity gives an error such as &quot;Linearization of inheritance graph impossible.</p>
<pre><code class="lang-bash">
    // &#x4EE5;&#x4E0B;&#x4EE3;&#x7801;&#x7F16;&#x8BD1;&#x51FA;&#x9519;

    pragma solidity ^0.4.0;

    contract X {}
    contract A is X {}
    contract C is A, X {}
</code></pre>
<p>The cause of code compilation error is <code>C</code> requirement <code>X</code> override <code>A</code> &#xFF08;because the order of definition is <code>A, X</code> &#xFF09;&#xFF0C;
but <code>A</code> it self requires rewriting <code>X</code>&#xFF0C;this conflict cannot be resolved.</p>
<p>You can remember it through a simple rule: from &quot;most base-like&quot; to &quot;most derived&quot; to specify all base classes.</p>
<h4 id="inheriting-different-types-of-members-with-the-same-name"><a name="inheriting-different-types-of-members-with-the-same-name" class="plugin-anchor" href="#inheriting-different-types-of-members-with-the-same-name"><i class="fa fa-link" aria-hidden="true"></i></a>Inheriting different types of members with the same name</h4>
<p>This is considered an error when inheritance causes a contract to have functions and | modifier | With the same name.
If an event has the same name as | modifier | Or a function has the same name as an event, it is also considered an error.
An exception is that the getter of a state variable can overwrite a public function.</p>
<h3 id="abstract-contract"><a name="abstract-contract" class="plugin-anchor" href="#abstract-contract"><i class="fa fa-link" aria-hidden="true"></i></a>Abstract contract</h3>
<p>The contract function can be missing implementation, as shown in the following example (note that the function declaration header is <code>;</code> end):</p>
<pre><code>    pragma solidity ^0.4.0;

    contract Feline {
        function utterance() public returns (bytes32);
    }
</code></pre><p>These contracts cannot be compiled successfully (even if they contain other implemented functions besides unimplemented functions), they can be used as base class contracts:</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.0;

    contract Feline {
        <span class="hljs-keyword">function</span> utterance() public returns (bytes32);
    }

    contract Cat is Feline {
        <span class="hljs-keyword">function</span> utterance() public returns (bytes32) { <span class="hljs-built_in">return</span> <span class="hljs-string">&quot;miaow&quot;</span>; }
    }
</code></pre>
<p>If a contract inherits from an abstract contract and does not implement all unimplemented functions by rewriting, it is abstract in itself.</p>
<h3 id="interface"><a name="interface" class="plugin-anchor" href="#interface"><i class="fa fa-link" aria-hidden="true"></i></a>interface</h3>
<p>Interfaces are similar to abstract contracts, but they cannot implement any functions. There are further restrictions:</p>
<ul>
<li>Unable to inherit other contracts or interfaces.</li>
<li>The constructor cannot be defined.</li>
<li>Variables cannot be defined.</li>
<li>Unable to define structure</li>
<li>Unable to define enumeration.</li>
</ul>
<p>Some restrictions here may be lifted in the future.</p>
<p>Interfaces are basically limited to what the contract ABI can represent, and the conversion between ABI and interfaces should not lose any information.</p>
<p>Interfaces are represented by their own keywords:</p>
<pre><code class="lang-bash">
    pragma solidity ^0.4.11;

    interface Token {
        <span class="hljs-keyword">function</span> transfer(address recipient, uint amount) public;
    }
</code></pre>
<p>Just like inheriting other contracts, contracts can inherit interfaces.</p>
<h3 id="library"><a name="library" class="plugin-anchor" href="#library"><i class="fa fa-link" aria-hidden="true"></i></a>Library</h3>
<p>Libraries are similar to contracts, they only need to be deployed at a specific address once, and their code can be passed through EVM&apos;s DELEGATECALL (Previously used Homestead CALLCODE Keyword) features for reuse. This means that if the library function is called, its code is executed in the context of the call contract, that is this Points to the call contract, especially the storage that can access the call contract. Because each library is a piece of independent code, it can only access the state variables explicitly provided by the call contract (otherwise it cannot access these variables by name). Because we assume that libraries are stateless, so if they do not modify the state (that is, if they are view Or pure Function), library functions can only be used by direct calls (that is, do not use DELEGATECALL Key words), in particular, it is impossible to destroy any library unless Solidity type systems can be avoided.</p>
<p>Libraries can be seen as implicit base class contracts that use their contracts. Although they are not explicitly visible in inheritance relationships, calling library functions is very similar to calling explicit base class contracts (if L If it is a library, it can be used L.f() Call the library function). In addition, just as the library is a base class contract, for all contracts that use the library, internal Functions are visible.
Of course, internal calling conventions must be used to call internal functions, which means that all internal types and memory types are passed by reference rather than replication. To implement these in EVM, the code of the internal library function and all the functions called from it are pulled into the call contract at the compilation stage, and then use one JUMP Call to replace DELEGATECALL .</p>
<p>The following example shows how to use the library&#xFF08;a better example of the implementation set&#xFF09;:</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.16;

    library Set {
      // &#x6211;&#x4EEC;&#x5B9A;&#x4E49;&#x4E86;&#x4E00;&#x4E2A;&#x65B0;&#x7684;&#x7ED3;&#x6784;&#x4F53;&#x6570;&#x636E;&#x7C7B;&#x578B;&#xFF0C;&#x7528;&#x4E8E;&#x5728;&#x8C03;&#x7528;&#x5408;&#x7EA6;&#x4E2D;&#x4FDD;&#x5B58;&#x6570;&#x636E;&#x3002;
      struct Data { mapping(uint =&gt; bool) flags; }

      // &#x6CE8;&#x610F;&#x7B2C;&#x4E00;&#x4E2A;&#x53C2;&#x6570;&#x662F;&#x201C;storage reference&#x201D;&#x7C7B;&#x578B;&#xFF0C;&#x56E0;&#x6B64;&#x5728;&#x8C03;&#x7528;&#x4E2D;&#x53C2;&#x6570;&#x4F20;&#x9012;&#x7684;&#x53EA;&#x662F;&#x5B83;&#x7684;&#x5B58;&#x50A8;&#x5730;&#x5740;&#x800C;&#x4E0D;&#x662F;&#x5185;&#x5BB9;&#x3002;
      // &#x8FD9;&#x662F;&#x5E93;&#x51FD;&#x6570;&#x7684;&#x4E00;&#x4E2A;&#x7279;&#x6027;&#x3002;&#x5982;&#x679C;&#x8BE5;&#x51FD;&#x6570;&#x53EF;&#x4EE5;&#x88AB;&#x89C6;&#x4E3A;&#x5BF9;&#x8C61;&#x7684;&#x65B9;&#x6CD5;&#xFF0C;&#x5219;&#x4E60;&#x60EF;&#x79F0;&#x7B2C;&#x4E00;&#x4E2A;&#x53C2;&#x6570;&#x4E3A; `self` &#x3002;
      <span class="hljs-keyword">function</span> insert(Data storage self, uint value)
          public
          returns (bool)
      {
          <span class="hljs-keyword">if</span> (self.flags[value])
              <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>; // &#x5DF2;&#x7ECF;&#x5B58;&#x5728;
          self.flags[value] = <span class="hljs-literal">true</span>;
          <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">function</span> remove(Data storage self, uint value)
          public
          returns (bool)
      {
          <span class="hljs-keyword">if</span> (!self.flags[value])
              <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>; // &#x4E0D;&#x5B58;&#x5728;
          self.flags[value] = <span class="hljs-literal">false</span>;
          <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">function</span> contains(Data storage self, uint value)
          public
          view
          returns (bool)
      {
          <span class="hljs-built_in">return</span> self.flags[value];
      }
    }

    contract C {
        Set.Data knownValues;

        <span class="hljs-keyword">function</span> register(uint value) public {
            // &#x4E0D;&#x9700;&#x8981;&#x5E93;&#x7684;&#x7279;&#x5B9A;&#x5B9E;&#x4F8B;&#x5C31;&#x53EF;&#x4EE5;&#x8C03;&#x7528;&#x5E93;&#x51FD;&#x6570;&#xFF0C;
            // &#x56E0;&#x4E3A;&#x5F53;&#x524D;&#x5408;&#x7EA6;&#x5C31;&#x662F;&#x201C;instance&#x201D;&#x3002;
            require(Set.insert(knownValues, value));
        }
        // &#x5982;&#x679C;&#x6211;&#x4EEC;&#x613F;&#x610F;&#xFF0C;&#x6211;&#x4EEC;&#x4E5F;&#x53EF;&#x4EE5;&#x5728;&#x8FD9;&#x4E2A;&#x5408;&#x7EA6;&#x4E2D;&#x76F4;&#x63A5;&#x8BBF;&#x95EE; knownValues.flags&#x3002;
    }
</code></pre>
<p>Of course, you don&apos;t have to use libraries in this way: They can also be used without defining structural data types. Functions also do not require any storage reference parameters. Libraries can appear anywhere and have multiple storage reference parameters.</p>
<p>call <code>Set.contains</code>&#xFF0C;<code>Set.insert</code> and <code>Set.remove</code> all are compiled as external calls&#xFF08; <code>DELEGATECALL</code> ). If you use libraries, note that external function calls are actually executed. <code>msg.sender</code>&#xFF0C; <code>msg.value</code> and <code>this</code> values will be retained in the call (before Homestead, because <code>CALLCODE</code>&#xFF0C;changed <code>msg.sender</code> and <code>msg.value</code>)&#x3002;</p>
<p>The following example shows how to use memory types and internal functions in a library to implement custom types without paying for the overhead of external function calls:</p>
<pre><code class="lang-bash">
    pragma solidity ^0.4.16;

    library BigInt {
        struct bigint {
            uint[] limbs;
        }

        <span class="hljs-keyword">function</span> fromUint(uint x) internal pure returns (bigint r) {
            r.limbs = new uint[](1);
            r.limbs[0] = x;
        }

        <span class="hljs-keyword">function</span> add(bigint _a, bigint _b) internal pure returns (bigint r) {
            r.limbs = new uint[](max(_a.limbs.length, _b.limbs.length));
            uint carry = 0;
            <span class="hljs-keyword">for</span> (uint i = 0; i &lt; r.limbs.length; ++i) {
                uint a = limb(_a, i);
                uint b = limb(_b, i);
                r.limbs[i] = a + b + carry;
                <span class="hljs-keyword">if</span> (a + b &lt; a || (a + b == uint(-1) &amp;&amp; carry &gt; 0))
                    carry = 1;
                <span class="hljs-keyword">else</span>
                    carry = 0;
            }
            <span class="hljs-keyword">if</span> (carry &gt; 0) {
                // &#x592A;&#x5DEE;&#x4E86;&#xFF0C;&#x6211;&#x4EEC;&#x9700;&#x8981;&#x589E;&#x52A0;&#x4E00;&#x4E2A; limb
                uint[] memory newLimbs = new uint[](r.limbs.length + 1);
                <span class="hljs-keyword">for</span> (i = 0; i &lt; r.limbs.length; ++i)
                    newLimbs[i] = r.limbs[i];
                newLimbs[i] = carry;
                r.limbs = newLimbs;
            }
        }

        <span class="hljs-keyword">function</span> limb(bigint _a, uint _limb) internal pure returns (uint) {
            <span class="hljs-built_in">return</span> _limb &lt; _a.limbs.length ? _a.limbs[_limb] : 0;
        }

        <span class="hljs-keyword">function</span> max(uint a, uint b) private pure returns (uint) {
            <span class="hljs-built_in">return</span> a &gt; b ? a : b;
        }
    }

    contract C {
        using BigInt <span class="hljs-keyword">for</span> BigInt.bigint;

        <span class="hljs-keyword">function</span> f() public pure {
            var x = BigInt.fromUint(7);
            var y = BigInt.fromUint(uint(-1));
            var z = x.add(y);
        }
    }
</code></pre>
<p>Since the compiler cannot know the deployment location of the library, we need to fill these addresses in the final bytecode through the linker.
If these addresses are not passed to the compiler as parameters, the compiled hexadecimal code will contain <strong>Set<em>__</em></strong> Placeholder of the form (where Set Is the name of the library). You can manually fill in the address to replace the 40 characters with the hexadecimal code of the library contract address.</p>
<p>Compared with contracts, library restrictions:</p>
<ul>
<li>No state variables</li>
<li>Unable to inherit or be inherited</li>
<li>Unable to receive Sipc coins</li>
</ul>
<p>&#xFF08;These restrictions may be lifted in the future&#xFF09;</p>
<h4 id="library-call-protection"><a name="library-call-protection" class="plugin-anchor" href="#library-call-protection"><i class="fa fa-link" aria-hidden="true"></i></a>Library call protection</h4>
<p>If the library code is passed <code>CALL</code> To execute, not <code>DELEGATECALL</code> Or <code>CALLCODE</code> Then the execution result will be rolled back unless it is right <code>view</code> Or <code>pure</code> The call of the function. EVM does not provide a check for the contract whether to use <code>CALL</code> But the contract can use <code>ADDRESS</code> The operation code finds the running location &quot;. The generated code determines the call mode by comparing this address with the constructed address.</p>
<p>More specifically, the runtime code of the library always starts with a push instruction, which is zero of 20 bytes at compile time. When the deployment code runs, this constant replaced by the current address in memory, the modified code is stored in the contract. At runtime, this causes the deployment address to be the first constant pushed to the stack, For any non-view and non-pure functions, the scheduler code compares whether the current address is consistent with this constant.</p>
<h3 id="using-for"><a name="using-for" class="plugin-anchor" href="#using-for"><i class="fa fa-link" aria-hidden="true"></i></a>Using For</h3>
<p>Command <code>using A for B;</code> can be used to attach library functions (from library <code>A</code> ) to any type ( <code>B</code> ).
These functions will receive the object that calls them as their first parameter (like Python&apos;s self Variable).
<code>using A for *;</code> the effect of IS, library <code>A</code> The function in is attached to any type. In both cases, all functions are appended with a parameter even if their first parameter type does not match the type of the object.
Type check is performed only when function calls and overload parsing are performed. <code>using A for B</code>; The directive is only valid in the current scope and only in the current contract. It may be upgraded to the global scope in the future. By introducing a module, you can use data types including library functions without adding code.</p>
<p>Let&apos;s use this way <code>libraries</code> Rewrite the set example in:</p>
<pre><code class="lang-bash">    pragma solidity ^0.4.16;

    // &#x8FD9;&#x662F;&#x548C;&#x4E4B;&#x524D;&#x4E00;&#x6837;&#x7684;&#x4EE3;&#x7801;&#xFF0C;&#x53EA;&#x662F;&#x6CA1;&#x6709;&#x6CE8;&#x91CA;&#x3002;
    library Set {
      struct Data { mapping(uint =&gt; bool) flags; }

      <span class="hljs-keyword">function</span> insert(Data storage self, uint value)
          public
          returns (bool)
      {
          <span class="hljs-keyword">if</span> (self.flags[value])
            <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>; // &#x5DF2;&#x7ECF;&#x5B58;&#x5728;
          self.flags[value] = <span class="hljs-literal">true</span>;
          <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">function</span> remove(Data storage self, uint value)
          public
          returns (bool)
      {
          <span class="hljs-keyword">if</span> (!self.flags[value])
              <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>; // &#x4E0D;&#x5B58;&#x5728;
          self.flags[value] = <span class="hljs-literal">false</span>;
          <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;
      }

      <span class="hljs-keyword">function</span> contains(Data storage self, uint value)
          public
          view
          returns (bool)
      {
          <span class="hljs-built_in">return</span> self.flags[value];
      }
    }

    contract C {
        using Set <span class="hljs-keyword">for</span> Set.Data; // &#x8FD9;&#x91CC;&#x662F;&#x5173;&#x952E;&#x7684;&#x4FEE;&#x6539;
        Set.Data knownValues;

        <span class="hljs-keyword">function</span> register(uint value) public {
            // Here, all variables of <span class="hljs-built_in">type</span> Set.Data have
            // corresponding member functions.
            // The following <span class="hljs-keyword">function</span> call is identical to
            // `Set.insert(knownValues, value)`
            // &#x8FD9;&#x91CC;&#xFF0C; Set.Data &#x7C7B;&#x578B;&#x7684;&#x6240;&#x6709;&#x53D8;&#x91CF;&#x90FD;&#x6709;&#x4E0E;&#x4E4B;&#x76F8;&#x5BF9;&#x5E94;&#x7684;&#x6210;&#x5458;&#x51FD;&#x6570;&#x3002;
            // &#x4E0B;&#x9762;&#x7684;&#x51FD;&#x6570;&#x8C03;&#x7528;&#x548C; `Set.insert(knownValues, value)` &#x7684;&#x6548;&#x679C;&#x5B8C;&#x5168;&#x76F8;&#x540C;&#x3002;
            require(knownValues.insert(value));
        }
    }
</code></pre>
<p>You can also extend basic types like this:</p>
<pre><code class="lang-bash">
    pragma solidity ^0.4.16;

    library Search {
        <span class="hljs-keyword">function</span> indexOf(uint[] storage self, uint value)
            public
            view
            returns (uint)
        {
            <span class="hljs-keyword">for</span> (uint i = 0; i &lt; self.length; i++)
                <span class="hljs-keyword">if</span> (self[i] == value) <span class="hljs-built_in">return</span> i;
            <span class="hljs-built_in">return</span> uint(-1);
        }
    }

    contract C {
        using Search <span class="hljs-keyword">for</span> uint[];
        uint[] data;

        <span class="hljs-keyword">function</span> append(uint value) public {
            data.push(value);
        }

        <span class="hljs-keyword">function</span> replace(uint _old, uint _new) public {
            // &#x6267;&#x884C;&#x5E93;&#x51FD;&#x6570;&#x8C03;&#x7528;
            uint index = data.indexOf(_old);
            <span class="hljs-keyword">if</span> (index == uint(-1))
                data.push(_new);
            <span class="hljs-keyword">else</span>
                data[index] = _new;
        }
    }
</code></pre>
<p>Note that all library calls are actual EVM function calls. This means that if the memory or value type is passed, a copy will be generated, even if self Variables.] Using a storage reference variable is the only case where copying does not occur.</p>
<h2 id="solidity-assembly"><a name="solidity-assembly" class="plugin-anchor" href="#solidity-assembly"><i class="fa fa-link" aria-hidden="true"></i></a>Solidity Assembly</h2>
<p>Solidity defines an assembly language that can be used without Solidity. This assembly language can also be embedded into Solidity source code as &quot;inline assembly. We begin with how to use inline assembly, introduce how it differs from independent assembly language, and then describe this assembly language in detail.</p>
<h3 id="inline-assembly"><a name="inline-assembly" class="plugin-anchor" href="#inline-assembly"><i class="fa fa-link" aria-hidden="true"></i></a>Inline assembly</h3>
<p>In order to achieve finer-grained control, especially to enhance the language by writing libraries, you can use a language close to the virtual machine to combine inline assembly with Solidity statements.
Since EVM is a stack-based virtual machine, it is usually difficult to accurately locate the address of the slot (storage location) in the stack and provide the correct stack location for the operation code to obtain parameters.
Solidity&apos;s inline assembly attempts to solve this problem and possible problems when writing assembly code manually by providing the following features:</p>
<ul>
<li>Function style operation code&#xFF1A; <code>mul(1, add(2, 3))</code> rather <code>push1 3 push1 2 add push1 1 mul</code></li>
<li>Assemble local variables&#xFF1A; <code>let x := add(2, 3)  let y := mload(0x40)  x := add(x, y)</code></li>
<li>External variables can be accessed&#xFF1A; <code>function f(uint x) public { assembly { x := sub(x, 1) } }</code></li>
<li>Label&#xFF1A; <code>let x := 10  repeat: x := sub(x, 1) jumpi(repeat, eq(x, 0))</code></li>
<li>Circulation&#xFF1A; <code>for { let i := 0 } lt(i, x) { i := add(i, 1) } { y := mul(2, y) }</code></li>
<li>if statement: <code>if slt(x, 0) { x := sub(0, x) }</code></li>
<li>switch statent&#xFF1A; <code>switch x case 0 { y := mul(x, 2) } default { y := 0 }</code></li>
<li>Function call&#xFF1A; <code>function f(x) -&gt; y { switch x case 0 { y := 1 } default { y := mul(x, f(sub(x, 1))) }   }</code></li>
</ul>
<p>Now let&apos;s explain the inline assembly language in detail.</p>
<blockquote>
<p>Inline assembly is a language that accesses Simplechain virtual machines at the underlying layer. This abandons many important security features provided by Solidity.</p>
<p>TODO&#xFF1A;describes the nuances of scope rules in an inline assembly and the complexity of using internal functions of library contracts. In addition, symbols about compiler definitions are also written.</p>
</blockquote>
<h2 id="example"><a name="example" class="plugin-anchor" href="#example"><i class="fa fa-link" aria-hidden="true"></i></a>Example</h2>
<p>The following example shows the code of a library contract, which can get the code of another contract and load it into a <code>bytes</code> Variable.
This is impossible for &quot;conventional Solidity&quot;, and Assembly Library contracts can enhance language characteristics in this way.</p>
<pre><code class="lang-bash">
    pragma solidity ^0.4.0;

    library GetCode {
        <span class="hljs-keyword">function</span> at(address _addr) public view returns (bytes o_code) {
            assembly {
                // &#x83B7;&#x53D6;&#x4EE3;&#x7801;&#x5927;&#x5C0F;&#xFF0C;&#x8FD9;&#x9700;&#x8981;&#x6C47;&#x7F16;&#x8BED;&#x8A00;
                <span class="hljs-built_in">let</span> size := extcodesize(_addr)
                // &#x5206;&#x914D;&#x8F93;&#x51FA;&#x5B57;&#x8282;&#x6570;&#x7EC4; &#x2013; &#x8FD9;&#x4E5F;&#x53EF;&#x4EE5;&#x4E0D;&#x7528;&#x6C47;&#x7F16;&#x8BED;&#x8A00;&#x6765;&#x5B9E;&#x73B0;
                // &#x901A;&#x8FC7;&#x4F7F;&#x7528; o_code = new bytes&#xFF08;size&#xFF09;
                o_code := mload(0x40)
                // &#x5305;&#x62EC;&#x8865;&#x4F4D;&#x5728;&#x5185;&#x65B0;&#x7684;&#x201C;memory end&#x201D;
                mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f))))
                // &#x628A;&#x957F;&#x5EA6;&#x4FDD;&#x5B58;&#x5230;&#x5185;&#x5B58;&#x4E2D;
                mstore(o_code, size)
                // &#x5B9E;&#x9645;&#x83B7;&#x53D6;&#x4EE3;&#x7801;&#xFF0C;&#x8FD9;&#x9700;&#x8981;&#x6C47;&#x7F16;&#x8BED;&#x8A00;
                extcodecopy(_addr, add(o_code, 0x20), 0, size)
            }
        }
    }
</code></pre>
<p>When the optimizer cannot generate efficient code, inline assembly may also be more beneficial. Note that it is definitely more difficult to write assembly code because the compiler cannot check assembly statements; Therefore, you need to use it only when dealing with some relatively complex problems, and you need to know clearly what you want to do.</p>
<pre><code class="lang-bash">
    pragma solidity ^0.4.16;

    library VectorSum {
        // &#x56E0;&#x4E3A;&#x76EE;&#x524D;&#x7684;&#x4F18;&#x5316;&#x5668;&#x5728;&#x8BBF;&#x95EE;&#x6570;&#x7EC4;&#x65F6;&#x65E0;&#x6CD5;&#x79FB;&#x9664;&#x8FB9;&#x754C;&#x68C0;&#x67E5;&#xFF0C;
        // &#x6240;&#x4EE5;&#x8FD9;&#x4E2A;&#x51FD;&#x6570;&#x7684;&#x6267;&#x884C;&#x6548;&#x7387;&#x6BD4;&#x8F83;&#x4F4E;&#x3002;
        <span class="hljs-keyword">function</span> sumSolidity(uint[] _data) public view returns (uint o_sum) {
            <span class="hljs-keyword">for</span> (uint i = 0; i &lt; _data.length; ++i)
                o_sum += _data[i];
        }

        // &#x6211;&#x4EEC;&#x77E5;&#x9053;&#x6211;&#x4EEC;&#x53EA;&#x80FD;&#x5728;&#x6570;&#x7EC4;&#x8303;&#x56F4;&#x5185;&#x8BBF;&#x95EE;&#x6570;&#x7EC4;&#x5143;&#x7D20;&#xFF0C;&#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x53EF;&#x4EE5;&#x5728;&#x5185;&#x8054;&#x6C47;&#x7F16;&#x4E2D;&#x4E0D;&#x505A;&#x8FB9;&#x754C;&#x68C0;&#x67E5;&#x3002;
        // &#x7531;&#x4E8E; ABI &#x7F16;&#x7801;&#x4E2D;&#x6570;&#x7EC4;&#x6570;&#x636E;&#x7684;&#x7B2C;&#x4E00;&#x4E2A;&#x5B57;&#xFF08;32 &#x5B57;&#x8282;&#xFF09;&#x7684;&#x4F4D;&#x7F6E;&#x4FDD;&#x5B58;&#x7684;&#x662F;&#x6570;&#x7EC4;&#x957F;&#x5EA6;&#xFF0C;
        // &#x6240;&#x4EE5;&#x6211;&#x4EEC;&#x5728;&#x8BBF;&#x95EE;&#x6570;&#x7EC4;&#x5143;&#x7D20;&#x65F6;&#x9700;&#x8981;&#x52A0;&#x5165; 0x20 &#x4F5C;&#x4E3A;&#x504F;&#x79FB;&#x91CF;&#x3002;
        <span class="hljs-keyword">function</span> sumAsm(uint[] _data) public view returns (uint o_sum) {
            <span class="hljs-keyword">for</span> (uint i = 0; i &lt; _data.length; ++i) {
                assembly {
                    o_sum := add(o_sum, mload(add(add(_data, 0x20), mul(i, 0x20))))
                }
            }
        }

        // &#x548C;&#x4E0A;&#x9762;&#x4E00;&#x6837;&#xFF0C;&#x4F46;&#x5728;&#x5185;&#x8054;&#x6C47;&#x7F16;&#x5185;&#x5B8C;&#x6210;&#x6574;&#x4E2A;&#x4EE3;&#x7801;&#x3002;
        <span class="hljs-keyword">function</span> sumPureAsm(uint[] _data) public view returns (uint o_sum) {
            assembly {
               // &#x53D6;&#x5F97;&#x6570;&#x7EC4;&#x957F;&#x5EA6;&#xFF08;&#x524D; 32 &#x5B57;&#x8282;&#xFF09;
               <span class="hljs-built_in">let</span> len := mload(_data)

               // &#x7565;&#x8FC7;&#x957F;&#x5EA6;&#x5B57;&#x6BB5;&#x3002;
               //
               // &#x4FDD;&#x6301;&#x4E34;&#x65F6;&#x53D8;&#x91CF;&#x4EE5;&#x4FBF;&#x5B83;&#x53EF;&#x4EE5;&#x5728;&#x539F;&#x5730;&#x589E;&#x52A0;&#x3002;
               //
               // &#x6CE8;&#x610F;&#xFF1A;&#x5BF9; _data &#x6570;&#x503C;&#x7684;&#x589E;&#x52A0;&#x5C06;&#x5BFC;&#x81F4; _data &#x5728;&#x8FD9;&#x4E2A;&#x6C47;&#x7F16;&#x8BED;&#x53E5;&#x5757;&#x4E4B;&#x540E;&#x4E0D;&#x518D;&#x53EF;&#x7528;&#x3002;
               //      &#x56E0;&#x4E3A;&#x65E0;&#x6CD5;&#x518D;&#x57FA;&#x4E8E; _data &#x6765;&#x89E3;&#x6790;&#x540E;&#x7EED;&#x7684;&#x6570;&#x7EC4;&#x6570;&#x636E;&#x3002;
               <span class="hljs-built_in">let</span> data := add(_data, 0x20)

               // &#x8FED;&#x4EE3;&#x5230;&#x6570;&#x7EC4;&#x6570;&#x636E;&#x7ED3;&#x675F;
               <span class="hljs-keyword">for</span>
                   { <span class="hljs-built_in">let</span> end := add(data, mul(len, 0x20)) }
                   lt(data, end)
                   { data := add(data, 0x20) }
               {
                   o_sum := add(o_sum, mload(data))
               }
            }
        }
    }
</code></pre>
<h4 id="syntax"><a name="syntax" class="plugin-anchor" href="#syntax"><i class="fa fa-link" aria-hidden="true"></i></a>Syntax</h4>
<p>Like Solidity, Assembly also parses comments, text, and identifiers, so you can use the usual <code>//</code> and <code>/* */</code> to comment.
The inline assembler is composed <code>assembly { ... }</code> to mark, the following can be used in these braces (see later for more details).</p>
<ul>
<li>Literal constant, that is <code>0x123</code>&#x3001;<code>42</code> or <code>&quot;abc&quot;</code> &#xFF08;a string not exceeding 32 characters&#xFF09;</li>
<li>Operation code&#xFF08;within &#x201C;instruction style&#x201D;&#xFF09;&#xFF0C;such <code>mload sload dup1 sstore</code>&#xFF0C;please see the following operation code list</li>
<li>Function-style opcodes, such <code>add(1&#xFF0C;mlod(0))</code></li>
<li>Tags, such<code>name:</code></li>
<li>Variable declaration, such <code>let x := 7</code>&#x3001;<code>let x := add(y, 3)</code> or <code>let x</code> &#xFF08;the initial value will be set to empty(0))&#xFF09;</li>
<li>Identifiers (tags or assembly local variables and external variables used as inline assemblies), such <code>jump(name)</code> , <code>3 x add</code></li>
<li>Assignment (within &quot;instruction style&quot;), such 3 =: x</li>
<li>Function style assignment, such x := add(y&#xFF0C;3)</li>
<li>Some statement blocks that control the scope of local variables, such {let x := 3 { let y := add(x&#xFF0C;1) }}</li>
</ul>
<h4 id="opcode"><a name="opcode" class="plugin-anchor" href="#opcode"><i class="fa fa-link" aria-hidden="true"></i></a>Opcode</h4>
<p>Reference operation code:</p>
<p>If an opcode requires parameters (always from the top of the stack), they are given in parentheses. Note: the order of parameters can be considered as a reverse order in a non-functional style (explained below). Marked - The operation code of does not push data into the stack, marked * The operation code of has special operations, while all other operations will only push one data into the push stack.
For <code>F</code>&#x3001;<code>H</code>&#x3001;<code>B</code> or <code>C</code> marked opcodes represent that they are introduced from Frontier, Homestead, Byzantium, or Constantinople. Constantinople is still planned, so it is marked C Currently, an invalid instruction is abnormal. In the following table, <code>mem[a...b)</code> indicates from position <code>a</code> start to&#xFF08;excluding&#xFF09;position <code>b</code> number of memory bytes,<code>storage[p]</code> indicates the position <code>p</code> storage content.
<code>pushi</code> and <code>jumpdest</code> these two operation codes cannot be used directly.</p>
<p>In the syntax table, the opcode is provided as a predefined identifier.</p>
<table>
<thead>
<tr>
<th>Instruction</th>
<th>symbol</th>
<th>Bool</th>
<th>Explanation  </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>stop</td>
<td><code>-</code></td>
<td>F</td>
<td>&#x505C;&#x6B62;&#x6267;&#x884C;&#xFF0C;&#x4E0E; return(0,0) &#x7B49;&#x4EF7;</td>
<td></td>
<td></td>
</tr>
<tr>
<td></td>
<td>add(x, y)</td>
<td></td>
<td>F</td>
<td>x + y</td>
<td></td>
</tr>
<tr>
<td></td>
<td>sub(x, y)</td>
<td></td>
<td>F</td>
<td>x - y</td>
<td></td>
</tr>
<tr>
<td></td>
<td>mul(x, y)</td>
<td></td>
<td>F</td>
<td>x * y</td>
<td></td>
</tr>
<tr>
<td></td>
<td>div(x, y)</td>
<td></td>
<td>F</td>
<td>x / y</td>
<td></td>
</tr>
<tr>
<td></td>
<td>sdiv(x, y)</td>
<td></td>
<td>F</td>
<td>x / y&#xFF0C;&#x4EE5;&#x4E8C;&#x8FDB;&#x5236;&#x8865;&#x7801;&#x4F5C;&#x4E3A;&#x7B26;&#x53F7;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>mod(x, y)</td>
<td></td>
<td>F</td>
<td>x % y</td>
<td></td>
</tr>
<tr>
<td></td>
<td>smod(x, y)</td>
<td></td>
<td>F</td>
<td>x % y&#xFF0C;&#x4EE5;&#x4E8C;&#x8FDB;&#x5236;&#x8865;&#x7801;&#x4F5C;&#x4E3A;&#x7B26;&#x53F7;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>exp(x, y)</td>
<td></td>
<td>F</td>
<td>x &#x7684; y &#x6B21;&#x5E42;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>not(x)</td>
<td></td>
<td>F</td>
<td>~x&#xFF0C;&#x5BF9; x &#x6309;&#x4F4D;&#x53D6;&#x53CD;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>lt(x, y)</td>
<td></td>
<td>F</td>
<td>&#x5982;&#x679C; x &lt; y &#x4E3A; 1&#xFF0C;&#x5426;&#x5219;&#x4E3A; 0</td>
<td></td>
</tr>
<tr>
<td></td>
<td>gt(x, y)</td>
<td></td>
<td>F</td>
<td>&#x5982;&#x679C; x &gt; y &#x4E3A; 1&#xFF0C;&#x5426;&#x5219;&#x4E3A; 0</td>
<td></td>
</tr>
<tr>
<td></td>
<td>slt(x, y)</td>
<td></td>
<td>F</td>
<td>&#x5982;&#x679C; x &lt; y &#x4E3A; 1&#xFF0C;&#x5426;&#x5219;&#x4E3A; 0&#xFF0C;&#x4EE5;&#x4E8C;&#x8FDB;&#x5236;&#x8865;&#x7801;&#x4F5C;&#x4E3A;&#x7B26;&#x53F7;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>sgt(x, y)</td>
<td></td>
<td>F</td>
<td>&#x5982;&#x679C; x &gt; y &#x4E3A; 1&#xFF0C;&#x5426;&#x5219;&#x4E3A; 0&#xFF0C;&#x4EE5;&#x4E8C;&#x8FDB;&#x5236;&#x8865;&#x7801;&#x4F5C;&#x4E3A;&#x7B26;&#x53F7;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>eq(x, y)</td>
<td></td>
<td>F</td>
<td>&#x5982;&#x679C; x == y &#x4E3A; 1&#xFF0C;&#x5426;&#x5219;&#x4E3A; 0</td>
<td></td>
</tr>
<tr>
<td></td>
<td>iszero(x)</td>
<td></td>
<td>F</td>
<td>&#x5982;&#x679C; x == 0 &#x4E3A; 1&#xFF0C;&#x5426;&#x5219;&#x4E3A; 0</td>
<td></td>
</tr>
<tr>
<td></td>
<td>and(x, y)</td>
<td></td>
<td>F</td>
<td>x &#x548C; y &#x7684;&#x6309;&#x4F4D;&#x4E0E;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>or(x, y)</td>
<td></td>
<td>F</td>
<td>x &#x548C; y &#x7684;&#x6309;&#x4F4D;&#x6216;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>xor(x, y)</td>
<td></td>
<td>F</td>
<td>x &#x548C; y &#x7684;&#x6309;&#x4F4D;&#x5F02;&#x6216;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>byte(n, x)</td>
<td></td>
<td>F</td>
<td>x &#x7684;&#x7B2C; n &#x4E2A;&#x5B57;&#x8282;&#xFF0C;&#x8FD9;&#x4E2A;&#x7D22;&#x5F15;&#x662F;&#x4ECE; 0 &#x5F00;&#x59CB;&#x7684;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>shl(x, y)</td>
<td></td>
<td>C</td>
<td>&#x5C06; y &#x903B;&#x8F91;&#x5DE6;&#x79FB; x &#x4F4D;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>shr(x, y)</td>
<td></td>
<td>C</td>
<td>&#x5C06; y &#x903B;&#xFFFD;&#xFFFD;&#x53F3;&#x79FB; x &#x4F4D;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>sar(x, y)</td>
<td></td>
<td>C</td>
<td>&#x5C06; y &#x7B97;&#x672F;&#x53F3;&#x79FB; x &#x4F4D;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>addmod(x, y, m)</td>
<td></td>
<td>F</td>
<td>&#x4EFB;&#x610F;&#x7CBE;&#x5EA6;&#x7684; (x + y) % m</td>
<td></td>
</tr>
<tr>
<td></td>
<td>mulmod(x, y, m)</td>
<td></td>
<td>F</td>
<td>&#x4EFB;&#x610F;&#x7CBE;&#x5EA6;&#x7684; (x * y) % m</td>
<td></td>
</tr>
<tr>
<td></td>
<td>signextend(i, x)</td>
<td></td>
<td>F</td>
<td>&#x5BF9; x &#x7684;&#x6700;&#x4F4E;&#x4F4D;&#x5230;&#x7B2C; (i * 8 + 7) &#x8FDB;&#x884C;&#x7B26;&#x53F7;&#x6269;&#x5C55;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>keccak256(p, n)</td>
<td></td>
<td>F</td>
<td>keccak(mem[p...(p + n)))</td>
<td></td>
</tr>
<tr>
<td></td>
<td>jump(label)</td>
<td><code>-</code></td>
<td>F</td>
<td>&#x8DF3;&#x8F6C;&#x5230;&#x6807;&#x7B7E; / &#x4EE3;&#x7801;&#x4F4D;&#x7F6E;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>jumpi(label, cond)</td>
<td><code>-</code></td>
<td>F</td>
<td>&#x5982;&#x679C;&#x6761;&#x4EF6;&#x4E3A;&#x975E;&#x96F6;&#xFF0C;&#x8DF3;&#x8F6C;&#x5230;&#x6807;&#x7B7E;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>pc</td>
<td></td>
<td>F</td>
<td>&#x5F53;&#x524D;&#x4EE3;&#x7801;&#x4F4D;&#x7F6E;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>pop(x)</td>
<td><code>-</code></td>
<td>F</td>
<td>&#x5220;&#x9664;&#xFF08;&#x5F39;&#x51FA;&#xFF09;&#x6808;&#x9876;&#x7684; x &#x4E2A;&#x5143;&#x7D20;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>dup1 ... dup16</td>
<td></td>
<td>F</td>
<td>&#x5C06;&#x6808;&#x5185;&#x7B2C; i &#x4E2A;&#x5143;&#x7D20;&#xFF08;&#x4ECE;&#x6808;&#x9876;&#x7B97;&#x8D77;&#xFF09;&#x590D;&#x5236;&#x5230;&#x6808;&#x9876;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>swap1 ... swap16</td>
<td><code>*</code></td>
<td>F</td>
<td>&#x5C06;&#x6808;&#x9876;&#x5143;&#x7D20;&#x548C;&#x5176;&#x4E0B;&#x7B2C; i &#x4E2A;&#x5143;&#x7D20;&#x4E92;&#x6362;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>mload(p)</td>
<td></td>
<td>F</td>
<td>mem[p...(p + 32))</td>
<td></td>
</tr>
<tr>
<td></td>
<td>mstore(p, v)</td>
<td><code>-</code></td>
<td>F</td>
<td>mem[p...(p + 32)) := v</td>
<td></td>
</tr>
<tr>
<td></td>
<td>mstore8(p, v)</td>
<td><code>-</code></td>
<td>F</td>
<td>mem[p] := v &amp; 0xff &#xFF08;&#x4EC5;&#x4FEE;&#x6539;&#x4E00;&#x4E2A;&#x5B57;&#x8282;&#xFF09;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>sload(p)</td>
<td></td>
<td>F</td>
<td>storage[p]</td>
<td></td>
</tr>
<tr>
<td></td>
<td>sstore(p, v)</td>
<td><code>-</code></td>
<td>F</td>
<td>storage[p] := v</td>
<td></td>
</tr>
<tr>
<td></td>
<td>msize</td>
<td></td>
<td>F</td>
<td>&#x5185;&#x5B58;&#x5927;&#x5C0F;&#xFF0C;&#x5373;&#x6700;&#x5927;&#x53EF;&#x8BBF;&#x95EE;&#x5185;&#x5B58;&#x7D22;&#x5F15;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>gas</td>
<td></td>
<td>F</td>
<td>&#x6267;&#x884C;&#x53EF;&#x7528;&#x7684; gas</td>
<td></td>
</tr>
<tr>
<td></td>
<td>address</td>
<td></td>
<td>F</td>
<td>&#x5F53;&#x524D;&#x5408;&#x7EA6; / &#x6267;&#x884C;&#x4E0A;&#x4E0B;&#x6587;&#x7684;&#x5730;&#x5740;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>balance(a)</td>
<td></td>
<td>F</td>
<td>&#x5730;&#x5740; a &#x7684;&#x4F59;&#x989D;&#xFF0C;&#x4EE5; wei &#x4E3A;&#x5355;&#x4F4D;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>caller</td>
<td></td>
<td>F</td>
<td>&#x8C03;&#x7528;&#x53D1;&#x8D77;&#x8005;&#xFF08;&#x4E0D;&#x5305;&#x62EC; <code>delegatecall</code>&#xFF09;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>callvalue</td>
<td></td>
<td>F</td>
<td>&#x968F;&#x8C03;&#x7528;&#x53D1;&#x9001;&#x7684; Wei &#x7684;&#x6570;&#x91CF;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>calldataload(p)</td>
<td></td>
<td>F</td>
<td>&#x4F4D;&#x7F6E; p &#x7684;&#x8C03;&#x7528;&#x6570;&#x636E;&#xFF08;32 &#x5B57;&#x8282;&#xFF09;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>calldatasize</td>
<td></td>
<td>F</td>
<td>&#x8C03;&#x7528;&#x6570;&#x636E;&#x7684;&#x5B57;&#x8282;&#x6570;&#x5927;&#x5C0F;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>calldatacopy(t, f, s)</td>
<td><code>-</code></td>
<td>F</td>
<td>&#x4ECE;&#x8C03;&#x7528;&#x6570;&#x636E;&#x7684;&#x4F4D;&#x7F6E; f &#x7684;&#x62F7;&#x8D1D; s &#x4E2A;&#x5B57;&#x8282;&#x5230;&#x5185;&#x5B58;&#x7684;&#x4F4D;&#x7F6E; t</td>
<td></td>
</tr>
<tr>
<td></td>
<td>codesize</td>
<td></td>
<td>F</td>
<td>&#x5F53;&#x524D;&#x5408;&#x7EA6; / &#x6267;&#x884C;&#x4E0A;&#x4E0B;&#x6587;&#x5730;&#x5740;&#x7684;&#x4EE3;&#x7801;&#x5927;&#x5C0F;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>codecopy(t, f, s)</td>
<td><code>-</code></td>
<td>F</td>
<td>&#x4ECE;&#x4EE3;&#x7801;&#x7684;&#x4F4D;&#x7F6E; f &#x5F00;&#x59CB;&#x62F7;&#x8D1D; s &#x4E2A;&#x5B57;&#x8282;&#x5230;&#x5185;&#x5B58;&#x7684;&#x4F4D;&#x7F6E; t</td>
<td></td>
</tr>
<tr>
<td></td>
<td>extcodesize(a)</td>
<td></td>
<td>F</td>
<td>&#x5730;&#x5740; a &#x7684;&#x4EE3;&#x7801;&#x5927;&#x5C0F;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>extcodecopy(a, t, f, s)</td>
<td><code>-</code></td>
<td>F</td>
<td>&#x548C; codecopy(t, f, s) &#x7C7B;&#x4F3C;&#xFF0C;&#x4F46;&#x4ECE;&#x5730;&#x5740; a &#x83B7;&#x53D6;&#x4EE3;&#x7801;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>returndatasize</td>
<td></td>
<td>B</td>
<td>&#x6700;&#x540E;&#x4E00;&#x4E2A; returndata &#x7684;&#x5927;&#x5C0F;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>returndatacopy(t, f, s)</td>
<td><code>-</code></td>
<td>B</td>
<td>&#x4ECE; returndata &#x7684;&#x4F4D;&#x7F6E; f &#x62F7;&#x8D1D; s &#x4E2A;&#x5B57;&#x8282;&#x5230;&#x5185;&#x5B58;&#x7684;&#x4F4D;&#x7F6E; t</td>
<td></td>
</tr>
<tr>
<td></td>
<td>create(v, p, s)</td>
<td></td>
<td>F</td>
<td>&#x7528; mem[p...(p + s)) &#x4E2D;&#x7684;&#x4EE3;&#x7801;&#x521B;&#x5EFA;&#x4E00;&#x4E2A;&#x65B0;&#x5408;&#x7EA6;&#x3001;&#x53D1;&#x9001; v wei &#x5E76;&#x8FD4;&#x56DE;&#x65B0;&#x5730;&#x5740;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>create2(v, n, p, s)</td>
<td></td>
<td>C</td>
<td>&#x7528; mem[p...(p + s)) &#x4E2D;&#x7684;&#x4EE3;&#x7801;&#xFF0C;&#x5728;&#x5730;&#x5740;keccak256(<address> . n . keccak256(mem[p...(p + s)))&#x521B;&#x5EFA;&#x65B0;&#x5408;&#x7EA6;&#x3001;&#x53D1;&#x9001; v wei &#x5E76;&#x8FD4;&#x56DE;&#x65B0;&#x5730;&#x5740;&#x4E0A;</address></td>
<td></td>
</tr>
<tr>
<td></td>
<td>call(g, a, v, in,insize, out, outsize)</td>
<td></td>
<td>F</td>
<td>&#x4F7F;&#x7528; mem[in...(in + insize)) &#x4F5C;&#x4E3A;&#x8F93;&#x5165;&#x6570;&#x636E;&#xFF0C;&#x63D0;&#x4F9B; g gas &#x548C; v wei &#x5BF9;&#x5730;&#x5740; a &#x53D1;&#x8D77;&#x6D88;&#x606F;&#x8C03;&#x7528;&#xFF0C;&#x8F93;&#x51FA;&#x7ED3;&#x679C;&#x6570;&#x636E;&#x4FDD;&#x5B58;&#x5728; mem[out...(out + outsize))&#xFF0C;&#x53D1;&#x751F;&#x9519;&#x8BEF;&#xFF08;&#x6BD4;&#x5982; gas &#x4E0D;&#x8DB3;&#xFF09;&#x65F6;&#x8FD4;&#x56DE; 0&#xFF0C;&#x6B63;&#x786E;&#x7ED3;&#x675F;&#x8FD4;&#x56DE; 1</td>
<td></td>
</tr>
<tr>
<td></td>
<td>callcode(g, a, v, in,insize, out, outsize)</td>
<td></td>
<td>F</td>
<td>&#x4E0E; <code>call</code> &#x7B49;&#x4EF7;&#xFF0C;&#x4F46;&#x4EC5;&#x4F7F;&#x7528;&#x5730;&#x5740; a &#x4E2D;&#x7684;&#x4EE3;&#x7801; &#x4E14;&#x4FDD;&#x6301;&#x5F53;&#x524D;&#x5408;&#x7EA6;&#x7684;&#x6267;&#x884C;&#x4E0A;&#x4E0B;&#x6587;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>delegatecall(g, a, in,insize, out, outsize)</td>
<td></td>
<td>F</td>
<td>&#x4E0E; <code>callcode</code> &#x7B49;&#x4EF7;&#x4E14;&#x4FDD;&#x7559; <code>caller</code> &#x548C; <code>callvalue</code></td>
<td></td>
</tr>
<tr>
<td></td>
<td>staticcall(g, a, in,insize, out, outsize)</td>
<td></td>
<td>F</td>
<td>&#x4E0E; <code>call(g, a, 0, in, insize, out, outsize)</code> &#x7B49;&#x4EF7;,&#x4F46;&#x4E0D;&#x5141;&#x8BB8;&#x72B6;&#x6001;&#x4FEE;&#x6539;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>return(p, s)</td>
<td><code>-</code></td>
<td>F</td>
<td>&#x7EC8;&#x6B62;&#x8FD0;&#x884C;&#xFF0C;&#x8FD4;&#x56DE; mem[p...(p + s)) &#x7684;&#x6570;&#x636E;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>revert(p, s)</td>
<td><code>-</code></td>
<td>B</td>
<td>&#x7EC8;&#x6B62;&#x8FD0;&#x884C;&#xFF0C;&#x64A4;&#x9500;&#x72B6;&#x6001;&#x53D8;&#x5316;&#xFF0C;&#x8FD4;&#x56DE; mem[p...(p + s)) &#x7684;&#x6570;&#x636E;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>selfdestruct(a)</td>
<td><code>-</code></td>
<td>F</td>
<td>&#x7EC8;&#x6B62;&#x8FD0;&#x884C;&#xFF0C;&#x9500;&#x6BC1;&#x5F53;&#x524D;&#x5408;&#x7EA6;&#x5E76;&#x4E14;&#x628A;&#x8D44;&#x91D1;&#x53D1;&#x9001;&#x5230;&#x5730;&#x5740; a</td>
<td></td>
</tr>
<tr>
<td></td>
<td>invalid</td>
<td><code>-</code></td>
<td>F</td>
<td>&#x4EE5;&#x65E0;&#x6548;&#x6307;&#x4EE4;&#x7EC8;&#x6B62;&#x8FD0;&#x884C;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>log0(p, s)</td>
<td><code>-</code></td>
<td>F</td>
<td>&#x4EE5; mem[p...(p + s)) &#x7684;&#x6570;&#x636E;&#x4EA7;&#x751F;&#x4E0D;&#x5E26; topic &#x7684;&#x65E5;&#x5FD7;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>log1(p, s, t1)</td>
<td><code>-</code></td>
<td>F</td>
<td>&#x4EE5; mem[p...(p + s)) &#x7684;&#x6570;&#x636E;&#x548C; topic t1 &#x4EA7;&#x751F;&#x65E5;&#x5FD7;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>log2(p, s, t1, t2)</td>
<td><code>-</code></td>
<td>F</td>
<td>&#x4EE5; mem[p...(p + s)) &#x7684;&#x6570;&#x636E;&#x548C; topic t1&#x3001;t2 &#x4EA7;&#x751F;&#x65E5;&#x5FD7;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>log3(p, s, t1, t2, t3)</td>
<td><code>-</code></td>
<td>F</td>
<td>&#x4EE5; mem[p...(p + s)) &#x7684;&#x6570;&#x636E;&#x548C; topic t1&#x3001;t2&#x3001;t3 &#x4EA7;&#x751F;&#x65E5;&#x5FD7;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>log4(p, s, t1, t2, t3, t4)</td>
<td><code>-</code></td>
<td>F</td>
<td>&#x4EE5; mem[p...(p + s)) &#x7684;&#x6570;&#x636E;&#x548C; topic t1&#x3001;t2&#x3001;t3 &#x548C; t4 &#x4EA7;&#x751F;&#x65E5;&#x5FD7;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>origin</td>
<td></td>
<td>F</td>
<td>&#x4EA4;&#x6613;&#x53D1;&#x8D77;&#x8005;&#x5730;&#x5740;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>gasprice</td>
<td></td>
<td>F</td>
<td>&#x4EA4;&#x6613;&#x6240;&#x6307;&#x5B9A;&#x7684; gas &#x4EF7;&#x683C;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>blockhash(b)</td>
<td></td>
<td>F</td>
<td>&#x533A;&#x5757;&#x53F7; b &#x7684;&#x54C8;&#x5E0C; - &#x76EE;&#x524D;&#x4EC5;&#x9002;&#x7528;&#x4E8E;&#x4E0D;&#x5305;&#x62EC;&#x5F53;&#x524D;&#x533A;&#x5757;&#x7684;&#x6700;&#x540E; 256 &#x4E2A;&#x533A;&#x5757;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>coinbase</td>
<td></td>
<td>F</td>
<td>&#x5F53;&#x524D;&#x7684;&#x6316;&#x77FF;&#x6536;&#x76CA;&#x8005;&#x5730;&#x5740;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>timestamp</td>
<td></td>
<td>F</td>
<td>&#x4ECE;&#x5F53;&#x524D; epoch &#x5F00;&#x59CB;&#x7684;&#x5F53;&#x524D;&#x533A;&#x5757;&#x65F6;&#x95F4;&#x6233;&#xFF08;&#x4EE5;&#x79D2;&#x4E3A;&#x5355;&#x4F4D;&#xFF09;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>number</td>
<td></td>
<td>F</td>
<td>&#x5F53;&#x524D;&#x533A;&#x5757;&#x53F7;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>difficulty</td>
<td></td>
<td>F</td>
<td>&#x5F53;&#x524D;&#x533A;&#x5757;&#x96BE;&#x5EA6;</td>
<td></td>
</tr>
<tr>
<td></td>
<td>gaslimit</td>
<td></td>
<td>F</td>
<td>&#x5F53;&#x524D;&#x533A;&#x5757;&#x7684; gas &#x4E0A;&#x9650;</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="literal-constant"><a name="literal-constant" class="plugin-anchor" href="#literal-constant"><i class="fa fa-link" aria-hidden="true"></i></a>Literal constant</h4>
<p>You can directly type decimal or hexadecimal symbols to use as integer constants, which automatically generates the corresponding <code>PUSHi</code> Instruction.
The following code calculates 2 plus 3 (equal to 5), and then calculates its bitwise sum with the string &quot;abc. The string is left aligned when stored and cannot exceed 32 bytes in length.</p>
<pre><code class="lang-bash">assembly { 2 3 add <span class="hljs-string">&quot;abc&quot;</span> and }
</code></pre>
<h4 id="function-style"><a name="function-style" class="plugin-anchor" href="#function-style"><i class="fa fa-link" aria-hidden="true"></i></a>Function style</h4>
<p>You can type an opcode after the opcode just like using a bytecode. For example, put <code>3</code> And memory location <code>0x80</code> Add the data</p>
<pre><code class="lang-bash">3 0x80 mload add 0x80 mstore
</code></pre>
<p>Because it is usually difficult to see the actual parameters of Some opcodes, Solidity inline assembly also provides a &quot;function style&quot; representation, code with the same function can be written</p>
<pre><code class="lang-bash">mstore(0x80, add(mload(0x80), 3))
</code></pre>
<p>Instruction style cannot be used in function style expressions, that is <code>1 2 mstore(0x80, add)</code> is an invalid assembly statement,
It must be written <code>mstore(0x80, add(2, 1))</code> this form. For opcodes without parameters, brackets can be omitted.</p>
<p>Note that in function style writing, the order of parameters is opposite to the instruction style. If you use function style, the first parameter is at the top of the stack.</p>
<h4 id="access-external-variables-and-functions"><a name="access-external-variables-and-functions" class="plugin-anchor" href="#access-external-variables-and-functions"><i class="fa fa-link" aria-hidden="true"></i></a>Access external variables and functions</h4>
<p>Solidity variables and other identifiers can be accessed by simply using their names. For memory variables, this pushes the address instead of the value into the stack.
Storage variables are different because the value of the storage variable may not occupy the complete storage slot, so its &quot;address&quot; consists of the byte offset in the storage slot and the slot.
To obtain variables <code>x</code> The storage slot used, you can use <code>x_slot</code> , and <code>x_offset</code> Gets its byte offset.</p>
<p>In assignment statements (see below), we can even use Solidity local variables to assign values.</p>
<p>External functions can also be accessed for inline assemblies: the Assembly pushes their entry tags (with virtual function parsing) into the stack. The call semantics in Solidity are:</p>
<ul>
<li>Caller press in <code>return label</code>&#x3001;<code>arg1</code>&#x3001;<code>arg2</code>&#x3001;...&#x3001;<code>argn</code></li>
<li>The caller returns<code>ret1</code>&#x3001;<code>ret2</code>&#x3001;...&#x3001;<code>retm</code></li>
</ul>
<p>This feature is still a little troublesome to use, because the stack offset has changed fundamentally during the call, so the reference to local variables will go wrong.</p>
<pre><code class="lang-bash">
    pragma solidity ^0.4.11;

    contract C {
        uint b;
        <span class="hljs-keyword">function</span> f(uint x) public returns (uint r) {
            assembly {
                r := mul(x, sload(b_slot)) // &#x56E0;&#x4E3A;&#x504F;&#x79FB;&#x91CF;&#x4E3A; 0&#xFF0C;&#x6240;&#x4EE5;&#x53EF;&#x4EE5;&#x5FFD;&#x7565;
            }
        }
    }
</code></pre>
<blockquote>
<p>If you access a data type with actual data digits less than 256 bits&#xFF08;such <code>uint64</code>&#x3001;<code>address</code>&#x3001;<code>bytes16</code> or <code>byte</code>&#xFF09;&#xFF0C;do not make any assumptions about the values on the unused data bits of this type after encoding. In particular, do not assume that they must be 0. For security reasons, before using this data in a context, you must clear the data to 0, which is very important: <code>uint32 x = f(); assembly { x := and(x, 0xffffffff) /* now use x */ }</code>To clear the symbolic type, you can use <code>signextend</code> operation code.</p>
</blockquote>
<h4 id="label"><a name="label" class="plugin-anchor" href="#label"><i class="fa fa-link" aria-hidden="true"></i></a>Label</h4>
<blockquote>
<p>Tags are not recommended. Use functions, loops, if, or switch statements.</p>
</blockquote>
<p>Another problem with EVM assembly is that jump and jumpi functions use absolute addresses, which are easy to change. Solidity inline assembly provides tags for easier use of jump. Note that tags have underlying characteristics, and efficient assembly code can be written using loop, if, and switch commands (see below) without tags. The following code is used to calculate an element in the Fibonacci sequence.</p>
<pre><code class="lang-bash">
    {
        <span class="hljs-built_in">let</span> n := calldataload(4)
        <span class="hljs-built_in">let</span> a := 1
        <span class="hljs-built_in">let</span> b := a
    loop:
        jumpi(loopend, eq(n, 0))
        a add swap1
        n := sub(n, 1)
        jump(loop)
    loopend:
        mstore(0, a)
        <span class="hljs-built_in">return</span>(0, 0x20)
    }
</code></pre>
<p>Note: stack variables can be automatically accessed only when the assembler knows the current stack height. If the stack heights of the jump source and the target are different, the access fails. Although we can use jump in this way, in this case, you should not access variables in any stack (even assembly variables).</p>
<p>In addition, the stack height analyzer can also check the code opcode through the opcode (rather than according to the control flow), so in the following cases, the assembler <code>two</code> The stack height at will generate the wrong impression:</p>
<pre><code class="lang-bash">
    {
        <span class="hljs-built_in">let</span> x := 8
        jump(two)
        one:
            // &#x8FD9;&#x91CC;&#x7684;&#x6808;&#x9AD8;&#x5EA6;&#x662F; 2&#xFF08;&#x56E0;&#x4E3A;&#x6211;&#x4EEC;&#x538B;&#x5165;&#x4E86; x &#x548C; 7&#xFF09;&#xFF0C;
            // &#x4F46;&#x56E0;&#x4E3A;&#x6C47;&#x7F16;&#x7A0B;&#x5E8F;&#x662F;&#x6309;&#x987A;&#x5E8F;&#x8BFB;&#x53D6;&#x4EE3;&#x7801;&#x7684;&#xFF0C;
            // &#x5B83;&#x4F1A;&#x8BA4;&#x4E3A;&#x6808;&#x9AD8;&#x5EA6;&#x662F; 1&#x3002;
            // &#x5728;&#x8FD9;&#x91CC;&#x8BBF;&#x95EE;&#x6808;&#x53D8;&#x91CF; x &#x4F1A;&#x5BFC;&#x81F4;&#x9519;&#x8BEF;&#x3002;
            x := 9
            jump(three)
        two:
            7 // &#x628A;&#x67D0;&#x4E2A;&#x6570;&#x636E;&#x538B;&#x5165;&#x6808;&#x4E2D;
            jump(one)
        three:
    }
</code></pre>
<h4 id="assembly-local-variable-declaration"><a name="assembly-local-variable-declaration" class="plugin-anchor" href="#assembly-local-variable-declaration"><i class="fa fa-link" aria-hidden="true"></i></a>Assembly local variable declaration</h4>
<p>You can use let Keywords to declare variables that are visible only in the inline assembly, actually only in the current <code>{...}</code> Visible in the block.
The following things should be: <code>let</code> The command creates a new data slot reserved for the variable and automatically deletes it when it reaches the end of the block.
You need to provide an initial value for the variable, which can only <code>0</code> But it can also be a complex function style expression.</p>
<pre><code class="lang-bash">
    pragma solidity ^0.4.16;

    contract C {
        <span class="hljs-keyword">function</span> f(uint x) public view returns (uint b) {
            assembly {
                <span class="hljs-built_in">let</span> v := add(x, 1)
                mstore(0x80, v)
                {
                    <span class="hljs-built_in">let</span> y := add(sload(v), 1)
                    b := y
                } // y &#x4F1A;&#x5728;&#x8FD9;&#x91CC;&#x88AB;&#x201C;&#x6E05;&#x9664;&#x201D;
                b := add(b, v)
            } // v &#x4F1A;&#x5728;&#x8FD9;&#x91CC;&#x88AB;&#x201C;&#x6E05;&#x9664;&#x201D;
        }
    }
</code></pre>
<h4 id="assignment"><a name="assignment" class="plugin-anchor" href="#assignment"><i class="fa fa-link" aria-hidden="true"></i></a>Assignment</h4>
<p>You can assign values to Assembly local variables and function local variables. Note: When assigning values to variables pointing to memory or storage, you just change the pointer instead of the data.</p>
<p>There are two assignment methods: Function style and instruction style. For function style assignment ( variable := value ), you need to provide a value in a function style expression, which can exactly generate a value in a stack;
For Instruction style assignment ( =: variable ), the data is only obtained from the top of the stack. For both methods, colons point to variable names. Assignment is achieved by replacing the variable values in the stack with new values.</p>
<pre><code class="lang-bash">
    {
        <span class="hljs-built_in">let</span> v := 0 // &#x4F5C;&#x4E3A;&#x53D8;&#x91CF;&#x58F0;&#x660E;&#x7684;&#x51FD;&#x6570;&#x98CE;&#x683C;&#x8D4B;&#x503C;
        <span class="hljs-built_in">let</span> g := add(v, 2)
        sload(10)
        =: v // &#x6307;&#x4EE4;&#x98CE;&#x683C;&#x7684;&#x8D4B;&#x503C;&#xFF0C;&#x5C06; sload(10) &#x7684;&#x7ED3;&#x679C;&#x8D4B;&#x7ED9; v
    }
</code></pre>
<blockquote>
<p>Assignment of instruction style is not recommended.</p>
</blockquote>
<h4 id="if"><a name="if" class="plugin-anchor" href="#if"><i class="fa fa-link" aria-hidden="true"></i></a>If</h4>
<p>if if statements can be used to conditionally execute code and do not have the &quot;else&quot; section; </p>
<pre><code class="lang-bash">
    {
        <span class="hljs-keyword">if</span> eq(value, 0) { revert(0, 0) }
    }
</code></pre>
<p>Braces for the code body are required.</p>
<h4 id="switch"><a name="switch" class="plugin-anchor" href="#switch"><i class="fa fa-link" aria-hidden="true"></i></a>Switch</h4>
<p>As a very preliminary version of &quot;if/else&quot;, you can use the switch statement. It calculates the value of the expression and compares it with several constants. Select the branch corresponding to the matching constant.
Unlike some programming languages that are prone to errors, the control flow will not continue to be executed from one situation to the next. We can set a fallback or called default The default.</p>
<pre><code class="lang-bash">
    {
        <span class="hljs-built_in">let</span> x := 0
        switch calldataload(4)
        <span class="hljs-keyword">case</span> 0 {
            x := calldataload(0x24)
        }
        default {
            x := calldataload(0x44)
        }
        sstore(0, div(x, 2))
    }
</code></pre>
<p>The Case list does not need braces, but the case body needs braces.</p>
<h4 id="circulating"><a name="circulating" class="plugin-anchor" href="#circulating"><i class="fa fa-link" aria-hidden="true"></i></a>Circulating</h4>
<p>Assembly language supports a simple for-style loop. The For-style loop has a header that contains the initialization part, conditions, and iteration post-processing parts.
The condition must be a function-style expression, while the other two parts are statement blocks. If the start part declares a variable, the scope of these variables will be extended to the loop body (including conditions and post-iteration parts).</p>
<p>The following example calculates the sum of values in a memory area.</p>
<pre><code class="lang-bash">
    {
        <span class="hljs-built_in">let</span> x := 0
        <span class="hljs-keyword">for</span> { <span class="hljs-built_in">let</span> i := 0 } lt(i, 0x100) { i := add(i, 0x20) } {
            x := add(x, mload(i))
        }
    }
</code></pre>
<p>The For loop can also be written as the while loop: only the initialization part and the iteration post-processing part are left blank.</p>
<pre><code class="lang-bash">
    {
        <span class="hljs-built_in">let</span> x := 0
        <span class="hljs-built_in">let</span> i := 0
        <span class="hljs-keyword">for</span> { } lt(i, 0x100) { } {     // <span class="hljs-keyword">while</span>(i &lt; 0x100)
            x := add(x, mload(i))
            i := add(i, 0x20)
        }
    }
</code></pre>
<h4 id="function"><a name="function" class="plugin-anchor" href="#function"><i class="fa fa-link" aria-hidden="true"></i></a>Function</h4>
<p>Assembly language allows you to define underlying functions. The underlying function needs to obtain their parameters (and return PC) from the stack and put the results into the stack. The method of calling a function is the same as that of executing a function-style opcode. Functions can be defined anywhere and visible in the statement blocks that declare them. Local variables defined outside the function cannot be accessed within the function. There is no strict here return Statement. If you call a function that returns multiple values, you must use <code>a&#xFF0C;b&#xFF1A;= f(x)</code> Or let <code>a&#xFF0C;b&#xFF1A;= f(x)</code> Assign them to a tuple.</p>
<p>The following example implements the power operation function by square multiplication.</p>
<pre><code class="lang-bash">{
  <span class="hljs-keyword">function</span> power(base, exponent) -&gt; result {
    switch exponent
    <span class="hljs-keyword">case</span> 0 { result := 1 }
    <span class="hljs-keyword">case</span> 1 { result := base }
    default {
        result := power(mul(base, base), div(exponent, 2))
        switch mod(exponent, 2)
        <span class="hljs-keyword">case</span> 1 { result := mul(base, result) }
    } 
 }
}
</code></pre>
<h4 id="precautions"><a name="precautions" class="plugin-anchor" href="#precautions"><i class="fa fa-link" aria-hidden="true"></i></a>Precautions</h4>
<p>Inline assembly language may have a fairly high-level appearance, but in fact it is a very low-level programming language. Function calls, loops, if statements, and switch statements are converted through simple rewrite rules, Then, the only thing the assembler does for you is to reorganize function-style opcodes, manage jump tags, and calculate the stack height of access variables, in addition, the stack data of partial assembly variables is deleted when the end of the statement block is reached. Especially for the last two cases, the assembler will only calculate the height of the stack in the order of the code, not necessarily following the control process; Understanding this is very important. In addition, operations such as swap only exchange the data in the stack, not the variable position.</p>
<h4 id="solidity-convention"><a name="solidity-convention" class="plugin-anchor" href="#solidity-convention"><i class="fa fa-link" aria-hidden="true"></i></a>Solidity convention</h4>
<p>Compared with EVM assembly language, Solidity can identify types less than 256 bits, such <code>uint24</code> . In order to improve efficiency, most arithmetic operations only regard them as 256 digits and clear unused data bits only when necessary, this is done only before they are written to memory or compared. This means that if you access such variables from an inline assembly you must first manually clear those unused data bits.</p>
<p>Solidity manages memory in a very simple way: in <code>0x40</code> location of has a &quot;idle memory pointer&quot;. If you plan to allocate memory, just start using memory from here and update the pointer accordingly. The first 64 bytes of memory can be used as temporary storage space for temporary allocation &quot;. The 32-byte position after the &quot;free memory pointer&quot; (that is, from <code>0x60</code> Start position) will always be 0, which can be used to initialize an empty dynamic memory array.</p>
<p>In Solidity, elements in memory arrays always occupy a multiple of 32 bytes (yes, even <code>byte[]</code> It&apos;s all like this, only <code>bytes</code> and <code>string</code> Not like this). A multi-dimensional memory array is a pointer to a memory array. The length of a dynamic array is stored in the first slot of the array, followed by array elements.</p>
<blockquote>
<p>Static memory arrays do not have length fields, but will soon increase. This is to better convert between static arrays and dynamic arrays, so do not rely on this.</p>
</blockquote>
<h3 id="independent-assembly"><a name="independent-assembly" class="plugin-anchor" href="#independent-assembly"><i class="fa fa-link" aria-hidden="true"></i></a>Independent Assembly</h3>
<p>The assembly language described in the preceding inline assembly can also be used alone. In fact, the plan is to use it as an intermediate language for the Solidity compiler. In this sense, it tries to achieve the following goals:</p>
<p>1&#x3001;Even if the code is generated by Solidity&apos;s compiler, the program written with it should also be readable.
2&#x3001;From assembly to bytecode translation, &quot;accidents&quot; should be included as little as possible &quot;.
3&#x3001;The control flow should be easy to detect to help carry out formal test and optimization.</p>
<p>To achieve the first and last goals, the Assembly provides an advanced structure: such <code>for</code> Circulation, <code>if</code> Statement, <code>switch</code> Statements and function calls. Should be able to write without using explicit <code>SWAP</code> , <code>DUP</code> , <code>JUMP</code> And <code>JUMPI</code> Statement assembler,because the first two confuse the data stream, while the last two confuse the control flow. In addition, the form is <code>mul(add(x, y), 7)</code> The function style statement of is better <code>7 y x add</code> mul Because it is easier to see which operation is used for which operation code in the first form.</p>
<p>The second goal is to use a very regular way to treat the advanced instruction structure as a bytecode.
The only non-local operation performed by the assembler is the name search of the user-defined identifier (function, variable, azone), it follows very simple and fixed scope rules and clears local variables from the stack.</p>
<p>Scope: Identifiers (tags, variables, functions, assemblies) declared in it are only visible in declared statement blocks (including nested statement blocks in the current statement block). Even if they are within the scope of action, it is illegal to cross the function boundary to access local variables. Shadowing is prohibited. Local variables cannot be accessed before declaration, but tags, functions, and assemblies are possible.
Assembly is a special statement block, for example, used to return runtime codes or create contracts. Identifiers declared in Assembly statement blocks outside the subassembly are all invisible in the subassembly.</p>
<p>If the control flow passes through the end of the block, pop instructions matching the number of local variables declared in the current statement block are inserted. Whenever a local variable is referenced, the code generator needs to know the relative position in the current stack,
Therefore, it is necessary to track the current so-called stack height. Because all local variables declared in the statement block are clear at the end of the statement block, the stack height before and after the statement block should be the same. If this is not the case a warning will be issued.</p>
<p>Use <code>switch</code> , <code>for</code> And functions should be able to write complex code without manual calls <code>jump</code> Or <code>jumpi</code> . This will allow improved forms of laboratory certificates and optimization to analyze the control process more simply.</p>
<p>In addition, if manual redirection is allowed, the calculation stack height will be more complicated. The positions of all local variables in the stack need to be clearly known, otherwise, references to local variables cannot be automatically obtained at the end of the statement block, thus clearing them correctly.</p>
<p>Example:</p>
<p>We will refer to an instance from Solidity to assembly instructions. Consider the runtime bytecode of the following Solidity program:</p>
<pre><code>pragma solidity ^0.4.16;

contract C {
  function f(uint x) public pure returns (uint y) {
    y = 1;
    for (uint i = 0; i &lt; x; i++)
      y = 2 * y;
  }
}
</code></pre><p>The following assembly instructions will be generated:</p>
<pre><code>{
  mstore(0x40, 0x60) // &#x4FDD;&#x5B58;&#x201C;&#x7A7A;&#x95F2;&#x5185;&#x5B58;&#x6307;&#x9488;&#x201D;
  // &#x51FD;&#x6570;&#x9009;&#x62E9;&#x5668;
  switch div(calldataload(0), exp(2, 226))
  case 0xb3de648b {
    let r := f(calldataload(4))
    let ret := $allocate(0x20)
    mstore(ret, r)
    return(ret, 0x20)
  }
  default { revert(0, 0) }
  // &#x5185;&#x5B58;&#x5206;&#x914D;&#x5668;
  function $allocate(size) -&gt; pos {
    pos := mload(0x40)
    mstore(0x40, add(pos, size))
  }
  // &#x5408;&#x7EA6;&#x51FD;&#x6570;
  function f(x) -&gt; y {
    y := 1
    for { let i := 0 } lt(i, x) { i := add(i, 1) } {
      y := mul(2, y)
    }
  }
}
</code></pre><h2 id="assembly-syntax"><a name="assembly-syntax" class="plugin-anchor" href="#assembly-syntax"><i class="fa fa-link" aria-hidden="true"></i></a>Assembly syntax</h2>
<p>Parser tasks are as follows:</p>
<ul>
<li>Convert the byte stream into a symbolic stream, and discard the comments in the C++ style (there is a special comment on the source code reference, and we will not explain it here).</li>
<li>According to the following syntax, convert the symbol flow to AST.</li>
<li>Register the identifier defined in the statement Block (annotated to the AST node) and indicate where the variable can be accessed from.</li>
</ul>
<p>The Assembly lexical analyzer follows the rules defined by Solidity itself.</p>
<p>A space is used to separate all symbols. It consists of space characters, tabs, and line breaks. The annotation format is regular JavaScript/C envoy style and is interpreted as a space.</p>
<p>Grammar::</p>
<pre><code>AssemblyBlock = &apos;{&apos; AssemblyItem* &apos;}&apos;
AssemblyItem =
    Identifier |
    AssemblyBlock |
    AssemblyExpression |
    AssemblyLocalDefinition |
    AssemblyAssignment |
    AssemblyStackAssignment |
    LabelDefinition |
    AssemblyIf |
    AssemblySwitch |
    AssemblyFunctionDefinition |
    AssemblyFor |
    &apos;break&apos; |
    &apos;continue&apos; |
    SubAssembly
AssemblyExpression = AssemblyCall | Identifier | AssemblyLiteral
AssemblyLiteral = NumberLiteral | StringLiteral | HexLiteral
Identifier = [a-zA-Z_$] [a-zA-Z_0-9]*
AssemblyCall = Identifier &apos;(&apos; ( AssemblyExpression ( &apos;,&apos; AssemblyExpression )* )? &apos;)&apos;
AssemblyLocalDefinition = &apos;let&apos; IdentifierOrList ( &apos;:=&apos; AssemblyExpression )?
AssemblyAssignment = IdentifierOrList &apos;:=&apos; AssemblyExpression
IdentifierOrList = Identifier | &apos;(&apos; IdentifierList &apos;)&apos;
IdentifierList = Identifier ( &apos;,&apos; Identifier)*
AssemblyStackAssignment = &apos;=:&apos; Identifier
LabelDefinition = Identifier &apos;:&apos;
AssemblyIf = &apos;if&apos; AssemblyExpression AssemblyBlock
AssemblySwitch = &apos;switch&apos; AssemblyExpression AssemblyCase*
    ( &apos;default&apos; AssemblyBlock )?
AssemblyCase = &apos;case&apos; AssemblyExpression AssemblyBlock
AssemblyFunctionDefinition = &apos;function&apos; Identifier &apos;(&apos; IdentifierList? &apos;)&apos;
    ( &apos;-&gt;&apos; &apos;(&apos; IdentifierList &apos;)&apos; )? AssemblyBlock
AssemblyFor = &apos;for&apos; ( AssemblyBlock | AssemblyExpression )
    AssemblyExpression ( AssemblyBlock | AssemblyExpression ) AssemblyBlock
SubAssembly = &apos;assembly&apos; Identifier AssemblyBlock
NumberLiteral = HexNumber | DecimalNumber
HexLiteral = &apos;hex&apos; (&apos;&quot;&apos; ([0-9a-fA-F]{2})* &apos;&quot;&apos; | &apos;\&apos;&apos; ([0-9a-fA-F]{2})* &apos;\&apos;&apos;)
StringLiteral = &apos;&quot;&apos; ([^&quot;\r\n\\] | &apos;\\&apos; .)* &apos;&quot;&apos;
HexNumber = &apos;0x&apos; [0-9a-fA-F]+
DecimalNumber = [0-9]+
</code></pre>
                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="../18_contract/" class="navigation navigation-prev " aria-label="Previous page: Smart contract">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../20_contractPattern.html" class="navigation navigation-next " aria-label="Next page: Contract template">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"understand Solidity","level":"7.2","depth":1,"next":{"title":"Contract template","level":"7.3","depth":1,"path":"20_contractPattern.md","ref":"20_contractPattern.md","articles":[]},"previous":{"title":"Smart contract","level":"7.1","depth":1,"path":"18_contract/README.md","ref":"18_contract/README.md","articles":[]},"dir":"ltr"},"config":{"plugins":["-lunr","-search","search-pro","language-picker","anchors"],"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"search-pro":{},"language-picker":{"grid-columns":3},"anchors":{},"highlight":{},"sharing":{"facebook":true,"twitter":true,"google":false,"weibo":false,"instapaper":false,"vk":false,"all":["facebook","google","twitter","weibo","instapaper"]},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56}},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"variables":{},"title":"Simplechain Documentation","language":"en","gitbook":"*"},"file":{"path":"19_understandSolidity/README.md","mtime":"2020-07-02T07:22:51.352Z","type":"markdown"},"gitbook":{"version":"3.2.3","time":"2020-07-02T07:28:23.420Z"},"basePath":"..","book":{"language":"en"}});
        });
    </script>
</div>

        
    <script src="../../gitbook/gitbook.js"></script>
    <script src="../../gitbook/theme.js"></script>
    
        
        <script src="../../gitbook/gitbook-plugin-search-pro/jquery.mark.min.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-search-pro/search.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-language-picker/plugin.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-sharing/buttons.js"></script>
        
    
        
        <script src="../../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

