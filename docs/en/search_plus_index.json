{"./":{"url":"./","title":"Introduction","keywords":"","body":"Simplechan developer document SimpleChainis a public chain with the design concept of one main chain and multiple sub-chains. Through the multi-level distributed value network design, it supports the deployment and expansion of blockchains in multiple consensus and multiple business scenarios, supports cross-chain transactions and sub-chains that meet tens of millions of TPS, involving distributed computing, judicial digitization, digital auction, real estate, digital entertainment games, transaction settlement, and other scenarios, jointly Build a new digital economy ecosystem. WithSimpleChainmian network running, We have seen more and more Blockchain enthusiasts and technology developers participate in our technology community and ecosystem construction. Welcome more technology developers to join our technology community. Our documents are designed to serve developers and community enthusiasts to quickly understand and get startedSimpleChain。Document fromSimpleChainCommunity and SimpleChainThe core team maintains it together, so you are welcome to make your own contribution here! We hope that the document can be understood more clearly SimpleChaintechnology and ecosystem. At the beginning SimpleChainBefore network development, you need to make the following preparations: Understand the basic concepts of blockchain Have a certain mainstream programming and development foundation Have Right SimpleChainUnderstanding of basic attributes and specific understanding of your business needs We sincerely welcome everyone to join our SimpleChainCommunity developer friends and based on SimpleChainOrganize applications on the ground. "},"1_quickStart.html":{"url":"1_quickStart.html","title":"Quick Start","keywords":"","body":"This page provides guidelines for different types of users, allowing developers to quickly find what they need. If you want to know SimpleChainthe basic concept. Entering SimpleChain Technical details or in SimpleChainBefore developing smart contracts，first understand SimpleChainBasic concepts andSimpleChainit is helpful to have a thorough understanding. You can learn aboutSimpleChain some basic concepts of account system, economic model and voting process. If you want to use SimpleChain Even if you are not a developer, you can joinSimpleChainCommunity and SimpleChainMake contributions to daily operations. You can have a look Browser. If you are a developer For developers, there are many materials to help you. Run and operate SimpleChain You can choose to run a local single-node network or join SimpleChain network. You can use command line tools to operate SimpleChain. Intelligent contract development For smart contract developers, you can refer to the smart contract development section for more information. We also provide some examples for smart contract developers to describe how to write/deploy/run contracts. Landing case This is used SimpleChaina landing case of development. SDK and API SDKs and APIs are also provided for developers: Javascript SDK Java SDK Python SDK JSON RPC API If you are interested in technical details For those who are interested in technical details, you can learn about the database infrastructure, network layer, and virtual machines. You will be able to understand through these documentsSimpleChain the internal logic help If you have any questions, please feel free Medium, Telegram forum for help. "},"2_BuildNode/":{"url":"2_BuildNode/","title":"Build Node","keywords":"","body":"Docker image building Obtain an image： docker pull simplechain/sipe:latest Start node: docker run -it -p 30312:30312 simplechain/sipe Enable RPC: docker run -it -p 8545:8545 -p 30312:30312 simplechain/sipe --rpc --rpcaddr \"0.0.0.0\" Enable the JavaScript console: docker run -it -p 30303:30303 simplechain/sipe console Store block data in a specified directory: docker run -it -p 30312:30312 -v /path/on/host:/root/.simplechain simplechain/sipe If RPC is enabled, you can run the following command to check whether your node is successfully started: curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":68}' Installation package construction Open theofficial websiteof Simplechain and drop down to find the SimpleNode module, as shown in the following figure: Download the corresponding version according to your server system. After downloading, follow the prompts to install it. After installation, create a wallet account by using the credential. Then you can pay or receive sipc, mining, and publish contracts. Account： Mining Contract Source code construction Preliminary preparations: Go language environment (1.10 or higher), C language compiler 1.Download SimpleChain You can clone a project locally through git or https://github.com/simplechain-org/go- Download directly from the simplechain page. git clone https://github.com/simplechain-org/go-simplechain.git 2.Install sipe 1.Enter the go-simplechain root directory. cd go-simplechain 2.Use the make tool to install sipe. make sipe >>> /usr/local/go/bin/go install -ldflags -X main.gitCommit=9d73f67e1dc5587a95f52c13fee93be6434b42ac -s -v ./cmd/sipe github.com/simplechain-org/go-simplechain/core ... github.com/simplechain-org/go-simplechain/cmd/sipe Done building. Run \"/Users/yuanchao/go/src/github.com/simplechain-org/go-simplechain/build/bin/sipe\" to launch sipe. When the above output appears on the terminal, the make execution is successful. In this case, the sipe executable file is generated in the go-simplechain/build/bin directory. You can move it to any directory or add it to environment variables to facilitate the running of sipe programs. Start sipe 1.Create a folder for storing node data： mkdir chaindata 2.Start the sipe Master network node Enable the RPC service and specify the RPC listening address as 127.0.0.1, Port 8545. The node data storage directory is chaindata ./sipe --rpc --rpcaddr 127.0.0.1 --rpcport 8545 --datadir chaindata When an output similar to the following appears, the startup is successful and the SimpleChain master Network block is synchronized. INFO [06-19|09:35:01.481] Maximum peer count ETH=25 LES=0 total=25 INFO [06-19|09:35:01.492] Starting peer-to-peer node instance=Sipe/v1.0.2-stable-0cbf2a41/darwin-amd64/go1.12.1 ... INFO [06-19|09:35:33.700] Block synchronisation started INFO [06-19|09:35:36.756] Imported new block headers count=192\\ elapsed=22.273ms number=192 hash=bb758a...bea1b6 ignored=0 3.Start the sipe console Create a new terminal window and run the following command to open an interaction console connected to this node. sipe attach chaindata/sipe.ipc 4.Create an account Use the following command to create an account in the started console. > personal.newAccount() Passphrase: Repeat passphrase: \"0xc8d8ba3bdba3a1e3ca1d6cd48106d84036f6c0bd\" //account address After the account is created, the console returns the account address and generates a json file for the account in chaindata/keystore. This file can obtain the account private key through password parsing. 5.Enable mining Restart the sipe node，enable mining, and specify the miner address as the account address you created. The number of mining Threads is 1. sipe --rpc --rpcaddr 127.0.0.1 --rpcport 8545 --datadir chaindata --mine --minerthreads=1 --etherbase=0xc8d8ba3bdba3a1e3ca1d6cd48106d84036f6c0bd You can also specify the miner address and enable mining in the console. > miner.setEtherbase('0xc8d8ba3bdba3a1e3ca1d6cd48106d84036f6c0bd') > miner.start() "},"47_techniqueLanguage.html":{"url":"47_techniqueLanguage.html","title":"Technical Manual","keywords":"","body":"We need to know some common terms and nouns before we begin to understand Simplechain and learn more about Simplechain in the future. Proper noun External account：EOAs(External Owned Accounts), associated with personal private key. Can be used to send transactions (transfer Sipc or send messages), like a savings card with a digital ID. Contract account：Contracts Accounts, which can store contract codes and contract data on Simplechain. External users cannot directly operate this account. It can only be called directly or indirectly from an external account. Account Status： account state, which indicates the status of an account in Simplechain. The account status changes when the account data changes. The account status includes four items: nonce, balance, root hash value of account storage content, and hash value of account code. Status data is not directly stored in the block. Account Nonce: account random number, which is the transaction count of the account. To prevent replay attacks. Smart Contract：Smart Contract,Simplechain supports writing Smart Contract code through Turing's complete advanced programming language. After being deployed on the chain, you can accept transaction requests and events from outside to trigger the execution of specific contract code logic and further generate new transactions and events. Even call other smart contracts. World State：state, which manages the mapping relationship between account address and account state. The status of all accounts constitutes the status of the entire blockchain. Trading：Transaction is the only way for external interaction with Simplechain. It must be signed by an external account. The miner executes the Transaction and finally packages it into the block. Transaction receipt：Receipt, which is convenient for zero-knowledge proof, index and search of transactions, and codes some specific information during transaction execution as transaction receipts. Block：block is a data block composed of a set of transactions, some auxiliary information (block header for short), and other block header hashes. Other block header hash indicates the parent block or the back block. uncle block：Uncle Block，an orphan Block that cannot be part of the main chain. If you are lucky enough to be taken into the Block chain by later blocks, it becomes Uncle Block. Additional rewards will be given to the blocks that have retained the isolated blocks. Once a block becomes a block, the block will be rewarded. Reduce Simplechain soft forking and balance the benefits of miners with slow network speed through the block reward mechanism. Random number：nonce，recorded in the block header, proof of hard work. Gas：fuel is a visualized concept of the amount of resources consumed during the operation of EVM when a transaction is packaged into a block. It is a metaphor that fuel is required to run EVM. In Simplechain, CPU resources and storage resources are expressed in accordance with built-in rules and Gas is used as a resource unit. Each time a virtual machine command is executed, a certain amount of Gas is consumed. GasPrice: fuel price, any transaction needs to include a unit price of fuel that is willing to pay, and finally according to the amount of fuel consumed by the transaction, the handling fee (usedGas * gasPrice) is calculated and paid to the miners. Price forecast：GPO(Gas Price Oracle),Gas Price forecast, predict the future GasPrice trend according to GasPrice of historical transactions. Technical terms ZKP: Zero Knowledge Proof. EVM：Ethereum Virtual Machine，which is a lightweight sandbox Virtual Machine for executing transactions. Message：A message is a virtual object that cannot be serialized and only exists in the running environment of Simplechain. A message mainly includes the sender, receiver, and gasLimit of the message; 序列化：RLP is used to encode data into a set of byte data to facilitate data exchange and storage. RLP: ecursive length prefix encoding, a data encoding protocol that can compress data, is often used to serialize data in Simplechain. MPT：Merkel compressed prefix Tree, Merkle Patricia Tree, is a modified data structure that combines the advantages of Merkel Tree and prefix Tree, it is an important data structure used in Simplechain to organize and manage account data and generate transaction set hash. Patricia Trie: a compressed prefix tree, a tree that saves more space. For each node of trie, if the node is the only son of its parent node, it is combined with the parent node; Merkle Tree: Merkel Tree, also known as Hash Tree, the value of the leaf node of Merkel Tree is the content of the data item, or the Hash value of the data item; The value of the non-leaf node is based on the information of its child node, then it is calculated according to the Hash algorithm. Whisper：ciphertext is a communication protocol based on P2P. Through Whisper, nodes can send information to a specific node, achieve dual-node private chat and communication on multiple nodes by topic. It is mainly designed for DApp with large-scale point-to-point data discovery, signal negotiation, minimum transmission communication and complete privacy protection. Swarm： it is a distributed storage platform and content distribution service, and is the local basic Layer Service of Simplechain web3 technology stack; LLL，Sperpent、Mutan和Solidity：the programming language used to write intelligent contract code, which can be compiled into EVM code. ERC20: it can be understood as a Token protocol specification of Simplechain. All Token contracts developed based on Simplechain comply with this specification. Tokens that comply with the ERC20 protocol specifications can be supported by various Simplechain wallets. ERC721: it is a Token protocol specification established on the ERC20 standard and a smart contract standard for non-fundable tokens (NFTs for short). "},"3_sipcCoin.html":{"url":"3_sipcCoin.html","title":"Sipc Coin","keywords":"","body":"Sipcis a public blockchain platformSimpleChain the circulation of tokens on the chain, issued at the beginning of 2019, the total amount of tokens issued is100000000Pieces. SimpleChainit is a public chain with the design concept of one main chain and multiple sub-chains. It supports blockchain deployment and expansion in multiple consensus and business scenarios, and supports cross-chain transactions, support sub-chains to meet tens of millions of TPS, involving distributed computing, judicial digitization, digital auction, real estate, digital entertainment games, transaction settlement and other scenarios. Circulation platform ZT Support wallet SIPC ChainBox Market tool Feixiaohao mytoken Support mine pool Matpool Dxpool Simpool "},"4_PublishCoin/":{"url":"4_PublishCoin/","title":"Publish Coin","keywords":"","body":"How to issue digital assets on SimpleChain Prerequisites Preparations for implementing publish coin on the chain include: Download and deploy SimpleChain. Start the node. Create an account. Ensure that the account is unlocked and has a token. Preparatory work Understand the ERC20 token standard. Explanation: The implementation of tokens on SimpleChain needs to follow the ERC20 standard. //ERC20Token.sol //ERC 合约标准，该标准规定在发 Token 之前，需要指定 token 的名称、标识、总量、实现合 //约标准函数等 pragma solidity ^0.4.26; contract ERC20Token { //获取 token 名称 function name() public constant returns (string name); //获取 token 标识 function symbol() public constant returns (string symbol); //获取 token 的最小分割量 function decimals() public constant returns (uint8 decimals); //获取 token 的总量 function totalSupply() public constant returns (uint256 totalSupply); //获取_owner 账户当前的 token 量 function balanceOf(address _owner) public constant returns (uint256 balance); //转账交易 function transfer(address _to, uint256 _value) public returns (bool success); //由_from 向_to 进行转账 function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); //许可_spender 能从调用合约方法的账户转出总量为_value 的 token function approve(address _spender, uint256 _value) public returns (bool success); //获取_spender 可以从账户_owner 中转出 token 的剩余数量 function allowance(address _owner, address _spender) public constant returns (uint remaining); //转账事件(transfer、transferFrom 会触发该事件) event Transfer(address indexed _from, address indexed _to, uint256 _value); //许可事件(approve 会触发该事件) event Approval(address indexed _owner, address indexed _spender, uint256 _value); } Compile token contracts that meet ERC20 standards. //Mytoken.sol pragma solidity ^0.4.26; import \"./ERC20Token.sol\"; contract MyToken is ERC20Token { string private _name; string private _symbol; uint8 private _decimals = 18; //此处建议为 18，代表最小单位为 0.1^18 uint256 private _totalSupply; //存储账户的 token 总量 mapping(address => uint256) private _balances; //存储前一个address允许后一个address转出token的剩余数量 mapping(address => mapping(address => uint256)) private _allowances; function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol) public{ _name = tokenName; _symbol = tokenSymbol; _totalSupply = initialSupply * 10 ** uint256(_decimals); _balances[msg.sender] = _totalSupply; } function name() public constant returns (string name){ name = _name; } function symbol() public constant returns (string symbol){ symbol = _symbol; } function decimals() public constant returns (uint8 decimals){ decimals = _decimals; } function totalSupply() public constant returns (uint256 totalSupply){ totalSupply = _totalSupply; } function balanceOf(address _owner) public constant returns (uint256 balance){ balance = _balances[_owner]; } function transfer(address _to, uint256 _value) public returns (bool success){ require(_balances[msg.sender] >= _value); //保证发出交易的账户 token 足够完成转账 _balances[msg.sender] -= _value; _balances[_to] += value; Transfer(msg.sender, _to, _value); success = true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){ require(_balances[_from] >= _value); //保证_from 账户 token 足够完成转 账 require(_allowances[_from][msg.sender] >= _value); //保证_from 账户允许 执行账户转出的 token 剩余量足够 _balances[_from] -= _value; _allowances[_from][msg.sender] -= _value; _balances[_to] += _value; Transfer(_from, _to, _value); success = true; } } //许可_spender 能从调用合约方法的账户转出总量为_value 的 token function approve(address _spender, uint256 _value) public returns (bool success){ _allowances[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); success = true; } //获取_spender 可以从账户_owner 中转出 token 的剩余数量 function allowance(address _owner, address _spender) public constant returns (uint256 remaining){ remaining = _allowances[_owner][_spender]; } } Contract compilation: Use a browser to open Remix Solidity IDE. Add ERC20Token.sol and MyToken.sol to the browser folder. Select the Compile option in the right-side box of the webpage and select the version of the contract compiler (0.4.26 is selected in this article). Click Start to compile. Contract deployment Select the Run option and select the Web3 Provider in the Environment. In the dialog box that appears, enter the port of the currently enabled sipe node. Select an unlocked Account with a token. Select the MyToken contract, enter the initialization parameters in the Deploy field: total number of tokens, token name, token identifier, and click Deploy. Wait about one minute until the contract deployment is completed. If the contract appears in the Deployed Contracts column, the deployment is completed. So far, the Fa Bi completed. Contract Verification Execute the decimals,name,symbol,totalSupply methods of the contract to check whether the token is successfully created. Execute the transfer method, expand the transfer method to transfer money to other accounts, and use balanceOf to check whether the transfer is successful. "},"5_concoct.html":{"url":"5_concoct.html","title":"Deploy","keywords":"","body":"SimpleChainthe basic configuration of the service chain, startSimpleChain node, you need to load the chain configuration. Therefore, inSimpleChain the main network (mainnet) and test network (testnet) configurations are built in. When the node is initially started, different chain configurations are loaded by default according to different parameters (-dev,-testnet). Chain Configuration Different from traditional software, because of the non-tamper nature of the blockchain, it requires the same block, regardless of the software version when the block is released or the software version n years later. All must ensure that the software does the same operation on the out-of-block block. Therefore, the blockchain configuration of the blockchain cannot be changed at will, and important historical changes need to be maintained. The following is the core configuration information of the chain, which is defined in params/config.go: // ChainConfig is the core config which determines the blockchain settings. // ChainConfig is stored in the database on a per block basis. This means // that any network, identified by its genesis block, can have its own // set of configuration options. type ChainConfig struct { ChainID *big.Int `json:\"chainId\"` // chainId identifies the current chain and is used for replay protection SingularityBlock *big.Int `json:\"singularityBlock,omitempty\"` // Singularity switch block (nil = no fork, 0 = already on singularity) EWASMBlock *big.Int `json:\"ewasmBlock,omitempty\"` // EWASM switch block (nil = no fork, 0 = already activated) // Various consensus engines Ethash *EthashConfig `json:\"ethash,omitempty\"` Clique *CliqueConfig `json:\"clique,omitempty\"` Scrypt *ScryptConfig `json:\"scrypt,omitempty\"` DPoS *DPoSConfig `json:\"dpos,omitempty\"` Raft bool `json:\"raft,omitempty\"` Istanbul *IstanbulConfig `json:\"istanbul,omitempty\"` } The blockchain cannot be tampered with. Non-centralized programs make the upgrade of blockchain network programs more complicated. The core configuration of Simplechain reflects the critical moments of the entire Simplechain network. As aboveSimpleChainChain configuration, not the program is initially written, but SimpleChain development is accumulated during major changes in consensus agreements. The following is a description of the role of each configuration: ChainID ChianIDis the identifier of the current chain to prevent replay attacks. SingularityBlock Hard Fork height. This means that from this height, the new District block is restricted by the new version of consensus rules. Because consensus changes are involved, if you want to continue accepting new blocks, you must upgrade the Simplechain program, which belongs to the blockchain hard fork. If you do not want to accept consensus changes, you can use the new ChainID to continue the original consensus independently, and the version must be maintained independently. EWASMBlock Ethash Ethashthe consensus algorithm engine configuration. Ethash is the consensus algorithm of Ethereum. It is a PoW consensus algorithm. It can be used as a consensus algorithm for Simplechain sub-chains. Clique Clique POA consensus algorithm is configured as a consensus engine. PoA consensus algorithm is also one of the consensus algorithms that Simplechain can choose. You can choose this consensus algorithm when building a test chain and a private chain. Scrypt Scryptthe consensus algorithm engine configuration. Scrypt is the consensus algorithm of the Simplechain main chain, which belongs to the PoW consensus algorithm. DPoS DPoS is a consensus algorithm of Simplechain sub-chains. Because Simplechain is a blockchain architecture with one master and multiple sub-chains, multiple consensus algorithms can be selected for sub-chains, DPos is a consensus algorithm that can be selected for sub-chains. Raft Raftis a consensus algorithm that you can choose from the Simplechain sub-chain. Raft selects a noble leader and gives him all the responsibilities to manage and copy logs to achieve consistency.性。 Istanbul IstanbulSimplechain consensus engine configuration "},"6_genesis/":{"url":"6_genesis/","title":"Genesis Block","keywords":"","body":"The genesis block is the zero th block, and other blocks are directly or indirectly referenced to the genesis block. Therefore, the correct creation block information must be loaded at the beginning of the node startup and cannot be arbitrarily modified. SimpleChainyou can use the creation configuration file to initialize the creation block. You can also use the creation configuration that uses multiple built-in network environments. Default useSimpleChain Master network creation configuration. Genesis configuration file If you need to build SimpleChain private chain, then it is necessary to understand the creation configuration, otherwise you don't care about the creation configuration. The following is an example of creation configuration in JSON format: { \"config\": { \"chainId\": 100, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"alloc\" : {}, \"coinbase\" : \"0x0000000000000000000000000000000000000000\", \"difficulty\" : \"0x20000\", \"extraData\" : \"\", \"gasLimit\" : \"0x2fefd8\", \"nonce\" : \"0x0000000000000042\", \"mixhash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"timestamp\" : \"0x00\" } According to the configuration usage, it can be divided into three categories: Chain configuration configthe item defines the chain configuration, which affects the consensus protocol. Although the chain configuration has little impact on Genesis, the block-out rules of new blocks all depend on the chain configuration. Information configuration of Genesis block head nonce：random number, corresponding to the genesis block Nonce Field. timestamp：UTC timestamp, corresponding to the genesis block Time Field. extraData：additional data, corresponding to the genesis block Extra Field. gasLimit：required, fuel upper limit, corresponding to the genesis block GasLimit Field. difficulty：required, difficulty coefficient, corresponding to the genesis block Difficulty Field. When building a private chain, you need to select the appropriate difficulty value according to the situation to adjust the block. mixHash：a hash value, corresponding to MixDigest Field. Together with the nonce value, sufficient calculations have been performed on the block. coinbase：An address corresponding to Coinbase Field. 3.Initial account asset allocation alloc Item is the initial account asset allocation in Genesis. When a genesis block is generated, the account assets in this dataset are written into the block, which is equivalent to pre-mining. This is very useful for development testing and private chains. You can directly allocate assets to any number of accounts without mining. Chuangshi block loading process When running Simplechain, you must load the creation configuration and the creation block according to the configuration file, and verify its validity. If the configuration information is changed at will, problems such as consensus verification failure may occur. The program can continue to run only when loading and checking pass. The preceding figure shows a brief process. The following two sub-processes are \"loading the creation configuration\" and \"installing the creation block. Load Genesis configuration Which Creation configuration should be used depends on when the user starts Sipe. The following figure shows the flow chart of creation configuration selection: You can use Sipe command parameters to select different network configurations networkid Select, you can also use the network name to enable. 1.Use networkid, Different networks use different ID. 1=Frontier，main network environment, is the default option. 2=Morden test network, but disabled. 3=Ropsten test network. 4=Rinkeby test network. 2.Directly use the network name: testnet: Ropsten tests the network. rinkeby: Rinkeby tests the network. goerli: Görli tests the network. dev: local development environment. When Sipe is started, select to load different network configurations according to different parameters and correspond to different network environments. If no choice is made, although no choice is made here, the main network configuration will be used by default in the subsequent process. Install the genesis block First, you need to read the genesis block hash from the database based on the block height 0. If it does not exist, the local startup is the first time. Use the runtime creation configuration directly to build the creation block. For the first time, you also need to store the creation block and chain configuration. If it exists, you need to use the runtime creation configuration to build the creation block and compare it with the created block hash that has been stored this time. Once inconsistent, an error is returned and cannot continue. Then, you need to check the chain configuration. Obtain the chain configuration from the database first. If it does not exist, use the runtime chain configuration directly without verification. Otherwise, check whether the runtime chain configuration is correct and replace the update only when it is correct. However, there is an exception: the Master network configuration cannot be changed at will and is controlled by code rather than manually specified. In general, Simplechain uses the Master network configuration by default. It only creates and stores the creation block when it is running for the first time. In other cases, it is only used for verification. In addition to the main network, the chain configuration can be changed at any time under the rules. Build and create blocks We have known the overall process above. Here we will describe in detail how Simplechain generates creation blocks based on the creation configuration. The core code is located in core/genesis.go:229: func (g *Genesis) ToBlock(db ethdb.Database) *types.Block{ if db == nil { db = rawdb.NewMemoryDatabase() } statedb, _ := state.New(common.Hash{}, state.NewDatabase(db))//1 for addr, account := range g.Alloc { //2 statedb.AddBalance(addr, account.Balance) statedb.SetCode(addr, account.Code) statedb.SetNonce(addr, account.Nonce) for key, value := range account.Storage { statedb.SetState(addr, key, value) } } root := statedb.IntermediateRoot(false)//3 head := &types.Header{//4 Number: new(big.Int).SetUint64(g.Number), Nonce: types.EncodeNonce(g.Nonce), Time: g.Timestamp, ParentHash: g.ParentHash, Extra: g.ExtraData, GasLimit: g.GasLimit, GasUsed: g.GasUsed, Difficulty: g.Difficulty, MixDigest: g.Mixhash, Coinbase: g.Coinbase, Root: root, } //5 if g.GasLimit == 0 { head.GasLimit = params.GenesisGasLimit } if g.Difficulty == nil { head.Difficulty = params.GenesisDifficulty } statedb.Commit(false)//6 statedb.Database().TrieDB().Commit(root, true)//7 return types.NewBlock(head, nil, nil, nil)//8 } The preceding code is the code logic that generates the creation block based on the creation configuration. The details are as follows: Genesis block has no parent block, initialize the new from zero state (Follow-up articles will be explained in detail state Object). Traversal configuration Alloc Item account collection data, directly written to the state. Not only can be set here balance , you can also set code , nonce And any multiple storage Data. It means that smart contracts can be deployed directly when creating the world. For example, the following configuration deployed a configuration named093f59f1d91017d30d8c2caa78feb5beb0d2cfafsmart contract. \"alloc\": { \"093f59f1d91017d30d8c2caa78feb5beb0d2cfaf\": { \"balance\": \"0xffffffffffffffff\", \"nonce\": \"0x3\", \"code\":\"0x606060\", \"storage\":{ \"11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa\":\"1234ff\" } } } After the account data is written into the state, the root value of Merkel tree for the state data can be calculated, which is called StateRoot . This value is recorded in the block header Root Field. Part of the creation configuration is directly mapped to the block header to complete the creation of the block header. Because GasLimit And Difficulty Directly affects the next block outbound processing.Therefore, the default configuration is used when it is not set (Difficulty = 131072,GasLimit = 4712388). Submit the state to submit the state data to the underlying memory trie data. Update memory trie data to db. This is an unnecessary step, because the submission to the database is done externally, here you only need to be responsible for generating blocks. Use the block header to create a block, and there is no transaction record in the block. "},"7_account.html":{"url":"7_account.html","title":"Account","keywords":"","body":"Compared with Bitcoin's \"UTXO\" balance model, SimpleChain similar to Simplechain the account balance model is used. SimpleChain it enriches the account content and can store any amount of data in addition to the balance. And use the maintainability of account data to build an intelligent contract account. Actually SimpleChainit is an account model refined to realize smart contracts. Isolate data in an account. The information between accounts is independent of each other and does not interfere with each other. Cooperate again SimpleChainVirtual machine, let the smart contract sandbox run. SimpleChain as an intelligent contract operation platform, accounts are divided into two types: external account (EOAs) and contract account. External account EOAs-external owned accouts are accounts created by people through private keys. It is the mapping of real-world financial accounts, and anyone with the private key of the account can control the account. Just like a bank card, when you withdraw money from an ATM, you only need to enter the correct password to trade. This is also the only medium for human beings to communicate with Simplechain account books, becauseSimpleChain transaction in needs to be signed, You can only use a private external account signature. Summary of external account characteristics: Have sipc balance. Can send transactions, including transfer and execution of contract codes. Controlled by the private key. No relevant executable code. Contract account The account that contains the contract code. Created by an external account or contract, the contract is automatically assigned to an account address when created, Used to store contract code and stored data generated during contract deployment or execution. The contract account address is generated by the SHA3 hash algorithm, not the private key. Because of the selfless key, no one can use the contract account as an external account. Contract execution code can only be driven through external accounts. The following is the contract address generation algorithm: Keccak256(rlp([sender,nonce])[12:] // crypto/crypto.go:74 func CreateAddress(b common.Address, nonce uint64) common.Address { data, _ := rlp.EncodeToBytes([]interface{}{b, nonce}) return common.BytesToAddress(Keccak256(data)[12:]) } Because the contract is created by another account, the creator's address and the random number of the transaction are hashed and then the truncated part is generated. It is particularly important to note that inEIP1014 another algorithm for generating contract addresses proposed in. Its purpose is to facilitate the status channel by determining a stable contract address for content output. You can know the exact contract address before deploying the contract. The following is the algorithm method:keccak256( 0xff ++ address ++ salt ++ keccak256(init_code))[12:]。 // crypto/crypto.go:81 func CreateAddress2(b common.Address, salt [32]byte, inithash []byte) common.Address { return common.BytesToAddress(Keccak256([]byte{0xff}, b.Bytes(), salt[:], inithash)[12:]) } Summary of contract account characteristics: Have sipc balance. Relevant executable code (contract code). Contract codes can be called by transactions or other contract messages. Other contract codes can be called when the contract code is executed. When the contract code is executed, it can perform complex operations and permanently change the data storage inside the contract. Difference comparison To sum up, the following table lists the differences between the two types of accounts, and contract accounts are better than external accounts. However, the external account is the only medium for people to communicate with Simplechain, and it is complementary to the contract account. Item External account Contract account private Key ✔️ ✖️ balance ✔️ ✔️ code ✖️ ✔️ Multiple signature ✖️ ✔️ Control mode Private key control Execute the contract through an external account Multiple signatures are listed above because SimpleChain an external account is created by only one independent private key and cannot be signed multiple times. However, the contract is programmable, and the logic conforming to multiple signatures can be written to implement an account that supports multiple signatures. Account data structure SimpleChainData is organized by accounts, and changes in account data cause changes in account status. this causes changes in the Simplechain state. Logically, the data structures of the two types of accounts are the same: The corresponding code is as follows: // core/state/state_object.go:100 type Account struct { Nonce uint64 Balance *big.Int Root common.Hash CodeHash []byte } However, the data storage is slightly different, because the external account does not have internal storage data and contract code, so the external account data StateRootHash And CodeHash Is an empty default value. Once it belongs to an empty default value, it is not stored in the corresponding physical database. In the program logic, exist code The contract account. That CodeHash When the value is null, the account is an external account, otherwise it is a contract account. The above figure is SimpleChain the account data storage structure. In fact, only key data is stored within the account, while the contract code and the contract data are associated by corresponding hash values. Because each account object will be treated as a SimpleChain the data storage of a leaf in the account tree cannot be too large. In the field of cryptography, Nonce represents a number that is used only once. It is often a random or pseudo random number to avoid duplication. SimpleChain adding Nonce to the account can avoid replay attacks, but not randomly generated. The initial Nonce value of the account is 0. The Nonce value is added once for each subsequent account execution. The counting logic of one of them is as follows: // core/state_transition.go:212 st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1) The additional advantage of this is that Nonce can generally be used as the counter for the number of transactions of the account, especially for the contract account, the number of times the contract is called can be accurately recorded. and Balance Then record the number of sipcs owned by the account, which is called account balance. Transfer assets (Transfer) are in one account Balance Add up and reduce in another account. // core/evm.go:94 func Transfer(db vm.StateDB, sender, recipient common.Address, amount *big.Int) { db.SubBalance(sender, amount) db.AddBalance(recipient, amount) } // core/vm/evm.go:191 if !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) { return nil, gas, ErrInsufficientBalance } // core/vm/evm.go:214 evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value) Of course, the balance of the transferor must be guaranteed to be sufficient. Before the transfer CanTransfer Check, If the balance is sufficient, execute Transfer Transfer Value The number of ether. Account Status hash value StateRoot, is the root value of a Merkle Patricia Tree composed of methods and field information owned by the contract. In short, it is the root node value of a binary Tree. Any slight change in the contract status will eventually cause StateRoot Change, so the change of contract status will be reflected in the account StateRoot Up. At the same time, you can directly use StateRoot Quickly read a specific state data from Leveldb, such as the contract creator. Pass SimpleChain API web3.eth.getStorageAt data at any position in the contract can be read. Next, let's use a sample code to feel SimpleChaindata storage. import(...) var toAddr =common.HexToAddress var toHash =common.BytesToHash func main() { statadb, _ := state.New(common.Hash{}, state.NewDatabase(rawdb.NewMemoryDatabase()))// 1 acct1:=toAddr(\"0x0bB141C2F7d4d12B1D27E62F86254e6ccEd5FF9a\")// 2 acct2:=toAddr(\"0x77de172A492C40217e48Ebb7EEFf9b2d7dF8151B\") statadb.AddBalance(acct1,big.NewInt(100)) statadb.AddBalance(acct2,big.NewInt(888)) contract:=crypto.CreateAddress(acct1,statadb.GetNonce(acct1))//3 statadb.CreateAccount(contract) statadb.SetCode(contract,[]byte(\"contract code bytes\"))//4 statadb.SetNonce(contract,1) statadb.SetState(contract,toHash([]byte(\"owner\")),toHash(acct1.Bytes()))//5 statadb.SetState(contract,toHash([]byte(\"name\")),toHash([]byte(\"ysqi\"))) statadb.SetState(contract,toHash([]byte(\"online\")),toHash([]byte{1}) statadb.SetState(contract,toHash([]byte(\"online\")),toHash([]byte{}))//6 statadb.Commit(true)//7 fmt.Println(string(statadb.Dump()))//8 } In the above code, we created three accounts and submitted them to the database. Finally, print out the data information of all accounts in the current data: A line of code involves multiple operations. First, create a memory KV database and package it as a stata database instance, Finally, use an empty DB-level StateRoot , initialize a Simplechain statadb. Define two accounts acct1 and acct2, and add 100 and 888 to the account balance respectively. Simulate the creation process of a contract account, create a contract account address from the external account acct1, and load the address into statadb. Add the contract code to the newly created contract account, while writing the contract code, Can use crypto.Keccak256Hash(code) Calculate the contract code hash and keep it in the account data. Simulate the contract execution process, involving modifying the contract status and adding three new status data owner , name And online , corresponding to different values. What is different from the previous is that it is given status online The assignment is empty []byte{} Because the default value for all states is []byte{} , When submitted to the database, Leveldb deletes this record from the database file if it considers these states to have no valid values. Therefore, this operation is actually a delete State online Operation. All the above operations only occur in the statdb memory and are not actually written to database files. Implementation Commit , then all changes about statadb will be updated to the database file. Once the data is submitted, you can use Dump Command to find all data related to this stata from the database, including all accounts. And return it in JSON format. Here, we will directly print out the returned results. The code execution output is as follows: { \"root\": \"3a25b0816cf007c0b878ca7a62ba35ee0337fa53703f281c41a791a137519f00\", \"accounts\": { \"0bb141c2f7d4d12b1d27e62f86254e6cced5ff9a\": { \"balance\": \"100\", \"nonce\": 0, \"root\": \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"codeHash\": \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"code\": \"\", \"storage\": {} }, \"77de172a492c40217e48ebb7eeff9b2d7df8151b\": { \"balance\": \"888\", \"nonce\": 0, \"root\": \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"codeHash\": \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"code\": \"\", \"storage\": {} }, \"80580f576731dc1e1dcc53d80b261e228c447cdd\": { \"balance\": \"0\", \"nonce\": 1, \"root\": \"1f6d937817f2ac217d8b123c4983c45141e50bd0c358c07f3c19c7b526dd4267\", \"codeHash\": \"c668dac8131a99c411450ba912234439ace20d1cc1084f8e198fee0a334bc592\", \"code\": \"636f6e747261637420636f6465206279746573\", \"storage\": { \"000000000000000000000000000000000000000000000000000000006e616d65\": \"8479737169\", \"0000000000000000000000000000000000000000000000000000006f776e6572\": \"940bb141c2f7d4d12b1d27e62f86254e6cced5ff9a\" } } } } We can see that these displayed data directly correspond to all the operations we just performed. Only contract accounts storage And code . And external account codeHash And root The same value is a default value. "},"8_transaction/":{"url":"8_transaction/","title":"Transaction","keywords":"","body":"SimpleChaintransaction refers to the transfer of certain assets from an external account to an account, Or send a message to a smart contract. in SimpleChainnetwork, transaction execution belongs to a transaction. It has the characteristics of atomicity, consistency, isolation and persistence. ` atom： Is the indivisible minimum execution unit, either do it or not do it. same： the execution of the same transaction must change the Simplechain account book from one consistency state to another. isolate： The transaction will not be disturbed by other transactions during execution. lasting： once the transaction is submitted, the change to Simplechain account book is permanent. Subsequent operations will not affect it. Because it is a transaction type, we need to ensure that the transaction meets some design requirements before executing the transaction. The transaction must be unique and can distinguish different transactions and the same transaction cannot be submitted to the Ledger repeatedly. The transaction content must not be changed, the transactions received by each node must be consistent, and the change of account book status during transaction execution is also consistent. Transactions must be legally signed. Only transactions with correct signatures can be executed. Transactions cannot occupy too many system resources and affect the execution of other transactions. The design requirements for transactions involve all aspects of the software system, but the most basic part is the transaction data itself. Transaction data structure The following figure is SimpleChaintransaction data structure is divided into four parts according to the purpose. The beginning is a number of uint64 type, which is called a random number. Used to cancel transactions, prevent double flowers and modify SimpleChain Nonce value of the account (account data structure). The second part is about the setting of transaction execution restrictions, gas for willing to offerSimpleChainmaximum fuel limit for virtual machine operation. gasPrice is the unit price of fuel that is willing to pay. gasPrcie * gas it is the highest handling fee that is willing to pay for this transaction. The third part is the input of transaction sender SimpleChain the initial information for the virtual machine To execute this transaction: the virtual machine operation object (recipient), the asset (Value) transferred from the transaction sender To the operation object, and the virtual machine runtime input. When To is empty, it means that the virtual machine has no operation object. In this case, the virtual machine will use the input content to deploy a new contract. The fourth part is the signature result of the transaction sender. You can use the transaction content and signature result to deduce the signer, that is, the address of the transaction sender. The combination of four parts solves the problem of transaction security, realizes the interactive mode of intelligent contracts and provides flexible and adjustable transaction handling fees. Transaction object definition Specific to the code, SimpleChain defines a transaction object as an externally accessibleTransation objects and embedded objects that are invisible to external packagestxdata . Lowercase txdata It is the feature of Go language. The initial letter is lowercase, which is equivalent to that in other programming languages. private Modifier, indicating that the data structure is invisible to external packets. The same lowercase object field (such as hash in Transaction) also indicates that the external package cannot access this field. Otherwise, the definition of uppercase type, field, method, etc. is regarded public . // core/types/transaction.go:38 type Transaction struct { data txdata // caches hash atomic.Value size atomic.Value from atomic.Value } type txdata struct { AccountNonce uint64 Price *big.Int GasLimit uint64 Recipient *common.Address Amount *big.Int Payload []byte // Signature values V *big.Int R *big.Int S *big.Int // This is only used when marshaling to JSON. Hash *common.Hash `json:\"hash\" rlp:\"-\"` } First look at the private txdata The structure defines the necessary content in the transaction message, which corresponds to the transaction data structure mentioned above in sequence. There are three points that need special attention. First, because hash operation is involved, the order of field definition cannot be adjusted at will, and fields must be defined as required under non-special processing conditions. So txdata The fields defined in conform to the content order of Simplechain transaction messages. Second, when monetary calculation is involved, the problem of inaccurate calculation cannot be caused by lack of accuracy. Therefore, in all blockchain designs such as Simplechain and Bitcoin, the currency type is an integer, but the minimum value 1 The value of the currency represented is different. InSimpleChaina sipc is equal to the 18th power Amount of 10. When 10 billion sipcs are to be represented, the Amount is equal to the 27th power of 10. It has far exceeded the range (0-18446744073709551615) that Uint64 can represent. ThereforeSimpleChainall use the large numbers provided by the Go standard package big.Int Perform currency operations and define currencies. Here Price And Amount Both are of the big.Int pointer type. In addition, the three values of the signature also use the big.Int type because the number is too large. The third is the last Hash Field, which is not part of the transaction content, just to include the transaction hash in the transaction JSON. To prevent participation hash, the field is marked rlp:\"-\" . In addition, Transaction also defines three cache items: Transaction hash, Transaction size, and Transaction sender (from). The cache is used frequently and consumes a large amount of CPU. Hash operation is the most common operation in a blockchain. Data on all chains is basically involved in hash operation. However, hash operations are CPU intensive, so it is necessary to cache some hash operations to reduce CPU computing. After the transaction hash value is calculated for the first time, the transaction hash is cached on the hash field. func (tx *Transaction) Hash() common.Hash { if hash := tx.hash.Load(); hash != nil { return hash.(common.Hash) } v := rlpHash(tx) tx.hash.Store(v) return v } hash is atomic.Value Type, which is the atomic operation object provided by the Go standard package. This prevents concurrency from causing multiple hash calculations. First, the atom loads the hash value, and returns if it exists. If it does not exist, hash calculation is performed on the transaction (rlpHash, yes SimpleChain)，save the hash result and return it. The second cache is the transaction size. Transaction size refers to the data size after RLP encoding of transaction information. Represents the network transmission size of the transaction, the block size of the transaction, and the storage size of the transaction. When each transaction enters the transaction pool, you must check whether the transaction size exceeds 32KB . When pushing transaction data to other nodes, you must subcontract and push data when the transaction size does not exceed the maximum network message limit (default 10MB). To avoid repeated computing overhead, cache after the first computing. func (tx *Transaction) Size() common.StorageSize { if size := tx.size.Load(); size != nil { return size.(common.StorageSize) } c := writeCounter(0) rlp.Encode(&c, &tx.data) tx.size.Store(common.StorageSize(c)) return common.StorageSize(c) } As above, execute rlp.Encode Obtain the available data size, cache the result and return it. rlp is a set of blockchain data encoding and decoding protocols defined by Simplechain, instead of using common gzip, json, and Protobuf encoding formats. The purpose is to compress data as much as possible. After all, there are only several common data types in the blockchain data structure, which can meet the requirements without complicated protocols. The last cache item is the transaction sender (from). The sender of the transaction performs reverse computation based on the signature, which is also CPU-intensive. In order to ensure the legality of the transaction, the procedure involves taking the address of the transaction sender and verifying the legality of the sender everywhere. Only the correct signature can get the sender's address. Therefore, the transaction sender is also cached. //core/types/transaction_signing.go:72 func Sender(signer Signer, tx *Transaction) (common.Address, error) { if sc := tx.from.Load(); sc != nil { sigCache := sc.(sigCache) if sigCache.signer.Equal(signer) { return sigCache.from, nil } } addr, err := signer.Sender(tx) if err != nil { return common.Address{}, err } tx.from.Store(sigCache{signer: signer, from: addr}) return addr, nil } A special point is needed Signer Unsign and pass Signer Obtains the Sender. If it is valid, it is cached and returned. However, when using the cached content, you also need to check whether the two signers are consistent, because different Signer algorithms are different, and the transaction signers obtained are also different. Note that the above three cache usage have a precondition: Once a transaction object is created, the transaction content cannot be modified. This is also one of the reasons why the Transaction object is defined separately in the private txdata rather than directly defined in the Transaction. As shown in the following figure, only the transaction object method can be called to obtain the transaction content, and there is no way to modify the content of an existing transaction object. Transaction object method introduction In addition to providing external transaction content access, transaction object Transtion also defines some auxiliary methods. Let's introduce the methods in turn. ChainId() and Protected() func (tx *Transaction) ChainId() *big.Int { return deriveChainId(tx.data.V) } func (tx *Transaction) Protected() bool { return isProtectedV(tx.data.V) } From Transaction Signature content VMedium extraction chain ID . It is used to determine the validity of the signature when obtaining the transaction signer, once it is protected Protected() The signature information must contain the current chain ID, otherwise it is an illegal transaction. RLP interface implementation method func (tx *Transaction) EncodeRLP(w io.Writer) error { return rlp.Encode(w, &tx.data) } func (tx *Transaction) DecodeRLP(s *rlp.Stream) error { _, size, _ := s.Kind() err := s.Decode(&tx.data) if err == nil { tx.size.Store(common.StorageSize(rlp.ListSize(size))) } return err } Unlike other object-oriented languages, an object is considered to belong to an interface type as long as it has all methods to implement an interface in Go language. Here, the Transaction implements Encoder And Decoder Two interfaces. //rlp/encode.go:36 type Encoder interface { EncodeRLP(io.Writer) error } type Decoder interface { DecodeRLP(*Stream) error } This means that RLP encoding and decoding will be performed by two custom methods. RLP encoding decodes transactions. In fact, the transaction content txdata is encoded and decoded. At the same time, the transaction size is cached when the transaction is decoded. JJSON interface implementation func (tx *Transaction) MarshalJSON() ([]byte, error) { hash := tx.Hash() data := tx.data data.Hash = &hash return data.MarshalJSON() } func (tx *Transaction) UnmarshalJSON(input []byte) error { var dec txdata if err := dec.UnmarshalJSON(input); err != nil { return err } withSignature := dec.V.Sign() != 0 || dec.R.Sign() != 0 || dec.S.Sign() != 0 if withSignature { var V byte if isProtectedV(dec.V) { chainID := deriveChainId(dec.V).Uint64() V = byte(dec.V.Uint64() - 35 - 2*chainID) } else { V = byte(dec.V.Uint64() - 27) } if !crypto.ValidateSignatureValues(V, dec.R, dec.S, false) { return ErrInvalidSig } } *tx = Transaction{data: dec} return nil } This is a standard json package encoding and decoding method. It mainly returns JSON format data that meets the requirements when calling web3 APIs. The transaction hash is attached during encoding, and the validity of the signature format is also verified during decoding. The following is an example of complete transaction data in JSON format. { \"nonce\": \"0x16\", \"gasPrice\": \"0x2\", \"gas\": \"0x1\", \"to\": \"0x0100000000000000000000000000000000000000\", \"value\": \"0x0\", \"input\": \"0x616263646566\", \"v\": \"0x25\", \"r\": \"0x3c46a1ff9d0dd2129a7f8fbc3e45256d85890d9d63919b42dac1eb8dfa443a32\", \"s\": \"0x6b2be3f225ae31f7ca18efc08fa403eb73b848359a63cd9fdeb61e1b83407690\", \"hash\": \"0xb848eb905affc383b4f431f8f9d3676733ea96bcae65638c0ada6e45038fb3a6\" } json all numeric fields are expressed in hexadecimal numbers. This is to unify all data formats and serve large numbers of big.Int. The bignumber Library is specially built into the web3js library to process large numbers. "},"9_block/":{"url":"9_block/","title":"Block","keywords":"","body":"Simplechainit can be regarded as a database, and changes in database data are catalyzed by transactions. In order to manage transactions effectively and orderly, one or more transactions must be formed into one data block before they can be submitted to the database. This data Block is a Block. A block not only contains multiple transactions, but also records some additional data for correct submission to the database. The following figure shows the structure and relationship of Simplechain block data. When explaining the block data structure, other data must be presented together. Only by mastering the data sources in the block can you truly understand the block chain data. The block is divided into two parts: the block Header and the block Body. The block header is rich in information. It not only establishes contact with the previous unit, but also records some transaction execution information and miner work information. The above figure involves a very important concept Trie, whose full name is Merkel compressed prefix tree. Block header data interpretation The data of each field is as follows: parentHash Is a hash value that records the hash value of the parent block directly referenced by this block. Only through this record can the blocks be organized in an orderly manner to form a blockchain. In addition, the content of the parent block can be prevented from being modified. Because of data modification, the block hash is bound to change. Therefore, a block directly or indirectly strengthens all parent blocks, the encryption algorithm ensures that historical blocks cannot be modified. sha3Uncles Is a hash value that represents multiple uncle blocks referenced by the block. The block body also contains the block header information of multiple uncle, while sha3Uncles is the RLPHASH hash value of the Uncle block set. In Bitcoin, only when blocks are successfully dug out and accepted by other nodes can they be rewarded. This is a reward for all miners to strive for accounting rights and joint rewards. Simplechain is slightly different from Simplechain. It cannot be an orphan block in the main chain. If you are lucky enough to be taken into the block chain by later blocks, it will become an orphan block. Additional rewards will be given to the blocks that have retained the isolated blocks. Once a block becomes a block, the block will be rewarded. Reduce Simplechain soft forking and balance the benefits of miners with slow network speed through the block reward mechanism. miner Is an address, indicating that the block is dug by the miners of this account, and the mining reward will be issued to this account. stateRoot Is a hash value that indicates the snapshot ID of the Simplechain status after all transactions in this block are executed. Because Simplechain is described as a state machine system, the snapshot ID is called a state hash value. And because the status hash is generated by all account states according to Merkel prefix tree algorithm, it is called status Merkel tree root value. transactionsRoot Is a hash value, indicating that all transactions in the block generate a Merkel tree root node hash value. It is a cryptographic summary of guaranteed transactions. This Root can directly verify whether a transaction is included in this block. receiptRoot Is a hash value, which is also a hash value of Merkel tree root node. A collection of transaction receipt information generated after a block transaction is executed. logsBloom Is a 256-Byte array. Extract the self-receipt to quickly locate and find the intelligent contract event information in the transaction receipt. difficulty Is a big.Int value, indicating the difficulty coefficient that this block can be dug up. number Is the big.Int value, indicating the height of the block. It is used to mark the sequence number of a block. On a block chain, the block height must increase continuously. gasLimit Is the uint64 value, indicating the amount of Gas and fuel allowed to be consumed in this block. This value is dynamically adjusted based on the parent block. The purpose of the adjustment is to adjust the number of transactions that the block can contain. gasUsed Is the uint64 value, indicating the amount of Gas and fuel actually consumed during the execution of all transactions in this block. timestamp Is the value of uint64, which indicates the UTC timestamp of the block. Unit: seconds. Because Simplechain produces a block for an average of 14.5 seconds (12 seconds in the white paper), the block timestamp can be used as a timestamp service, but cannot be fully trusted. extraData Is a Byte array of unfixed length, up to 32 bits. It is completely customized by miners, who usually write some public promotion content or use it as a vote. mixHash Is a hash value. Check whether the block is correctly dug out. It is actually a hash value when the block header data does not contain nonce. nonce Is an 8-length Byte, which is actually a uint64 value. It is used to verify whether the block is correctly dug up. mixHash can only prove the PoW workload with a correct nonce. key code The following is the block header and block structure definition code defined in Simplechain code. All core codes are in the core/types/block.go file: //core/types/block.go:70 type Header struct { ParentHash common.Hash `json:\"parentHash\" gencodec:\"required\"` UncleHash common.Hash `json:\"sha3Uncles\" gencodec:\"required\"` Coinbase common.Address `json:\"miner\" gencodec:\"required\"` Root common.Hash `json:\"stateRoot\" gencodec:\"required\"` TxHash common.Hash `json:\"transactionsRoot\" gencodec:\"required\"` ReceiptHash common.Hash `json:\"receiptsRoot\" gencodec:\"required\"` Bloom Bloom `json:\"logsBloom\" gencodec:\"required\"` Difficulty *big.Int `json:\"difficulty\" gencodec:\"required\"` Number *big.Int `json:\"number\" gencodec:\"required\"` GasLimit uint64 `json:\"gasLimit\" gencodec:\"required\"` GasUsed uint64 `json:\"gasUsed\" gencodec:\"required\"` Time uint64 `json:\"timestamp\" gencodec:\"required\"` Extra []byte `json:\"extraData\" gencodec:\"required\"` MixDigest common.Hash `json:\"mixHash\"` Nonce BlockNonce `json:\"nonce\"` } type Body struct { Transactions []*Transaction Uncles []*Header } To create a block, call the NewBlock function: func NewBlock(header *Header, txs []*Transaction, uncles []*Header, receipts []*Receipt) *Block { b := &Block{header: CopyHeader(header), td: new(big.Int)} // TODO: panic if len(txs) != len(receipts) if len(txs) == 0 { b.header.TxHash = EmptyRootHash } else { b.header.TxHash = DeriveSha(Transactions(txs)) b.transactions = make(Transactions, len(txs)) copy(b.transactions, txs) } if len(receipts) == 0 { b.header.ReceiptHash = EmptyRootHash } else { b.header.ReceiptHash = DeriveSha(Receipts(receipts)) b.header.Bloom = CreateBloom(receipts) } if len(uncles) == 0 { b.header.UncleHash = EmptyUncleHash } else { b.header.UncleHash = CalcUncleHash(uncles) b.uncles = make([]*Header, len(uncles)) for i := range uncles { b.uncles[i] = CopyHeader(uncles[i]) } } return b } "},"10_transactionReceipt/":{"url":"10_transactionReceipt/","title":"Transaction Receipt","keywords":"","body":"Unlike bitcoin, Simplechain serves as an intelligent contract platform. When each transaction is executed as a message in the Simplechain virtual machine, a transaction Receipt is obtained. This transaction receipt records the processing result information about this transaction: The receipt information is divided into three parts: consensus information, transaction information, and block information. The following describes all kinds of information. Introduction to transaction receipt Transaction receipt consensus information Consensus means that this part of information is also involved in the verification when verifying the validity of the block. The reason for this information to participate in verification is to ensure that transactions must be executed in a fixed order in the block and record the status information after the transaction is executed. This can strengthen the transaction order. //core/state_processor.go:104 var root []byte if config.IsByzantium(header.Number) { statedb.Finalise(true) } else { root = statedb.IntermediateRoot(config.IsEIP158(header.Number)).Bytes() } //... receipt := types.NewReceipt(root, failed, *usedGas) CumulativeGasUsed：the accumulated Gas consumed by executed transactions in the block, including the current transaction. Logs: the list of smart contract events generated by the execution of the current transaction. Bloom：an event Bloom filter extracted from Logs to quickly detect whether an event on a topic exists in Logs. How does this information participate in consensus verification? In fact, only the receipt hash is involved in the verification, while the receipt hash calculation only contains this information. First, the root hash value of Merkel tree that obtains the receipt information of the entire block during verification. Then judge whether the hash value is the same as the content defined by the block header. //core/block_validator.go:92 receiptSha := types.DeriveSha(receipts) if receiptSha != header.ReceiptHash { return fmt.Errorf(\"invalid receipt root hash (remote: %x local: %x)\", header.ReceiptHash, receiptSha) } The root hash value generated by the function types. Metastesha is to form the Merck tree with the RLP encoding information of the list element (here is the transaction receipt), and finally obtain the hash value of the list. //core/types/derive_sha.go:32 func DeriveSha(list DerivableList) common.Hash { keybuf := new(bytes.Buffer) trie := new(trie.Trie) for i := 0; i The transaction receipt implements the RLP encoding interface. In the method EncodeRLP, a private tunntrlp is built. //core/types/receipt.go:119 func (r *Receipt) EncodeRLP(w io.Writer) error { return rlp.Encode(w, &receiptRLP{r.statusEncoding(), r.CumulativeGasUsed, r.Bloom, r.Logs}) } Transaction receipt transaction information This part of information records the transaction information corresponding to the receipt, including: TxHash ： the transaction hash corresponding to the transaction receipt. ContractAddress： records the address of the new contract when the transaction is deployed. //core/state_processor.go:118 if msg.To() == nil { receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce()) } GasUsed: the Gas handling fee consumed in the execution of this transaction Transaction receipt block information This part of information is to facilitate external reading of transaction receipts, not only to know the transaction execution, but also to specify the number of transactions in which block the transaction belongs. BlockHash: the hash of the block where the transaction is located. BlockNumber: the height of the block where the transaction is located. TransactionIndex：the sequence number of the transaction in the block. These three information are specified in real time when the transaction receipt is read from the Leveldb database. //core/rawdb/accessors_chain.go:315 receipts := make(types.Receipts, len(storageReceipts)) logIndex := uint(0) for i, receipt := range storageReceipts { //... receipts[i] = (*types.Receipt)(receipt) receipts[i].BlockHash = hash receipts[i].BlockNumber = big.NewInt(0).SetUint64(number) receipts[i].TransactionIndex = uint(i) } Transaction receipt structure Transaction receipt is the transaction execution result information sorted out according to the results after the Simplechain virtual machine processes the transaction. It reflects the Simplechain changes and transaction execution status before and after the transaction is executed. The construction details have already been mentioned before and will not be described in detail. The complete transaction receipt construction code is given here. // core/state_processor.go:94 context := NewEVMContext(msg, header, bc, author) vmenv := vm.NewEVM(context, statedb, config, cfg) _, gas, failed, err := ApplyMessage(vmenv, msg, gp) if err != nil { return nil, 0, err } var root []byte if config.IsByzantium(header.Number) { statedb.Finalise(true) } else { root = statedb.IntermediateRoot(config.IsEIP158(header.Number)).Bytes() } *usedGas += gas receipt := types.NewReceipt(root, failed, *usedGas) receipt.TxHash = tx.Hash() receipt.GasUsed = gas if msg.To() == nil { receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce()) } receipt.Logs = statedb.GetLogs(tx.Hash()) receipt.Bloom = types.CreateBloom(types.Receipts{receipt}) receipt.BlockHash = statedb.BlockHash() receipt.BlockNumber = header.Number receipt.TransactionIndex = uint(statedb.TxIndex()) return receipt, gas, err Transaction receipt storage As an intermediate product of transaction execution, the transaction receipt is used to quickly obtain the execution details of a transaction. Simplechain stores transaction receipts in real time when following block storage. However, in order to reduce the storage capacity, only necessary content is stored. First, convert the transaction receipt object to simplified content during storage. //core/rawdb/accessors_chain.go:338 storageReceipts := make([]*types.ReceiptForStorage, len(receipts)) for i, receipt := range receipts { storageReceipts[i] = (*types.ReceiptForStorage)(receipt) } Streamlined content is a structure that is specifically defined for storage. RLP encoding is used to store the transaction receipt set. //core/rawdb/accessors_chain.go:342 bytes, err := rlp.EncodeToBytes(storageReceipts) if err != nil { log.Crit(\"Failed to encode block receipts\", \"err\", err) } if err := db.Put(blockReceiptsKey(number, hash), bytes); err != nil { log.Crit(\"Failed to store block receipts\", \"err\", err) } Look at the EncodeRLP method of tunntforstorage to know what content is stored //core/types/receipt.go:179 func (r *ReceiptForStorage) EncodeRLP(w io.Writer) error { enc := &receiptStorageRLP{ PostStateOrStatus: (*Receipt)(r).statusEncoding(), CumulativeGasUsed: r.CumulativeGasUsed, TxHash: r.TxHash, ContractAddress: r.ContractAddress, Logs: make([]*LogForStorage, len(r.Logs)), GasUsed: r.GasUsed, } for i, log := range r.Logs { enc.Logs[i] = (*LogForStorage)(log) } return rlp.Encode(w, enc) } According to the EncodeRLP method, it can be concluded that only part of the content is stored during storage, and the Logs are also specially processed. LogForStorage "},"11_constructDesign/":{"url":"11_constructDesign/","title":"Structure Design","keywords":"","body":"The following figure shows the overall architecture of Simplechain: Top-level architecture design The blockchain can be simply divided into three layers: protocol layer, extension layer, and application layer. The protocol layer can be divided into storage layer and network layer, which are independent but inseparable. The top layer of Simplechain is DApp, which is the display layer of the entire blockchain. It exchanges with the intelligent contract layer through Web3.js. For example, Simplechain uses web3-js, the application layer of a blockchain can be a mobile terminal, a web terminal, or an existing server that is integrated into the application layer. All smart contracts run on EVM (virtual machines) and use RPC(Remote Procedure Call Protocol, which is A process method called by B through the network). Under EVM and RPC, there are four core contents of Simplechain, including blockChain, consensus algorithm, mining, and network layer. All parts except DApp are in the client sipe of Simplechain. From the perspective of data structure The protocol layer is the underlying technology. This layer is usually a complete blockchain product, similar to the operating system of our computer. It maintains network nodes and only provides APIs for calling. Network programming, distributed algorithm, encryption signature, data storage technology and other four aspects, distributed algorithm is basically a business logic implementation, can be achieved in any language, the encrypted signature technology is used directly and simply, and the database technology is also mainly used at the use level. Storage layer:A Block + Lian Biao and blockchain data structure. The database used in Simplechain is levelDB. Network layer:p2p network, the implementation of P2P network and concurrent processing are the difficulties in development, so for those languages with strong network programming ability and simple concurrent processing, block chain applications in Nodejs Development Zone, gradually becoming more and more popular, Go language began to be very popular. Consensus layer:That is, the incentive layer, through the mining mechanism, formulates the way of obtaining currency through the blockchain. For example, Bitcoin uses POW(Proof of Work workload): The better the performance of a computer, the easier it is to obtain monetary rewards. And POS(Proof of Stake equity certification mechanism): similar to the concept of crowdfunding dividends, it will pay interest to holders according to the amount and time of currency you hold. Extension layer:Similar to computer drivers, this part of Simplechain includes EVM (virtual machine) and intelligent contract. To make blockchain products more practical, such as Simplechain's \"smart contract\" concept, which is a typical application development at the expansion level. Contract layer:Previous blockchains did not have this layer. Therefore, the original blockchain can only conduct transactions, but cannot be used in other fields or other logical processing. But the emergence of contract layer and intelligent contract is \"programmable contract\", or \"contract intelligence\", in which \"intelligence\" is the intelligence of execution, that is to say, to reach a certain condition, the automatic execution of contracts makes the use of blockchains in other fields a reality. Application layer:Similar to various software programs in a computer, the display layer of the blockchain. DAPP is also an application at this level. It publishes smart contracts to the blockchain. People access this block through addresses and then interact with smart contracts. Simplechain uses web3-js. The application layer of a blockchain can be a mobile terminal, a web terminal, or an existing server that is integrated into the application layer. The DAPP developed based on this actually encapsulates a layer of Web applications on the basis of intelligent contracts. The issue of tokens and so on are all at this level, and interact with intelligent contracts through Web applications provided by DAPP. Aggregate chain architecture SimpleChain designs an aggregate chain structure of a main chain and multiple sub-chains, which supports blockchain deployment and expansion in various business scenarios. The SimpleChain main chain adopts the mature PoW mechanism, while the sub-chain can set consensus algorithms suitable for its own scenarios according to business requirements, and form a two-way anchoring method with the main chain through atomic exchange or cross-chain nodes, cross-chain transactions with other sub-chains. This main chain mechanism can help the sub-chain obtain the final consistency guarantee provided by the SimpleChain main chain on the premise of meeting thousands of levels of performance per second. The Simplechain sub-chain can be either a public chain or a consortium chain. Its chain structure is similar to that of the main chain (see blockchain architecture design). However, due to different business requirements, different consensus algorithms can be used to achieve thousands of TPS performance, or other custom development functions. The main chain and sub-chain achieve mutual anchoring, information exchange and capital flow through cross-chain protocols. The cross-chain protocol (see cross-chain protocol) adopts the free notary mechanism. All users in the whole network ecosystem can participate in and supervise it. The community's self-care ability can be effectively utilized to effectively ensure the reliability of cross-chain information, the transaction is safe and orderly. At the same time, Simplechain Foundation has carried out the research on the economic model of the main chain and established a set of incentive mechanism for the sustainable and healthy development of Simplechain ecosystem. Under the effect of this mechanism, the main chain ecosystem will integrate and promote each other, common development. ! "},"12_structAndStore/":{"url":"12_structAndStore/","title":"Data Struct and ","keywords":"","body":"The Block and transaction data of Simplechain are ultimately stored in Level DB In the database. Level DB A database is a key-value database. key is generally related to hash, while value is the RLP encoding for storing content. KV storage LevelDB Trigg tree Merkle Patricia Trie is a prefix tree that uses hash to index data. Macroscopically speaking, the triggtree is a prefix tree that uses key to query the value. To query the value by using the key is to use the key to index on the Modbus tree. After passing through multiple intermediate nodes, it finally reaches the leaf node where the data is stored. In terms of details, the triggtree is a Merkle tree. The index of each node on each tree is the hash value of this node. When using the key to search for a value, the hash value of the next node to be redirected and the hash value of the next node are obtained based on the fact that the key is within a certain node, you can retrieve the data of the next node from the underlying database, and then use the key to query the hash value of the next node in the next node until the leaf node where the value is located is reached. When the data of a leaf node on the Modbus tree is updated, the hash of the leaf node will also be updated, the hash of all intermediate nodes traced back to the root node by this leaf node is updated. Finally, the hash of the root node of the profiler is also updated. When you want to index this new data, use the new root node hash of profiler to find a new root node from the underlying database, and then traverse it layer by layer to finally find the new data. If you want to query historical data, you can use the old root hash to retrieve the old root node from the underlying database and traverse it down to query historical data. The implementation diagram of triggtree (the picture is from the Yellow Book of Ethereum) Account State On Simplechain, data is stored in account units. In each account, data such as the code, parameters, and nonce of the contract (user) are stored. The data of the account is indexed by the address of the account. As the account data changes, the hash of the account also changes. At the same time, the hash of the root of profiler also changes. When the account data is different, the root of the corresponding profiler is different. Here, Ethereum concretizes this layer of meaning and puts forward the concept of \"state. Call the hash of triggroot as state root. Different state root, corresponding to different \"states\", corresponding to the query of different Modbus root nodes, then, use the account address to query the account data in this status from the root node of different profiles. Different states may result in different amount of account queries, because the root node of the modifier is different. state root is a field in a block, and each block corresponds to a different \"state\". Transactions in the block operate on the account to change the data in the account. account data varies in different blocks, that is, the state of this block is different, specifically, the state root is different. Take the state root of the block from a certain block and query the root node of the profiler, then the data History of the account in the block can be indexed. 二、索引存储StormDB StormDB(a simple and powerful toolkit for BoltDB)是一种基于boltDB实现的数据库，它支持索引与搜索查询，相对于传统关系数据库MySQL、Oracle等，StormDB使用单一文件存储，没有单独的服务，更加轻量便于系统移植，SImplechain使用它来存储跨链交易。 名词解释 Bucket Storage unit of a custom object Id The primary key index of the stored object. The index is unique and cannot be duplicated. Index Sort indexes. Currently, only numeric fields (int8, int16, int32, int64, uint8, uint16, uint32, uint64) are supported, other types are sorted by byte comparison after encoding. Unique Unique hash index Options Query options, such as Limit, OrderBy, Skip, and so on. Matcher The input condition of the query. It supports Eq, Gt(greater than), Lt(less than), And, Or, Not, And Re (regular match). Example Take the cross-chain transaction storage structure as an example to explain the above terms. type CrossTransactionIndexed struct { PK uint64 `storm:\"id,increment\"` CtxId common.Hash `storm:\"unique\"` From common.Address `storm:\"index\"` To common.Address `storm:\"index\"` TxHash common.Hash `storm:\"index\"` Price *big.Float `storm:\"index\"` Status uint8 `storm:\"index\"` Value *big.Int BlockNum uint64 `storm:\"index\"` BlockHash common.Hash DestinationId *big.Int DestinationValue *big.Int `storm:\"index\"` Input []byte V []*big.Int R []*big.Int S []*big.Int } The explanation is as follows: storm:\"id,increment\"：indicates that this field is the primary key, and increment indicates that it automatically increments when inserted. storm:\"unique\"：indicates that this field uses a non-repeatable hash index. storm:\"index\"：indicates that this field uses a sort index. CRUD and transactions Insert object user := User{ ID: 10, Group: \"staff\", Email: \"john@provider.com\", Name: \"John\", Age: 21, CreatedAt: time.Now(), } err := db.Save(&user) // err == nil user.ID++ err = db.Save(&user) // err == storm.ErrAlreadyExists update object // Update multiple fields err := db.Update(&User{ID: 10, Name: \"Jack\", Age: 45}) // Update a single field err := db.UpdateField(&User{ID: 10}, \"Age\", 0) Delete object err := db.DeleteStruct(&user) Delete Bucket err := db.Drop(&User) //OR err := db.Drop(\"User\") Query object var users []User err := db.Find(\"Group\", \"staff\", &users, storm.Skip(10)) err = db.Find(\"Group\", \"staff\", &users, storm.Limit(10)) err = db.Find(\"Group\", \"staff\", &users, storm.Reverse()) err = db.Find(\"Group\", \"staff\", &users, storm.Limit(10), storm.Skip(10), storm.Reverse()) err = db.All(&users, storm.Limit(10), storm.Skip(10), storm.Reverse()) err = db.AllByIndex(\"CreatedAt\", &users, storm.Limit(10), storm.Skip(10), storm.Reverse()) err = db.Range(\"Age\", 10, 21, &users, storm.Limit(10), storm.Skip(10), storm.Reverse()) Conditional query query := db.Select(q.Gte(\"Age\", 7), q.Lte(\"Age\", 77)) var users []User err = query.Find(&users) Use transactions tx, err := db.Begin(true) if err != nil { return err } defer tx.Rollback() accountA.Amount -= 100 accountB.Amount += 100 err = tx.Save(accountA) if err != nil { return err } err = tx.Save(accountB) if err != nil { return err } return tx.Commit() Efficient memory multi-index storage To meet different index types and efficiency requirements, stormDB alone is difficult to meet. Therefore, a multi-index structure is introduced into the memory to store data with high read/write frequency. Hash index The hash indexes used in Simplechain are all hash indexes with unique key values, so map is directly used for storage. Insert and update idx := make(map[Key]Value) idx[key]=value Delete delete(idx,key) Read if v,ok := idx[key]; ok {//...} Sort index Simplechain uses red and black trees as sorting indexes to store any data type with sequence requirements. Initialization redblacktree.NewWith(container.UInt64Comparator, true) Insert and update idx.Put(key,value) Query itr := idx.Get(key) Delete key idx.Remove(key) Delete a specific object for it:=idx.LowerBound(key); it!=idx.UpperBound(key); it.Next() { if ... { idx.RemoveOne(itr) break } } "},"50_togetherStep.html":{"url":"50_togetherStep.html","title":"Data Synchronize","keywords":"","body":"Basic synchronization process Synchronization is a very important function of blockchain nodes. It is consensus to provide the consensus with the necessary operating conditions. Synchronization is divided into transaction synchronization and status synchronization. Transaction synchronization ensures that each transaction can reach each node correctly. Status synchronization can ensure that the backward nodes in the block can return to the latest status correctly. Only nodes with the latest block status can participate in the consensus. Transaction synchronization Transaction synchronization allows transactions on the blockchain to reach all nodes as much as possible. Provides the basis for packaging transactions into blocks in consensus. A transaction (tx1) is sent from the client to a node. After receiving the transaction, the node will put the transaction into its own transaction Pool (Tx Pool) for consensus packaging. At the same time, the node broadcasts the transaction to other nodes. After receiving the transaction, other nodes will also put the transaction into their own transaction pool. The transaction may be lost during the process of sending. In order to make the transaction reach all nodes as much as possible, the node that receives the broadcast transaction will choose other nodes according to a certain strategy, broadcast again. Transaction broadcast strategy If each node has no restrictions on forwarding or broadcasting received transactions, the bandwidth will be occupied and the transaction broadcast avalanche will occur. In order to avoid the avalanche of transaction Broadcasting, Simplechain chose a relatively delicate transaction broadcasting strategy based on experience. On the premise of ensuring the reachability of the transaction as much as possible, reduce the repeated transaction broadcast as much as possible. For transactions from the SDK, broadcast to all nodes A transaction is broadcast only once on a node. When a duplicate transaction is received, no secondary broadcast is performed. Through the above strategy, transactions can reach all nodes as much as possible, but a transaction cannot reach a node with a minimum probability. This situation is allowed. The purpose of reaching as many nodes as possible is to package, reach consensus, and confirm the transaction as soon as possible, so that the transaction can be executed as quickly as possible. When the transaction does not reach a certain node, the transaction execution time will only be longer and the correctness of the transaction will not be affected. Status synchronization Status synchronization is to keep the status of blockchain nodes up to date. The status of a blockchain is the new and old data that a blockchain node currently holds, that is, the height of the current block that a node holds. If the block height of a node is the highest block height of the blockchain, the node has the latest status of the blockchain. Only nodes with the latest status can participate in the consensus and carry out the consensus of the next new district. When a new node is added to the blockchain, or a node that has been disconnected is restored to the network, the block of this node lags behind other nodes, and the status is not up to date. Status synchronization is required. As shown in the figure, the Node (Node 1) that needs state synchronization initiatively requests other nodes to download the block. During the entire download process, the download load is distributed to multiple nodes. Status synchronization and Download Queue When a blockchain node is running, it regularly broadcasts its highest block height to other nodes. After a node receives the block height broadcasted by other nodes, it compares it with its own block height. If its own block height falls behind this block height, the block download process is started. The download of the block is completed by request. The node that enters the download process randomly selects the node that meets the requirements and sends the block interval to be downloaded. The node that receives the download request will reply to the corresponding block based on the request content. The node that receives the reply block maintains a download queue locally to buffer and sort the downloaded blocks. A download queue is a priority queue in order of block heights. The downloaded blocks are continuously inserted into the Download Queue. When the blocks in the queue can connect to the current local blockchain of the node, the blocks are taken out of the download queue, connect to the current local blockchain. Examples of synchronization scenarios Transaction synchronization The process of broadcasting a transaction to all nodes: A transaction is sent to a node through a channel or RPC The node that receives the transaction broadcasts the transaction to other nodes in full. After other nodes receive the transaction, to be on the safe side, select 25% of the nodes to broadcast again The node receives a broadcast transaction and will not broadcast it again Status synchronization Broadcast logic when node blocks Outbound block of a node This section broadcasts its latest status (latest block height, highest block hash, Genesis block hash) to all nodes After other nodes receive the peer status, the peer data managed locally is updated. "},"13_p2pNetwork.html":{"url":"13_p2pNetwork.html","title":"p2p network","keywords":"","body":"Design objectives Simplechain P2P The module provides efficient, universal, and secure basic network communication functions, supports unicast, multicast, and broadcast of blockchain messages, supports status synchronization of blockchain nodes, and supports multiple protocols. Main functions of P2P Blockchain Node Identification: A blockchain node is uniquely identified by the blockchain Node Identification, and the blockchain node is addressed by the blockchain node identification on the blockchain network. Manage network connections: Maintain long TCP connections between blockchain nodes on the blockchain network, automatically disconnect abnormal connections, and automatically lift connections Message sending and receiving: Unicast, multicast, or broadcast messages between blockchain nodes in the blockchain network Status synchronization: Synchronization status between blockchain nodes Simplechain Node Identification The Node Identification of Simplechain is generated by the public key of the ECC algorithm. Each blockchain node must have a unique ECC key pair. The Node Identification uniquely identifies a blockchain node in the blockchain network. In general, to join a blockchain network, a node key node.key file in ECC format is required. In addition to the unique blockchain Node Identification, Simplechain nodes can also focus on topics for addressing. Simplechain node addressing: Blockchain Node Identification addressing: Use the blockchain Node Identification to locate a unique blockchain node in the blockchain network. Topic addressing: Use the Topic to locate a group of nodes that focus on the Topic in the blockchain network. Manage network connections A long TCP connection is automatically initiated and maintained between Simplechain nodes. When a system fault or network exception occurs, the connection is automatically restarted. When a connection is established between nodes, the CA certificate is used for authentication. Connection establishment process participant node A participant node B Node A->>Node A: Load the Key Node B->>Node B: Load the key Node A->>NOde B: Initiate the connection Node B->>Node A: Successful Node B->Node A: Initiate SSL handshake Node B->Node A: Successful handshake, establish SSL connection Sending and receiving messages Messages between nodes support unicast, multicast, and broadcast. Unicast: a single node sends a message to a single blockchain node and identifies the address through the blockchain node. Multicast: a single node sends messages to a group of blockchain nodes through Topic addressing Broadcast: a single node sends messages to all blockchain nodes Unicast process sequenceDiagram participant node A participant node B node A->>node A: Filter online nodes based on node ID node A->>node B: Send message node B->>node A: message return packet Multicast process sequenceDiagram participant node A participant node B participant node C participant node D node A->>node A: 根据Topic 1，选择节点B、C node A->>node B: 发送消息 nide A->>node C: 发送消息 node B->>node B: 根据Topic 2，选择节点C、D node B->>node C: 发送消息 node B->>node D: 发送消息 node C->>node C: 根据Topic 3，选择节点D node C->>node B: 发送消息 Broadcast process sequenceDiagram participant node A participant node B participant node C participant node D 节点A->>节点A: 遍历所有节点ID 节点A->>节点B: 发送消息 节点A->>节点C: 发送消息 节点A->>节点D: 发送消息 节点B->>节点B: 遍历所有节点ID 节点B->>节点C: 发送消息 节点B->>节点D: 发送消息 节点C->>节点C: 遍历所有节点ID 节点C->>节点D: 发送消息 Status synchronization Each node maintains its own state, broadcasts the Seq of the state on the whole network at a fixed time, and synchronizes it with other nodes. sequenceDiagram participant node A participant node B node A->node B: 广播seq node A->>node A: 判断节点B的seq是否变化 node A->>node B: seq变化，发起状态查询请求 node B->>node A: 返回节点状态 node A->>node A: 更新节点B的状态和seq "},"14_consensus/":{"url":"14_consensus/","title":"Consensus mechanism","keywords":"","body":"Consensus mechanism is an algorithm for distributed consensus of blockchain transactions. Due to high or low network latency in a point-to-point network, the order of transactions received by each node may be different, therefore, the blockchain system needs to design a mechanism to enable nodes to reach a consensus on the order of transactions that occur at about the same time. This is the consensus mechanism. PoW consensus algorithm PoW proves that you have completed the characteristics of the corresponding work hash function through the work results: Collision-free, that is, there is no case where the input values are different and the hash values are the same after hash transformation. Concealment, that is, given a hash value, it is infeasible to reverse the input value. There is no better method than exhaustive to make hash values fall within a specific range. POW algorithm principle: the node searches for the appropriate hash value by constantly changing random numbers. When the node first calculates the appropriate hash value, if the packaged block passes the verification of other consensus nodes, it is added to the blockchain. Introduction to Scrypt algorithm The mining algorithm adopted by Simplechain is Scrypt algorithm. Scrypt is a memory-dependent POW algorithm that conforms to the PoW consensus mechanism. The Scrypt algorithm also needs to calculate the hash value, but more memory resources are needed in the Scrypt calculation process. Scrypt algorithm process Several functions used by the Scrypt algorithm are interlocking. This section describes the calling order of the functions from inside to outside. Salsa20/8 #define R(a,b) (((a) > (32 - (b)))) void salsa20_word_specification(uint32 out[16],uint32 in[16]) { int i; uint32 x[16]; for (i = 0;i 0;i -= 2) { x[ 4] ^= R(x[ 0]+x[12], 7); x[ 8] ^= R(x[ 4]+x[ 0], 9); x[12] ^= R(x[ 8]+x[ 4],13); x[ 0] ^= R(x[12]+x[ 8],18); x[ 9] ^= R(x[ 5]+x[ 1], 7); x[13] ^= R(x[ 9]+x[ 5], 9); x[ 1] ^= R(x[13]+x[ 9],13); x[ 5] ^= R(x[ 1]+x[13],18); x[14] ^= R(x[10]+x[ 6], 7); x[ 2] ^= R(x[14]+x[10], 9); x[ 6] ^= R(x[ 2]+x[14],13); x[10] ^= R(x[ 6]+x[ 2],18); x[ 3] ^= R(x[15]+x[11], 7); x[ 7] ^= R(x[ 3]+x[15], 9); x[11] ^= R(x[ 7]+x[ 3],13); x[15] ^= R(x[11]+x[ 7],18); x[ 1] ^= R(x[ 0]+x[ 3], 7); x[ 2] ^= R(x[ 1]+x[ 0], 9); x[ 3] ^= R(x[ 2]+x[ 1],13); x[ 0] ^= R(x[ 3]+x[ 2],18); x[ 6] ^= R(x[ 5]+x[ 4], 7); x[ 7] ^= R(x[ 6]+x[ 5], 9); x[ 4] ^= R(x[ 7]+x[ 6],13); x[ 5] ^= R(x[ 4]+x[ 7],18); x[11] ^= R(x[10]+x[ 9], 7); x[ 8] ^= R(x[11]+x[10], 9); x[ 9] ^= R(x[ 8]+x[11],13); x[10] ^= R(x[ 9]+x[ 8],18); x[12] ^= R(x[15]+x[14], 7); x[13] ^= R(x[12]+x[15], 9); x[14] ^= R(x[13]+x[12],13); x[15] ^= R(x[14]+x[13],18); } for (i = 0;i scryptBlockMix Parameters: r Block size parameter. Input: B[0] || B[1] || ... || B[2 * r - 1] Input octet string (of size 128 * r octets), treated as 2 * r 64-octet blocks, where each element in B is a 64-octet block. Output: B'[0] || B'[1] || ... || B'[2 * r - 1] Output octet string. Steps: 1. X = B[2 * r - 1] 2. for i = 0 to 2 * r - 1 do T = X xor B[i] X = Salsa (T) Y[i] = X end for 3. B' = (Y[0], Y[2], ..., Y[2 * r - 2], Y[1], Y[3], ..., Y[2 * r - 1]) scryptROMix Input: r Block size parameter. B Input octet vector of length 128 * r octets. N CPU/Memory cost parameter, must be larger than 1, a power of 2, and less than 2^(128 * r / 8). Output: B' Output octet vector of length 128 * r octets. Steps: 1. X = B 2. for i = 0 to N - 1 do V[i] = X X = scryptBlockMix (X) end for 3. for i = 0 to N - 1 do j = Integerify (X) mod N where Integerify (B[0] ... B[2 * r - 1]) is defined as the result of interpreting B[2 * r - 1] as a little-endian integer. T = X xor V[j] X = scryptBlockMix (T) end for 4. B' = X scrypt Input: P Passphrase, an octet string. S Salt, an octet string. N CPU/Memory cost parameter, must be larger than 1, a power of 2, and less than 2^(128 * r / 8). r Block size parameter. p Parallelization parameter, a positive integer less than or equal to ((2^32-1) * hLen) / MFLen where hLen is 32 and MFlen is 128 * r. dkLen Intended output length in octets of the derived key; a positive integer less than or equal to (2^32 - 1) * hLen where hLen is 32. Output: DK Derived key, of length dkLen octets. Steps: 1. Initialize an array B consisting of p blocks of 128 * r octets each: B[0] || B[1] || ... || B[p - 1] = PBKDF2-HMAC-SHA256 (P, S, 1, p * 128 * r) 2. for i = 0 to p - 1 do B[i] = scryptROMix (r, B[i], N) end for 3. DK = PBKDF2-HMAC-SHA256 (P, B[0] || B[1] || ... || B[p - 1], 1, dkLen) In the mining algorithm, the selected parameters are: P：block header; S：block header; N：fixed as 1024; r：fixed as 1; p：fixed as 1; dkLen：fixed to 32, that is, the output length is 32 bytes. Therefore, the hash value of the block header of the Wright coin is powhash = scrypt(blockheader, blockheader, 1024, 1, 1, 32). You can refer to the Go language version for obtaining the block header hash in Wright coin. // Copyright (c) 2013-2016 The btcsuite developers // Use of this source code is governed by an ISC // license that can be found in the LICENSE file. package wire import ( \"bytes\" \"io\" \"time\" \"golang.org/x/crypto/scrypt\" \"github.com/ltcsuite/ltcd/chaincfg/chainhash\" ) // MaxBlockHeaderPayload is the maximum number of bytes a block header can be. // Version 4 bytes + Timestamp 4 bytes + Bits 4 bytes + Nonce 4 bytes + // PrevBlock and MerkleRoot hashes. const MaxBlockHeaderPayload = 16 + (chainhash.HashSize * 2) // BlockHeader defines information about a block and is used in the bitcoin // block (MsgBlock) and headers (MsgHeaders) messages. type BlockHeader struct { // Version of the block. This is not the same as the protocol version. Version int32 // Hash of the previous block header in the block chain. PrevBlock chainhash.Hash // Merkle tree reference to hash of all transactions for the block. MerkleRoot chainhash.Hash // Time the block was created. This is, unfortunately, encoded as a // uint32 on the wire and therefore is limited to 2106. Timestamp time.Time // Difficulty target for the block. Bits uint32 // Nonce used to generate the block. Nonce uint32 } // blockHeaderLen is a constant that represents the number of bytes for a block // header. const blockHeaderLen = 80 // BlockHash computes the block identifier hash for the given block header. func (h *BlockHeader) BlockHash() chainhash.Hash { // Encode the header and double sha256 everything prior to the number of // transactions. Ignore the error returns since there is no way the // encode could fail except being out of memory which would cause a // run-time panic. buf := bytes.NewBuffer(make([]byte, 0, MaxBlockHeaderPayload)) _ = writeBlockHeader(buf, 0, h) return chainhash.DoubleHashH(buf.Bytes()) } // PowHash returns the litecoin scrypt hash of this block header. This value is // used to check the PoW on blocks advertised on the network. func (h *BlockHeader) PowHash() (*chainhash.Hash, error) { var powHash chainhash.Hash buf := bytes.NewBuffer(make([]byte, 0, MaxBlockHeaderPayload)) _ = writeBlockHeader(buf, 0, h) scryptHash, err := scrypt.Key(buf.Bytes(), buf.Bytes(), 1024, 1, 1, 32) if err != nil { return nil, err } copy(powHash[:], scryptHash) return &powHash, nil } // BtcDecode decodes r using the bitcoin protocol encoding into the receiver. // This is part of the Message interface implementation. // See Deserialize for decoding block headers stored to disk, such as in a // database, as opposed to decoding block headers from the wire. func (h *BlockHeader) BtcDecode(r io.Reader, pver uint32, enc MessageEncoding) error { return readBlockHeader(r, pver, h) } // BtcEncode encodes the receiver to w using the bitcoin protocol encoding. // This is part of the Message interface implementation. // See Serialize for encoding block headers to be stored to disk, such as in a // database, as opposed to encoding block headers for the wire. func (h *BlockHeader) BtcEncode(w io.Writer, pver uint32, enc MessageEncoding) error { return writeBlockHeader(w, pver, h) } // Deserialize decodes a block header from r into the receiver using a format // that is suitable for long-term storage such as a database while respecting // the Version field. func (h *BlockHeader) Deserialize(r io.Reader) error { // At the current time, there is no difference between the wire encoding // at protocol version 0 and the stable long-term storage format. As // a result, make use of readBlockHeader. return readBlockHeader(r, 0, h) } // Serialize encodes a block header from r into the receiver using a format // that is suitable for long-term storage such as a database while respecting // the Version field. func (h *BlockHeader) Serialize(w io.Writer) error { // At the current time, there is no difference between the wire encoding // at protocol version 0 and the stable long-term storage format. As // a result, make use of writeBlockHeader. return writeBlockHeader(w, 0, h) } // NewBlockHeader returns a new BlockHeader using the provided version, previous // block hash, merkle root hash, difficulty bits, and nonce used to generate the // block with defaults for the remaining fields. func NewBlockHeader(version int32, prevHash, merkleRootHash *chainhash.Hash, bits uint32, nonce uint32) *BlockHeader { // Limit the timestamp to one second precision since the protocol // doesn't support better. return &BlockHeader{ Version: version, PrevBlock: *prevHash, MerkleRoot: *merkleRootHash, Timestamp: time.Unix(time.Now().Unix(), 0), Bits: bits, Nonce: nonce, } } // readBlockHeader reads a bitcoin block header from r. See Deserialize for // decoding block headers stored to disk, such as in a database, as opposed to // decoding from the wire. func readBlockHeader(r io.Reader, pver uint32, bh *BlockHeader) error { return readElements(r, &bh.Version, &bh.PrevBlock, &bh.MerkleRoot, (*uint32Time)(&bh.Timestamp), &bh.Bits, &bh.Nonce) } // writeBlockHeader writes a bitcoin block header to w. See Serialize for // encoding block headers to be stored to disk, such as in a database, as // opposed to encoding for the wire. func writeBlockHeader(w io.Writer, pver uint32, bh *BlockHeader) error { sec := uint32(bh.Timestamp.Unix()) return writeElements(w, bh.Version, &bh.PrevBlock, &bh.MerkleRoot, sec, bh.Bits, bh.Nonce) } POA consensus algorithm Background of POA generation If you want to use Simplechain to build a private chain with lower transaction costs, lower transaction latency, and higher concurrency, also have full control (meaning lower probability of being attacked). Currently, Simplechain cannot meet the requirements by using PoW. First of all, pow has a 51% attack problem. Malicious miners who exceed 51% of the total network computing power can basically fully control the entire network. Because the chain cannot be changed, the data that has been linked cannot be changed, but malicious miners can also do some DoS attacks to prevent legitimate transactions from being linked, considering that absenteeism with the same creation block can join your network, potential security risks will exist for a long time. Secondly, a large amount of PoW power resource consumption also needs to be considered as follow-up cost. PoS can solve some Pow problems, such as saving power and protecting 51% of attacks to a certain extent (malicious absenteeism will be punished), but there are still deficiencies in control and security considerations, because PoS still allows any eligible absenteeism to join. Features of POA PoA relies on the default authorized nodes (signers) to generate blocks. A new signer can be elected by an authorized signer (voting more than 50%) to join the new signer. Even if a malicious signer exists, it can only attack one of the consecutive blocks (the number is (SIGNER_COUNT / 2) +1). During this period, other signers can vote to kick the malicious signer. You can specify the time when the block is generated. The workflow of POA is as follows Specify a group of initially authorized signers in the creation block. All addresses are stored in the Extra field of the creation block. After mining is started, the group of signers begin to sign and broadcast the generated block. The signature results are saved in the Extra field of the block header. Update the addresses of all currently highly authorized signers in Extra because there are new signers added or kicked out Each height has a signer IN the IN-TURN State and other signers IN the OUT-OF-TURN state. The block signed by the signer IN-TURN will be broadcast immediately, the OUT-OF-TURN signer-signed block will be broadcast after a little random time delay to ensure that the IN-TURN signature block has a higher priority. If a new signer needs to be added, the signer initiates a proposal through the API interface, which uses the block header Coinbase (new signer address) and Nonce(\"0xffffffffffff\") fields are broadcast to other nodes. All authorized signers vote for the new signer. If the affirmative vote exceeds 50% of the total number of signers, they agree to join If an old signer needs to be kicked out, all authorized signers will \"kick out\" the old signer. If the affirmative vote exceeds 50% of the total number of signers, it means they agree to kick out. How to Select POA consensus algorithm in Simplechain Download and generate a new genesis block file, Download Address After the download is complete, run the command Generate genesis block In the process of generating the creation block file, you can choose the consensus algorithm you want. As shown below: "},"15_virtualMache/":{"url":"15_virtualMache/","title":"virtual machine","keywords":"","body":"On Simplechain, you can run the contract deployed on Simplechain to complete the operations that require consensus. Simplechain virtual machine is the executor of intelligent contract code. Therefore, when the smart contract is compiled into a binary file, it is deployed on Simplechain. The user calls the smart contract interface to trigger the execution of the smart contract. EVM executes the code of the smart contract to modify the data (status) on the current blockchain. The modified data will be agreed to ensure consistency. SVMC EVM can be stripped from Simplechain to form an independent module. The interaction between EVM and nodes abstracts the SVMC interface standard. Through the SVMC interface standard, nodes can connect to a variety of virtual machines, not limited to traditional solidity-based virtual machines. The traditional solidity virtual machine is called interpreter in Simplechain. The implementation of the interpreter is mainly explained in the following section. SVMC interface SVMC mainly defines two calling interfaces: Instance interface: the interface that the node calls EVM Callback interface: the interface of the EVM Callback node. EVM itself does not save status data. The node operates EVM through the instance interface. In turn, EVM calls the Callback interface to operate the status of the node. Instance interface Defines the operations of nodes on virtual machines, including creation, destruction, and setting. The interface is defined in evmc_instance(evmc.h) abi_version name version destroy execute set_tracer set_option Callback interface Defines how EVM operates on nodes, mainly reading and writing state and block information. The interface is defined in evmc_context_fn_table(evmc.h). evmc_account_exists_fn account_exists evmc_get_storage_fn get_storage evmc_set_storage_fn set_storage evmc_get_balance_fn get_balance evmc_get_code_size_fn get_code_size evmc_get_code_hash_fn get_code_hash evmc_copy_code_fn copy_code evmc_selfdestruct_fn selfdestruct evmc_call_fn call evmc_get_tx_context_fn get_tx_context evmc_get_block_hash_fn get_block_hash evmc_emit_log_fn emit_log EVM execution EVM instruction ssolidity is the execution language of the contract. solidity is compiled by solc and becomes an EVM instruction similar to assembly. The Interpreter defines a complete set of instructions. After solidity is compiled, a binary file is generated. The binary file is a collection of EVM instructions. The transaction is sent to the node in the form of binary. After the node receives it, it calls EVM to execute these instructions through SVMC. In EVM, the logic of these instructions is simulated with code. Solidity is a stack-based language. When EVM executes binary, it is also called as a stack. Arithmetic instruction example An ADD instruction. The code in EVM is implemented as follows. SP is the pointer of the stack, from the first and second positions on the top of the stack（SP[0]、SP[1]）take out the data, add and write it to the top of the result stack SP SPP[0]。 CASE(ADD) { ON_OP(); updateIOGas(); // pops two items and pushes their sum mod 2^256. m_SPP[0] = m_SP[0] + m_SP[1]; } Jump instruction example The JUMP command realizes the JUMP between binary codes. First from the top of the stack SP[0] Take out the address to be redirected, verify whether it is out of line, and put it in the program counter PC. The next instruction will start from the position pointed by the PC. CASE(JUMP) { ON_OP(); updateIOGas(); m_PC = verifyJumpDest(m_SP[0]); } Example of state read instruction SLOAD can query status data. The general process is from the top of the stackSP[0]take out the key to be accessed, take the key as a parameter, and then adjust the callback function of evmcget_storage()，To query the value of the corresponding key. Then write the read value to the top of the result stack SPP SPP[0]。 CASE(SLOAD) { m_runGas = m_rev >= EVMC_TANGERINE_WHISTLE ? 200 : 50; ON_OP(); updateIOGas(); evmc_uint256be key = toEvmC(m_SP[0]); evmc_uint256be value; m_context->fn_table->get_storage(&value, m_context, &m_message->destination, &key); m_SPP[0] = fromEvmC(value); } Example of state write instruction The SSTORE command can write data to the state of a node. The general process is from the first and second positions at the top of the stack（SP[0]、SP[1]）take out key and value, take key and value as parameters, and call the callback function of evmc set_storage() , write the status of the node. CASE(SSTORE) { ON_OP(); if (m_message->flags & EVMC_STATIC) throwDisallowedStateChange(); static_assert( VMSchedule::sstoreResetGas fn_table->set_storage(m_context, &m_message->destination, &key, &value); if (status == EVMC_STORAGE_ADDED) { // Charge additional amount for added storage item. m_runGas = VMSchedule::sstoreSetGas - VMSchedule::sstoreResetGas; updateIOGas(); } } Contract call instruction example The CALL instruction can CALL another contract based on the address. First, EVM determines that the CALL instruction is called caseCall()，caseCall() usedcaseCallSetup()Take the data from the stack, encapsulate it into msg, and call evmc's callback function as a parameter. Eth is being called backcall()after，Start a new EVM, process the call, and then execute the result of the new EVM bycall()```parameter is returned to the current EVM. The current EVM writes the result to the result stack SSP and the call ends. The logic of contract creation is similar to this logic. CASE(CALL) CASE(CALLCODE) { ON_OP(); if (m_OP == Instruction::DELEGATECALL && m_rev flags & EVMC_STATIC && m_SP[2] != 0) throwDisallowedStateChange(); m_bounce = &VM::caseCall; } BREAK void VM::caseCall() { m_bounce = &VM::interpretCases; evmc_message msg = {}; // Clear the return data buffer. This will not free the memory. m_returnData.clear(); bytesRef output; if (caseCallSetup(msg, output)) { evmc_result result; m_context->fn_table->call(&result, m_context, &msg); m_returnData.assign(result.output_data, result.output_data + result.output_size); bytesConstRef{&m_returnData}.copyTo(output); m_SPP[0] = result.status_code == EVMC_SUCCESS ? 1 : 0; m_io_gas += result.gas_left; if (result.release) result.release(&result); } else { m_SPP[0] = 0; m_io_gas += msg.gas; } ++m_PC; } Summary EVM is a state execution machine. The input is the binary instruction compiled by solidity and the state data of the node. The output is the change of the node state. Simplechain implements compatibility with various virtual machines through EVMC. "},"16_runMechanism/":{"url":"16_runMechanism/","title":"Operating mechanism","keywords":"","body":"Simplechain model description Simplechain is essentially a transaction-based state machine. In computer science, a state machine refers to something that can read a series of inputs and then convert them into a new state. According to Simplechain's state machine, we start with genesis state. There is no transaction generation status in the network. When the transaction is executed, the Genesis state will turn into the final state. At any time, this final state represents the current state of Simplechain. Simplechain has millions of transactions in the state. These transactions are \"grouped\" into a block. A block contains a series of transactions, and each block is linked to its previous block. In order to convert a state to the next state, the transaction must be valid. In order to make a transaction considered effective, it must go through a verification process, which is mining. Mining is a group of nodes (computers) that use their computing resources to create a block containing valid transactions. To add a block to the main chain, a miner must provide this \"proof\" faster than other miners \". The process of verifying each block through a \"proof\" of mathematical mechanism provided by miners is called proof of work. It is proved that miners in a new area will be rewarded with a certain value. What is the reward? Simplechain uses an internal digital token-Sipc as a reward. Every time a miner proves a new block, a new Sipc will be generated and rewarded to the miner. Whenever multiple paths are generated, a \"fork\" will appear. We usually want to avoid forking, because they will destroy the system and force people to choose which chain they believe. In order to determine which path is the most effective and prevent the generation of multiple chains, Simplechain uses a mathematical mechanism called \"GHOST protocol.。 GHOST = Greedy Heaviest Observed Subtree In short, the GHOST Protocol allows us to select a path on which the most calculations are completed. One way to determine the path is to use the block number of the nearest block (leaf block). The block number represents the total number of blocks on the current path (excluding Genesis blocks). The larger the block number is, the longer the path is, indicating that more mining computing power is consumed on this path to reach the leaf block. Using this reasoning can allow us to agree with the authoritative version of the current state. "},"17_unusual.html":{"url":"17_unusual.html","title":"Handle exceptions","keywords":"","body":"An error was reported when calling the contract Possible problems: The common problem is that the contract execution fails. When the contract execution fails, Simplechain prompts that the cause of the error is generally not very intuitive and may not be related to the error. 1.Insufficient tokens and balances in the contract account; 2.Whether the current operating account has permissions; 3.Contract execution failed. spring boot applications use web3j You can directly use the spring boot dependency package that web3j-spring-boot-starter depends on without repeatedly depending on the spring boot package. org.web3j web3j-spring-boot-starter 1.6.0 Does the spring boot application use web3J dependency to report an error The gradle I used in the demo depends on web3j, and there is no problem when the function is completed. In the formal project, the code that maven depends on web3j package is reported as the same, but no specific problem can be found. If you use maven to rely on web3j 3.5.0, an error is reported. If you use web3j 3.6.0, the same error is reported. The error message is as follows: at java.net.URLClassLoader.findClass(URLClassLoader.java:382) ~[na:1.8.0_191] at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_191] at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349) ~[na:1.8.0_191] at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_191] at org.web3j.crypto.Sign.(Sign.java:34) ~[crypto-3.5.0.jar:na] at org.web3j.crypto.ECKeyPair.create(ECKeyPair.java:68) ~[crypto-3.5.0.jar:na] at org.web3j.crypto.Credentials.create(Credentials.java:36) ~[crypto-3.5.0.jar:na] Solution: After troubleshooting, the reason is that the download of some files is incomplete when maven downloads the web3j dependency, and the ec package does not exist, Delete the downloaded web3j dependency package in the maven local repository, download the maven tool, and use the command to clear and install dependencies in the project directory. ->mvn clean ->mvn install Open Idea and refresh the project to compile and run normally. we3j reports an error when \"import ./safeERC20.sol\" is used in the file when compiling the. sol file. The import file cannot be found. The solution is to write the import contract or libary to the current file. "},"18_contract/":{"url":"18_contract/","title":"Smart contract","keywords":"","body":"Simplechain's smart contract is not a common contract in reality, but a piece of program code that exists on the blockchain and can be triggered to execute. These codes implement some predetermined rules, is an \"autonomous proxy\" that exists in the Simplechain execution environment \". Simplechain's account and contract are shown in Figure 1. The intelligent contract design of Simplechain is concise Anyone can develop smart contracts on the Simplechain Blockchain. The code of these smart contracts exists in the account of Simplechain, and the account with code is called the contract account. Correspondingly, an account controlled by a key can be called an external account. The smart contract program of Simplechain runs on the Simplechain virtual machine. The contract account cannot start and run its own smart contract. To run a smart contract, an external account needs to initiate a transaction with the contract account to start the execution of the code in it. A major difference between Simplechain and bitcoin is that Simplechain provides Turing's complete programming language (Solidity) and the corresponding operating environment (EVM). The so-called Turing completeness means that this scripting programming language can run all possible calculations, while bitcoin UTXO models and scripts can only run partial calculations. The most popular intelligent contract language in Simplechain is Solidity, which is similar to classes in object-oriented languages. The contract contains state variables for data persistence and functions that can modify state variables. When a function of another contract instance is called, an EVM function is called. This operation switches the context of the execution, so that the status variable of the previous contract cannot be accessed. "},"19_understandSolidity/":{"url":"19_understandSolidity/","title":"understand Solidity","keywords":"","body":"Solidity Source File structure The source file can contain any number of contract definitions, import instructions, and miscellaneous instructions. Version miscellaneous note To avoid being compiled by compilers that may introduce incompatible changes in the future, the source file can (and should) be annotated by so-called version annotations. We try to make such changes as small as possible. In particular, we need to introduce changes in a way that syntax must be modified synchronously when modifying semantics. Of course, this is sometimes difficult to do. Therefore, it is always a good way to read through the change log for versions with major changes at least. The versions of these versions are always 0.x.0 Or x.0.0 The form. Version miscellaneous notes are used as follows:: pragma solidity ^0.4.0; In this way, the source file does not allow compiler compilation earlier than Version 0.4.0 or higher than (including) 0.5.0 Compiler compilation of the version (the second condition is due to the use ^ Added). The consideration of this approach is that the compiler will not have major changes before version 0.5.0, so it can ensure that the source code is always compiled as expected. In the preceding example, the specific version number of the compiler is not fixed, so the compiler patch version can also be used. You can use more complex rules to specify the compiler version and the expression follows npm version semantics. Pragma 是 pragmatic information 的简称，微软 Visual C++ 文档 中译为杂注。Solidity 中沿用 C ，C++ 等中的编译指令概念，用于告知编译器 如何 编译。 ——译者注 Import other source files Grammar and semantics Although Solidity does not know what \"default export\" is, the syntax of import statements supported by Solidity is very similar to JavaScript (starting from ES6). ES6 即 ECMAScript 6.0，ES6是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布。 ——译者注 At the global level, you can use import statements in the following format： import \"filename\"; This statement imports all global symbols from \"filename\" into the current global scope (unlike ES6,Solidity is backward compatible). import * as symbolName from \"filename\"; Create a new global symbol symbolName , whose members are all from filename Global symbol in. import {symbol1 as alias, symbol2} from \"filename\"; Create a new global symbol alias And symbol2，respectively from \"filename\" reference symbol1 and symbol2 。 Another syntax does not belong to ES6, but may be simpler: import \"filename\" as symbolName; This statement is equivalent import * as symbolName from \"filename\";。 Path The filename mentioned above is always processed by path / as a directory separator, . mark the current directory .. Indicates the parent directory. When . or .. the following characters are / they can be treated as the current directory or parent directory. Only the path to the current directory . or parent directory .. at the beginning, it can be regarded as a relative path. For import \"./x\" as x statement to import files under the same directory as the current source file x 。 If used import \"x\" as x; instead, different files may be introduced (in the global include directory Medium). The final file to be imported depends on how the compiler (see below) parses the path.Generally, directory levels do not need to be strictly mapped to local file systems,It can also be mapped to resources that can be discovered through ipfs,http, or git. Use in actual compilers When running the compiler, it can specify not only how to discover the first element of the path, but also the path prefix|remapping|。 For example，github.com/ethereum/dapp-bin/library will be replayed to shoot /usr/local/dapp-bin/library ， The compiler reads the file from the remapping location. If multiple paths are remapped, the longest path is remapped first. This allows \"\" be mapped \"/usr/local/include/solidity\" to perform \"rollback and remapping. At the same time, these remaps depend on the context, allowing you to configure the packages to be imported, such as different versions of the same library. solc: For solc（command line compiler），these remaps are based on context:prefix=target parameters in the form are provided. among them，context: and =target parts are optional（the target is prefix by default）。 All remapping values are compiled regular files (including their dependencies), and this mechanism is completely backward compatible（as long as the file name does not contain = or :），Therefore, this is not a destructive modification. in content source code files in the directory or its subdirectories, all import statements prefix Import files starting with will be used target Replacement prefix To redirect. For example, if you have cloned github.com/ethereum/dapp-bin/ to local /usr/local/dapp-bin ， used int the source file: import \"github.com/ethereum/dapp-bin/library/iterable_mapping.sol\" as it_mapping; Then run the compiler: solc github.com/ethereum/dapp-bin/=/usr/local/dapp-bin/ source.sol For a more complex example, suppose you rely on some modules that use a very old version of dapp-bin. The old version of dapp-bin has been checked out /usr/local/dapp-bin_old , at this time you can use: solc module1:github.com/ethereum/dapp-bin/=/usr/local/dapp-bin/ \\ module2:github.com/ethereum/dapp-bin/=/usr/local/dapp-bin_old/ \\ source.sol In this way, module2 all imports in point to the old version, and module1 import in to obtain the new version. Note that solc only allows files from a specific directory: they must be located in a explicitly specified source file directory (or subdirectory), or in a remapped target Directory (or subdirectory). If you want to include files directly with an absolute path, just add a remapping =/ . If multiple remappings point to a valid file, the remapping with the longest common prefix is selected. Remix: Remix Provides an automatic remapping for the github source code platform, which automatically obtains files through the network: for example, you can use import \"github.com/ethereum/dapp-bin/library/iterable_mapping.sol\" as it_mapping; import a map iterator. In the future, Remix may support other source code platforms. Annotation you can use a single of comments（//）and multiple lines of comments（/*...*/） // 这是一个单行注释。 /* 这是一个 多行注释。 */ In addition, there is another annotation called natspec annotation, and its documentation has not yet been compiled. They use three backslashes（///）or a block beginning with a double star（/** ... */）writing, they should be used directly on function declarations or statements. Can be used in comments Doxygen style labels to document functions, The condition for passing the label form verification, and provide a condition that is displayed to the user when the user attempts to call a function Confirmation text. In the following example, we record the contract title, two input parameters, and two return values: pragma solidity ^0.4.0; /** @title 形状计算器。 */ contract shapeCalculator { /** @dev 求矩形表明面积与周长。 * @param w 矩形宽度。 * @param h 矩形高度。 * @return s 求得表面积。 * @return p 求得周长。 */ function rectangle(uint w, uint h) returns (uint s, uint p) { s = w * h; p = 2 * (w + h); } } Contract structure In Solidity, contracts are similar to classes in object-oriented programming languages. Each contract can contain 状态变量，函数，函数修饰器，事件，结构类型 and 枚举类型 the contract can be inherited from other contracts. State variable State variables are values permanently stored in contract storage. pragma solidity ^0.4.0; contract SimpleStorage { uint storedData; // 状态变量 // ... } Valid state variable types see type chapters, Possible options for state variable visibility see 可见性和getter函数 。 Function A function is the executable unit of the code in a contract. pragma solidity ^0.4.0; contract SimpleAuction { function bid() public payable { // 函数 // ... } } 函数调用 can occur inside or outside the contract, and the function has different degrees of visibility to other contracts（ 可见性和getter函数）。 Function modifier Function modifiers can be used to improve function semantics in a declarative manner (see contract section function ). pragma solidity ^0.4.22; contract Purchase { address public seller; modifier onlySeller() { // 修饰器 require( msg.sender == seller, \"Only seller can call this.\" ); _; } function abort() public onlySeller { // Modifier usage // ... } } Event Events are interfaces that can easily call the log function of Simplechain virtual machines. pragma solidity ^0.4.21; contract SimpleAuction { event HighestBidIncreased(address bidder, uint amount); // 事件 function bid() public payable { // ... emit HighestBidIncreased(msg.sender, msg.value); // 触发事件 } } For information on how to declare events and how to use events in dapp see contracts event。 Structure type Structure is a custom type that can Group several variables (see type section structure）。 pragma solidity ^0.4.0; contract Ballot { struct Voter { // 结构 uint weight; bool voted; address delegate; uint vote; } } Enumeration type Enumeration can be used to create a custom type consisting of a certain number of constant values（see type chapter Enumeration type）。 pragma solidity ^0.4.0; contract Purchase { enum State { Created, Locked, Inactive } // 枚举 } Type Solidity is a static type language, which means each variable (state variable and local variable) you need to specify the type of the variable at compile time (or at least you can deduce the variable type). Solidity provides several basic types that can be used to combine complex types. In addition, types can interact in expressions containing operator symbols. Value type The following types are also called value types because variables of these types are always passed by value. That is, when these variables are used as function parameters or in assignment statements, values are always copied. Boolean type bool ：the possible value is a literal constant value true and false 。 Operator: ! （logical no） && （logic and， \"and\" ） || （logic or， \"or\" ） == （equal to） != （not equal to） Operator || and && all follow the same short-counterfeiting rule. that means in the expression f(x) || g(y) middle， If f(x) Value of true ，then g(y) will not be executed even if there are some side effects. Integer int / uint ：integer variables representing different numbers of signed and unsigned digits respectively. Supported keywords uint8 to uint256 （unsigned, from 8 bits to 256 bits）and int8 to int256，8 bit is the step increment. uint and int respectively uint256 and int256 the alias. Operator: Comparison operator: ， ， == ， != ， >= ， > （return a boolean value） bit operator： & ， | ， ^ （different or）， ~ （reverse bit） Arithmetic operator:： + ， - ， unary operation - ， unary operation + ， * ， / ， % （Surplus） ， ** （Power）， （Left Shift） ， >> （Right Shift） Division is always truncated（only compiled as in EVM DIV`` Operation Code）， But if all the operands are字面常数（literals)`(Or literal constant expression), it will not be truncated. Dividing by zero or modulo zero will cause runtime exceptions. The result of the shift operation depends on the type to the left of the operator. expression x and x * 2**y is equivalent, x >> y 与 x / 2**y Is equivalent. This means that shifting a negative number will cause its symbol to disappear. .. warning:: The result generated by the right shift of the negative value of the signed integer type is different from that produced in other languages. In Solidity, the right shift and division are equivalent, so the right shift of a negative number will result in the rounded (truncated) to 0. In other languages, moving the negative number to the right is similar to Rounding (to the negative infinity). Fixed-length floating point type Solidity does not fully support the fixed-length floating point type. You can declare floating-point variables of fixed length, but you cannot assign them or assign them to other variables. fixed / ufixed：indicates signed and unsigned fixed-length floating point types of various sizes. In keywords ufixedMxN and fixedMxN Middle，M Indicates the number of digits occupied by this type,N Indicates the number of available decimal places. M Must be able to divide exactly 8, that is, 8 to 256 bits. N It can be any number from 0 to 80. ufixed and fixed fixed ufixed128x19 and fixed128x19 alias。 Operator： Comparison operator：， ， ==， !=， >=， > （return value is boolean） Arithmetic operator：+， -， unary operation -， unary operation +， *， /， % （take the remainder） .. note:: Floating point type (in many languages float And double The biggest difference between type, more precisely IEEE 754 type) and fixed-length floating point type is, In the former, the number of digits required for the integral part and the decimal part (the part after the decimal point) is flexible and variable, while the length of these two parts in the latter is strictly regulated. Generally speaking, in the floating point type, almost the whole space is used to represent numbers, but only a few bits represent the position of decimal point. Address type address：The address type stores a 20-byte value (the size of the Simplechain address). The address type also has member variables and serves as the basis for all contracts. Operator： ， ， ==， !=， >= and > Starting from version 0.5.0, the contract does not derive from the address type, but can still be explicitly converted to the address type. Address type member variable balance 和 transfer can used balance property to query the balance of an address, can also used transfer function sends | ether | (in wei) to an address: address x = 0x123; address myAddress = this; if (x.balance = 10) x.transfer(10); If x is a contract address, its code (more specifically, its fallback function, if any) and transfer Function calls are executed together (this is a feature of EVM and cannot be prevented). If gas is used up in the execution process or the execution fails for any reason, the | ether | Transaction will be called back, and the current contract will also throw an exception at the same time of termination. send send is transfer the low-level version. If execution fails, the current contract will not be terminated due to exceptions, send 会返回 false. In use send there are some risks：if the call stack depth is 1024, it will lead to sending failure (which can always be forced by the caller), and if the receiver uses up gas, it will also lead to sending failure. Therefore, in order to ensure the security of | ether | Sending, you must check send the return value of, using transfer or a better way: Use a mode in which the receiver can retrieve funds. call， callcode and delegatecall In addition, in order to interact with contracts that do not conform to | ABI |, there are contracts that can accept any type and any number of parameters call Function. These parameters are packaged into a continuous area of 32 bytes. One exception is when the first parameter is encoded into exactly 4 bytes. In this case, this parameter is not followed by subsequent parameter encoding to allow the use of function signatures. address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2; nameReg.call(\"register\", \"MyName\"); nameReg.call(bytes4(keccak256(\"fun(uint256)\")), a); call The returned Boolean value indicates that the called function has been executed（true）or an EVM exception is thrown（false）。 The real data returned cannot be accessed (for this we need to know the encoding and size in advance). Can be used .gas() | modifier | Adjust the quantity of gas provided: namReg.call.gas(1000000)(\"register\", \"MyName\"); Similarly, the value of | ether | Provided can also be controlled: nameReg.call.value(1 ether)(\"register\", \"MyName\"); Finally, these | modifier | Can be used together. The order in which each modifier appears is not important: nameReg.call.gas(1000000).value(1 ether)(\"register\", \"MyName\"); gas or value cannot be used in overloaded functions at present. One solution is to introduce a special case to gas and values and re-check whether they appear at heavy loads. Similarly, it can also be used delegatecall：The difference is that only the code of the given address is used, and other attributes (storage, balance,…) All are taken from the current contract. delegatecall the purpose is to use the library code stored in another contract. You must ensure that the storage structures in both contracts apply to delegatecall. Before the homestead version, there was only one with similar functions but limited functions callcode the function of is available, but it cannot obtain the entrusting party's msg.sender and msg.value。 These three functions call， delegatecall and callcode they are all very low-level functions and should only be regarded Last move To use, because they undermine the type security of Solidity. All contracts inherit the member variable of address, so it can be used this.balance query the balance of the current contract. Use is not encouraged callcode，it will also be removed in the future. These three functions are all low-level functions and need to be used with caution. Specifically, any unknown contract can be malicious. When you call a contract, you give control to it. It can call your contract in turn. Therefore, when the call returns, be prepared for changes in your state variables. Fixed-length byte array Keywords: bytes1， bytes2， bytes3， ...， bytes32，byte is bytes1 alias。 Operator： Comparison operator: ， ， ==， !=， >=， > （return boolean） Bit operator: &， |， ^ （bit or）， ~ （reverse by position）， （left shift）， >> （right shift） Index access: if x is bytesI type，then x[k] （Among them 0 ） return k bytes（read-only）。 This type can be shifted to any integer type as the right operand (but the returned result type is the same as the left operand type), and the right operand indicates the number of digits to be moved. A negative displacement operation will cause a runtime exception. Member variables: .length indicates the length of the byte array (read-only). Can put byte[] it is used as a byte array, but this method wastes a lot of storage space. To be exact, each element wastes 31 bytes when calling in. A better approach is to use bytes。 Variable length byte array bytes: Variable length byte array，It is not a value type. string: Variable length UTF-8 encoding string type, It is not a value type. Address literal constant（Address Literals） For example 0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF such hexadecimal literal constants that pass the address checksum test belong address type. The hexadecimal literal constant, which is 39 to 41 numbers in length and fails to pass the checksum test and generates a warning, is regarded as a normal rational literal constant. Mixed case address checksum format is defined in EIP-55medium. Literal constants of rational numbers and integers The literal constant of an integer consists of a string of numbers ranging from 0 to 9 and is expressed as decimal. For example, 69 Indicates the number 69. Solidity There is no octal in, so the pre -0 is invalid. Decimal face constant with one .，at least there will be a number on one side. For example:1.，.1，and 1.3。 Scientific symbols are also supported. Although the index must be an integer, the base number can be a decimal. For example:2e10， -2e10， 2e-10， 2.5e1。 Numeric literal constant expressions themselves support arbitrary precision unless they are converted to non-literal constant types (that is, conversion occurs when they appear in non-literal constant expressions). This means that in numerical constant expressions, calculations do not overflow and division does not truncate. For example， (2**800 + 1) - 2**800 result is a literal constant 1 （belong uint8 type），although the intermediate result of the calculation has exceeded the machine word length of |evm| . In addition, .5 * 8 result is integer 4 （Although there are non-integers involved in the calculation）. As long as the operands are integers, operators supported by any integer can be applied to literal constant expressions of numerical values. If either of the two numbers is a decimal, bit operation is not allowed. If the index is a decimal, power operation is not supported (because this may result in an irrational number). Solidity has a corresponding literal constant type for each rational number. Integer literal constant and rational number literal constant both belong to the type of numerical literal constant. In addition, all numerical literal constant expressions (expressions containing only numerical literal constants and operators) belong to the type of numerical literal constants. Therefore, the literal constant expression of the numerical value 1 + 2 And 2 + 1 The result is the same as the literal constant type of the value of rational number three. In earlier versions, the division of the literal constant of an integer was also truncated, but in current versions, the result was converted into a rational number. That 5 / 2 Not equal 2 , but equal 2.5 . A numeric literal constant expression is converted to a non-literal constant type as long as it is used in a non-literal constant expression. In the following example, although we know b The value of is an integer, 2.5 + a This part of the expression does not perform type check, so compilation cannot pass. uint128 a = 1; uint128 b = 2.5 + a + 0.5; String literal constant The literal constant of a string refers to a string caused by double quotation marks or single quotation marks（\"foo\" or 'bar'）。 Not like having an ending character in C language;\"foo\" it is equivalent to 3 bytes instead of 4. Like integer literal constants, the types of string literal constants can also be changed, but they can be converted bytes1，……，bytes32，if appropriate, it can also be converted bytes and string。 String literal constants support escape characters, such \\n，\\xNN and \\uNNNN。\\xNN represents a hexadecimal value, which is finally converted into an appropriate byte, and\\uNNNN indicates the Unicode encoded value, which is eventually converted to a sequence of UTF-8. Hexadecimal literal constant Hexadecimal literal constants use keywordshex a string that starts with single or double quotation marks (for example, hex \"001122FF\" ). the content of the string must be a hexadecimal string, and their values will be represented in binary. Hexadecimal literal constants are similar to string literal constants and have the same conversion rules. Enumeration type pragma solidity ^0.4.16; contract test { enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill } ActionChoices choice; ActionChoices constant defaultChoice = ActionChoices.GoStraight; function setGoStraight() public { choice = ActionChoices.GoStraight; } // 由于枚举类型不属于 |ABI| 的一部分，因此对于所有来自 Solidity 外部的调用， // \"getChoice\" 的签名会自动被改成 \"getChoice() returns (uint8)\"。 // 整数类型的大小已经足够存储所有枚举类型的值，随着值的个数增加， // 可以逐渐使用 `uint16` 或更大的整数类型。 function getChoice() public view returns (ActionChoices) { return choice; } function getDefaultChoice() public pure returns (uint) { return uint(defaultChoice); } } Function type A function type is a type that represents a function. You can assign a function to a variable of another function type, pass a function as a parameter, and return a function type variable in a function call. There are two types of functions:- internal (internal) Function sum external (external) Function: Internal functions can only be called within the current contract (more specifically, within the current code block, including internal library functions and inherited functions), because they cannot be executed outside the current contract context. Calling an internal function is implemented by redirecting to its entry label, just like calling a function inside the current contract. An external function consists of an address and a function signature, which can be passed or returned by calling an external function. The function type is expressed as follows: function () {internal|external} [pure|constant|view|payable] [returns ()] Contrary to the parameter type, the return type cannot be empty-if the function type does not need to return, you need to delete the entire returns Part. The function type is an internal function by default, so it does not need to be declared internal keywords. On the contrary, the function itself in the contract is public by default, and it is an internal function by default only when it is regarded as a type name. There are two ways to access the function in the current contract: one is to use its name directlyf ，other is to use this.f 。 The former applies to internal functions, while the latter applies to external functions. An exception is thrown if a function type variable is called before initialization. If in a function is delete same situation occurs after calling it. If external function types are used outside the context environment of Solidity, they are considered function Type. This type encodes the function address along with its function identifier as one bytes24 Type. Note that the public function of the current contract can be used either as an internal function or as an external function. If you want to use a function as an internal function, use f Call, if you want to use it as an external function, use this.f . In addition, the public (or external) function also has a special member variable called selector , can returnABI function selector pragma solidity ^0.4.16; contract Selector { function f() public view returns (bytes4) { return this.f.selector; } } If use an example of an internal function type: pragma solidity ^0.4.16; library ArrayUtils { // 内部函数可以在内部库函数中使用， // 因为它们会成为同一代码上下文的一部分 function map(uint[] memory self, function (uint) pure returns (uint) f) internal pure returns (uint[] memory r) { r = new uint[](self.length); for (uint i = 0; i Another example of using an external function type: pragma solidity ^0.4.11; contract Oracle { struct Request { bytes data; function(bytes memory) external callback; } Request[] requests; event NewRequest(uint); function query(bytes data, function(bytes memory) external callback) public { requests.push(Request(data, callback)); NewRequest(requests.length - 1); } function reply(uint requestID, bytes response) public { // 这里要验证 reply 来自可信的源 requests[requestID].callback(response); } } contract OracleUser { Oracle constant oracle = Oracle(0x1234567); // 已知的合约 function buySomething() { oracle.query(\"USD\", this.oracleResponse); } function oracleResponse(bytes response) public { require(msg.sender == address(oracle)); // 使用数据 } } The introduction of Lambda expressions or inline functions is planned, but is not currently supported. Reference type Compared with the value types discussed before, we need to be more cautious when dealing with complex types (that is, types that occupy more than 256 bits of space). Since the overhead of copying these type variables is considerable, we have to consider its storage location and save them in memory (Not permanent storage), Or storage Where state variables are saved. Data Location All complex types, namely Array And Structure Type, all have an additional attribute, \"data location\", indicating that the data is saved in memory Medium or storage Medium. Depending on the context, most of the time the data has a default location, but you can also add keywords after the type name. storage Or memory Modify. By default, the data location of function parameters (including returned parameters) is memory , the default data location of the local variable is storage , the data location of the state variable is forced to be storage (This is obvious). There is also a third data location, calldata , this is a read-only and not permanently stored location, used to store function parameters. The data location of external function parameters (non-return parameters) is forcibly specified calldata , effect and memory Almost. The designation of data locations is very important because they affect assignment behavior: In storage And memory Assign values between two pairs, or storage Assigning values to state variables (even from other state variables) creates an independent copy. However, when a state variable assigns a value to a local variable, it only passes a reference, and this reference always points to a state variable, so the latter changes while the former changes. On the other hand, from one memory The reference type of the storage to another memory The reference type assignment of the storage does not create a copy. pragma solidity ^0.4.0; contract C { uint[] x; // x 的数据存储位置是 storage // memoryArray 的数据存储位置是 memory function f(uint[] memoryArray) public { x = memoryArray; // 将整个数组拷贝到 storage 中，可行 var y = x; // 分配一个指针（其中 y 的数据存储位置是 storage），可行 y[7]; // 返回第 8 个元素，可行 y.length = 2; // 通过 y 修改 x，可行 delete x; // 清除数组，同时修改 y，可行 // 下面的就不可行了；需要在 storage 中创建新的未命名的临时数组， / // 但 storage 是“静态”分配的： // y = memoryArray; // 下面这一行也不可行，因为这会“重置”指针， // 但并没有可以让它指向的合适的存储位置。 // delete y; g(x); // 调用 g 函数，同时移交对 x 的引用 h(x); // 调用 h 函数，同时在 memory 中创建一个独立的临时拷贝 } function g(uint[] storage storageArray) internal {} function h(uint[] memoryArray) public {} } Summary Force the specified data location: Parameters of external functions (excluding return parameters): calldata Status variable: storage Default data location: Function parameters (including return parameters): memory All other local variables: storage Array An array can be declared with a length specified or dynamically resized. for storage element type can be arbitrary (that is, the element can also be an array type, mapping type, or structure). for memory The element type cannot be a mapping type. If it is a parameter of the public function, it can only be a ABI type. An element type is T，fixed length isk the array of can be declared T[k]，while the dynamic array is declared T[]. For example, a length of 5 and an element type uint array of the dynamic array of, should be declared uint[][5] （Note that compared with other languages, the declared position of array length is reversed). To access the second element of the third dynamic array, you should use x[2]1. bytes and string variables of type are special arrays. bytes similar byte[]，but it will be \"tightly packaged\" in calldata (Translator's note: elements are continuously stored together and will not be stored in a unit per 32 bytes). string and bytes Same, but (temporarily) access with length or index is not allowed. .. note:: If you want to access a string in bytes s，please usebytes(s).length / bytes(s)[7] = 'x';。 Note that you are accessing low-level bytes in the form of UTF-8 instead of a single character. You can identify an array public，so that Solidity can create a getter. After that, you must use the digital subscript as a parameter to access getter. Create a memory array Available new keyword creates a variable length array in memory. and storage opposite of the array is that you Can't By modifying member variables length change memory size of array pragma solidity ^0.4.16; contract C { function f(uint len) public pure { uint[] memory a = new uint[](7); bytes memory b = new bytes(len); // 这里我们有 a.length == 7 以及 b.length == len a[6] = 8; } } Array literal constant/inline array The literal constant of an array is an array in the form of writing expressions and is not immediately assigned to a variable. pragma solidity ^0.4.16; contract C { function f() public pure { g([uint(1), 2, 3]); } function g(uint[3] _data) public pure { // ... } } The literal constant of an array is a fixed-length | memory | Array type. Its basic type is determined by the common type of elements in the array. For example，[1, 2, 3] type of is uint8[3] memory，because the type of each literal constant is uint8。 Because of this, it is necessary to convert the first element in the above example uint type. At present, it should be noted that the fixed length memory An array cannot be assigned to a longer memory Array, the following is a counter example: // 这段代码并不能编译。 pragma solidity ^0.4.0; contract C { function f() public { // 这一行引发了一个类型错误，因为 unint[3] memory // 不能转换成 uint[] memory。 uint[] x = [uint(1), 3, 4]; } } Such restrictions have been planned to be removed in the future, but the current array is ABI The problem of transmission in caused some trouble. Members length: Array has length member variable indicates the length of the current array. Dynamic arrays can be in storage（not memory ）by changing member variables .length Change the array size. You cannot automatically extend the length of an array by accessing the length of the current array. Once created, memory The size of the array is fixed (but dynamic, that is, it depends on runtime parameters). push: Variable length | storage | Array and bytes Type (not string Type) all have one called push The member function of, which is used to attach new elements to the end of the array. This function returns the new array length. Multidimensional arrays are not currently available in external functions. Due to the limitation of | evm |, dynamic content cannot be returned through external function calls. For example, if you call web3.js contract C { function f() returns (uint[]) { ... } } In f Function，which returns some content，but cannot be achieved through Solidity. At present, the only alternative is to use large static arrays. pragma solidity ^0.4.16; contract ArrayContract { uint[2**20] m_aLotOfIntegers; // 注意下面的代码并不是一对动态数组， // 而是一个数组元素为一对变量的动态数组（也就是数组元素为长度为 2 的定长数组的动态数组）。 bool[2][] m_pairsOfFlags; // newPairs 存储在 memory 中 —— 函数参数默认的存储位置 function setAllFlagPairs(bool[2][] newPairs) public { // 向一个 storage 的数组赋值会替代整个数组 m_pairsOfFlags = newPairs; } function setFlagPair(uint index, bool flagA, bool flagB) public { // 访问一个不存在的数组下标会引发一个异常 m_pairsOfFlags[index][0] = flagA; m_pairsOfFlags[index][1] = flagB; } function changeFlagArraySize(uint newSize) public { // 如果 newSize 更小，那么超出的元素会被清除 m_pairsOfFlags.length = newSize; } function clear() public { // 这些代码会将数组全部清空 delete m_pairsOfFlags; delete m_aLotOfIntegers; // 这里也是实现同样的功能 m_pairsOfFlags.length = 0; } bytes m_byteData; function byteArrays(bytes data) public { // 字节的数组（语言意义中的 byte 的复数 ``bytes``）不一样，因为它们不是填充式存储的， // 但可以当作和 \"uint8[]\" 一样对待 m_byteData = data; m_byteData.length += 7; m_byteData[3] = byte(8); delete m_byteData[2]; } function addFlag(bool[2] flag) public returns (uint) { return m_pairsOfFlags.push(flag); } function createMemoryArray(uint size) public pure returns (bytes) { // 使用 `new` 创建动态 memory 数组： uint[2][] memory arrayOfPairs = new uint[2][](size); // 创建一个动态字节数组： bytes memory b = new bytes(200); for (uint i = 0; i Structure Solidity supports defining new types by constructing structures. The following is an example of how a structure is used: pragma solidity ^0.4.11; contract CrowdFunding { // 定义的新类型包含两个属性。 struct Funder { address addr; uint amount; } struct Campaign { address beneficiary; uint fundingGoal; uint numFunders; uint amount; mapping (uint => Funder) funders; } uint numCampaigns; mapping (uint => Campaign) campaigns; function newCampaign(address beneficiary, uint goal) public returns (uint campaignID) { campaignID = numCampaigns++; // campaignID 作为一个变量返回 // 创建新的结构体示例，存储在 storage 中。我们先不关注映射类型。 campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0); } function contribute(uint campaignID) public payable { Campaign storage c = campaigns[campaignID]; // 以给定的值初始化，创建一个新的临时 memory 结构体， // 并将其拷贝到 storage 中。 // 注意你也可以使用 Funder(msg.sender, msg.value) 来初始化。 c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value}); c.amount += msg.value; } function checkGoalReached(uint campaignID) public returns (bool reached) { Campaign storage c = campaigns[campaignID]; if (c.amount The above contract is just a simplified version of crowdfunding contract, but it is enough to let us understand the basic concept of structure. Structure types can be used as elements in mappings and arrays, and can also contain mappings and arrays as member variables. Although the structure itself can be a mapping value type member, it cannot contain itself. This restriction is necessary because the size of the structure must be limited. Note how a structure is assigned to a local variable when a structure is used in a function (the default storage location is storage ). In this process, the structure is not copied, but a reference is saved, so the assignment of local variable members is actually written into the state. Of course, you can also directly access the members of the structure without assigning it to a local variable, like this, campaigns[campaignID].amount = 0。 Mapping The mapping type is declared in the form mapping(_KeyType => _ValueType)。 Of which _KeyType it can be almost all types except mappings, variable-length arrays, contracts, enumerations, and structures. _ValueType it can be any type including the mapping type. Mapping can be treated 哈希表，they create each possible key in the actual initialization process and map it to a value whose byte form is all zero: a type 默认值。However, the following is where the mapping differs from the hash table: In the mapping, it does not actually store the key, but stores its keccak256 Hash value, so that it is easy to query the actual value. Because of this, mapping has no length, nor the concept of a set of keys or values. Only state variables (or references to storage variables in internal functions) can use mapping types. You can declare the mapping public，and then let Solidity create a getter。_KeyType Will become a required parameter for getter, and getter will return _ValueType。_ValueType It can also be a mapping. When getter is used, each _KeyType parameters. pragma solidity ^0.4.0; contract MappingExample { mapping(address => uint) public balances; function update(uint newBalance) public { balances[msg.sender] = newBalance; } } contract MappingUser { function f() public returns (uint) { MappingExample m = new MappingExample(); m.update(100); return m.balances(this); } } Mapping does not support iteration, but such a data structure can be implemented on top of it. For example, see: Iterable mapping Operators involving LValues If a is an LValue (that is, a variable or other things that can be assigned values), and the following operators can be used in shorthand: a += e equivalent a = a + e. Other operators -=， *=， /=， %=， |=， &= and ^= they are all defined in this way. a++ and a-- respectively equivalent a += 1 and a -= 1，But the value of the expression itself is equal a value before the calculation. On the contrary, --a and ++a although eventuall a result of is the same as that of the previous expression, but the return value of the expression is the value after calculation. Delete delete a result of is a value of the type during initialization is assigned a. That is for integer variables, equivalent a = 0， However, delete is also applicable to Arrays. For dynamic arrays, the length of the array is set to 0, while for static arrays, all elements in the array are reset. If the object is a structure, all properties in the structure are reset. delete It is invalid for the entire mapping because the mapping key can be arbitrary and usually unknown. Therefore, when you delete a structure, the result will reset all non-mapping attributes. This process is recursive unless they are mapped. However, individual keys and their mapped values can be deleted. Understanddelete a effect is like giving a assignment is very important, in other words, this is equivalent to in a new object is stored in. pragma solidity ^0.4.0; contract DeleteExample { uint data; uint[] dataArray; function f() public { uint x = data; delete x; // 将 x 设为 0，并不影响数据 delete data; // 将 data 设为 0，并不影响 x，因为它仍然有个副本 uint[] storage y = dataArray; delete dataArray; // 将 dataArray.length 设为 0，但由于 uint[] 是一个复杂的对象，y 也将受到影响， // 因为它是一个存储位置是 storage 的对象的别名。 // 另一方面：\"delete y\" 是非法的，引用了 storage 对象的局部变量只能由已有的 storage 对象赋值。 } } Conversion between Basic types Implicit conversion If an operator is used between two different types of variables, the compiler will implicitly convert one type to another (so is the assignment between different types). Generally speaking, as long as the conversion between value types is semantic and there is no information loss during the conversion process, implicit conversion is basically achievable: uint8can be converted uint16，int128 convert int256，but int8 cannot convert uint256（because uint256 Some values cannot be covered, for example,-1）. furthermore, an unsigned integer can be converted to a byte type of the same size or larger as it, but vice versa. Any can be converted uint160 type of can be converted address type. Explicit conversion In some cases, if the compiler does not support implicit conversion, but you know what you want to do, explicit conversion can be considered. Note that this may have some unexpected consequences, so be sure to test and make sure the results are what you want! the following example is int8 Convert a negative number of the type uint : int8 y = -3; uint x = uint(y); At the end of this code，x value of will be 0xfffff..fd （64 hexadecimal characters），because this is the 256-bit complement form of -3. If a type is explicitly converted to a smaller type, the corresponding high order will be discarded: uint32 a = 0x12345678; uint16 b = uint16(a); // 此时 b 的值是 0x5678 Type inference For convenience, it is not necessary to specify the type of a variable precisely every time. The compiler automatically infers the type of the variable based on the type of the first expression that assigns the variable: uint24 x = 0x123; var y = x; Here y The type of will be uint24 . Cannot be used for function parameters or return parameters var . The type can only be inferred from the first assignment, so the loop in the following code is infinite because i The type of IS uint8 , and the maximum value ratio of this type of variable 2000 Small.for (var i = 0; i Unit and global variables sipc unit The conversion between sipc units is to add after the number wei、 finney、 szabo or ether to implement, if there is no unit behind, the default is Wei. For example 2 ether == 2000 finney logical judgment value of IS true。 Time Unit Seconds is the default time unit, between time units, followed by numbers seconds、 minutes、 hours、 days、 weeks and years Can be converted, the basic conversion relationship is as follows: 1 == 1 seconds 1 minutes == 60 seconds 1 hours == 60 minutes 1 days == 24 hours 1 weeks == 7 days 1 years == 365 days It is not 365 days a year and not 24 hours a day due to leap seconds leap seconds，so if you want to use these units to calculate the date and time, please pay attention to this problem. Because leap seconds cannot be predicted, an external prediction machine (oracle, an out-of-chain data service, noted by the translator) is required to correct the time of a certain date code base. years Suffix is no longer recommended because it will no longer be supported from version 0.5.0. These suffixes cannot be used directly behind variables. If you want to convert the input variable to time in a unit of time (for example, days), you can do this as follows: function f(uint start, uint daysAfter) public { if (now >= start + daysAfter * 1 days) { // ... } } Special variables and functions Some special variables and functions already exist (by default) in the global namespace, which are mainly used to provide information about the block chain or some common tool functions. .. index:: abi, block, coinbase, difficulty, encode, number, block;number, timestamp, block;timestamp, msg, data, gas, sender, value, now, gas price, origin Block and transaction attributes block.blockhash(uint blockNumber) returns (bytes32)：The block hash of the specified block-can only be used for the latest 256 blocks, excluding the current block. blocks are not recommended since version 0.4.22 blockhash(uint blockNumber) replace block.coinbase (address): dig out the miner address of the current block block.difficulty (uint): current block difficulty block.gaslimit (uint): current block gas limit block.number (uint): current block number block.timestamp (uint): the timestamp in seconds of the current block starting from the unix azone. gasleft() returns (uint256)：the remaining gas msg.data (bytes): complete calldata msg.gas (uint): residual gas-is not recommended since version 0.4.21, gesleft() replace msg.sender (address): Message sender (current call) msg.sig (bytes4): cthe first 4 bytes of calldata (that is, the function identifier) msg.value (uint): The number of wei sent with the message now (uint): current block timestamp（block.timestamp） tx.gasprice (uint): The gas price of the transaction tx.origin (address): transaction initiator (full call chain) For each External function call, including msg.sender and msg.value all included msg The value of the member changes. This includes calls to library functions. Do not rely on block.timestamp、 now and blockhash generate random numbers unless you know what you are doing. The timestamp and block Hash may be affected by miners to some extent. For example, malicious miners in the mining community can use a given hash to run the payout function of casino contracts, and if they do not receive money, they can also try again with a different hash. The timestamp of the current block must be strictly greater than that of the last block. However, the only thing that can be ensured here is the value between the timestamps of the two consecutive blocks on the authoritative chain. Based on the scalability factor, the block hash is not valid for all blocks. You can only access the hashes of the last 256 blocks, and the remaining hashes are zero. ABI coding function abi.encode(...) returns (bytes)：ABIencode the given parameters abi.encodePacked(...) returns (bytes)：execute the given parameter紧打包编码 abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)：ABI encode the given parameter and return the 4-byte data starting with the given function selector. abi.encodeWithSignature(string signature, ...) returns (bytes):equivalent abi.encodeWithSelector(bytes4(keccak256(signature), ...) These encoding functions can be used to construct function call data without actually calling. In addition, keccak256(abi.encodePacked(a, b)) is a more accurate method to calculate what is not recommended in future versionskeccak256(a, b)。 For more details, see ABI and 紧打包编码。 Error handling assert(bool condition): If the conditions are not met, the current transaction is ineffective-used to check for internal errors. require(bool condition): Revoke state changes if conditions are not met-used to check for errors caused by input or external components. require(bool condition, string message): Revoke state changes if conditions are not met-used to check for errors caused by input or external components, an error message can be provided at the same time. revert(): Terminate the operation and cancel the status change. revert(string reason): Terminating the operation and canceling state changes can provide an explanatory string at the same time. Mathematical and cryptographic functions addmod(uint x, uint y, uint k) returns (uint):calculation (x + y) % k，addition will be executed at any precision, and even if the result of addition exceeds 2**256 it will not be intercepted. Starting from the compiler version 0.5.0 k != 0 verify（assert）。 mulmod(uint x, uint y, uint k) returns (uint):calculation (x * y) % k，multiplication is executed at any precision, and even if the result of multiplication exceeds 2**256 it will not be intercepted. Starting from the compiler version 0.5.0 k != 0 verify（assert）。 keccak256(...) returns (bytes32): calculation :ref:(tightly packed) arguments Ethereum-SHA-3 （Keccak-256）hash。 sha256(...) returns (bytes32):calculation :ref:(tightly packed) arguments SHA-256 hash。 sha3(...) returns (bytes32):equivalent to keccak256。 ripemd160(...) returns (bytes20):calculation :ref:(tightly packed) arguments RIPEMD-160 hash。 ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address) Use the elliptic curve signature to restore the address related to the public key. An error returns a zero value. example usage Above tightly packed does not perform parameter values padding processing (that is, the bytecode of all parameter values is stored continuously, translator's note), which means that the following calls are equivalent: keccak256(\"ab\", \"c\") keccak256(\"abc\") keccak256(0x616263) keccak256(6382179) keccak256(97, 98, 99) If padding is required, you can use explicit type conversion: keccak256(\"\\x00\\x12\") and keccak256(uint16(0x12)) it's the same. Note that constant values are packaged using the minimum number of bytes required to store them. For example：keccak256(0) == keccak256(uint8(0))，keccak256(0x12345678) == keccak256(uint32(0x12345678))。 On a private chain, you are likely to encounter sha256、ripemd160 or ecrecover caused by Out-of-Gas. The reason is that these cryptographic functions exist in the form of \"precompiled contracts\" in Simplechain virtual machines, and it does not really exist until the first time you receive the message (although the contract code is a hard code already existing in EVM). Therefore, messages sent to non-existent contracts are very expensive, so actual execution will lead to Out-of-Gas errors. Before you actually use your contract, send a little Sipc to each contract, such as 1 Wei. This is not a problem on the official network or test network. Address-related .balance (uint256):in Wei :ref:address balance .transfer(uint256 amount):to :ref:address if the number of Wei sent is the amount, an exception is thrown when the error occurs. The miner fee for sending 2300 gas cannot be adjusted. .send(uint256 amount) returns (bool):to :ref:address the number of Wei sent is amount. If the number fails, the system returns false，miner's fee for sending 2300 gas cannot be adjusted. .call(...) returns (bool):issue low-level functions CALL，if it fails, return false，send all available gas, adjustable. .callcode(...) returns (bool)：issue low-level functions CALLCODE，if it fails, return false , send all available gas, adjustable. .delegatecall(...) returns (bool):issue low-level functions DELEGATECALL，if it fails, return false，send all available gas,adjustable. There are many dangers when using send: if the call stack depth has reached 1024 (which can always be forcibly specified by the caller), the transfer will fail; And if the receiver uses up the gas, the transfer will also fail. In order to ensure the security of Ethernet currency transfer, always check send The return value of, using transfer Or the following is a better way: use this mode of receiving money back. If you need to access the variables in the storage when you use the low-level function delegatecall to initiate a call, the variables in the storage of the two contracts must be defined in the same order, so that the called contract code can correctly access the contract's storage variables through the variable name. Of course, this does not refer to the situation like the stored variable pointer passed when an advanced library function is called. Use is not encouraged callcode , and it will be removed in the future. Contract-related this (current contract's type):current contract, which can be explicitly converted to address。 selfdestruct(address recipient):destroy the contract and send the balance to the specified address。 suicide(address recipient):equivalent to selfdestruct, but not recommended. In addition, all functions in the current contract can be called directly, including the current function. Expression and control structure Input and output parameters Like Javascript, functions may require parameters as input; Unlike Javascript and C, they may return any number of parameters as output. Input parameters Input parameters are declared in the same way as variables. However, one exception is that unused parameters can omit parameter names. For example, if we want the contract to accept external calls to functions with two integer parameters, we will write as follows pragma solidity ^0.4.16; contract Simple { function taker(uint _a, uint _b) public pure { // 用 _a 和 _b 实现相关功能. } } Output parameters The declaration method of the output parameter is in the keyword returns After that, the declaration method is the same as that of the input parameters. For example, if we need to return two results: the sum and product of two given integers, we should write pragma solidity ^0.4.16; contract Simple { function arithmetics(uint _a, uint _b) public pure returns (uint o_sum, uint o_product) { o_sum = _a + _b; o_product = _a * _b; } } The output parameter name can be omitted. The output value can also be used return Statement specifies. return Statement can also return multiple values, The returned output parameters are initialized to 0; If they are not explicitly assigned, they are always 0. Input and output parameters can be used as expressions in function bodies. Therefore, they can also be assigned to the left of the equal sign. Control Structure Most control structures in JavaScript are available in Solidity, switch And goto . Therefore, there are if，else，while，do，for，break，continue，return，? : these keywords express the same semantics as in C or JavaScript. Brackets used to represent conditions No. If it is omitted, the braces on both sides of the single statement body can be omitted. Note that unlike C and JavaScript, non-Boolean values in Solidity cannot be converted to Boolean types, so if (1) { ... } write in Solidity in Invalid . Returns multiple values When a function has multiple output parameters, return (v0, v1, ...,vn) you can return multiple values. However, the number of elements must be the same as the number of output parameters. Function call Internal function call The functions in the current contract can be called directly (\"from inside\") or recursively, just like the ridiculous example below. pragma solidity ^0.4.16; contract C { function g(uint a) public pure returns (uint ret) { return f(); } function f() internal pure returns (uint ret) { return g(7) + f(); } } These function calls are interpreted as simple redirection in EVM. The effect of this is that the current memory will not be cleared, that is, passing memory references between functions through internal calls is very effective. External function call Expression this.g(8); and c.g(2); （among them c is a contract instance）is also a valid function call, but in this case, the function will be \"called externally\" through a message call, rather than directly jump. Note that this function cannot be called in the constructor because the real contract instance has not been created yet. If you want to call functions of other contracts, you need to call them externally. For an external call, all function parameters need to be copied to memory. When calling functions of other contracts, the number of Wei and gas sent along with the function call can be determined by specific options respectively .value() And .gas() Specify: pragma solidity ^0.4.0; contract InfoFeed { function info() public payable returns (uint ret) { return 42; } } contract Consumer { InfoFeed feed; function setFeed(address addr) public { feed = InfoFeed(addr); } function callFeed() public { feed.info.value(10).gas(800)(); } } payable modifiers should be used for Modifiers info，otherwise，.value() options will not be available. Note, expression InfoFeed(addr) an explicit type conversion was performed, indicating that \"we know that the contract type for a given address is InfoFeed “and this will not execute the constructor. Explicit type conversion requires caution. Never execute a function call on a contract that you do not know the type. We can also use it directly function setFeed(InfoFeed _feed) { feed = _feed; } 。 pay attention to a fact，feed.info.value(10).gas(800) only (partially) the number of Wei values and gas values sent together with the function call is set, and only the final parentheses execute the real call. if the contract where the function is called does not exist (that is, the account does not contain code) or the called contract itself throws an exception or gas runs out, the function call throws an exception. Any interaction with other contracts will impose potential dangers, especially when the contract code cannot be known in advance. The current contract transfers control to the invoked contract, and the invoked contract may do anything. Even if the called contract is inherited from a known parent contract, the inherited contract only needs to have a correct interface. The implementation of the called contract can be completely arbitrary, thus bringing danger. In addition, be careful in case it calls other contracts in your system again, or even returns your call contract before the first call returns. This means that the called contract can change the state variables of the called contract through its own functions.. A suggested function writing method is, for example, calling external functions after various changes have been made to the state variables in your contract, so that your contract will not be easily abused reentrancy (reentrancy) affected Named calls and anonymous function parameters If they are included in {} Function call parameters can also be given by name in any order, As shown in the following example. The parameter list must match the parameter list in the function declaration by name, but can be arranged in any order. pragma solidity ^0.4.0; contract C { function f(uint key, uint value) public { // ... } function g() public { // 具名参数 f({value: 2, key: 3}); } } Omit the function parameter name Names of unused parameters (especially returned parameters) can be omitted. These parameters still exist in the stack, but they cannot be accessed. pragma solidity ^0.4.16; contract C { // 省略参数名称 function func(uint k, uint) public pure returns(uint) { return k; } } 通Pass new Create a contract Use keywords new You can create a new contract. The complete code of the contract to be created must be known in advance, so recursive dependency creation is impossible. pragma solidity ^0.4.0; contract D { uint x; function D(uint a) public payable { x = a; } } contract C { D d = new D(4); // 将作为合约 C 构造函数的一部分执行 function createD(uint arg) public { D newD = new D(arg); } function createAndEndowD(uint arg, uint amount) public payable { //随合约的创建发送 ether D newD = (new D).value(amount)(arg); } } 如As shown in the example, use .value（） Option creation D The Ether can be forwarded to the instance, but it is impossible to limit the amount of gas. If the creation fails (possibly because of Stack Overflow, or insufficient balance or other problems), an exception is thrown. Expression Calculation order The order of expression calculation is not specific (more precisely, the order of calculation between byte points of a node in the expression tree is not specific, but their settlement will certainly be before the node's own settlement). This rule can only ensure that the statements are executed in sequence and the short circuit of Boolean expressions is executed. For more information。 Assignment Deconstruct assignment and return multiple values Solidity internally allows tuple class，which is a list of objects with a fixed number of elements at compile time. The elements in the list can be different types of objects. These tuples can be used to return multiple values at the same time, or they can be used to simultaneously give multiple newly declared variables or existing variables (or common LValues): pragma solidity >0.4.23 Until version 0.4.24, it is possible to assign values to tuples with fewer elements, whether on the left or on the right (for example, several elements are left at the end). Now, this is not recommended. Both sides of the assignment operation should have the same number of constituent elements. Complexity of arrays and structures Assignment semantics is somewhat complicated for non-value types such as arrays and structures. Is a state variable Assignment A standalone copy is often created. On the other hand, the assignment of local variables only creates an independent copy for the basic type (that is, the static type within 32 bytes). If a structure or array (including bytes And string ) is assigned from the state variable to the local variable, the local variable will retain the reference to the original state variable. The second assignment to a local variable does not modify the state variable, but only changes the reference. If a member or element is assigned to a local variable Change State variables. Scope and declaration A variable is declared with a default initial value, whose initial value bytes indicate all zero. The default value of any type variable is the typical zero state of its corresponding type \". For example, bool default value of the type is false . uint or int default value of the type is 0. For static size arrays and bytes1 to bytes32 ，each individual element will be initialized to the default value corresponding to its type. Finally, for an array of dynamic size. bytes and string type，default default value is an empty array or string. Scope rules in Solidity follow C99 (like many other languages): variables will be visible after they are declared until a pair { } The end of the block. As an exception, the visibility of variables initialized in the for loop statement is maintained only until the end of the for loop. Variables defined outside code blocks, such as functions, contracts, and custom types, do not affect their scope properties. This means that you can use state variables before actually declaring statements and call functions recursively. Based on the above rules, compilation warnings will not appear in the following example, because the two variables have the same name but are in different scopes. pragma solidity >0.4.24; contract C { function minimalScoping() pure public { { uint same2 = 0; } { uint same2 = 0; } } } As a special case of a C99 scope rule, note that in the following example, for the first time x assignment of changes the variable values declared in the previous layer. If the variables declared outside are \"shadowed\" (that is, replaced by a variable with the same name in the internal scope), you will receive a warning. pragma solidity >0.4.24; contract C { function f() pure public returns (uint) { uint x = 1; { x = 2; // 这个赋值会影响在外层声明的变量 uint x; } return x; // x has value 2 } } Earlier than Solidity 0.5.0, Javascript rules were used for scope rules. That is, a variable can be declared anywhere in the function and can be visible throughout the function. This rule will be broken from version 0.5.0. Starting with version 0.5.0, the code segment in the following example will cause compilation errors. // 这将无法编译通过 pragma solidity >0.4.24; contract C { function f() pure public returns (uint) { x = 2; uint x; return x; } } Error handling：Assert, Require, Revert and Exceptions Solidity uses status recovery exceptions to handle errors. This exception cancels all changes made to the status of the current call and all its sub-calls and marks the caller with an error. Convenience function assert and require can be used to check conditions and throw exceptions when conditions are not met. assert functions can only be used to test internal errors and check non-variables. require function is used to confirm condition validity, such as input variable, or contract status variable meets the condition, or to verify the value returned by external contract call. If used properly, the analysis tool can evaluate your contract and mark those that will assert Failed conditions and function calls. Normal code does not cause an assert statement to fail. If this happens, a bug that you need to fix appears. There are two other ways to trigger an exception: revert functions can be used to mark errors and restore the current call. revert It is possible that the call contains detailed information about the error, and this message is returned to the caller. Keywords that are not recommended throw can also be used to replace revert() （but unable to return an error message.）. Starting from version 0.4.13, throw this keyword has been abandoned and will be gradually eliminated in the future. When a sub-call exception occurs, they automatically \"bubble\" (that is, throw an exception again). The exception to this rule is send and low-level functions call ， delegatecall and callcode -- If these functions are abnormal, false is returned instead of bubbling \". As part of the EVM design, if the called contract account does not exist, the low-level function call , delegatecall And callcode success is returned. Therefore, if you need to use low-level functions, you must check whether the called contract exists before calling. Exception capture has not been implemented In the following example, you can see how to use it easily require Check input conditions and how to use them assert Check for internal errors. Note that you can give require Provides a message string, and assert No. pragma solidity ^0.4.22; contract Sharer { function sendHalf(address addr) public payable returns (uint balance) { require(msg.value % 2 == 0, \"Even value required.\"); uint balanceBeforeTransfer = this.balance; addr.transfer(msg.value / 2); //由于转移函数在失败时抛出异常并且不能在这里回调，因此我们应该没有办法仍然有一半的钱。 assert(this.balance == balanceBeforeTransfer - msg.value / 2); return this.balance; } } One of the following situations will be generated assert Type exception: If the index of the array you access is too large or negative（for example x[i] of which i >= x.length or i ）。 If you access a fixed length bytesN index of is too large or negative. If you use zero as a divisor for division or modulo（for example 5 / 0 or 23 % 0 ）。 If you shift negative digits. If you convert a too large or negative value to an enumeration type. If you call a zero-initialization variable of the internal function type. If you call assert final settlement of the parameter (expression) is false. One of the following situations will be generated require type exception: call throw 。 If you call require final settlement of the parameter (expression) is false 。 If you call a function through a message, but the function does not end correctly (it runs out of gas, does not match the function, or throws an exception itself), the above function does not include low-level operations. call ， send ， delegatecall or callcode . A low-level operation does not throw an exception but returns false To indicate failure. If you use new Keyword creates a contract, but the contract was not created correctly (see the definition of \"not completed correctly\" in the above article). If you execute an external function call on a contract that does not contain code. If your contract passes one payable Public functions of modifiers (including constructors and fallback functions) receive Ether. If your contract receives Ether through the public getter function. If .transfer() Failed. Internally, Solidity for a require abnormal execution rollback operation (instruction 0xfd ) and execute an invalid operation (instruction 0xfe ) to trigger assert Abnormal formula. In both cases, EVM will roll back all changes made to the state. The reason for the rollback is that it cannot continue to be safely executed because the expected effect has not been achieved. Because we want to retain the atomicity of the transaction, the safest way is to roll back all changes and make the entire transaction (or at least called) ineffective. Please note, assert The type exception consumes all available call gas, and from the Metropolis version require The abnormality of the formula will not consume any gas. The following example shows how to use error strings in Invocation and require: pragma solidity ^0.4.22; contract VendingMachine { function buy(uint amount) payable { if (amount > msg.value / 2 ether) revert(\"Not enough Ether provided.\"); // 下边是等价的方法来做同样的检查： require( amount The string provided here should go through:ABI 编码 later, because it is actually called Error(string) function. In the above example,revert(\"Not enough Ether provided.\"); following hexadecimal error return value is generated: 0x08c379a0 // Error(string) function selector 0x0000000000000000000000000000000000000000000000000000000000000020 // data offset（32） 0x000000000000000000000000000000000000000000000000000000000000001a // string length（26） 0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // string data（ASCII encoding of \"Not enough Ether provided.\", 26 bytes） Contract Solidity Contracts are similar to classes in object-oriented languages. The contract contains state variables for data persistence and functions that can modify state variables. When a function of another contract instance is called, an EVM function is called. This operation switches the context of the execution, so that the status variable of the previous contract cannot be accessed. Create a contract You can create contracts \"from outside\" through Simplechain transactions or from inside Solidity contracts. Some integrated development environments, such Remix, through the use of some user interface elements to make the creation process more smooth. You 'd better use JavaScript API to create a contract by programming on Simplechain web3.j. Now, we already have one called web3.eth.Contract method can make it easier to create a contract. When a contract is created, the constructor (a function with the same name as the contract) is executed once. The constructor is optional. Only one constructor is allowed, which means overloading is not supported. Internally, the constructor parameters are passed after the contract code ABI code pass, but if you useweb3.jsthere is no need to care about this problem. If a contract wants to create another contract, the creator must know the source code (and binary code) of the contract to be created. This means that it is impossible to create dependencies cyclically. pragma solidity ^0.4.16; contract OwnedToken { // TokenCreator 是如下定义的合约类型. // 不创建新合约的话，也可以引用它。 TokenCreator creator; address owner; bytes32 name; // 这是注册 creator 和设置名称的构造函数。 function OwnedToken(bytes32 _name) public { // 状态变量通过其名称访问，而不是通过例如 this.owner 的方式访问。 // 这也适用于函数，特别是在构造函数中，你只能像这样（“内部地”）调用它们， // 因为合约本身还不存在。 owner = msg.sender; // 从 `address` 到 `TokenCreator` ，是做显式的类型转换 // 并且假定调用合约的类型是 TokenCreator，没有真正的方法来检查这一点。 creator = TokenCreator(msg.sender); name = _name; } function changeName(bytes32 newName) public { // 只有 creator （即创建当前合约的合约）能够更改名称 —— 因为合约是隐式转换为地址的， // 所以这里的比较是可行的。 if (msg.sender == address(creator)) name = newName; } function transfer(address newOwner) public { // 只有当前所有者才能发送 token。 if (msg.sender != owner) return; // 我们也想询问 creator 是否可以发送。 // 请注意，这里调用了一个下面定义的合约中的函数。 // 如果调用失败（比如，由于 gas 不足），会立即停止执行。 if (creator.isTokenTransferOK(owner, newOwner)) owner = newOwner; } } contract TokenCreator { function createToken(bytes32 name) public returns (OwnedToken tokenAddress) { // 创建一个新的 Token 合约并且返回它的地址。 // 从 JavaScript 方面来说，返回类型是简单的 `address` 类型，因为 // 这是在 ABI 中可用的最接近的类型。 return new OwnedToken(name); } function changeName(OwnedToken tokenAddress, bytes32 name) public { // 同样，`tokenAddress` 的外部类型也是 `address` 。 tokenAddress.changeName(name); } function isTokenTransferOK(address currentOwner, address newOwner) public view returns (bool ok) { // 检查一些任意的情况。 address tokenAddress = msg.sender; return (keccak256(newOwner) & 0xff) == (bytes20(tokenAddress) & 0xff); } } Visibility and getter functions Because Solidity has two kinds of function calls (internal calls do not generate actual EVM calls or \"message calls\", while external calls generate an EVM call), functions and state variables have four visibility types. Function can be specified external ，public ，internal or private，by default , function type is public。 For state variables, cannot be set external ，default is internal 。 external ：As part of the contract interface, the external function means that we can call it from other contracts and transactions. An external function f cannot be called from inside (that is f It doesn't work, this.f() Yes). When a large amount of data is received, external functions are sometimes more efficient. public ：The public function is part of the contract interface and can be called internally or through messages. For common state variables, a getter function is automatically generated (see below). internal ：these functions and state variables can only be internal access (I .e. access from inside the current contract or from contracts derived from it), and are not used this Call. private ：private functions and state variables are only used in contracts that currently define them and cannot be used by derived contracts. All content in the contract is visible to external observers. Set some private The type can only prevent other contracts from accessing and modifying this information, but it is still visible for the whole world outside the blockchain. The definition position of the visibility identifier. For a state variable, it is after the type. For a function, it is between the parameter list and the returned keyword. pragma solidity ^0.4.16; contract C { function f(uint a) private pure returns (uint b) { return a + 1; } function setData(uint a) internal { data = a; } uint public data; } In the following example, D Can be called c.getData（） to obtain status storage data But cannot call f . Contract E Inherited from C , so it can be called compute . // 下面代码编译错误 pragma solidity ^0.4.0; contract C { uint private data; function f(uint a) private returns(uint b) { return a + 1; } function setData(uint a) public { data = a; } function getData() public returns(uint) { return data; } function compute(uint a, uint b) internal returns (uint) { return a+b; } } contract D { function readData() public { C c = new C(); uint local = c.f(7); // 错误：成员 `f` 不可见 c.setData(3); local = c.getData(); local = c.compute(3, 5); // 错误：成员 `compute` 不可见 } } contract E is C { function g() public { C c = new C(); uint val = compute(3, 5); // 访问内部成员（从继承合约访问父合约成员） } } Getter function The compiler automatically for all Public State variables create getter functions. For the contract given below, the compiler generates a contract named data The function, This function does not receive any parameters and returns a uint , that is, the state variable data The value. You can complete the initialization of the state variable at the time of declaration. pragma solidity ^0.4.0; contract C { uint public data = 42; } contract Caller { C c = new C(); function f() public { uint local = c.data(); } } The getter function has external visibility. If getter is accessed internally (that is, none this. ), it is considered a state variable. If it is externally accessed (that is, use this. ), it is considered as a function. pragma solidity ^0.4.0; contract C { uint public data; function x() public { data = 3; // 内部访问 uint val = this.data(); // 外部访问 } } The next example is slightly more complicated: pragma solidity ^0.4.0; contract Complex { struct Data { uint a; bytes3 b; mapping (uint => uint) map; } mapping (uint => mapping(bool => Data[])) public data; } This generates a function in the following form: function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) { a = data[arg1][arg2][arg3].a; b = data[arg1][arg2][arg3].b; } Note that because there is no good method to provide the keys for mapping, the mapping in the structure is omitted. Function |modifier| Use | modifier | To easily change the behavior of the function. For example, they can automatically check a condition before executing a function. | modifier | Is an inheritable property of the contract, And may be overwritten by derived contracts. pragma solidity ^0.4.11; contract owned { function owned() public { owner = msg.sender; } address owner; // 这个合约只定义一个修饰器，但并未使用： 它将会在派生合约中用到。 // 修饰器所修饰的函数体会被插入到特殊符号 _; 的位置。 // 这意味着如果是 owner 调用这个函数，则函数会被执行，否则会抛出异常。 modifier onlyOwner { require(msg.sender == owner); _; } } contract mortal is owned { // 这个合约从 `owned` 继承了 `onlyOwner` 修饰符，并将其应用于 `close` 函数， // 只有在合约里保存的 owner 调用 `close` 函数，才会生效。 function close() public onlyOwner { selfdestruct(owner); } } contract priced { // 修改器可以接收参数： modifier costs(uint price) { if (msg.value >= price) { _; } } } contract Register is priced, owned { mapping (address => bool) registeredAddresses; uint price; function Register(uint initialPrice) public { price = initialPrice; } // 在这里也使用关键字 `payable` 非常重要，否则函数会自动拒绝所有发送给它的以太币。 function register() public payable costs(price) { registeredAddresses[msg.sender] = true; } function changePrice(uint _price) public onlyOwner { price = _price; } } contract Mutex { bool locked; modifier noReentrancy() { require(!locked); locked = true; _; locked = false; } // 这个函数受互斥量保护，这意味着 `msg.sender.call` 中的重入调用不能再次调用 `f`。 // `return 7` 语句指定返回值为 7，但修改器中的语句 `locked = false` 仍会执行。 function f() public noReentrancy returns (uint) { require(msg.sender.call()); return 7; } } If the same function has multiple modifier , they are separated by spaces, modifier Checks the execution in sequence. In earlier versions of Solidity, there were functions of | modifier |, return behavior of the statement is different. modifier or the explicit return statement in the function body only jumps out of the current modifier and fucntion bodies. returned variable is assigned a value, but the entire execution logic continues after the \"_\" defined in the previous | modifier |. modifierparameter of can be any expression, in this context, all symbols visible in the function，in modifier all visible. in modifier symbols introduced in are invisible in the function (may be overloaded). Constant state variable Status variables can be declared constant . In this case, only expressions that determine values at compile time can be used to assign values to them. Any blockchain data (such now , this.balance Or block.number ) or execution data ( msg.gas ) or calls to external contracts to assign values to them are not allowed. There is a boundary effect on memory allocation ( side-effect ) expressions are allowed, but expressions that produce boundary effects on other memory objects are not allowed. built-in function keccak256 , sha256 , ripemd160 , ecrecover , addmod and mulmod is allowed (even if they do invoke external contracts). The reason why memory allocators with boundary effects are allowed is that this will allow the construction of complex objects, such as lookup-table. This feature is not fully available. The compiler does not reserve storage for these variables, and each time they appear, they are replaced with the corresponding constant expression (which may be calculated by the optimizer as an actual value). Not all types of state variables support constant modification. Currently, only value types and strings are supported. pragma solidity ^0.4.0; contract C { uint constant x = 32**22 + 8; string constant text = \"abc\"; bytes32 constant myHash = keccak256(\"abc\"); } Function View function You can declare a function view type, in this case, make sure that the state is not modified. The following statement is considered to modify the state: Modify the status variable. generate an event。 create smart contract。 use selfdestruct。 send Sipc coins by calling。 Call any that is not marked view Or pure The function. Use low-level calls. Use an inline assembly that contains specific opcodes. pragma solidity ^0.4.16; contract C { function f(uint a, uint b) public view returns (uint) { return a * (b + 42) + now; } } constant is view alias。 The Getter method is marked view。 The compiler does not force view method cannot modify the status. Pure function Functions can be declared pure , in this case, promise not to read or modify the status. In addition to the list of state modification statements explained above, the following is considered to be read from the state: Read status variables. Access this.balance or .balance。 Access block，tx， msg any member in （beside msg.sig and msg.data outside). Call any not marked pure function. Use an inline assembly that contains certain opcodes. pragma solidity ^0.4.16; contract C { function f(uint a, uint b) public pure returns (uint) { return a * (b + 42); } } The compiler does not force pure method cannot read the status. Fallback function A contract can have an unnamed function. This function cannot have parameters or return values. If no other function matches the given function identifier (or no call data is provided) in a contract call, the function (fallback function) will be executed. In addition, this function will be executed every time the contract receives Sipc coins (without any data). In addition, the fallback function must be marked payable . If such a function does not exist, the contract cannot receive Sipc coins through regular transactions. In this context, usually only a few gas can be used to complete this function call (to be exact, 2300 gas), so it is important to make the call of fallback function as cheap as possible. Note that the gas required for transactions calling the fallback function (rather than internal calls) is much higher, because an additional 21000 gas or more is charged for each transaction for signature check and other operations. Specifically, the following operations consume more gas than the fallback function: Write storage Create a contract Call external functions that consume a lot of gas Send Sipc coins Make sure that you thoroughly test your fallback function before deploying the contract to ensure that the execution cost is less than 2300 gas. Even if the fallback function cannot have parameters, it can still be used msg.data to obtain any valid data provided with the call. A contract that does not define a fallback function directly receives ether coins (no function call, that is, use send Or transfer ) throws an exception and returns the ether coin (the behavior will be different before Solidity v0.4.0). Therefore, if you want your contract to receive Ether coins, you must implement the fallback function. A contract without the payable fallback function can be used coinbase transaction (Also known miner block reward ) the recipient or selfdestruct The target to receive sipc coins. A contract cannot respond to this ether transfer, so it cannot refuse them either. This is determined by EVM when designing, and Solidity cannot bypass this problem. This also means this.balance can be higher than the sum of some manual accounting implemented in the contract (that is, the accumulator updated in the fallback function). pragma solidity ^0.4.0; contract Test { // 发送到这个合约的所有消息都会调用此函数（因为该合约没有其它函数）。 // 向这个合约发送以太币会导致异常，因为 fallback 函数没有 `payable` 修饰符 function() public { x = 1; } uint x; } // 这个合约会保留所有发送给它的以太币，没有办法返还。 contract Sink { function() public payable { } } contract Caller { function callTest(Test test) public { test.call(0xabcdef01); // 不存在的哈希 // 导致 test.x 变成 == 1。 // 以下将不会编译，但如果有人向该合约发送以太币，交易将失败并拒绝以太币。 // test.send(2 ether）; } } Function overload A contract can have functions with the same name with multiple different parameters. This also applies to inheritance functions. The following example shows the contract A Overloaded functions in f . pragma solidity ^0.4.16; contract A { function f(uint _in) public pure returns (uint out) { out = 1; } function f(uint _in, bytes32 _key) public pure returns (uint out) { out = 2; } } The above two `f` Function overloads accept ABI address types, although they are considered different in Solidity. ```bash // 以下代码无法编译 pragma solidity ^0.4.16; contract A { function f(B _in) public pure returns (B out) { out = _in; } function f(address _in) public pure returns (address out) { out = _in; } } contract B { } The above two f Function overloads accept ABI address types, although they are considered different in Solidity. Overloaded parsing and parameter matching You can choose to reload the function by matching the function declarations in the current range with the parameters provided in the function call. If all parameters can be implicitly converted to the expected type, the function is selected as the overload candidate. If none of the candidates exist, the parsing fails. The returned parameter is not used as the basis for overload resolution. pragma solidity ^0.4.16; contract A { function f(uint8 _in) public pure returns (uint8 out) { out = _in; } function f(uint256 _in) public pure returns (uint256 out) { out = _in; } } Call f(50) causes type errors because 50 can be implicitly converted uint8 can also be implicitly converted uint256 on the other hand, callf(256) parses f(uint256) overload，because 256 cannot be implicitly converted uint8。 Event Events allow us to easily use the log infrastructure of EVM. We can listen to events in the user interface of dapp, and the log mechanism of EVM can in turn \"call\" the Javascript callback function used to listen to events. Events can be inherited in the contract. When they are called, parameters are stored in transaction logs-a special data structure in the blockchain. These logs are associated with the address and incorporated into the blockchain. They exist as long as the block is accessible (they are permanently saved in Frontier and Homestead versions and may be changed in Serenity versions). Logs and events cannot be directly accessed within the contract (even the contract for creating logs cannot be accessed). The Simplified Payment Verification of logs is possible. If an external entity provides a contract with this proof, it can check whether the logs actually exist in the blockchain. However, it should be noted that only the latest 256 block hashes can be accessed in the contract, so the block header information needs to be provided. A maximum of three parameters can be received indexed Property so that they can be searched: specific values of indexed parameters can be used for filtering on the user interface. If the array (including string And bytes ) type is marked as index item, their keccak-256 hash values are saved as topic. Unless you use anonymous The descriptor declares an event. Otherwise, the hash value of the event signature is one of the topics. It also means that anonymous events cannot be filtered by names. All non-index parameters are stored in the data section of the log. The index parameters themselves are not saved. You can only search for their values (to determine whether the corresponding log data exists), not their values themselves. pragma solidity ^0.4.0; contract ClientReceipt { event Deposit( address indexed _from, bytes32 indexed _id, uint _value ); function deposit(bytes32 _id) public payable { // 我们可以过滤对 `Deposit` 的调用，从而用 Javascript API 来查明对这个函数的任何调用（甚至是深度嵌套调用）。 Deposit(msg.sender, _id, msg.value); } } Use JavaScript APIs to call events as follows: var abi = /* abi 由编译器产生 */; var ClientReceipt = web3.eth.contract(abi); var clientReceipt = ClientReceipt.at(\"0x1234...ab67\" /* 地址 */); var event = clientReceipt.Deposit(); // 监视变化 event.watch(function(error, result){ // 结果包括对 `Deposit` 的调用参数在内的各种信息。 if (!error) console.log(result); }); // 或者通过回调立即开始观察 var event = clientReceipt.Deposit(function(error, result) { if (!error) console.log(result); }); The underlying interface of the log through function log0，log1， log2， log3 and log4 you can access the underlying interface of the log mechanism. logi accept i + 1 a bytes32 parameter of the type. The first parameter is used as the data part of the log, and the others are used as the topic. The preceding event calls can be executed in the same way. pragma solidity ^0.4.10; contract C { function f() public payable { bytes32 _id = 0x420042; log3( bytes32(msg.value), bytes32(0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20), bytes32(msg.sender), _id ); } } The calculation method of the long hexadecimal number is keccak256(\"Deposit(address,hash256,uint256)\")，that is, the signature of the event. Resources for other learning event mechanisms Javascript documentation event usage routine How to access them in js Inheritance Solidity supports multiple inheritance by copying code that includes polymorphism. All function calls are virtual, which means that the farthest derived function will be called unless the contract name is explicitly given. When a contract is inherited from multiple contracts, only one contract is created on the blockchain, and the code of all base-class contracts is copied to the created contract. In general, Solidity's inheritance system and Python inherutance system，very similar, especially in terms of multiple inheritance. The following example is described in detail. pragma solidity ^0.4.16; contract owned { function owned() { owner = msg.sender; } address owner; } // 使用 is 从另一个合约派生。派生合约可以访问所有非私有成员，包括内部函数和状态变量， // 但无法通过 this 来外部访问。 contract mortal is owned { function kill() { if (msg.sender == owner) selfdestruct(owner); } } // 这些抽象合约仅用于给编译器提供接口。 // 注意函数没有函数体。 // 如果一个合约没有实现所有函数，则只能用作接口。 contract Config { function lookup(uint id) public returns (address adr); } contract NameReg { function register(bytes32 name) public; function unregister() public; } // 可以多重继承。请注意，owned 也是 mortal 的基类， // 但只有一个 owned 实例（就像 C++ 中的虚拟继承）。 contract named is owned, mortal { function named(bytes32 name) { Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970); NameReg(config.lookup(1)).register(name); } // 函数可以被另一个具有相同名称和相同数量/类型输入的函数重载。 // 如果重载函数有不同类型的输出参数，会导致错误。 // 本地和基于消息的函数调用都会考虑这些重载。 function kill() public { if (msg.sender == owner) { Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970); NameReg(config.lookup(1)).unregister(); // 仍然可以调用特定的重载函数。 mortal.kill(); } } } // 如果构造函数接受参数， // 则需要在声明（合约的构造函数）时提供， // 或在派生合约的构造函数位置以修饰器调用风格提供（见下文）。 contract PriceFeed is owned, mortal, named(\"GoldFeed\") { function updateInfo(uint newInfo) public { if (msg.sender == owner) info = newInfo; } function get() public view returns(uint r) { return info; } uint info; } Note that in the above code, we call mortal.kill() To \"forward\" the destruction request. This approach is problematic, as shown in the following example: pragma solidity ^0.4.0; contract owned { function owned() public { owner = msg.sender; } address owner; } contract mortal is owned { function kill() public { if (msg.sender == owner) selfdestruct(owner); } } contract Base1 is mortal { function kill() public { /* 清除操作 1 */ mortal.kill(); } } contract Base2 is mortal { function kill() public { /* 清除操作 2 */ mortal.kill(); } } contract Final is Base1, Base2 { } Call Final.kill() farthest derived overloaded function is called Base2.kill，but it will bypass Base1.kill，mainly because it doesn't even know Base1 existence. the way to solve this problem is to use super: pragma solidity ^0.4.0; contract owned { function owned() public { owner = msg.sender; } address owner; } contract mortal is owned { function kill() public { if (msg.sender == owner) selfdestruct(owner); } } contract Base1 is mortal { function kill() public { /* 清除操作 1 */ super.kill(); } } contract Base2 is mortal { function kill() public { /* 清除操作 2 */ super.kill(); } } contract Final is Base1, Base2 { } If Base2 call super it does not simply call the function on its base class contract. On the contrary, it calls this function in the next base class contract of the final inheritance relation graph, so it calls Base1.kill() (Note that the Final inheritance sequence is -- starting from the farthest derived contract: Final, Base2, Base1, epoch, ownerd). The actual function called using super in the class is unknown in the context of the current class although its type is known. This is similar to a common virtual method to find. Parameters of the base class constructor The derived contract needs to provide all the parameters required by the base class constructor. this can be done in two ways: pragma solidity ^0.4.0; contract Base { uint x; function Base(uint _x) public { x = _x; } } contract Derived is Base(7) { function Derived(uint _y) Base(_y * _y) public { } } One method directly calls the base class constructor in the inheritance list（is Base(7)）another method is like the | modifier | Usage method, as part of the derived contract constructor definition header（Base(_y * _y)). If the constructor parameter is a constant and defines or describes the behavior of the contract, it is more convenient to use the first method. If the parameters of the base class constructor depend on the derived contract, the second method must be used. If, like this simple example, both parts are used, the | modifier | Style parameter is preferred. Multiple inheritance and linearization Several problems need to be solved for programming languages to implement multiple inheritance. One problem isDiamond problem Solidity uses Python as a reference and uses C3 线性化 forces a DAG (directed acyclic graph) composed of the base class to maintain a specific order. This is finally reflected as the unique result we hope, but it also makes some inheritance methods invalid. In particular, the base class in is The following order is very important. In the following code, Solidity gives an error such as \"Linearization of inheritance graph impossible. // 以下代码编译出错 pragma solidity ^0.4.0; contract X {} contract A is X {} contract C is A, X {} The cause of code compilation error is C requirement X override A （because the order of definition is A, X ）， but A it self requires rewriting X，this conflict cannot be resolved. You can remember it through a simple rule: from \"most base-like\" to \"most derived\" to specify all base classes. Inheriting different types of members with the same name This is considered an error when inheritance causes a contract to have functions and | modifier | With the same name. If an event has the same name as | modifier | Or a function has the same name as an event, it is also considered an error. An exception is that the getter of a state variable can overwrite a public function. Abstract contract The contract function can be missing implementation, as shown in the following example (note that the function declaration header is ; end): pragma solidity ^0.4.0; contract Feline { function utterance() public returns (bytes32); } These contracts cannot be compiled successfully (even if they contain other implemented functions besides unimplemented functions), they can be used as base class contracts: pragma solidity ^0.4.0; contract Feline { function utterance() public returns (bytes32); } contract Cat is Feline { function utterance() public returns (bytes32) { return \"miaow\"; } } If a contract inherits from an abstract contract and does not implement all unimplemented functions by rewriting, it is abstract in itself. interface Interfaces are similar to abstract contracts, but they cannot implement any functions. There are further restrictions: Unable to inherit other contracts or interfaces. The constructor cannot be defined. Variables cannot be defined. Unable to define structure Unable to define enumeration. Some restrictions here may be lifted in the future. Interfaces are basically limited to what the contract ABI can represent, and the conversion between ABI and interfaces should not lose any information. Interfaces are represented by their own keywords: pragma solidity ^0.4.11; interface Token { function transfer(address recipient, uint amount) public; } Just like inheriting other contracts, contracts can inherit interfaces. Library Libraries are similar to contracts, they only need to be deployed at a specific address once, and their code can be passed through EVM's DELEGATECALL (Previously used Homestead CALLCODE Keyword) features for reuse. This means that if the library function is called, its code is executed in the context of the call contract, that is this Points to the call contract, especially the storage that can access the call contract. Because each library is a piece of independent code, it can only access the state variables explicitly provided by the call contract (otherwise it cannot access these variables by name). Because we assume that libraries are stateless, so if they do not modify the state (that is, if they are view Or pure Function), library functions can only be used by direct calls (that is, do not use DELEGATECALL Key words), in particular, it is impossible to destroy any library unless Solidity type systems can be avoided. Libraries can be seen as implicit base class contracts that use their contracts. Although they are not explicitly visible in inheritance relationships, calling library functions is very similar to calling explicit base class contracts (if L If it is a library, it can be used L.f() Call the library function). In addition, just as the library is a base class contract, for all contracts that use the library, internal Functions are visible. Of course, internal calling conventions must be used to call internal functions, which means that all internal types and memory types are passed by reference rather than replication. To implement these in EVM, the code of the internal library function and all the functions called from it are pulled into the call contract at the compilation stage, and then use one JUMP Call to replace DELEGATECALL . The following example shows how to use the library（a better example of the implementation set）: pragma solidity ^0.4.16; library Set { // 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。 struct Data { mapping(uint => bool) flags; } // 注意第一个参数是“storage reference”类型，因此在调用中参数传递的只是它的存储地址而不是内容。 // 这是库函数的一个特性。如果该函数可以被视为对象的方法，则习惯称第一个参数为 `self` 。 function insert(Data storage self, uint value) public returns (bool) { if (self.flags[value]) return false; // 已经存在 self.flags[value] = true; return true; } function remove(Data storage self, uint value) public returns (bool) { if (!self.flags[value]) return false; // 不存在 self.flags[value] = false; return true; } function contains(Data storage self, uint value) public view returns (bool) { return self.flags[value]; } } contract C { Set.Data knownValues; function register(uint value) public { // 不需要库的特定实例就可以调用库函数， // 因为当前合约就是“instance”。 require(Set.insert(knownValues, value)); } // 如果我们愿意，我们也可以在这个合约中直接访问 knownValues.flags。 } Of course, you don't have to use libraries in this way: They can also be used without defining structural data types. Functions also do not require any storage reference parameters. Libraries can appear anywhere and have multiple storage reference parameters. call Set.contains，Set.insert and Set.remove all are compiled as external calls（ DELEGATECALL ). If you use libraries, note that external function calls are actually executed. msg.sender， msg.value and this values will be retained in the call (before Homestead, because CALLCODE，changed msg.sender and msg.value)。 The following example shows how to use memory types and internal functions in a library to implement custom types without paying for the overhead of external function calls: pragma solidity ^0.4.16; library BigInt { struct bigint { uint[] limbs; } function fromUint(uint x) internal pure returns (bigint r) { r.limbs = new uint[](1); r.limbs[0] = x; } function add(bigint _a, bigint _b) internal pure returns (bigint r) { r.limbs = new uint[](max(_a.limbs.length, _b.limbs.length)); uint carry = 0; for (uint i = 0; i 0)) carry = 1; else carry = 0; } if (carry > 0) { // 太差了，我们需要增加一个 limb uint[] memory newLimbs = new uint[](r.limbs.length + 1); for (i = 0; i b ? a : b; } } contract C { using BigInt for BigInt.bigint; function f() public pure { var x = BigInt.fromUint(7); var y = BigInt.fromUint(uint(-1)); var z = x.add(y); } } Since the compiler cannot know the deployment location of the library, we need to fill these addresses in the final bytecode through the linker. If these addresses are not passed to the compiler as parameters, the compiled hexadecimal code will contain Set__ Placeholder of the form (where Set Is the name of the library). You can manually fill in the address to replace the 40 characters with the hexadecimal code of the library contract address. Compared with contracts, library restrictions: No state variables Unable to inherit or be inherited Unable to receive Sipc coins （These restrictions may be lifted in the future） Library call protection If the library code is passed CALL To execute, not DELEGATECALL Or CALLCODE Then the execution result will be rolled back unless it is right view Or pure The call of the function. EVM does not provide a check for the contract whether to use CALL But the contract can use ADDRESS The operation code finds the running location \". The generated code determines the call mode by comparing this address with the constructed address. More specifically, the runtime code of the library always starts with a push instruction, which is zero of 20 bytes at compile time. When the deployment code runs, this constant replaced by the current address in memory, the modified code is stored in the contract. At runtime, this causes the deployment address to be the first constant pushed to the stack, For any non-view and non-pure functions, the scheduler code compares whether the current address is consistent with this constant. Using For Command using A for B; can be used to attach library functions (from library A ) to any type ( B ). These functions will receive the object that calls them as their first parameter (like Python's self Variable). using A for *; the effect of IS, library A The function in is attached to any type. In both cases, all functions are appended with a parameter even if their first parameter type does not match the type of the object. Type check is performed only when function calls and overload parsing are performed. using A for B; The directive is only valid in the current scope and only in the current contract. It may be upgraded to the global scope in the future. By introducing a module, you can use data types including library functions without adding code. Let's use this way libraries Rewrite the set example in: pragma solidity ^0.4.16; // 这是和之前一样的代码，只是没有注释。 library Set { struct Data { mapping(uint => bool) flags; } function insert(Data storage self, uint value) public returns (bool) { if (self.flags[value]) return false; // 已经存在 self.flags[value] = true; return true; } function remove(Data storage self, uint value) public returns (bool) { if (!self.flags[value]) return false; // 不存在 self.flags[value] = false; return true; } function contains(Data storage self, uint value) public view returns (bool) { return self.flags[value]; } } contract C { using Set for Set.Data; // 这里是关键的修改 Set.Data knownValues; function register(uint value) public { // Here, all variables of type Set.Data have // corresponding member functions. // The following function call is identical to // `Set.insert(knownValues, value)` // 这里， Set.Data 类型的所有变量都有与之相对应的成员函数。 // 下面的函数调用和 `Set.insert(knownValues, value)` 的效果完全相同。 require(knownValues.insert(value)); } } You can also extend basic types like this: pragma solidity ^0.4.16; library Search { function indexOf(uint[] storage self, uint value) public view returns (uint) { for (uint i = 0; i Note that all library calls are actual EVM function calls. This means that if the memory or value type is passed, a copy will be generated, even if self Variables.] Using a storage reference variable is the only case where copying does not occur. Solidity Assembly Solidity defines an assembly language that can be used without Solidity. This assembly language can also be embedded into Solidity source code as \"inline assembly. We begin with how to use inline assembly, introduce how it differs from independent assembly language, and then describe this assembly language in detail. Inline assembly In order to achieve finer-grained control, especially to enhance the language by writing libraries, you can use a language close to the virtual machine to combine inline assembly with Solidity statements. Since EVM is a stack-based virtual machine, it is usually difficult to accurately locate the address of the slot (storage location) in the stack and provide the correct stack location for the operation code to obtain parameters. Solidity's inline assembly attempts to solve this problem and possible problems when writing assembly code manually by providing the following features: Function style operation code： mul(1, add(2, 3)) rather push1 3 push1 2 add push1 1 mul Assemble local variables： let x := add(2, 3) let y := mload(0x40) x := add(x, y) External variables can be accessed： function f(uint x) public { assembly { x := sub(x, 1) } } Label： let x := 10 repeat: x := sub(x, 1) jumpi(repeat, eq(x, 0)) Circulation： for { let i := 0 } lt(i, x) { i := add(i, 1) } { y := mul(2, y) } if statement: if slt(x, 0) { x := sub(0, x) } switch statent： switch x case 0 { y := mul(x, 2) } default { y := 0 } Function call： function f(x) -> y { switch x case 0 { y := 1 } default { y := mul(x, f(sub(x, 1))) } } Now let's explain the inline assembly language in detail. Inline assembly is a language that accesses Simplechain virtual machines at the underlying layer. This abandons many important security features provided by Solidity. TODO：describes the nuances of scope rules in an inline assembly and the complexity of using internal functions of library contracts. In addition, symbols about compiler definitions are also written. Example The following example shows the code of a library contract, which can get the code of another contract and load it into a bytes Variable. This is impossible for \"conventional Solidity\", and Assembly Library contracts can enhance language characteristics in this way. pragma solidity ^0.4.0; library GetCode { function at(address _addr) public view returns (bytes o_code) { assembly { // 获取代码大小，这需要汇编语言 let size := extcodesize(_addr) // 分配输出字节数组 – 这也可以不用汇编语言来实现 // 通过使用 o_code = new bytes（size） o_code := mload(0x40) // 包括补位在内新的“memory end” mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f)))) // 把长度保存到内存中 mstore(o_code, size) // 实际获取代码，这需要汇编语言 extcodecopy(_addr, add(o_code, 0x20), 0, size) } } } When the optimizer cannot generate efficient code, inline assembly may also be more beneficial. Note that it is definitely more difficult to write assembly code because the compiler cannot check assembly statements; Therefore, you need to use it only when dealing with some relatively complex problems, and you need to know clearly what you want to do. pragma solidity ^0.4.16; library VectorSum { // 因为目前的优化器在访问数组时无法移除边界检查， // 所以这个函数的执行效率比较低。 function sumSolidity(uint[] _data) public view returns (uint o_sum) { for (uint i = 0; i Syntax Like Solidity, Assembly also parses comments, text, and identifiers, so you can use the usual // and /* */ to comment. The inline assembler is composed assembly { ... } to mark, the following can be used in these braces (see later for more details). Literal constant, that is 0x123、42 or \"abc\" （a string not exceeding 32 characters） Operation code（within “instruction style”），such mload sload dup1 sstore，please see the following operation code list Function-style opcodes, such add(1，mlod(0)) Tags, suchname: Variable declaration, such let x := 7、let x := add(y, 3) or let x （the initial value will be set to empty(0))） Identifiers (tags or assembly local variables and external variables used as inline assemblies), such jump(name) , 3 x add Assignment (within \"instruction style\"), such 3 =: x Function style assignment, such x := add(y，3) Some statement blocks that control the scope of local variables, such {let x := 3 { let y := add(x，1) }} Opcode Reference operation code: If an opcode requires parameters (always from the top of the stack), they are given in parentheses. Note: the order of parameters can be considered as a reverse order in a non-functional style (explained below). Marked - The operation code of does not push data into the stack, marked * The operation code of has special operations, while all other operations will only push one data into the push stack. For F、H、B or C marked opcodes represent that they are introduced from Frontier, Homestead, Byzantium, or Constantinople. Constantinople is still planned, so it is marked C Currently, an invalid instruction is abnormal. In the following table, mem[a...b) indicates from position a start to（excluding）position b number of memory bytes,storage[p] indicates the position p storage content. pushi and jumpdest these two operation codes cannot be used directly. In the syntax table, the opcode is provided as a predefined identifier. Instruction symbol Bool Explanation stop - F 停止执行，与 return(0,0) 等价 add(x, y) F x + y sub(x, y) F x - y mul(x, y) F x * y div(x, y) F x / y sdiv(x, y) F x / y，以二进制补码作为符号 mod(x, y) F x % y smod(x, y) F x % y，以二进制补码作为符号 exp(x, y) F x 的 y 次幂 not(x) F ~x，对 x 按位取反 lt(x, y) F 如果 x gt(x, y) F 如果 x > y 为 1，否则为 0 slt(x, y) F 如果 x sgt(x, y) F 如果 x > y 为 1，否则为 0，以二进制补码作为符号 eq(x, y) F 如果 x == y 为 1，否则为 0 iszero(x) F 如果 x == 0 为 1，否则为 0 and(x, y) F x 和 y 的按位与 or(x, y) F x 和 y 的按位或 xor(x, y) F x 和 y 的按位异或 byte(n, x) F x 的第 n 个字节，这个索引是从 0 开始的 shl(x, y) C 将 y 逻辑左移 x 位 shr(x, y) C 将 y 逻��右移 x 位 sar(x, y) C 将 y 算术右移 x 位 addmod(x, y, m) F 任意精度的 (x + y) % m mulmod(x, y, m) F 任意精度的 (x * y) % m signextend(i, x) F 对 x 的最低位到第 (i * 8 + 7) 进行符号扩展 keccak256(p, n) F keccak(mem[p...(p + n))) jump(label) - F 跳转到标签 / 代码位置 jumpi(label, cond) - F 如果条件为非零，跳转到标签 pc F 当前代码位置 pop(x) - F 删除（弹出）栈顶的 x 个元素 dup1 ... dup16 F 将栈内第 i 个元素（从栈顶算起）复制到栈顶 swap1 ... swap16 * F 将栈顶元素和其下第 i 个元素互换 mload(p) F mem[p...(p + 32)) mstore(p, v) - F mem[p...(p + 32)) := v mstore8(p, v) - F mem[p] := v & 0xff （仅修改一个字节） sload(p) F storage[p] sstore(p, v) - F storage[p] := v msize F 内存大小，即最大可访问内存索引 gas F 执行可用的 gas address F 当前合约 / 执行上下文的地址 balance(a) F 地址 a 的余额，以 wei 为单位 caller F 调用发起者（不包括 delegatecall） callvalue F 随调用发送的 Wei 的数量 calldataload(p) F 位置 p 的调用数据（32 字节） calldatasize F 调用数据的字节数大小 calldatacopy(t, f, s) - F 从调用数据的位置 f 的拷贝 s 个字节到内存的位置 t codesize F 当前合约 / 执行上下文地址的代码大小 codecopy(t, f, s) - F 从代码的位置 f 开始拷贝 s 个字节到内存的位置 t extcodesize(a) F 地址 a 的代码大小 extcodecopy(a, t, f, s) - F 和 codecopy(t, f, s) 类似，但从地址 a 获取代码 returndatasize B 最后一个 returndata 的大小 returndatacopy(t, f, s) - B 从 returndata 的位置 f 拷贝 s 个字节到内存的位置 t create(v, p, s) F 用 mem[p...(p + s)) 中的代码创建一个新合约、发送 v wei 并返回新地址 create2(v, n, p, s) C 用 mem[p...(p + s)) 中的代码，在地址keccak256( . n . keccak256(mem[p...(p + s)))创建新合约、发送 v wei 并返回新地址上 call(g, a, v, in,insize, out, outsize) F 使用 mem[in...(in + insize)) 作为输入数据，提供 g gas 和 v wei 对地址 a 发起消息调用，输出结果数据保存在 mem[out...(out + outsize))，发生错误（比如 gas 不足）时返回 0，正确结束返回 1 callcode(g, a, v, in,insize, out, outsize) F 与 call 等价，但仅使用地址 a 中的代码 且保持当前合约的执行上下文 delegatecall(g, a, in,insize, out, outsize) F 与 callcode 等价且保留 caller 和 callvalue staticcall(g, a, in,insize, out, outsize) F 与 call(g, a, 0, in, insize, out, outsize) 等价,但不允许状态修改 return(p, s) - F 终止运行，返回 mem[p...(p + s)) 的数据 revert(p, s) - B 终止运行，撤销状态变化，返回 mem[p...(p + s)) 的数据 selfdestruct(a) - F 终止运行，销毁当前合约并且把资金发送到地址 a invalid - F 以无效指令终止运行 log0(p, s) - F 以 mem[p...(p + s)) 的数据产生不带 topic 的日志 log1(p, s, t1) - F 以 mem[p...(p + s)) 的数据和 topic t1 产生日志 log2(p, s, t1, t2) - F 以 mem[p...(p + s)) 的数据和 topic t1、t2 产生日志 log3(p, s, t1, t2, t3) - F 以 mem[p...(p + s)) 的数据和 topic t1、t2、t3 产生日志 log4(p, s, t1, t2, t3, t4) - F 以 mem[p...(p + s)) 的数据和 topic t1、t2、t3 和 t4 产生日志 origin F 交易发起者地址 gasprice F 交易所指定的 gas 价格 blockhash(b) F 区块号 b 的哈希 - 目前仅适用于不包括当前区块的最后 256 个区块 coinbase F 当前的挖矿收益者地址 timestamp F 从当前 epoch 开始的当前区块时间戳（以秒为单位） number F 当前区块号 difficulty F 当前区块难度 gaslimit F 当前区块的 gas 上限 Literal constant You can directly type decimal or hexadecimal symbols to use as integer constants, which automatically generates the corresponding PUSHi Instruction. The following code calculates 2 plus 3 (equal to 5), and then calculates its bitwise sum with the string \"abc. The string is left aligned when stored and cannot exceed 32 bytes in length. assembly { 2 3 add \"abc\" and } Function style You can type an opcode after the opcode just like using a bytecode. For example, put 3 And memory location 0x80 Add the data 3 0x80 mload add 0x80 mstore Because it is usually difficult to see the actual parameters of Some opcodes, Solidity inline assembly also provides a \"function style\" representation, code with the same function can be written mstore(0x80, add(mload(0x80), 3)) Instruction style cannot be used in function style expressions, that is 1 2 mstore(0x80, add) is an invalid assembly statement, It must be written mstore(0x80, add(2, 1)) this form. For opcodes without parameters, brackets can be omitted. Note that in function style writing, the order of parameters is opposite to the instruction style. If you use function style, the first parameter is at the top of the stack. Access external variables and functions Solidity variables and other identifiers can be accessed by simply using their names. For memory variables, this pushes the address instead of the value into the stack. Storage variables are different because the value of the storage variable may not occupy the complete storage slot, so its \"address\" consists of the byte offset in the storage slot and the slot. To obtain variables x The storage slot used, you can use x_slot , and x_offset Gets its byte offset. In assignment statements (see below), we can even use Solidity local variables to assign values. External functions can also be accessed for inline assemblies: the Assembly pushes their entry tags (with virtual function parsing) into the stack. The call semantics in Solidity are: Caller press in return label、arg1、arg2、...、argn The caller returnsret1、ret2、...、retm This feature is still a little troublesome to use, because the stack offset has changed fundamentally during the call, so the reference to local variables will go wrong. pragma solidity ^0.4.11; contract C { uint b; function f(uint x) public returns (uint r) { assembly { r := mul(x, sload(b_slot)) // 因为偏移量为 0，所以可以忽略 } } } If you access a data type with actual data digits less than 256 bits（such uint64、address、bytes16 or byte），do not make any assumptions about the values on the unused data bits of this type after encoding. In particular, do not assume that they must be 0. For security reasons, before using this data in a context, you must clear the data to 0, which is very important: uint32 x = f(); assembly { x := and(x, 0xffffffff) /* now use x */ }To clear the symbolic type, you can use signextend operation code. Label Tags are not recommended. Use functions, loops, if, or switch statements. Another problem with EVM assembly is that jump and jumpi functions use absolute addresses, which are easy to change. Solidity inline assembly provides tags for easier use of jump. Note that tags have underlying characteristics, and efficient assembly code can be written using loop, if, and switch commands (see below) without tags. The following code is used to calculate an element in the Fibonacci sequence. { let n := calldataload(4) let a := 1 let b := a loop: jumpi(loopend, eq(n, 0)) a add swap1 n := sub(n, 1) jump(loop) loopend: mstore(0, a) return(0, 0x20) } Note: stack variables can be automatically accessed only when the assembler knows the current stack height. If the stack heights of the jump source and the target are different, the access fails. Although we can use jump in this way, in this case, you should not access variables in any stack (even assembly variables). In addition, the stack height analyzer can also check the code opcode through the opcode (rather than according to the control flow), so in the following cases, the assembler two The stack height at will generate the wrong impression: { let x := 8 jump(two) one: // 这里的栈高度是 2（因为我们压入了 x 和 7）， // 但因为汇编程序是按顺序读取代码的， // 它会认为栈高度是 1。 // 在这里访问栈变量 x 会导致错误。 x := 9 jump(three) two: 7 // 把某个数据压入栈中 jump(one) three: } Assembly local variable declaration You can use let Keywords to declare variables that are visible only in the inline assembly, actually only in the current {...} Visible in the block. The following things should be: let The command creates a new data slot reserved for the variable and automatically deletes it when it reaches the end of the block. You need to provide an initial value for the variable, which can only 0 But it can also be a complex function style expression. pragma solidity ^0.4.16; contract C { function f(uint x) public view returns (uint b) { assembly { let v := add(x, 1) mstore(0x80, v) { let y := add(sload(v), 1) b := y } // y 会在这里被“清除” b := add(b, v) } // v 会在这里被“清除” } } Assignment You can assign values to Assembly local variables and function local variables. Note: When assigning values to variables pointing to memory or storage, you just change the pointer instead of the data. There are two assignment methods: Function style and instruction style. For function style assignment ( variable := value ), you need to provide a value in a function style expression, which can exactly generate a value in a stack; For Instruction style assignment ( =: variable ), the data is only obtained from the top of the stack. For both methods, colons point to variable names. Assignment is achieved by replacing the variable values in the stack with new values. { let v := 0 // 作为变量声明的函数风格赋值 let g := add(v, 2) sload(10) =: v // 指令风格的赋值，将 sload(10) 的结果赋给 v } Assignment of instruction style is not recommended. If if if statements can be used to conditionally execute code and do not have the \"else\" section; { if eq(value, 0) { revert(0, 0) } } Braces for the code body are required. Switch As a very preliminary version of \"if/else\", you can use the switch statement. It calculates the value of the expression and compares it with several constants. Select the branch corresponding to the matching constant. Unlike some programming languages that are prone to errors, the control flow will not continue to be executed from one situation to the next. We can set a fallback or called default The default. { let x := 0 switch calldataload(4) case 0 { x := calldataload(0x24) } default { x := calldataload(0x44) } sstore(0, div(x, 2)) } The Case list does not need braces, but the case body needs braces. Circulating Assembly language supports a simple for-style loop. The For-style loop has a header that contains the initialization part, conditions, and iteration post-processing parts. The condition must be a function-style expression, while the other two parts are statement blocks. If the start part declares a variable, the scope of these variables will be extended to the loop body (including conditions and post-iteration parts). The following example calculates the sum of values in a memory area. { let x := 0 for { let i := 0 } lt(i, 0x100) { i := add(i, 0x20) } { x := add(x, mload(i)) } } The For loop can also be written as the while loop: only the initialization part and the iteration post-processing part are left blank. { let x := 0 let i := 0 for { } lt(i, 0x100) { } { // while(i Function Assembly language allows you to define underlying functions. The underlying function needs to obtain their parameters (and return PC) from the stack and put the results into the stack. The method of calling a function is the same as that of executing a function-style opcode. Functions can be defined anywhere and visible in the statement blocks that declare them. Local variables defined outside the function cannot be accessed within the function. There is no strict here return Statement. If you call a function that returns multiple values, you must use a，b：= f(x) Or let a，b：= f(x) Assign them to a tuple. The following example implements the power operation function by square multiplication. { function power(base, exponent) -> result { switch exponent case 0 { result := 1 } case 1 { result := base } default { result := power(mul(base, base), div(exponent, 2)) switch mod(exponent, 2) case 1 { result := mul(base, result) } } } } Precautions Inline assembly language may have a fairly high-level appearance, but in fact it is a very low-level programming language. Function calls, loops, if statements, and switch statements are converted through simple rewrite rules, Then, the only thing the assembler does for you is to reorganize function-style opcodes, manage jump tags, and calculate the stack height of access variables, in addition, the stack data of partial assembly variables is deleted when the end of the statement block is reached. Especially for the last two cases, the assembler will only calculate the height of the stack in the order of the code, not necessarily following the control process; Understanding this is very important. In addition, operations such as swap only exchange the data in the stack, not the variable position. Solidity convention Compared with EVM assembly language, Solidity can identify types less than 256 bits, such uint24 . In order to improve efficiency, most arithmetic operations only regard them as 256 digits and clear unused data bits only when necessary, this is done only before they are written to memory or compared. This means that if you access such variables from an inline assembly you must first manually clear those unused data bits. Solidity manages memory in a very simple way: in 0x40 location of has a \"idle memory pointer\". If you plan to allocate memory, just start using memory from here and update the pointer accordingly. The first 64 bytes of memory can be used as temporary storage space for temporary allocation \". The 32-byte position after the \"free memory pointer\" (that is, from 0x60 Start position) will always be 0, which can be used to initialize an empty dynamic memory array. In Solidity, elements in memory arrays always occupy a multiple of 32 bytes (yes, even byte[] It's all like this, only bytes and string Not like this). A multi-dimensional memory array is a pointer to a memory array. The length of a dynamic array is stored in the first slot of the array, followed by array elements. Static memory arrays do not have length fields, but will soon increase. This is to better convert between static arrays and dynamic arrays, so do not rely on this. Independent Assembly The assembly language described in the preceding inline assembly can also be used alone. In fact, the plan is to use it as an intermediate language for the Solidity compiler. In this sense, it tries to achieve the following goals: 1、Even if the code is generated by Solidity's compiler, the program written with it should also be readable. 2、From assembly to bytecode translation, \"accidents\" should be included as little as possible \". 3、The control flow should be easy to detect to help carry out formal test and optimization. To achieve the first and last goals, the Assembly provides an advanced structure: such for Circulation, if Statement, switch Statements and function calls. Should be able to write without using explicit SWAP , DUP , JUMP And JUMPI Statement assembler,because the first two confuse the data stream, while the last two confuse the control flow. In addition, the form is mul(add(x, y), 7) The function style statement of is better 7 y x add mul Because it is easier to see which operation is used for which operation code in the first form. The second goal is to use a very regular way to treat the advanced instruction structure as a bytecode. The only non-local operation performed by the assembler is the name search of the user-defined identifier (function, variable, azone), it follows very simple and fixed scope rules and clears local variables from the stack. Scope: Identifiers (tags, variables, functions, assemblies) declared in it are only visible in declared statement blocks (including nested statement blocks in the current statement block). Even if they are within the scope of action, it is illegal to cross the function boundary to access local variables. Shadowing is prohibited. Local variables cannot be accessed before declaration, but tags, functions, and assemblies are possible. Assembly is a special statement block, for example, used to return runtime codes or create contracts. Identifiers declared in Assembly statement blocks outside the subassembly are all invisible in the subassembly. If the control flow passes through the end of the block, pop instructions matching the number of local variables declared in the current statement block are inserted. Whenever a local variable is referenced, the code generator needs to know the relative position in the current stack, Therefore, it is necessary to track the current so-called stack height. Because all local variables declared in the statement block are clear at the end of the statement block, the stack height before and after the statement block should be the same. If this is not the case a warning will be issued. Use switch , for And functions should be able to write complex code without manual calls jump Or jumpi . This will allow improved forms of laboratory certificates and optimization to analyze the control process more simply. In addition, if manual redirection is allowed, the calculation stack height will be more complicated. The positions of all local variables in the stack need to be clearly known, otherwise, references to local variables cannot be automatically obtained at the end of the statement block, thus clearing them correctly. Example: We will refer to an instance from Solidity to assembly instructions. Consider the runtime bytecode of the following Solidity program: pragma solidity ^0.4.16; contract C { function f(uint x) public pure returns (uint y) { y = 1; for (uint i = 0; i The following assembly instructions will be generated: { mstore(0x40, 0x60) // 保存“空闲内存指针” // 函数选择器 switch div(calldataload(0), exp(2, 226)) case 0xb3de648b { let r := f(calldataload(4)) let ret := $allocate(0x20) mstore(ret, r) return(ret, 0x20) } default { revert(0, 0) } // 内存分配器 function $allocate(size) -> pos { pos := mload(0x40) mstore(0x40, add(pos, size)) } // 合约函数 function f(x) -> y { y := 1 for { let i := 0 } lt(i, x) { i := add(i, 1) } { y := mul(2, y) } } } Assembly syntax Parser tasks are as follows: Convert the byte stream into a symbolic stream, and discard the comments in the C++ style (there is a special comment on the source code reference, and we will not explain it here). According to the following syntax, convert the symbol flow to AST. Register the identifier defined in the statement Block (annotated to the AST node) and indicate where the variable can be accessed from. The Assembly lexical analyzer follows the rules defined by Solidity itself. A space is used to separate all symbols. It consists of space characters, tabs, and line breaks. The annotation format is regular JavaScript/C envoy style and is interpreted as a space. Grammar:: AssemblyBlock = '{' AssemblyItem* '}' AssemblyItem = Identifier | AssemblyBlock | AssemblyExpression | AssemblyLocalDefinition | AssemblyAssignment | AssemblyStackAssignment | LabelDefinition | AssemblyIf | AssemblySwitch | AssemblyFunctionDefinition | AssemblyFor | 'break' | 'continue' | SubAssembly AssemblyExpression = AssemblyCall | Identifier | AssemblyLiteral AssemblyLiteral = NumberLiteral | StringLiteral | HexLiteral Identifier = [a-zA-Z_$] [a-zA-Z_0-9]* AssemblyCall = Identifier '(' ( AssemblyExpression ( ',' AssemblyExpression )* )? ')' AssemblyLocalDefinition = 'let' IdentifierOrList ( ':=' AssemblyExpression )? AssemblyAssignment = IdentifierOrList ':=' AssemblyExpression IdentifierOrList = Identifier | '(' IdentifierList ')' IdentifierList = Identifier ( ',' Identifier)* AssemblyStackAssignment = '=:' Identifier LabelDefinition = Identifier ':' AssemblyIf = 'if' AssemblyExpression AssemblyBlock AssemblySwitch = 'switch' AssemblyExpression AssemblyCase* ( 'default' AssemblyBlock )? AssemblyCase = 'case' AssemblyExpression AssemblyBlock AssemblyFunctionDefinition = 'function' Identifier '(' IdentifierList? ')' ( '->' '(' IdentifierList ')' )? AssemblyBlock AssemblyFor = 'for' ( AssemblyBlock | AssemblyExpression ) AssemblyExpression ( AssemblyBlock | AssemblyExpression ) AssemblyBlock SubAssembly = 'assembly' Identifier AssemblyBlock NumberLiteral = HexNumber | DecimalNumber HexLiteral = 'hex' ('\"' ([0-9a-fA-F]{2})* '\"' | '\\'' ([0-9a-fA-F]{2})* '\\'') StringLiteral = '\"' ([^\"\\r\\n\\\\] | '\\\\' .)* '\"' HexNumber = '0x' [0-9a-fA-F]+ DecimalNumber = [0-9]+ "},"20_contractPattern.html":{"url":"20_contractPattern.html","title":"Contract template","keywords":"","body":"Some contract templates of Jin Dian can help developers learn quickly Solidity,and quickly start the development. Create excellent Dapp applications based on Simplechain. Vote The following contract is quite complex, but shows many Solidity functions. It achieved a voting contract. Of course, the main problem of electronic voting is how to distribute the voting rights to the right people and how to prevent manipulation. We will not solve all the problems here, but at least we will show how to conduct delegation voting. At the same time, counting votes is also Automatic and fully transparent 。 Our idea is to create a contract for each (vote) vote and provide short for each option. Then as the creator of the contract-the chairman, he will give each independent address the right to vote. People behind the address can choose to vote by themselves or entrust people they trust to vote. At the end of the voting time，winningProposal() the proposal that received the most votes will be returned. pragma solidity ^0.4.22; /// @title 委托投票 contract Ballot { // 这里声明了一个新的复合类型用于稍后的变量 // 它用来表示一个选民 struct Voter { uint weight; // 计票的权重 bool voted; // 若为真，代表该人已投票 address delegate; // 被委托人 uint vote; // 投票提案的索引 } // 提案的类型 struct Proposal { bytes32 name; // 简称（最长32个字节） uint voteCount; // 得票数 } address public chairperson; // 这声明了一个状态变量，为每个可能的地址存储一个 `Voter`。 mapping(address => Voter) public voters; // 一个 `Proposal` 结构类型的动态数组 Proposal[] public proposals; /// 为 `proposalNames` 中的每个提案，创建一个新的（投票）表决 constructor(bytes32[] proposalNames) public { chairperson = msg.sender; voters[chairperson].weight = 1; //对于提供的每个提案名称， //创建一个新的 Proposal 对象并把它添加到数组的末尾。 for (uint i = 0; i winningVoteCount) { winningVoteCount = proposals[p].voteCount; winningProposal_ = p; } } } // 调用 winningProposal() 函数以获取提案数组中获胜者的索引，并以此返回获胜者的名称 function winnerName() public view returns (bytes32 winnerName_) { winnerName_ = proposals[winningProposal()].name; } } Possible optimization At present, in order to distribute the voting rights to all participants, many transactions need to be executed. Do you have a better idea? Secret bidding (blind auction) In this section, we will show how to easily create a secret bidding contract on Simplechain. We will start from the public auction, everyone can see the bid, and then extend this contract to blind auction contract, The actual bid cannot be seen before the bidding period ends. Simple public auction The general idea of the following simple auction contract is that everyone can send their bids within the bidding period. The bid already contains funds/Ethernet coins to bind bidders to their bids. If the highest bid is raised (it is exceeded by other bidders), the former highest bidder can get her money back. At the end of the bidding period, the beneficiary needs to manually call the contract to receive his money-the contract cannot activate the receipt by itself. pragma solidity ^0.4.22; contract SimpleAuction { // 拍卖的参数。 address public beneficiary; // 时间是unix的绝对时间戳（自1970-01-01以来的秒数） // 或以秒为单位的时间段。 uint public auctionEnd; // 拍卖的当前状态 address public highestBidder; uint public highestBid; //可以取回的之前的出价 mapping(address => uint) pendingReturns; // 拍卖结束后设为 true，将禁止所有的变更 bool ended; // 变更触发的事件 event HighestBidIncreased(address bidder, uint amount); event AuctionEnded(address winner, uint amount); // 以下是所谓的 natspec 注释，可以通过三个斜杠来识别。 // 当用户被要求确认交易时将显示。 /// 以受益者地址 `_beneficiary` 的名义， /// 创建一个简单的拍卖，拍卖时间为 `_biddingTime` 秒。 constructor( uint _biddingTime, address _beneficiary ) public { beneficiary = _beneficiary; auctionEnd = now + _biddingTime; } /// 对拍卖进行出价，具体的出价随交易一起发送。 /// 如果没有在拍卖中胜出，则返还出价。 function bid() public payable { // 参数不是必要的。因为所有的信息已经包含在了交易中。 // 对于能接收以太币的函数，关键字 payable 是必须的。 // 如果拍卖已结束，撤销函数的调用。 require( now highestBid, \"There already is a higher bid.\" ); if (highestBid != 0) { // 返还出价时，简单地直接调用 highestBidder.send(highestBid) 函数， // 是有安全风险的，因为它有可能执行一个非信任合约。 // 更为安全的做法是让接收方自己提取金钱。 pendingReturns[highestBidder] += highestBid; } highestBidder = msg.sender; highestBid = msg.value; emit HighestBidIncreased(msg.sender, msg.value); } /// 取回出价（当该出价已被超越） function withdraw() public returns (bool) { uint amount = pendingReturns[msg.sender]; if (amount > 0) { // 这里很重要，首先要设零值。 // 因为，作为接收调用的一部分， // 接收者可以在 `send` 返回之前，重新调用该函数。 pendingReturns[msg.sender] = 0; if (!msg.sender.send(amount)) { // 这里不需抛出异常，只需重置未付款 pendingReturns[msg.sender] = amount; return false; } } return true; } /// 结束拍卖，并把最高的出价发送给受益人 function auctionEnd() public { // 对于可与其他合约交互的函数（意味着它会调用其他函数或发送以太币）， // 一个好的指导方针是将其结构分为三个阶段： // 1. 检查条件 // 2. 执行动作 (可能会改变条件) // 3. 与其他合约交互 // 如果这些阶段相混合，其他的合约可能会回调当前合约并修改状态， // 或者导致某些效果（比如支付以太币）多次生效。 // 如果合约内调用的函数包含了与外部合约的交互， // 则它也会被认为是与外部合约有交互的。 // 1. 条件 require(now >= auctionEnd, \"Auction not yet ended.\"); require(!ended, \"auctionEnd has already been called.\"); // 2. 生效 ended = true; emit AuctionEnded(highestBidder, highestBid); // 3. 交互 beneficiary.transfer(highestBid); } } Secret auction (blind auction) The previous public auction will then be expanded to a secret auction. The advantage of secret auction is that there will be no time pressure before the bid ends. Secret auction on a transparent computing platform sounds self-contradictory, but cryptography can realize it. In Bidding period ，the bidder did not actually send her bid, but only sent a hash version of the bid. Since it is almost impossible to find two (long enough) values at present and their hash values are equal, tenderers can submit quotations in this way. After the bidding is completed, bidders must disclose their bids: they send their bids unencrypted, and the contract checks whether the hash value of the bid is the same as that provided during the bidding period. Another challenge is how to make the auction work at the same time Binding and secret : The only way to prevent the bidder from not paying after she wins the auction is to let her send out the money together with the bid. However, since the transfer of funds cannot be hidden in Simplechain, anyone can see the transferred funds. The following contract solves this problem by accepting any value greater than the highest bid. Of course, because this can only be checked at the disclosure stage, some bids may be Invalid of， Moreover, this is intentional (together with the high bid, it even provides a clear mark to identify invalid bids): Bidders can confuse competitors by setting several high or low invalid bids. pragma solidity >0.4.23 Bid[]) public bids; address public highestBidder; uint public highestBid; // 可以取回的之前的出价 mapping(address => uint) pendingReturns; event AuctionEnded(address winner, uint highestBid); /// 使用 modifier 可以更便捷的校验函数的入参。 /// `onlyBefore` 会被用于后面的 `bid` 函数： /// 新的函数体是由 modifier 本身的函数体，并用原函数体替换 `_;` 语句来组成的。 modifier onlyBefore(uint _time) { require(now _time); _; } constructor( uint _biddingTime, uint _revealTime, address _beneficiary ) public { beneficiary = _beneficiary; biddingEnd = now + _biddingTime; revealEnd = biddingEnd + _revealTime; } /// 可以通过 `_blindedBid` = keccak256(value, fake, secret) /// 设置一个秘密竞拍。 /// 只有在出价披露阶段被正确披露，已发送的以太币才会被退还。 /// 如果与出价一起发送的以太币至少为 “value” 且 “fake” 不为真，则出价有效。 /// 将 “fake” 设置为 true ，然后发送满足订金金额但又不与出价相同的金额是隐藏实际出价的方法。 /// 同一个地址可以放置多个出价。 function bid(bytes32 _blindedBid) public payable onlyBefore(biddingEnd) { bids[msg.sender].push(Bid({ blindedBid: _blindedBid, deposit: msg.value })); } /// 披露你的秘密竞拍出价。 /// 对于所有正确披露的无效出价以及除最高出价以外的所有出价，你都将获得退款。 function reveal( uint[] _values, bool[] _fake, bytes32[] _secret ) public onlyAfter(biddingEnd) onlyBefore(revealEnd) { uint length = bids[msg.sender].length; require(_values.length == length); require(_fake.length == length); require(_secret.length == length); uint refund; for (uint i = 0; i = value) { if (placeBid(msg.sender, value)) refund -= value; } // 使发送者不可能再次认领同一笔订金 bid.blindedBid = bytes32(0); } msg.sender.transfer(refund); } // 这是一个 \"internal\" 函数， 意味着它只能在本合约（或继承合约）内被调用 function placeBid(address bidder, uint value) internal returns (bool success) { if (value 0) { // 这里很重要，首先要设零值。 // 因为，作为接收调用的一部分， // 接收者可以在 `transfer` 返回之前重新调用该函数。（可查看上面关于‘条件 -> 影响 -> 交互’的标注） pendingReturns[msg.sender] = 0; msg.sender.transfer(amount); } } /// 结束拍卖，并把最高的出价发送给受益人 function auctionEnd() public onlyAfter(revealEnd) { require(!ended); emit AuctionEnded(highestBidder, highestBid); ended = true; beneficiary.transfer(highestBid); } } Secure Remote purchase pragma solidity ^0.4.22; contract Purchase { uint public value; address public seller; address public buyer; enum State { Created, Locked, Inactive } State public state; //确保 `msg.value` 是一个偶数。 //如果它是一个奇数，则它将被截断。 //通过乘法检查它不是奇数。 constructor() public payable { seller = msg.sender; value = msg.value / 2; require((2 * value) == msg.value, \"Value has to be even.\"); } modifier condition(bool _condition) { require(_condition); _; } modifier onlyBuyer() { require( msg.sender == buyer, \"Only buyer can call this.\" ); _; } modifier onlySeller() { require( msg.sender == seller, \"Only seller can call this.\" ); _; } modifier inState(State _state) { require( state == _state, \"Invalid state.\" ); _; } event Aborted(); event PurchaseConfirmed(); event ItemReceived(); ///中止购买并回收以太币。 ///只能在合约被锁定之前由卖家调用。 function abort() public onlySeller inState(State.Created) { emit Aborted(); state = State.Inactive; seller.transfer(address(this).balance); } /// 买家确认购买。 /// 交易必须包含 `2 * value` 个以太币。 /// 以太币会被锁定，直到 confirmReceived 被调用。 function confirmPurchase() public inState(State.Created) condition(msg.value == (2 * value)) payable { emit PurchaseConfirmed(); buyer = msg.sender; state = State.Locked; } /// 确认你（买家）已经收到商品。 /// 这会释放被锁定的以太币。 function confirmReceived() public onlyBuyer inState(State.Locked) { emit ItemReceived(); // 首先修改状态很重要，否则的话，由 `transfer` 所调用的合约可以回调进这里（再次接收以太币）。 state = State.Inactive; // 注意: 这实际上允许买方和卖方阻止退款 - 应该使用取回模式。 buyer.transfer(value); seller.transfer(address(this).balance); } } "},"21_buildTest.html":{"url":"21_buildTest.html","title":"Build Test network","keywords":"","body":"Create a genesis block file Create a new file genesis.json with the following content. { \"config\": { \"chainId\": 100, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"alloc\" : {}, \"coinbase\" : \"0x0000000000000000000000000000000000000000\", \"difficulty\" : \"0x20000\", \"extraData\" : \"\", \"gasLimit\" : \"0x2fefd8\", \"nonce\" : \"0x0000000000000042\", \"mixhash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"timestamp\" : \"0x00\" } Of which chainId the ID of the test network. the ID of the primary network is 1,difficulty for the difficulty of mining, to facilitate the operation of the test network, the difficulty setting is low. Start node 1.Create the storage directory nodedata1 for node one mkdir nodedata1 2.Use genesis.json to initialize the genesis block of node 1 sipe init --datadir nodedata1 genesis.json 3.Start the node and specify the networkid. Ensure that the specified networkid is the same when communicating with the node sipe --datadir nodedata1 --port 30312 --rpc --rpcaddr 127.0.0.1 --rpcport 8541 --networkid 10001 console 4. View the node information in the open console to obtain the node enode > admin.nodeInfo { enode: \"enode://05a9c3bd1f6716a1806e677b8337d4e1eb4b9f57d8f94d11bcf4870fd8d5d943b9591 1a3c51f40714f33a307049d8c0c1a7019a71d099a27c6a939a85a809110@[::]:30312\", id: \"05a9c3bd1f6716a1806e677b8337d4e1eb4b9f57d8f94d11bcf4870fd8d5d943b95911a3c51f4 0714f33a307049d8c0c1a7019a71d099a27c6a939a85a809110\", ip: \"::\", listenAddr: \"[::]:30312\", name: \"Sipe/v1.0.2-stable-0cbf2a41/darwin-amd64/go1.12.1\", ports: { discovery: 30312, listener: 30312 }, protocols: { eth: { config: { chainId: 100, eip150Hash: \"0x0000000000000000000000000000000000000000000000000000000000000000\", eip155Block: 0, eip158Block: 0, homesteadBlock: 0 }, difficulty: 131072, genesis: \"0x5e1fc79cb4ffa4739177b5408045cd5d51c6cf766133f23f7cd72ee1f8d790e0\", head: \"0x5e1fc79cb4ffa4739177b5408045cd5d51c6cf766133f23f7cd72ee1f8d790e0\", network: 10001 }} } 3.Start node 2 1. Create the storage directory nodedata2 for node one mkdir nodedata2 2. Use genesis.json to initialize the genesis block of node 1. sipe init --datadir nodedata2 genesis.json 3. Start the node to ensure that networdid is the same as node one. Note that when configuring bootnodes, replace the enode [::] obtained by node one with the IP address of node one, that is 127.0.0.1 sipe --datadir nodedata2 --port 30313 --rpc --rpcaddr 127.0.0.1 --rpcport 8542 --networkid 10001 --bootnodes \"enode://05a9c3bd1f6716a1806e677b8337d4e1eb4b9f57d8f94d11bcf4870fd8d5d943b9591 1a3c51f40714f33a307049d8c0c1a7019a71d099a27c6a939a85a809110@127.0.0.1:30312\" console 4. View the information of the associated node. If the returned result is not empty, it is confirmed that node 2 and node 1 are successfully connected. > admin.peers [{ caps: [\"eth/63\"], id: \"05a9c3bd1f6716a1806e677b8337d4e1eb4b9f57d8f94d11bcf4870fd8d5d943b95911a3c51f4 0714f33a307049d8c0c1a7019a71d099a27c6a939a85a809110\", name: \"Sipe/v1.0.2-stable-0cbf2a41/darwin-amd64/go1.12.1\", network: { inbound: false, localAddress: \"127.0.0.1:58388\", remoteAddress: \"127.0.0.1:30312\", static: false, trusted: false }, protocols: { eth: { difficulty: 131072, head: \"0x5e1fc79cb4ffa4739177b5408045cd5d51c6cf766133f23f7cd72ee1f8d790e0\", version: 63 } } }] 3.Mining in the test network 1.Create an account on Node 1 and set it as the miner address > personal.newAccount() Passphrase: Repeat passphrase:=\"0x7f53309f95559c52d08f18724c0b24aa758d1953\" > miner.setEtherbase('0x7f53309f95559c52d08f18724c0b24aa758d1953') true 2.Start mining on Node 1 > miner.start() INFO [06-19|10:53:15.918] Updated mining threads threads=0 INFO [06-19|10:53:15.918] Transaction pool price threshold updated price=1000000000 INFO [06-19|10:53:15.918] Starting mining operation null > INFO [06-19|10:53:15.918] Commit new mining work number=1 txs=0 uncles=0 elapsed=207.516μs INFO [06-19|10:53:47.601] Successfully sealed new block number=1 hash=755f08...62e560 INFO [06-19|10:53:47.607] 🔨 mined potential block number=1 hash=755f08...62e560 3.Confirm the synchronization block on Node 2 INFO [06-19|10:53:49.246] Block synchronisation started INFO [06-19|10:53:49.538] Imported new block headers count=2 elapsed=6.482ms number=2 hash=c7c0a9...79db3e ignored=0 INFO [06-19|10:53:49.539] Imported new chain segment blocks=2 txs=0 mgas=0.000 elapsed=766.945μs mgasps=0.000 number=2 hash=c7c0a9...79db3e cache=1.20kB INFO [06-19|10:53:49.556] Imported new state entries count=3 elapsed=90.308μs processed=3 pending=0 retry=0 duplicate=0 unexpected=0 INFO [06-19|10:53:49.601] Fast sync complete, auto disabling INFO [06-19|10:53:59.119] Imported new chain segment blocks=1 txs=0 mgas=0.000 elapsed=1.212ms mgasps=0.000 number=3 hash=6dd8b2...194509 cache=1.81kB 4.Transfer money in the test network 1. Use the console to create another account. > personal.newAccount() Passphrase: Repeat passphrase: \"0xf9143e3b7de8ce91e463e30480f5afe84d3067ba\" 2. Use the password to unlock the account of the transferor before transferring money. > personal.unlockAccount('0x7f53309f95559c52d08f18724c0b24aa758d1953') Unlock account 0x7f53309f95559c52d08f18724c0b24aa758d1953 Passphrase: true 3. Send the transaction for transfer, where from is the transferor, here is the address of the miner, to is the payee, and the value is the transfer amount. > eth.sendTransaction({from:\"0x7f53309f95559c52d08f18724c0b24aa758d1953\",to:\"0xf9143e 3b7de8ce91e463e30480f5afe84d3067ba\",value:web3.toWei(10,\"ether\")}) \"0x5a6fbb3161329ca2591b7ecbcaca8a15a94cac5d402fce929f24504c76b8b7bb\" 4. Confirm receipt. > eth.getBalance('0xf9143e3b7de8ce91e463e30480f5afe84d3067ba') 10000000000000000000 "},"22_sipcApi.html":{"url":"22_sipcApi.html","title":"Sip API","keywords":"","body":"Sipc API method list: web3_clientVersion web3_sha3 net_version net_listening net_peerCount eth_protocolVersion eth_syncing eth_coinbase eth_mining eth_hashrate eth_gasPrice eth_accounts eth_blockNumber eth_getBalance eth_getStorageAt eth_getBlockTransactionCountByHash eth_getBlockTransactionCountByNumb eth_getUncleCountByBlockHash eth_getUncleCountByBlockNumber eth_getCode eth_sign eth_sendTransaction eth_sendRawTransaction eth_call eth_estimateGas eth_getBlockByHash eth_getBlockByNumber eth_getTransactionByNUmber eth_getUncleByBlockHashAndIndex eth_getUncleByBlockNumberAndIndex eth_newFilter eth_newBlockFilter eth_newPendingTransactionFilter eth_uninstallFilter eth_getFilterChanges eth_getFilterLogs eth_getLogs eth_getWork eth_submitWork eth_submitHashrate eth_blockNumber JSON-RPC Endpoint Default JSON-RPC endpoints: Client URL Go http://localhost:8545 Default block parameters The following method has an additional default block parameter: eth_getBalance eth.getCode eth.getTransactionCount eth_getStorageAt eth_call When the request acts on the status of simplechain, the last default block parameter determines the height of the block. The following options can be used for the default block parameters: HEX String -Integer number of blocks String \"earliest\" - The earliest/genesis block String \"latest\" - Newly dug blocks String \"pending\" - For pending status/transactions web3_clientVersion Returns the current client version. Parameter No Return string: Current client version 示例 // Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":68}' //Result { \"id\":67, \"jsonrpc\":\"2.0\", \"result\": \"Mist/v0.9.3/darwin/go1.4.1\" } web3_sha3 Returns the keccak-256 of the given data (not a standardized sha3-256) Parameter string: The data to calculate the SHA3 hash must be (hex string) Return value string: Specifies the SHA3 result of the string. 示例 // Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"web3_sha3\",\"params\":[\"0x68656c6c6f20776f726c64\"],\"id\":64}' //Result { \"id\":64, \"jsonrpc\": \"2.0\", \"result\": \"0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad\" } net_version Returns the ID of the current connection network. Parameter no Return value String: The ID of the current connection network,\"1\": Simplechain mainnet,\"3\": testnet; 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"net_version\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\":67, \"result\": \"3\" } net_listening Returns whether the client is in the listening network connection state. If the client is in the listening state, the system returns true, otherwise return false. Parameter 无 Return value bool: Returns true when the client is listening. Otherwise, false is returned Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"net_listening\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\":\"2.0\", \"id\":67, \"result\":true } net_peerCount Returns the number of nodes currently connected to the client. Parameter No Return value Quantity: Number of connected nodes Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"net_peerCount\",\"params\":[],\"id\":74}' //Response { \"id\":74, \"jsonrpc\": \"2.0\", \"result\": \"0xf\" } eth_protocolVersion Returns the protocol version of simplechain. Parameter no 返回 String The current protocol version of simplechain. 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_protocolVersion\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\":\"2.0\", \"id\":67, \"result\":\"0x40\" } eth_syncing Returns an object that contains data about the synchronization status or false Number parameter No Return value Object|Boolean, synchronization status object or false. The structure of the synchronization object is as follows: startingBlock: QUANTITY - start Block currentBlock: QUANTITY - current block, and eth_blockNumber highestBlock: QUANTITY - maximum estimated block Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_syncing\",\"params\":[],\"id\":1}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": { startingBlock: '0x384', currentBlock: '0x386', highestBlock: '0x454' } } { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": false } eth_coinbase Returns the client miner address. Parameters No Return value Data: 20 bytes - current coinbase address Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_coinbase\",\"params\":[],\"id\":64}' //Response { \"id\":64, \"jsonrpc\": \"2.0\", \"result\": \"0x407d73d8a49eeb85d32cf465507dd71d507100c1\" } eth_mining If the client is mining, return true, otherwise, return false。 Parameter no Return value boolean When the client is mining, it returns true , otherwise, return false . Exaple //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_mining\",\"params\":[],\"id\":71}' //Response { \"id\":71, \"jsonrpc\": \"2.0\", \"result\": true } eth_hashrate Returns the hash rate per second that can be calculated during node mining. Parameter no Return quantity: Hash rate calculated per second Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_hashrate\",\"params\":[],\"id\":71}' //Response { \"jsonrpc\": \"2.0\", \"id\":71, \"result\": \"0x38a\" } eth_gasPrice Returns each current gas price, unit:wei。 parameter no Return value quantity:Integer, wei Is the current unit gas price Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_gasPrice\",\"params\":[],\"id\":73}' //Response { \"jsonrpc\": \"2.0\", \"id\":73, \"result\": \"0x09184e72a000\" // 10000000000000 } eth_accounts Returns the list of addresses held by the client. Parameter no Return string[]:String array, a list of address strings held by the client. Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_accounts\",\"params\":[],\"id\":1}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": [\"0x407d73d8a49eeb85d32cf465507dd71d507100c1\"] } eth_blockNumber Returns the block number (block height) of the latest block. Parameter No Return The integer of the current block number where the client is located. Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1}' //Response { \"jsonrpc\":\"2.0\", \"id\":1, \"result\":\"0x5a0d\" } eth_getBalance Returns the balance of the account at the specified address. Parameter data- 20 bytes, the address of the balance to be checked quantity|tag - Integer block number, or string \"latest\", \"earliest\" or \"pending\" Return quantity:Current balance, unit: wei Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBalance\",\"params\":[\"0x51e766a7f073955c8061073bbba60b10bf12d48a\", \"latest\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0x0234c8a3397aab58\" // 158972490234375000 } eth_getTransactionCount Returns the number of transactions at the specified address. Parameter DATA: 20 bytes, address QUANTITY|TAG Integer block number, or string \"latest\", \"earliest\", or \"pending\" Return QUANTITY The number of transactions sent from the specified address, an integer. Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionCount\",\"params\":[\"0xd79b8287a827e1387e6f0ff6d300fc663e10f592\",\"latest\"],\"id\":1}' //Response { \"jsonrpc\":\"2.0\", \"id\":1, \"result\":\"0x1303\" } // 1 eth_getBlockTransactionCountByHash Returns the number of transactions in a specified block using a hash. Parameter DATA: 20 bytes, address Return QUANTITY The number of transactions in the specified block, integer Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockTransactionCountByHash\",\"params\":[\"0x268343647d0fcf63628446a29959feccf57136dac58fd1c17e0df3babafce3b6\"],\"id\":1}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x2\" } eth_getBlockTransactionCountByNumber Returns the number of transactions in a block that matches a given block number. Parameter QUANTITY|TAG: Integer block number, or string \"earliest\", \"latest\", or \"pending\" Return QUANTITY: • The number of transactions in the specified block. Example //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockTransactionCountByNumber\",\"params\":[\"0x11c7\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0xa\" } eth_getUncleCountByBlockHash 从与给定块哈希匹配的块中返回叔块数。 参数 QUANTITY DATA, 32 字节，块哈希 返回值 QUANTITY: DATA，指定块的叔数，整数 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getUncleCountByBlockHash\",\"params\":[\"0x58052e3424b8c03643a3cd3595cad1a6104ab195cc78108318699f2bfa429d8f\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0x1\" } eth_getUncleCountByBlockNumber 从与给定块号匹配的块中返回块中的叔块数。 参数 QUANTITY|TAG -区块数, 或者字符串 \"latest\", \"earliest\" or \"pending\" 返回 QUANTITY: DATA，指定块的叔数，整数 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getUncleCountByBlockNumber\",\"params\":[\"0x1bb\"],\"id\":1}' //Response { \"jsonrpc\":\"2.0\", \"id\":1, \"result\":\"0x1\" } eth_getCode 返回指定地址的代码。 参数 string: DATA ,20 字节，地址 string QUANTITY|TAG, 整数块编号，或字符串\"latest\"、\"earliest\" 或\"pending\" 返回 string DATA: 指定地址处的代码 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getCode\",\"params\":[\"0xe558562c906c69787b8fabb6d0efb3f1163a20e4\",\"latest\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0x\" } eth_sign 通过向消息添加前缀，可以将计算出的签名识别为特定于simplechain的签名。这可以防止恶意DAPP在签署任意数据（如事务）并使用签名来冒充受害者时的误用。 注意: 必须先解锁要签名的地址. 参数 DATA 20字节，地址 DATA 要签名的消息 返回值 DATA 数据的签名 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sign\",\"params\":[\"0xb014763d71459855510255647be8cf39b0e82acb\",\"0xdeadbeaf\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0xa3f20717a250c2b0b729b7e5becbff67fdaef7e0699da4de7ca5895b02a170a12d887fd3b17bfdce3481f10bea41f45ba9f709d39ce8325427b57afcfc994cee1b\" } eth_sendTransaction 创建一个新的消息调用交易，如果数据字段中包含代码，则创建一个合约。 参数 from: DATA, 20 字节 - 发送交易的源地址 to: DATA, 20 字节 - 交易的目标地址，当创建新合约时可选 gas: QUANTITY - 交易执行可用 gas 量，可选整数，默认值 90000，未用 gas 将返还。 gasPrice: QUANTITY - gas 价格，可选，默认值:待定(To-Be-Determined) value: QUANTITY - 交易发送的金额，可选整数 data: DATA - 合约的编译代码或被调用方法的签名及编码参数 nonce: QUANTITY - nonce，可选。可以使用同一个 nonce 来重写挂起的交易 返回 DATA:32 字节 - 交易哈希，如果交易还未生效则返回 0 值哈希。当创建合约时，在交易生效后，使用 eth_getTransactionReceipt 调用获取合约地址。 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\", \"params\":[{ \"from\": \"0xb014763d71459855510255647be8cf39b0e82acb\", \"to\": \"0xac49f5e5b9161e0cb42372c90183d8428b060ff1\", \"gas\": \"0x76c0\", \"gasPrice\": \"0x9184e72a000\", \"value\": \"0x9184e72a\", \"data\": \"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675\" }],\"id\":1}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\" } eth_sendRawTransaction 为已签名的交易创建新的消息调用交易或合约创建。 参数 DATA: 签名的交易数据 返回值 DATA: 32字节，交易哈希，如果交易未生效则返回全0哈希。当创建合约时，在交易生效后，使用eth_getTransactionReceipt获取合约地址。 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendRawTransaction\",\"params\":[\"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675\"],\"id\":1}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\" } eth_call 立刻执行一个新的消息调用，无需在区块链上创建交易。 参数 from: DATA, 20 Bytes - 发送交易的原地址，可选 to: DATA, 20 Bytes - 交易目标地址 gas: QUANTITY - 交易可用 gas 量，可选。eth_call 不消耗 gas，但是某些 执行环节需要这个参数 gasPrice: QUANTITY - gas 价格，可选 value: QUANTITY - 交易发送的 sipc 数量，可选 data: DATA - 方法签名和编码参数的哈希，可选 string: QUANTITY|TAG - 整数块编号，或字符串\"latest\"、\"earliest\"或\"pending\" 返回值 result: DATA- 所执行合约的返回值 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_call\",\"params\":[\"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675\" ],\"id\":1}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x\" } eth_estimateGas 执行并估算一个交易需要的gas用量。该次交易不会写入区块链。注意，由于多种原因，例如EVM的机制及节点的性能，估算的数值可能比实际用量大的多。 参数 from: DATA, 20 Bytes - 发送交易的原地址，可选 to: DATA, 20 Bytes - 交易目标地址 gas: QUANTITY - 交易可用 gas 量，可选。eth_call 不消耗 gas，但是某些 执行环节需要这个参数 gasPrice: QUANTITY - gas 价格，可选 value: QUANTITY - 交易发送的 sipc 数量，可选 data: DATA - 方法签名和编码参数的哈希，可选 string: QUANTITY|TAG - 整数块编号，或字符串\"latest\"、\"earliest\"或\"pending\" 返回值 result: QUANTITY - gas用量估算值 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_estimateGas\",\"params\":[{ \"from\": \"0xb014763d71459855510255647be8cf39b0e82acb\", \"to\": \"0xac49f5e5b9161e0cb42372c90183d8428b060ff1\", \"gas\": \"0x76c0\", \"gasPrice\": \"0x9184e72a000\", \"value\": \"0x9184e72a\", \"data\": \"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675\" }],\"id\":1}' //response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x5cec\" // 21000 } eth_getBlockByHash 根据给定的哈希返回有关块的信息。 参数 DATA, 32个字节 - 区块的哈希 Boolean - 如果为true，则返回完整的交易对象，否则仅返回交易哈希 返回值 number: QUANTITY - 块编号，挂起块为 null hash: DATA, 32 Bytes - 块哈希，挂起块为 null parentHash: DATA, 32 Bytes - 父块的哈希 nonce: DATA, 8 Bytes - 生成的 pow 哈希，挂起块为 null sha3Uncles: DATA, 32 Bytes - 块中叔数据的 SHA3 哈希 logsBloom: DATA, 256 Bytes - 块日志的 bloom 过滤器，挂起块为null ansactionsRoot: DATA, 32 Bytes - 块中的交易树根节点 stateRoot: DATA, 32 Bytes - 块最终状态树的根节点 receiptsRoot: DATA, 32 Bytes - 块交易收据树的根节点 miner: DATA, 20 Bytes - 挖矿奖励的接收账户 difficulty: QUANTITY - 块难度，整数 totalDifficulty: QUANTITY - 截止到本块的链上总难度 extraData: DATA - 块额外数据 size: QUANTITY - 本块字节数 gasLimit: QUANTITY - 本块允许的最大 gas 用量 gasUsed: QUANTITY - 本块中所有交易使用的总 gas 用量 timestamp: QUANTITY - 块时间戳 transactions: Array - 交易对象数组，或 32 字节长的交易哈希数组 uncles: Array - 叔哈希数组 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByHash\",\"params\":[\"0xbe024aeab6138b6adffd616314c707e2af8d165f871c8068d1a4a9c38a59c69b\", true],\"id\":1}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": { \"number\": \"0x1b4\", // 436 \"hash\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\", \"parentHash\": \"0x9646252be9520f6e71339a8df9c55e4d7619deeb018d2a3f2d21fc165dde5eb5\", \"nonce\": \"0xe04d296d2460cfb8472af2c5fd05b5a214109c25688d3704aed5484f9a7792f2\", \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\", \"logsBloom\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\", \"transactionsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"stateRoot\": \"0xd5855eb08b3387c0af375e9cdb6acfc05eb8f519e419b874b6ff2ffda7ed1dff\", \"miner\": \"0x4e65fda2159562a496f9f3522f89122a3088497a\", \"difficulty\": \"0x027f07\", // 163591 \"totalDifficulty\": \"0x027f07\", // 163591 \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000 000000000\", \"size\": \"0x027f07\", // 163591 \"gasLimit\": \"0x9f759\", // 653145 \"gasUsed\": \"0x9f759\", // 653145 \"timestamp\": \"0x54e34e8e\" // 1424182926 \"transactions\": [{...},{ ... }] \"uncles\": [\"0x1606e5...\", \"0xd5145a9...\"] } } eth_getBlockByNumber 根据区块数（区块高度）返回有关块的信息。 参数 QUANTITY|TAG 区块数, 或者字符串 \"earliest\", \"latest\" or \"pending\" Boolean - 如果为true，则返回完整的交易对象；如果为false，则仅返回交易的哈希值。 返回 number: QUANTITY - 块编号，挂起块为 null hash: DATA, 32 Bytes - 块哈希，挂起块为 null parentHash: DATA, 32 Bytes - 父块的哈希 nonce: DATA, 8 Bytes - 生成的 pow 哈希，挂起块为 null sha3Uncles: DATA, 32 Bytes - 块中叔数据的 SHA3 哈希 logsBloom: DATA, 256 Bytes - 块日志的 bloom 过滤器，挂起块为null ansactionsRoot: DATA, 32 Bytes - 块中的交易树根节点 stateRoot: DATA, 32 Bytes - 块最终状态树的根节点 receiptsRoot: DATA, 32 Bytes - 块交易收据树的根节点 miner: DATA, 20 Bytes - 挖矿奖励的接收账户 difficulty: QUANTITY - 块难度，整数 totalDifficulty: QUANTITY - 截止到本块的链上总难度 extraData: DATA - 块额外数据 size: QUANTITY - 本块字节数 gasLimit: QUANTITY - 本块允许的最大 gas 用量 gasUsed: QUANTITY - 本块中所有交易使用的总 gas 用量 timestamp: QUANTITY - 块时间戳 transactions: Array - 交易对象数组，或 32 字节长的交易哈希数组 uncles: Array - 叔哈希数组 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"0x6bcd\", true],\"id\":1}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": { \"number\": \"0x1b4\", // 436 \"hash\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\", \"parentHash\": \"0x9646252be9520f6e71339a8df9c55e4d7619deeb018d2a3f2d21fc165dde5eb5\", \"nonce\": \"0xe04d296d2460cfb8472af2c5fd05b5a214109c25688d3704aed5484f9a7792f2\", \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\", \"logsBloom\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\", \"transactionsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"stateRoot\": \"0xd5855eb08b3387c0af375e9cdb6acfc05eb8f519e419b874b6ff2ffda7ed1dff\", \"miner\": \"0x4e65fda2159562a496f9f3522f89122a3088497a\", \"difficulty\": \"0x027f07\", // 163591 \"totalDifficulty\": \"0x027f07\", // 163591 \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000 000000000\", \"size\": \"0x027f07\", // 163591 \"gasLimit\": \"0x9f759\", // 653145 \"gasUsed\": \"0x9f759\", // 653145 \"timestamp\": \"0x54e34e8e\" // 1424182926 \"transactions\": [{...},{ ... }] \"uncles\": [\"0x1606e5...\", \"0xd5145a9...\"] } } eth_getTransactionByHash 返回有关交易哈希请求的交易的信息 参数 DATA, 32个字节 - 交易的哈希 返回 blockHash: DATA, 32 Bytes -此交易所在的区块的哈希。当它还处于待定状态时为null。 blockNumber: QUANTITY - 此交易所在的区块的高度. 当它还处于待定状态时为null。 from: DATA, 20 个字节 -交易发起者的地址。 gas: QUANTITY -交易发起者提供的gas数。 gasPrice: QUANTITY - 发送者提供的gas的价格，以wei为单位。 hash: DATA, 32个字节 -交易的哈希 input: DATA - 随交易一起发送的数据。 nonce: QUANTITY - 发送方在此之前进行的交易数。 to: DATA, 20个字节 -接受者的地址，当交易是一个合约创建的时候，它的值为null。 transactionIndex: QUANTITY - 交易在块中的索引位置的整数。当它为待定状态时为null。 value: QUANTITY - 转账的数额，以wei为单位。 v: QUANTITY - ECDSA recovery id r: DATA, 32 Bytes - ECDSA signature r s: DATA, 32 Bytes - ECDSA signature s 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionByHash\",\"params\":[\"0x8e63b031ac4f3a9c38642d69a86f73368fee539d9351e4eb312b5cfb6cd4f3e6\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"blockHash\": \"0xbe024aeab6138b6adffd616314c707e2af8d165f871c8068d1a4a9c38a59c69b\", \"blockNumber\": \"0x6bcd\", \"from\": \"0xd79b8287a827e1387e6f0ff6d300fc663e10f592\", \"gas\": \"0x5c20\", \"gasPrice\": \"0x218711a00\", \"hash\": \"0x8e63b031ac4f3a9c38642d69a86f73368fee539d9351e4eb312b5cfb6cd4f3e6\", \"input\": \"0xd3182ceafbaf2da3503237a4f60b74e30756e78f310d2b97761c38db06753c99353535363530\", \"nonce\": \"0xecc\", \"to\": \"0xd79b8287a827e1387e6f0ff6d300fc663e10f592\", \"transactionIndex\": \"0x3\", \"value\": \"0xde0b6b3a7640000\", \"v\": \"0x26\", \"r\": \"0x5076aebd122ba56eaa0d40a44ce950ac792851e97e1a4afcf660afbc8d1e625a\", \"s\": \"0x7a7af2b80ccbdce36363b338b96a3f6c96aafa7057ea586a4dae0e30da607747\" } } eth_getTransactionByBlockHashAndIndex 返回指定块内具有指定索引序号的交易。 参数 DATA, 32 字节 - 块哈希 QUANTITY, 交易在块内的索引序号 返回 hash: DATA, 32 字节 - 交易哈希 nonce: QUANTITY - 本次交易之前发送方已经生成的交易数量 blockHash: DATA, 32 字节 - 交易所在块的哈希，对于挂起块，该值为 null blockNumber: QUANTITY - 交易所在块的编号，对于挂起块，该值为 null transactionIndex: QUANTITY - 交易在块中的索引位置，挂起块该值为 null from: DATA, 20 字节 - 交易发送方地址 to: DATA, 20 字节 - 交易接收方地址，对于合约创建交易，该值为 null value: QUANTITY - 发送的 sipc 数量，单位:wei gasPrice: QUANTITY - 发送方提供的 gas 价格，单位:wei gas: QUANTITY - 发送方提供的 gas 可用量 input: DATA - 随交易发送的数据 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionByBlockHashAndIndex\",\"params\":[\"0xbe024aeab6138b6adffd616314c707e2af8d165f871c8068d1a4a9c38a59c69b\", \"0x3\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"blockHash\": \"0xbe024aeab6138b6adffd616314c707e2af8d165f871c8068d1a4a9c38a59c69b\", \"blockNumber\": \"0x6bcd\", \"from\": \"0xd79b8287a827e1387e6f0ff6d300fc663e10f592\", \"gas\": \"0x5c20\", \"gasPrice\": \"0x218711a00\", \"hash\": \"0x8e63b031ac4f3a9c38642d69a86f73368fee539d9351e4eb312b5cfb6cd4f3e6\", \"input\": \"0xd3182ceafbaf2da3503237a4f60b74e30756e78f310d2b97761c38db06753c99353535363530\", \"nonce\": \"0xecc\", \"to\": \"0xd79b8287a827e1387e6f0ff6d300fc663e10f592\", \"transactionIndex\": \"0x3\", \"value\": \"0xde0b6b3a7640000\", \"v\": \"0x26\", \"r\": \"0x5076aebd122ba56eaa0d40a44ce950ac792851e97e1a4afcf660afbc8d1e625a\", \"s\": \"0x7a7af2b80ccbdce36363b338b96a3f6c96aafa7057ea586a4dae0e30da607747\" } } eth_getTransactionByBlockNumberAndIndex 按区块数（区块高度）和交易索引位置返回有关交易的信息。 参数 QUANTITY|TAG - 整数块编号，或字符串\"earliest\"、\"latest\" 或\"pending\" QUANTITY - 交易索引序号 返回值 hash: DATA, 32 字节 - 交易哈希 nonce: QUANTITY - 本次交易之前发送方已经生成的交易数量 blockHash: DATA, 32 字节 - 交易所在块的哈希，对于挂起块，该值为 null blockNumber: QUANTITY - 交易所在块的编号，对于挂起块，该值为 null transactionIndex: QUANTITY - 交易在块中的索引位置，挂起块该值为 null from: DATA, 20 字节 - 交易发送方地址 to: DATA, 20 字节 - 交易接收方地址，对于合约创建交易，该值为 null value: QUANTITY - 发送的 sipc 数量，单位:wei gasPrice: QUANTITY - 发送方提供的 gas 价格，单位:wei gas: QUANTITY - 发送方提供的 gas 可用量 input: DATA - 随交易发送的数据 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionByBlockNumberAndIn dex\",\"params\":[\"0x29c\", \"0x0\"],\"id\":1}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": { \"hash\":\"0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1d105 5b\", \"nonce\":\"0x\", \"blockHash\": \"0xbeab0aa2411b7ab17f30a99d3cb9c6ef2fc5426d6ad6fd9e2a26a6aed1d1055b\", \"blockNumber\": \"0x15df\", // 5599 \"transactionIndex\": \"0x1\", // 1 \"from\":\"0x407d73d8a49eeb85d32cf465507dd71d507100c1\", \"to\":\"0x85h43d8a49eeb85d32cf465507dd71d507100c1\", \"value\":\"0x7f110\", // 520464 \"gas\": \"0x7f110\", // 520464 \"gasPrice\":\"0x09184e72a000\", \"input\":\"0x603880600c6000396000f300603880600c6000396000f3603880600c6000396000f360\", } } eth_getTransactionReceipt 根据交易哈希返回一个交易的收据,注意:收据不可用于待处理的交易。 参数 DATA, 32字节，交易哈希 返回 transactionHash: DATA, 32 字节 - 交易哈希 transactionIndex: QUANTITY - 交易在块内的索引序号 blockHash: DATA, 32 字节 - 交易所在块的哈希 blockNumber: QUANTITY - 交易所在块的编号 from: DATA, 20 字节 - 交易发送方地址 to: DATA, 20 字节 - 交易接收方地址，对于合约创建交易该值为 null cumulativeGasUsed: QUANTITY - 交易所在块消耗的 gas 总量 gasUsed: QUANTITY - 该次交易消耗的 gas 用量 contractAddress: DATA, 20 字节 - 对于合约创建交易，该值为新创建的合 约地址，否则为 null logs: Array - 本次交易生成的日志对象数组 logsBloom: DATA, 256 字节 - bloom 过滤器，轻客户端用来快速提取相关日志 root: DATA 32 字节，后交易状态根(pre Byzantium) status: QUANTITY ，1 (成功) 或 0 (失败) 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionReceipt\",\"params\":[\"0x b903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"],\"id\":1}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": { transactionHash: '0xb903239f8543d04b5dc1ba6579132b143087c68db1b216878640 8fcbce568238', transactionIndex: '0x1', // 1 blockNumber: '0xb', // 11 blockHash: '0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1 d1055b', cumulativeGasUsed: '0x33bc', // 13244 gasUsed: '0x4dc', // 1244 contractAddress: '0xb60e8dd61c5d32be8058bb8eb970870f07233155', // or null, if none was created logs: [{ // logs as returned by getFilterLogs, etc. }, ...], logsBloom: \"0x00...0\", // 256 byte bloom filter status: '0x1' } } eth_getUncleByBlockHashAndIndex 根据哈希和叔块索引位置返回有关块的叔块的信息。 参数 DATA, 32字节,块哈希 QUANTITY, 叔索引位置 返回值 number: QUANTITY - 块编号，挂起块为 null hash: DATA, 32 Bytes - 块哈希，挂起块为 null parentHash: DATA, 32 Bytes - 父块的哈希 nonce: DATA, 8 Bytes - 生成的 pow 哈希，挂起块为 null sha3Uncles: DATA, 32 Bytes - 块中叔数据的 SHA3 哈希 logsBloom: DATA, 256 Bytes - 块日志的 bloom 过滤器，挂起块为null ansactionsRoot: DATA, 32 Bytes - 块中的交易树根节点 stateRoot: DATA, 32 Bytes - 块最终状态树的根节点 receiptsRoot: DATA, 32 Bytes - 块交易收据树的根节点 miner: DATA, 20 Bytes - 挖矿奖励的接收账户 difficulty: QUANTITY - 块难度，整数 totalDifficulty: QUANTITY - 截止到本块的链上总难度 extraData: DATA - 块额外数据 size: QUANTITY - 本块字节数 gasLimit: QUANTITY - 本块允许的最大 gas 用量 gasUsed: QUANTITY - 本块中所有交易使用的总 gas 用量 timestamp: QUANTITY - 块时间戳 transactions: Array - 交易对象数组，或 32 字节长的交易哈希数组 uncles: Array - 叔哈希数组 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getUncleByBlockHashAndIndex\",\"params\":[\"0x58052e3424b8c03643a3cd3595cad1a6104ab195cc78108318699f2bfa429d8f\",'0x0'],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"difficulty\": \"0x267c3\", \"extraData\": \"0xd983010000847369706588676f312e31312e318664617277696e\", \"gasLimit\": \"0x12804\", \"gasUsed\": \"0x0\", \"hash\": \"0x7937f1ac55c87d4fb649c17d0c9411e8837d32e10bf5e8723611120b50154c16\", \"logsBloom\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"miner\": \"0x41da014ee4c2f583ba222344c095a631e739f2f1\", \"mixHash\": \"0xa50630bdd5800368de83fa719373ccceaaf69e56f07d32db11b2069c2af9a611\", \"nonce\": \"0x4f0713dd54bb9301\", \"number\": \"0x1b5\", \"parentHash\": \"0xf2ad2fbdd67936df73c447eabb49965d2bced51df9c1a80545b001600547d81a\", \"receiptsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\", \"size\": \"0x21b\", \"stateRoot\": \"0xbfb096cd9832414ad738ff806dcfb1e48d9836c00d130b723a3bb808098b1099\", \"timestamp\": \"0x5c2e3b64\", \"totalDifficulty\": null, \"transactionsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"uncles\": [] } } 注意: 叔块不包含单独的交易。 eth_getUncleByBlockNumberAndIndex 根据区块数（区块高度）和叔块索引位置返回有关叔块的信息. 参数 QUANTITY|TAG - 整数块编号，或字符串\"earliest\"、\"latest\" 或\"pending\" QUANTITY – 叔块在块内的索引序号 返回 number: QUANTITY - 块编号，挂起块为 null hash: DATA, 32 Bytes - 块哈希，挂起块为 null parentHash: DATA, 32 Bytes - 父块的哈希 nonce: DATA, 8 Bytes - 生成的 pow 哈希，挂起块为 null sha3Uncles: DATA, 32 Bytes - 块中叔数据的 SHA3 哈希 logsBloom: DATA, 256 Bytes - 块日志的 bloom 过滤器，挂起块为null ansactionsRoot: DATA, 32 Bytes - 块中的交易树根节点 stateRoot: DATA, 32 Bytes - 块最终状态树的根节点 receiptsRoot: DATA, 32 Bytes - 块交易收据树的根节点 miner: DATA, 20 Bytes - 挖矿奖励的接收账户 difficulty: QUANTITY - 块难度，整数 totalDifficulty: QUANTITY - 截止到本块的链上总难度 extraData: DATA - 块额外数据 size: QUANTITY - 本块字节数 gasLimit: QUANTITY - 本块允许的最大 gas 用量 gasUsed: QUANTITY - 本块中所有交易使用的总 gas 用量 timestamp: QUANTITY - 块时间戳 transactions: Array - 交易对象数组，或 32 字节长的交易哈希数组 uncles: Array - 叔哈希数组 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getUncleByBlockNumberAndIndex\",\"params\":[\"0x1bb\",\"0x0\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"difficulty\": \"0x267c3\", \"extraData\": \"0xd983010000847369706588676f312e31312e318664617277696e\", \"gasLimit\": \"0x12804\", \"gasUsed\": \"0x0\", \"hash\": \"0x7937f1ac55c87d4fb649c17d0c9411e8837d32e10bf5e8723611120b50154c16\", \"logsBloom\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"miner\": \"0x41da014ee4c2f583ba222344c095a631e739f2f1\", \"mixHash\": \"0xa50630bdd5800368de83fa719373ccceaaf69e56f07d32db11b2069c2af9a611\", \"nonce\": \"0x4f0713dd54bb9301\", \"number\": \"0x1b5\", \"parentHash\": \"0xf2ad2fbdd67936df73c447eabb49965d2bced51df9c1a80545b001600547d81a\", \"receiptsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\", \"size\": \"0x21b\", \"stateRoot\": \"0xbfb096cd9832414ad738ff806dcfb1e48d9836c00d130b723a3bb808098b1099\", \"timestamp\": \"0x5c2e3b64\", \"totalDifficulty\": null, \"transactionsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"uncles\": [] } } 注意: 叔块不包含单独的交易 ------ eth_newFilter 根据过滤器器选项创建过滤器对象，以便在状态更改（日志）时通知。要检查状态是否已更改，请调用eth getfilterchanges。 关于指定主题过滤器的说明: 关于特定主题过滤器的说明:主题是顺序相关的。如果一个交易的日志有主题[A, ，那么将被以下的主题过滤器匹配: []任何主题 [A]先匹配A主题 [null,B]先匹配其他主题，再匹配B主题 [A,B]先匹配A主题，再匹配B主题，最后匹配其他主题 [[A,B][A,B]\"先匹配A主题或B主题，再匹配A主题或B主题,最后匹配其他主题\"] 参数 fromBlock: QUANTITY|TAG - 可选，默认值:\"latest\"。整数块编号，或字符串\"latesr\"表示最后挖出的块，\"pending\"或\"earliest\"用于未挖出的交易。 toBlock: QUANTITY|TAG - 可选，默认值:\"latest\"。整数块编号，或字符串\"latesr\"表示最后挖出的块，\"pending\"或\"earliest\"用于未挖出的交易。 address: DATA|Array, 20 字节 - 可选，合约地址或生成日志的一组地址 topics: Array of DATA, - 可选，32 字节主题数组，每个主题可以是数组或使用 or 选项连接 返回 QUANTITY，过滤器编号 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_newBlockFilter\",\"params\":[],\"id\":73}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0x1\" // 1 } eth_newBlockFilter 在节点中创建一个过滤器，以便当新块生成时进行通知。要检查状态是否变化，请调用eth_getFilterChanges. 参数 无 返回 QUANTITY 过滤器编号 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_newBlockFilter\",\"params\":[],\"id\":73}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0x1\" // 1 } eth_newPendingTransactionFilter 在节点中创建一个过滤器，以便当产生挂起交易时进行通知。要检查状态是否发生变化，请调用eth_getFilterChanges。 参数 无 返回值 QUANTITY, 过滤器编号 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_newPendingTransactionFilter\",\"para ms\":[],\"id\":73}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x1\" // 1 } eth_uninstallFilter 卸载具有指定编号的过滤器。当不在需要监听时，总是需要执行该调用。另外，过滤器如果在一定时间内未接收到eth_getFilterChanges调用会自动超时。 参数 QUANTITY, 过滤器编号 返回 Boolean, 如果成功卸载则返回true,否则返回false 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_uninstallFilter\",\"params\":[\"0xb\"],\"id\":7 3}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": true } eth_getFilterChanges 轮询指定的过滤器，并返回自上次轮询之后新生成的日志数组。 参数 QUANTITY, 过滤器编号 返回值 Array, 日志对象数组，如果没有新生成的日志，则返回空数组。 使用eth_newBlockerFilter创建的过滤器将返回块哈希(32 字节)，例如[\")x3454645634534\"]。 使用eth_newPendingTransactionFilter创建的过滤器将返回交易哈希 (32 字节)，例如[\"0x6345343454645...\"]。 使用eth_newFilter创建的过滤器，日志对象具有如下数参数： removed: TAG - 如果日志已被删除则返回 true，如果是有效日志则返回false logIndex: QUANTITY - 日志在块内的索引序号。对于挂起日志，该值为 null transactionIndex: QUANTITY - 创建日志的交易索引序号，对于挂起日志，该值为 null transactionHash: DATA, 32 字节 - 创建该日志的交易的哈希。对于挂起日志，该值为 null blockHash: DATA, 32 字节 - 该日志所在块的哈希。对于挂起日志，该值为null blockNumber: QUANTITY - 该日志所在块的编号。对于挂起日志，该值为 null address: DATA, 20 字节 - 该日志的源地址 data: DATA - 包含该日志的一个或多个 32 字节无索引参数 topics: Array of DATA -0~4 个 32 字节索引日志参数的数据。在 solidity 中，第一个主题是事件签名，例如 Deposit(address,bytes32,uint256)，除非你声明的是匿名事件 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getFilterChanges\",\"params\":[\"0x16\"],\" id\":73}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": [{ \"logIndex\": \"0x1\", // 1 \"blockNumber\":\"0x1b4\", // 436 \"blockHash\": \"0x8216c5785ac562ff41e2dcfdf5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"transactionHash\": \"0xdf829c5a142f1fccd7d8216c5785ac562ff41e2dcfdf5785ac562f f41e2dcf\", \"transactionIndex\": \"0x0\", // 0 \"address\": \"0x16c5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"data\":\"0x0000000000000000000000000000000000000000000000000000000000000 000\", \"topics\": [\"0x59ebeb90bc63057b6515673c3ecf9438e5058bca0f92585014eced636878c9a5\"] },{... }] } eth_getFilterLogs 返回与给定ID匹配的过滤器的所有日志的数组. 参数 QUANTITY, 过滤器编号 返回 removed: TAG - 如果日志已被删除则返回true，如果是有效日志则返回false logIndex: QUANTITY - 日志在块内的索引序号。对于挂起日志，该值为null transactionIndex: QUANTITY - 创建日志的交易索引序号，对于挂起日志，该值为null transactionHash: DATA, 32 字节 - 创建该日志的交易的哈希。对于挂起日志，该值为null blockHash: DATA, 32 字节 - 该日志所在块的哈希。对于挂起日志，该值为null blockNumber: QUANTITY - 该日志所在块的编号。对于挂起日志，该值为null address: DATA, 20 字节 - 该日志的源地址 data: DATA - 包含该日志的一个或多个32字节无索引参数 topics: Array of DATA -0~4 个 32字节索引日志参数的数据。在 solidity 中，第一个主题是事件签名，例如 Deposit(address,bytes32,uint256)，除非你声明的是匿名事件 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getFilterLogs\",\"params\":[\"0x16\"],\"id\": 74}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": [{ \"logIndex\": \"0x1\", // 1 \"blockNumber\":\"0x1b4\", // 436 \"blockHash\": \"0x8216c5785ac562ff41e2dcfdf5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"transactionHash\": \"0xdf829c5a142f1fccd7d8216c5785ac562ff41e2dcfdf5785ac562f f41e2dcf\", \"transactionIndex\": \"0x0\", // 0 \"address\": \"0x16c5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"data\":\"0x0000000000000000000000000000000000000000000000000000000000000 000\", \"topics\": [\"0x59ebeb90bc63057b6515673c3ecf9438e5058bca0f92585014eced636878c9a5\"] },{... }] } eth_getLogs 返回与给定过滤器对象匹配的所有日志的数组。 参数 fromBlock: QUANTITY|TAG - 可选，默认值:\"latest\"。整数块编号，或字符串\"latesr\"表示最后挖出的块，\"pending\"或\"earliest\"用于未挖出的交易。 toBlock: QUANTITY|TAG - 可选，默认值:\"latest\"。整数块编号，或字符串\"latesr\"表示最后挖出的块，\"pending\"或\"earliest\"用于未挖出的交易。 address: DATA|Array, 20 字节 - 可选，合约地址或生成日志的一组地址 topics: Array of DATA, - 可选，32字节主题数组，每个主题可以是数组或使用or选项连接 返回值 Array, 日志对象数组，如果没有新生成的日志，则返回空数组。 使用eth_newBlockerFilter创建的过滤器将返回块哈希(32 字节)，例如[\")x3454645634534\"]。 使用eth_newPendingTransactionFilter创建的过滤器将返回交易哈希 (32 字节)，例如[\"0x6345343454645...\"]。 使用eth_newFilter创建的过滤器，日志对象具有如下数参数： removed: TAG - 如果日志已被删除则返回 true，如果是有效日志则返回false logIndex: QUANTITY - 日志在块内的索引序号。对于挂起日志，该值为 null transactionIndex: QUANTITY - 创建日志的交易索引序号，对于挂起日志，该值为 null transactionHash: DATA, 32 字节 - 创建该日志的交易的哈希。对于挂起日志，该值为 null blockHash: DATA, 32 字节 - 该日志所在块的哈希。对于挂起日志，该值为null blockNumber: QUANTITY - 该日志所在块的编号。对于挂起日志，该值为 null address: DATA, 20 字节 - 该日志的源地址 data: DATA - 包含该日志的一个或多个 32 字节无索引参数 topics: Array of DATA -0~4 个 32 字节索引日志参数的数据。在 solidity 中，第一个主题是事件签名，例如 Deposit(address,bytes32,uint256)，除非你声明的是匿名事件 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getLogs\",\"params\":[{\"topics\":[\"0x0000 00000000000000000000a94f5374fce5edbc8e2a8697c15331677e6ebf0b\"]}],\"id\":74}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": [{ \"logIndex\": \"0x1\", // 1 \"blockNumber\":\"0x1b4\", // 436 \"blockHash\": \"0x8216c5785ac562ff41e2dcfdf5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"transactionHash\": \"0xdf829c5a142f1fccd7d8216c5785ac562ff41e2dcfdf5785ac562f f41e2dcf\", \"transactionIndex\": \"0x0\", // 0 \"address\": \"0x16c5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"data\":\"0x0000000000000000000000000000000000000000000000000000000000000 000\", \"topics\": [\"0x59ebeb90bc63057b6515673c3ecf9438e5058bca0f92585014eced636878c9a5\"] },{... }] } eth_getWork 返回当前块的哈希、seedhash和要满足的边界条件 参数 无 返回值 DATA, 32 字节 - 当前块头的 pow-hash DATA, 32 字节 - 用于 DAG 的种子哈希 DATA, 32 字节 - 边界条件，目标， 2^256 / difficulty //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getWork\",\"params\":[],\"id\":73}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": [ \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\", \"0x5EED00000000000000000000000000005EED0000000000000000000000000000\", \"0xd1ff1c01710000000000000000000000d1ff1c01710000000000000000000000\" ] } eth_submitWork 用于提交POW解决方案。 参数 DATA, 8 字节 - nonce，64 位 DATA, 32 字节 - 头部的 pow 哈希，256 位  DATA, 32 字节 - 混合摘要，256 位 返回 Boolean, 如果提交的方案有效则返回true，否则返回false //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\", \"method\":\"eth_submitWork\", \"params\":[\"0x000000 0000000001\", \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890a bcdef\", \"0xD1GE5700000000000000000000000000D1GE5700000000000000000000000 000\"],\"id\":73}' //Response { \"id\":73, \"jsonrpc\":\"2.0\", \"result\": true } eth_submitHashrate 用于提交挖矿的哈希速率。 参数 hashRate - 哈希速率，采用 16 进制字符串表示，32 字节 ID, String - 随机 16 进制字符串，32 字节，用于标识客户端的编号 返回 Boolean, 如果提交成功则返回 true，否则返回 false 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\", \"method\":\"eth_submitHashrate\", \"params\":[\"0x000 0000000000000000000000000000000000000000000000000000000500000\", \"0x59daa2 6581d0acd1fce254fb7e85952f4c09d0915afd33d3886cd914bc7d283c\"],\"id\":73}' //Response { \"id\":73, \"jsonrpc\":\"2.0\", \"result\": true } eth_blockNumber 返回最新块的编号。 参数 无 返回值 QUANTITY, 节点当前块编号 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":83}' //Response { \"id\":83, \"jsonrpc\": \"2.0\", \"result\": \"0x4b7\" // 1207 } "},"23_crossChainApi.html":{"url":"23_crossChainApi.html","title":"Cross-chain API","keywords":"","body":"跨链API接口列表 eth_ctxQuery eth_ctxOwner eth_ctxOwnerByPage eth_ctxContent eth_ctxContent eth_getRemoteCtx eth_ctxStats eth_poolStats JSON-RPC Endpoint Default JSON-RPC endpoints: Client URL Go http://localhost:8545 eth_ctxQuery 通过TxHash跨链交易单。 参数 DATA, 32个字节 - 交易的哈希 返回 value: QUANTITY, 交易数额。 ctxId: DATA, 32个字节- 该交易ID。 txHash: DATA 32个字节- 交易的哈希。 from: DATA, 20个字节 -交易发送者的地址 blockHash: DATA, 32个字节- 该交易所在的区块的哈希。 destinationId: QUANTITY - 跨链目的链ID。 destinationValue: QUANTITY, 目的链币种数额 input: DATA, 交易的input数据。 v: Array - 交易多签V值数组。 r: Array - 交易多签R值数组。 s: Array - 交易多签S值数组。 示例 //request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxQuery\",\"params\":[\"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\"],\"id\":67}' //response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } } eth_ctxOwner 通过跨链发起人查询交易列表。 参数 ADDRESS, 20个字节 - 交易的发起地址 返回 local: 本地跨链列表 time: 跨链交易所在区块的时间戳 value: QUANTITY, 交易数额。 ctxId: DATA, 32个字节- 该交易ID。 txHash: DATA 32个字节- 交易的哈希。 from: DATA, 20个字节 -交易发送者的地址 blockHash: DATA, 32个字节- 该交易所在的区块的哈希。 destinationId: QUANTITY - 跨链目的链ID。 destinationValue: QUANTITY, 目的链币种数额 input: DATA, 交易的input数据。 v: Array - 交易多签V值数组。 r: Array - 交易多签R值数组。 s: Array - 交易多签S值数组。 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxOwner\",\"params\":[\"0x3db32cdacb1ba339786403b50568f4915892938a\"],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"local\": { \"221\": [ { \"value\": \"0xde0b6b3a7640000\", \"status\": 0, \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"time\": \"0x5ebb9cd2\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } ] } } } eth_ctxOwnerByPage 通过跨链发起人查询交易列表。 参数 ADDRESS, 20个字节 - 交易的发起地址 PAGESIZE, 每页的交易数量 STARTPAGE, 从第几页开始(初始页为第0页) 返回 data:OBJECT - 本地跨链列表: time: 跨链交易所在区块的时间戳 value: QUANTITY, 交易数额。 ctxId: DATA, 32个字节- 该交易ID。 txHash: DATA 32个字节- 交易的哈希。 from: DATA, 20个字节 -交易发送者的地址 blockHash: DATA, 32个字节- 该交易所在的区块的哈希。 destinationId: QUANTITY - 跨链目的链ID。 destinationValue: QUANTITY, 目的链币种数额 input: DATA, 交易的input数据。 v: Array - 交易多签V值数组。 r: Array - 交易多签R值数组。 s: Array - 交易多签S值数组。 total:QUANTITY - 总交易数量 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxOwner\",\"params\":[\"0x3db32cdacb1ba339786403b50568f4915892938a\"],\"id\":67}' //Respinse { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"data\": { \"221\": [ { \"value\": \"0xde0b6b3a7640000\", \"status\": 0, \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"time\": \"0x5ebb9cd2\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } ] }, \"total\": 1 } } eth_ctxContent 返回当前所有跨链交易单。 参数 无 返回 local - 本地链跨链交易列表 remote - 跨链目的链交易列表 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxContent\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"local\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } ] }, \"remote\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0xf9747951a56fb6392d1c2bddedf5f9cb0f380a43ac7e6345aa2fea73646e14d6\", \"txHash\": \"0x43f6150c0c308d2b5325f4f6f5820f00862a14beb2e961780eec518b4f6497c1\", \"from\": \"0x8029fcfc954ff7be80afd4db9f77f18c8aa1ecbc\", \"blockHash\": \"0x5391c792a14a3ec6be49201dbbf6a023fbb03025e0c600990107276dc3574ff5\", \"destinationId\": \"0xdd\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0xb003\", \"0xb003\" ], \"r\": [ \"0xae8928d14f2d6389803e29d94be0c1a7ef517818cf1a8a2305b282fb9f7cbf68\", \"0xb7d137e78069d4d2ad39940a4d2a82363fbff32920125853c5feef0b87e91cb4\" ], \"s\": [ \"0x7ab9cd7f753f4fc1c89a66df1ef8cf6d3c37aaa678164bb4df3fed8b19fc234f\", \"0x6d36ffed2dcf26278518def89a92e01b74f81e2ff12ecb29b0fc2b49db70566b\" ] } ] } } } eth_ctxContentByPage 分页返回当前所有跨链交易单。 参数 LOCALSIZE, - 本地跨链列表每页条数。 LOCALPAGE, - 本地跨链列表从第几页开始(初始页为第0页)。 REMOTESIZE, - 远端跨链列表每页条数。 REMOTEPAGE, - 远端跨链列表从第几页开始(初始页为第0页)。 返回 local - 本地链跨链交易列表 remote - 跨链目的链交易列表 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxContentByPage\",\"params\":[1,0,1,0],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"local\": { \"data\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } ] }, \"total\": 1 }, \"remote\": { \"data\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0xf9747951a56fb6392d1c2bddedf5f9cb0f380a43ac7e6345aa2fea73646e14d6\", \"txHash\": \"0x43f6150c0c308d2b5325f4f6f5820f00862a14beb2e961780eec518b4f6497c1\", \"from\": \"0x8029fcfc954ff7be80afd4db9f77f18c8aa1ecbc\", \"blockHash\": \"0x5391c792a14a3ec6be49201dbbf6a023fbb03025e0c600990107276dc3574ff5\", \"destinationId\": \"0xdd\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0xb003\", \"0xb003\" ], \"r\": [ \"0xae8928d14f2d6389803e29d94be0c1a7ef517818cf1a8a2305b282fb9f7cbf68\", \"0xb7d137e78069d4d2ad39940a4d2a82363fbff32920125853c5feef0b87e91cb4\" ], \"s\": [ \"0x7ab9cd7f753f4fc1c89a66df1ef8cf6d3c37aaa678164bb4df3fed8b19fc234f\", \"0x6d36ffed2dcf26278518def89a92e01b74f81e2ff12ecb29b0fc2b49db70566b\" ] } ] }, \"total\": 2 } } } eth_getLocalCtx 分页获取本地跨链交易列表。 参数 PAGESIZE, 每页的交易数量 STARTPAGE, 从第几页开始(初始页为第0页) 返回 data:OBJECT - 本地跨链列表: value: QUANTITY, 交易数额。 ctxId: DATA, 32个字节- 该交易ID。 txHash: DATA 32个字节- 交易的哈希。 from: DATA, 20个字节 -交易发送者的地址 blockHash: DATA, 32个字节- 该交易所在的区块的哈希。 destinationId: QUANTITY - 跨链目的链ID。 destinationValue: QUANTITY, 目的链币种数额 input: DATA, 交易的input数据。 v: Array - 交易多签V值数组。 r: Array - 交易多签R值数组。 s: Array - 交易多签S值数组。 total:QUANTITY - 总交易数量 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getLocalCtx\",\"params\":[1,0],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"data\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } ] }, \"total\": 1 } } eth_getRemoteCtx 分页获取本地跨链交易列表。 参数 PAGESIZE, 每页的交易数量 STARTPAGE, 从第几页开始(初始页为第0页) 返回 data:OBJECT - 本地跨链列表: value: QUANTITY, 交易数额。 ctxId: DATA, 32个字节- 该交易ID。 txHash: DATA 32个字节- 交易的哈希。 from: DATA, 20个字节 -交易发送者的地址 blockHash: DATA, 32个字节- 该交易所在的区块的哈希。 destinationId: QUANTITY - 跨链目的链ID。 destinationValue: QUANTITY, 目的链币种数额 input: DATA, 交易的input数据。 v: Array - 交易多签V值数组。 r: Array - 交易多签R值数组。 s: Array - 交易多签S值数组。 total:QUANTITY - 总交易数量 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getRemoteCtx\",\"params\":[1,0],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"data\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0xf9747951a56fb6392d1c2bddedf5f9cb0f380a43ac7e6345aa2fea73646e14d6\", \"txHash\": \"0x43f6150c0c308d2b5325f4f6f5820f00862a14beb2e961780eec518b4f6497c1\", \"from\": \"0x8029fcfc954ff7be80afd4db9f77f18c8aa1ecbc\", \"blockHash\": \"0x5391c792a14a3ec6be49201dbbf6a023fbb03025e0c600990107276dc3574ff5\", \"destinationId\": \"0xdd\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0xb003\", \"0xb003\" ], \"r\": [ \"0xae8928d14f2d6389803e29d94be0c1a7ef517818cf1a8a2305b282fb9f7cbf68\", \"0xb7d137e78069d4d2ad39940a4d2a82363fbff32920125853c5feef0b87e91cb4\" ], \"s\": [ \"0x7ab9cd7f753f4fc1c89a66df1ef8cf6d3c37aaa678164bb4df3fed8b19fc234f\", \"0x6d36ffed2dcf26278518def89a92e01b74f81e2ff12ecb29b0fc2b49db70566b\" ] } ] }, \"total\": 2 } } eth_ctxStats 获取跨链交易条数。 参数 无 返回 local: - 本地跨链条数: remote: - 远程链跨链条数: 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxStats\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"local\": 1, \"remote\": 2 } } eth_poolStats 获取跨链待确认交易池交易条数。 参数 无 返回 pending: - 本地已确认跨链条数: queue: - 远程同步跨链条数: 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_poolStats\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"pending\": 0, \"queue\": 0 } } "},"24_chromeWallet/":{"url":"24_chromeWallet/","title":"SimPlug","keywords":"","body":"Download wallet Download Plug-In wallet download address Decompression Install wallet 1.Open google browser, open the extension program 2.Install the installation package into the extension program 3.Open the wallet after installation 4.Open the wallet and select the main network or test network. If there is already a wallet, import it directly. If there is no account, create an account directly. 5.Create an account and back up the private key to enter your plug-in wallet. Wallet call method Preconditions Applications that need to run the plug-in (hereinafter referred to as developers) determine whether the plug-in is available according to window.hasSimplug. Developers need to place a button with the id \"run_contract_btn\" in the page to trigger the simplug event. Developers need to place a hidden input with the id \"run_contract_data\" in the page to send transaction data to sumpulg. Operation process The user clicks or the script triggers a button with the id \"run_contract_btn. At the same time, developers need to set the input value with id \"run_contract_data\" to the data to be sent. The plug-in automatically wakes up the call transaction. "},"25_sdk/":{"url":"25_sdk/","title":"SDK","keywords":"","body":"SimpleChainblockchain exposes interfaces to the outside world. External business programs can call these interfaces through the SDK provided by SimpleChain. Developers only need to select the SDK of the corresponding language according to the requirements of their own business programs, and use the API provided by the SDK to program, to implement the operation of the blockchain. Docking application Currently, the functions that the SDK interface can implement include (but are not limited to): Contract operation Contract compilation, deployment, and query Transaction sending, chain notification, parameter parsing, and receipt parsing Chain Management Chain status query and chain parameter settings Team member management Permission settings Multi-language SDK Currently, the SDK provided by SimpleChain includes: Java SDK（stable and powerful) Python SDK（simple and protable） Node-js SDK（simple and protable） "},"48_crossChain/":{"url":"48_crossChain/","title":"Cross-chain solution","keywords":"","body":"Free notary mechanism Cross-chain interaction can be divided into homogeneous chain cross-chain and heterogeneous chain cross-chain according to the different underlying technology platforms of the blockchain: security mechanism between homogeneous chains, consensus algorithm, network topology, the block generation validation logic is consistent, and the cross-chain interaction between them is relatively simple. The cross-chain interaction of heterogeneous chains is relatively complex, suchSimplechain using PoW algorithm and EOS using POS consensus algorithm, the composition form of the two blocks and the certainty guarantee mechanism are very different, and the direct cross-chain interaction mechanism is not easy to design. Cross-chain interaction between heterogeneous chains generally requires third-party auxiliary services to assist cross-chain interaction. Therefore, when designing cross-chain solutions, we need to design a set of synthesis Compare the current mainstream cross-chain solutions and the comprehensive performance of cross-chain solutions, and consider the later upgrade of the solution. Simplechain technical team has designed its own cross-chain scheme on the notary mechanism-the free notary mechanism. Why is this cross-chain technical solution selected? In the mode of \"Notary Public\", the single \"notary public\" mechanism operates in a relatively centralized way, because the efficiency requirement of \"notary public\" mechanism is higher than that of decentralization, this leads to obvious black-box risks in a single notary system. But we Simplechain the \"free notary mechanism\" of precisely makes up for the defects of the \"notary\" mechanism. It adds mortgage and corresponding punishment mechanism to the process of selecting trusted nodes in different block chain platforms. If a node does evil, it will be punished accordingly, and the \"notary\" in the network will be automatically replaced by the new notary. Therefore, the free notary mechanism can effectively ensure the complete decentralization, efficiency and safety of the whole cross-chain process. If the main target of the early cross-chain solution was asset transfer, the cross-chain solution of SIPC was not only asset transfer, but also focused on cross-chain infrastructure. It mainly emphasizes that assets can be realized through smart contracts. The cross-chain technology of SIPC is determined to become a high-performance and decentralized cross-chain infrastructure. It also accesses various cross-chain applications and focuses on commercial implementation. This cross-chain solution enables SIPC to have strong advantages in financial fields, Government chains, and enterprise blockchain solutions, helping the SIPC technology ecosystem become a set of industry blockchain solutions. The following is the structure diagram of SimpleChain cross-chain solution: The cross-chain structure includes a notary mechanism. The Master and sub-chains realize efficient communication and cross-chain assets through the notary mechanism. For example, you can write the block header information of the SimpleChain main chain into the block of the SimpleChain sub-chain. The SimpleChain main chain and the SimpleChain sub-chain use the same consensus verification method to achieve communication between the two chains. Through the notary mechanism, a trusted distributed node (notary/node1 or notary/node2) is used to record transactions on the SimpleChain sub-chain to prove that transactions have occurred on the SimpleChain main chain. Cross-chain interaction of assets is realized through communication. Simply speaking, the SimpleChain main chain and the SimpleChain sub-chain use shared-trusted distributed nodes (node1 or node2) as notaries. The SimpleChain main chain and the SimpleChain sub-chain can be trusted indirectly to complete asset exchange. The following figure shows the flow chart of SimpleChain cross-chain transactions: The cross-chain transaction process is as follows: Step 1: subnet User A makes coins to cross-chain transaction contracts. A. You need to pay the TPC to the subnet miner and pre-charge the transaction fee for step 5. Step 2: anchor the miner group synchronization block, identify the transaction chain in step 1, and initiate and complete multiple signatures after the transaction is confirmed to form valid multiple signatures. Step 3: User B receives the multiple signature message in step 2 and sends a transaction order to the cross-chain contract. The order-receiving transaction contains the Multi-sign broadcast information, and the transaction requires B to pay the online handling fee to the master network miner. After the transaction is confirmed, A obtains the main network currency. Step 4: anchor the miner group synchronization block, identify the transaction chain in step 3, and send instructions to the subnet process after the transaction is confirmed. Step 5: After receiving the instruction in step 4, the anchor miner subnet process initiates a transaction to the cross-chain contract and completes multiple signatures in the contract. B obtained after transaction confirmationTPC。 Advantages of \"free and fair man\" mechanism The advantages of the SIPC cross-chain solution are as follows: (1) Decentralization Anchor nodes are distributed in the blockchain distributed network, using multiple signatures to reach a consensus The anchor node group is open to the public. Common nodes can apply to become anchor nodes to provide services for cross-chain transactions; At the same time, cancel the identity qualification and punish the anchor nodes that have been cheated. (2) open and transparent Based on direct transactions on the blockchain, data is open, transparent, traceable, and verifiable; Cross-chain programs are open-source, and the community can spontaneously organize deployment to participate in service competition and support for cross-chain transactions. Blocks are anchored to each other and data across the network is interconnected; Regular statistical analysis to publish business data results of cross-chain transactions (3) easy to operate Cross-chain wallet one-stop management of all assets on the chain; The cross-chain transaction operation of the imitation exchange conforms to the user's habits and has a large user base; To complete a cross-chain transaction, the user only needs one operation; The transaction cost is low, and only 0.01Token is required for a cross-chain transaction; (4) safe and reliable Realize reliable data transmission based on decentralized multiple signature technology; The signature uses an elliptic curve key to sign. Is it a big crack The downtime of some anchor nodes does not affect the normal operation of cross-chain transactions; The interaction between chains is simple and the transaction efficiency is high. (5) strong expandability Cross-chain technology supports many-to-many cross-chain deployment and enables resource intercommunication among multiple chains; Based on this cross-chain technology, the sub-chain can be released infinitely and integrated into the chain ecosystem; Many sub-chain templates adopt mainstream consensus protocols to meet different business needs; "},"26_smallChain.html":{"url":"26_smallChain.html","title":"Subchain template","keywords":"","body":"Deploy DPOS consensus sub-chain network 1. Genesis block { \"config\": { \"chainId\": 10388, \"dpos\": { \"period\": 3, \"epoch\": 300, \"maxSignersCount\": 21, \"minVoterBalance\": 100000000000000000000, \"genesisTimestamp\": 1554004800, \"signers\": [ \"3d50e12fa9c76e4e517cd4ace1b36c453e6a9bcd\", \"f97df7fe5e064a9fe4b996141c2d9fb8a3e2b53e\", \"ef90068860527015097cd031bd2425cb90985a40\" ], \"pbft\": false, \"voterReward\": true } }, \"nonce\": \"0x0\", \"timestamp\": \"0x5ca03b40\", \"extraData\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"gasLimit\": \"0x47b760\", \"difficulty\": \"0x1\", \"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"alloc\": { \"3d50e12fa9c76e4e517cd4ace1b36c453e6a9bcd\": { \"balance\": \"0x21e19e0c9bab2400000\" }, \"ef90068860527015097cd031bd2425cb90985a40\": { \"balance\": \"0x21e19e0c9bab2400000\" }, \"f97df7fe5e064a9fe4b996141c2d9fb8a3e2b53e\": { \"balance\": \"0x21e19e0c9bab2400000\" } }, \"number\": \"0x0\", \"gasUsed\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\" } period dpos block-out interval, in seconds epoch How many blocks are there in the dpos interval to regularly clear the votes (after clearing, the voters need to re-initiate the voting transaction) maxSignersCount Maximum number of producers allowed for dpos minVoterBalance The minimum amount of votes allowed by dpos. Unit: Wei voterReward Whether dpos voters can get rewards (if enabled, voters can also get dividends when producers issue blocks) genesisTimestamp dpos allows the initial block output time, and calculates the subsequent block output time and the producer based on this time. signers dpos initial producer list pbft Whether dpos uses pbft to confirm each block after each round of block output alloc dpos initial producer mortgage vote amount 2. Sub-chain initialization process Method 1. Use sipe to initialize 1.Create or import a producer account ```shell script sipe --datadir=dposdata account new 2.Write the created or imported producer address into genesis.json, and write the initial voting amount at the same time (refer to 1. genesis block) 3.Initialize sub-chain nodes ```shell script sipe --datadir=dposdata --role=subchain init genesis.json Method 2. Use the consensus tool to initialize the cluster with one click in cmd/consensus run under directoryinit_dpos.sh ```shell script cd cmd/consensus ./init_dpos.sh --numNodes 3 + `numNodes` Number of cluster nodes generated After initialization is completed `cmd/consensus/dposdata` create corresponding node files under the Directory ### 3. Sub-chain startup process 1. Startup node ```bash sipe --datadir=dposdata --mine --etherbase= --unlock= --password= --port=30303 --role=subchain --v5disc Connect to other nodes sipe --datadir=dposdata --mine --etherbase= --unlock= --password= --port=30304 --role=subchain --v5disc --bootnodesv5={enode1} --bootnodesv4={enode1} 4. Votes and proposals 4.1 initiate voting transaction > eth.sendTransaction({from:\"\",to:\"\",value:0,data:web3.toHex(\"dpos:1:event:vote\")}) 4.2 initiate the cancellation of voting transaction > eth.sendTransaction({from:\"\",to:\"\",value:0,data:web3.toHex(\"dpos:1:event:devote\")}) 4.3 initiate a proposal to change miner rewards Change the miner block reward ratio666‰ > eth.sendTransaction({from:\"\",to:\"\",value:0,data:web3.toHex(\"dpos:1:event:proposal:proposal_type:3:mrpt:666\")}) 4.4 initiate a proposal to change the minimum allowed vote limit Change the minimum allowed vote limit 10 ether > eth.sendTransaction({from:\"\",to:\"\",value:0,data:web3.toHex(\"dpos:1:event:proposal:proposal_type:6:mvb:10\")}) 4.5 pass or oppose the proposal yes through the proposal,no objection proposal > eth.sendTransaction({from:\"\",to:\"\",value:0,data:web3.toHex(\"dpos:1:event:declare:hash::decision:yes\")}) 5. View consensus status > dpos.getSnapshot() candidates Miner candidate list confirmedNumber Confirmed block height historyHash The block hash of the last two rounds of block output, which is used to calculate the block output order of the producer in the new round. minerReward The reward percentage of each block producer, if enabled voterReward , the rest is the reward of voters signers List producers and block order punished List the punishment information of each producer for not releasing blocks on time tally List the total votes of each candidate votes List voting information voters The height of the block where the voters vote proposals Proposal list Deploy PBFT consensus sub-chain network 1. Genesis block { \"config\": { \"chainId\": 10388, \"istanbul\": { \"epoch\": 30000, \"policy\": 0 } }, \"nonce\": \"0x0\", \"timestamp\": \"0x0\", \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000000000000f843f83f941c46d10e91eafaac430718df3658b1a496b827bd94b67ee9395542b227c99941eb4168e3f3c6502dd8949d6510b637970085962c908c69e63e9d36a36cb480c0\", \"gasLimit\": \"0xe0000000\", \"difficulty\": \"0x1\", \"mixHash\": \"0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"alloc\": {}, \"number\": \"0x0\", \"gasUsed\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\" } epoch How many blocks are there at pbft intervals to regularly clear votes policy The polling method of pbft proposer: 0 is roundRobin (replaced in order), and 1 is sticky (if the proposer is not wrong, do not replace the proposer) mixHash pbft block shall mixhash specified as 0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365 extraData header.extra calculated by the initial pbft producer alloc pbft does not have a block reward currently, so tokens need to be allocated in advance. 2. Sub-chain initialization process Method 1. Use sipe to initialize 1.Create or import a producer account ```shell script sipe --datadir=pbftdata account new 2.Use the consensus tool to generate extraData and write it to genesis.json (refer to 1. genesis block) ```shell script cd cmd/consensus ./init_pbft.sh --numNodes 1 --validator 3.Initialize sub-chain nodes ```shell script sipe --datadir=pbftdata --role=subchain init genesis.json 4.Write the node's nodekey to pbftdata/static-nodes.json (the nodekey public key is the producer public key) #### Method 2. Use the consensus tool to initialize the cluster with one click Run init_pbft.sh in the cmd/consensus Directory ```bash cd cmd/consensus ./init_pbft.sh --numNodes 3 --ip 127.0.0.1 127.0.0.2 127.0.0.3 --port 21001 21002 21003 numNodes Number of cluster nodes generated ip List of ip addresses of the specified node (the default ip address is 127.0.0.1) port The list of ports for the specified node. The default port is 21001 ~ 2100x, and x is numNodes. After initialization is completedcmd/consensus/pbftdataCreate corresponding node files under the Directory 3. Sub-chain startup process sipe --datadir=pbftdata --istanbul.requesttimeout=10000 --istanbul.blockperiod=5 --syncmode=full --mine --minerthreads=1 --port=21001 --role=subchain port Must be consistent with the enode configured in static-nodes.json istanbul.requesttimeout The expiration time of each view in milliseconds. The default value is 10000. istanbul.blockperiod pbft block output interval, in seconds, the default value is 1 4.View consensus status ```shell script istanbul.getSnapshot() ``` validators pbft Block producer list votes Votes for adding or removing validators tally Total voting situation Deploy RAFT consensus sub-chain network 1. Genesis block { \"config\": { \"chainId\": 10, \"raft\": true }, \"nonce\": \"0x0\", \"timestamp\": \"0x0\", \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"gasLimit\": \"0xe0000000\", \"difficulty\": \"0x0\", \"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"alloc\": { \"1e69ebb349e802e25c7eb3b41adb6d18a4ae8591\": { \"balance\": \"0x21e19e0c9bab2400000\" }, \"73ce1d55593827ab5a680e750e347bf57485a511\": { \"balance\": \"0x21e19e0c9bab2400000\" }, \"b8564a5657fa7dc51605b58f271b5bafad93b984\": { \"balance\": \"0x21e19e0c9bab2400000\" } }, \"number\": \"0x0\", \"gasUsed\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\" } raft true indicates the use of raft consensus alloc The raft consensus packages blocks only when a transaction exists. Therefore, tokens need to be allocated in advance. 2. Sub-chain initialization process Method 1. Use sipe to initialize 1.Create or import a producer account sipe --datadir=raftdata account new 2.Initialize sub-chain nodes sipe --datadir=raftdata --role=subchain init genesis.json 4.nodekey Write raftdata/static-nodes.json (The nodekey public key is the producer public key) Method 2. Use the consensus tool to initialize the cluster with one click under cmd/consensuRun under the Directorinit_pbft.sh cd cmd/consensus ./init_raft.sh --numNodes 3 --ip 127.0.0.1 127.0.0.2 127.0.0.3 --port 21001 21002 21003 --raftport 50401 50402 50403 numNodes Number of cluster nodes generated ip List of ip addresses of the specified node (the default ip address is 127.0.0.1) port The list of ports for the specified node. The default port is 21001 ~ 2100x, and x is numNodes. raftport List of raft communication ports for the specified node (the default port is 50401 ~ 5040x, and x is numNodes) After initialization, the corresponding node file is created in the cmd/consensus/raftdata directory. 3. Sub-chain startup process sipe --datadir=raftdata --raft --port=21001 --raftport=50401 --role=subchain port Must be consistent with the enode configured in static-nodes.json raft Use raft mode raftport raft port number, which must be consistent with the enode configured in static-nodes.json 4.View consensus status > istanbul.getSnapshot() validators pbft Block producer list votes Votes for adding or removing validators tally Total voting situation "},"49_crossChainOrder/":{"url":"49_crossChainOrder/","title":"Cross-chain process","keywords":"","body":"Simplechain is a hybrid public chain with a master and sub-chain architecture. Cross-platform migration of assets between different chains involves cross-chain operations. The following is a detailed cross-chain process: Download ChainBox Download the corresponding according to your mobile device system ChainBox Installation package, keep your private key after registering your wallet. Find the wallet address and copy the wallet address. As shown below: Get test assets Turn on the tap, tap address: Test network faucet Enter the wallet address copied in the previous step into the tap, and you can receive the test currency. As shown below: Cross-chain transactions Cross-chain entry Open the wallet and enter the homepage. All the coins and their discount of the wallet in the chain ecosystem are displayed in the wallet assets (as shown in the following figure) Click a wallet asset (TEST) to enter the main chain transaction page (as shown in the following figure) Click the \"cross-chain\" button in the above figure to enter the transaction pair selection interface (as shown in the following figure). Only one transaction pair is provided here. Click SUB enter the cross-chain trading market. The cross-chain list in the following figure shows the orders between the main chain and the sub-chain. The red unit price records the orders sent from the main chain to the sub-chain, and the green unit price records the orders sent from the sub-chain to the main chain. The cross-chain list is arranged by unit price from high to low. For more records, click the Tab page. receive transaction andSend transaction listQuery and display. The current delegation page displays the cross-chain transaction orders that the current account participates in. Click all you can display all commissioned orders and historical cross-chain transactions. Order receiving: Click to receive an order in the red wirebox above to clinch a cross-chain transaction. This transaction means that you sell one TEST and get 10 SUB at the unit price of 0.1SUB/TEST. See the following figure After entering the wallet password, click \"confirm\" to send out an on-chain transaction. The transaction can be completed after the transaction is confirmed (about 6 minutes). Click \"all\"-> \"history\" to see the cross-chain transaction records that have just been closed, as shown in the following figure: View transaction details in the browser View cross-Chain records: View transaction details: Browser view details: Returning to the homepage of the wallet, I found that the SUB-chain coins have increased by 10 SUB-chains, and the handling fee is 0.001 TEST, which is far less than the handling fee rate of 0.2% of that of ordinary exchanges. Billing Click the \"issue\" button in the cross-chain trading market to enter the issue process. Click \"next\", enter the password and click \"confirm\". After the transaction is sent successfully and the transaction is confirmed (about 3 minutes), we can find that a new record has been added to the current delegation page of the account. At this moment, all users in the network can query the delegation, indicates that the order is issued successfully. User'sTESTReduce 1 related orders Select the commission record above and click \"withdraw order\" to enter the withdraw order process. Enter the password and click \"confirm\" to send the transaction. After the transaction is confirmed (about 6 minutes). The user delegation list is empty, and a new withdraw record is added to the history. Back to the home page, the TEST that has just been reduced has also returned. "},"27_dappFlow/":{"url":"27_dappFlow/","title":"Dapp process carding","keywords":"","body":"The Dapp development case is to develop a public-benefit crowdfunding project based on Simplechain. The following is a review of the development process of the entire crowdfunding project. Write a contract and test it in remix Download and Install remix , and try to write the contract method. And conduct tests. Create an empty project for React The empty project of The React creation mainly contains two commands. First, install create-react-app This command: install create-react-app It installs the directory on which your node depends and creates the project: ./create-react-app After creating a project, you can use the following command to initialize the project: npm run start Create a comple.js file Create the compile.js file and install the solc compiler. The command is as follows: npm install solc After solc is installed, you can call solc.com pile(sourceCode,1) to compile the source code. After compilation, export the compiled bytecode (bytecode),interface. Create a js file To build an interface, call web3, and interact with the blockchain, you need to use the js method. Therefore, you need to create multiple js files in this step. The following figure shows the specific js file to be created: Initiate contract function The function of initiating a contract mainly has two specific logics to implement. One is to write specific methods in interaction, and the other is to complete the call in CreateFundingTab. Initiate and participate in crowdfunding There are three main implementation functions of initiating and participating in crowdfunding. One is as follows: Pass a callback function onItemClick to CardList in the main interface to return the details of the contract clicked by the user. Pass to MyCard in CardList In MyCard, when onClick is triggered, the onItemClick is called and the corresponding detail is returned. The address of the contract and the supported amount can be obtained through the above three-step method. The second is to write specific methods in interaction, and the last is to complete the call in CreatorFundingTab. The figure is as follows: "},"28_editor.html":{"url":"28_editor.html","title":"translater","keywords":"","body":"Remix We recommend that you use Remix to develop simple contracts and quickly learn Solidity Remix it can be used online without installing anything. If you want to use it offline, press https://github.com/ethereum/browser-solidity/tree/gh-pages download the zip file to use. This page provides further details on how to install the Solidity command line compiler on your computer. If you are just dealing with large contracts or need more compilation options, you should choose to use the command line compiler solc. npm / Node.js Use npm can easily install the Solidity compiler solcjs. But solcjs function of the program is less than all other options below this page. In commandline-compiler chapter, we assume that you are using a full-featured compiler. So if you are from npm installation solcjs ，jump directly solc-js understand . Note: The solc-js project uses Emscripten to compile from the solc version of the C version to JavaScript across platforms. Therefore, solcjs (like Remix) can be used in JavaScript projects. For more information, see the solc-js code library. npm install -g solc In the command, use solcjs not solc .solcjs command options are the same solc and some tools（such geth )is incompatible, so don't expect solcjs energy imagesolc work the same. Docker We provide the latest docker build for the compiler.stable published version is in the warehouse, nightlyrepository is a version with unstable changes in the development branch. docker run ethereum/solc:stable solc --version Currently, docker images only contain solc executable programs, so you need extra work to connect the source code with the output directory. Binary package Can be in solidity/releases download Solidity binary installation package. For Ubuntu, we also provide PPAs. You can obtain the latest stable version by using the following command: sudo add-apt-repository ppa:ethereum/ethereum sudo apt-get update sudo apt-get install solc Of course, you can also install an early version of the developer: sudo add-apt-repository ppa:ethereum/ethereum sudo add-apt-repository ppa:ethereum/ethereum-dev sudo apt-get update sudo apt-get install solc At the same time, it also provides installable All supported Linux versions downloaded snap package , You can obtain the latest stable version by using the following command: sudo snap install solc Or, if you want to test the latest changes under the develop branch, you can install the developer version as follows: sudo snap install solc --edge Similarly, Arch Linux Installation packages are also available, but only for the latest developer version: pacman -S solidity At the time of writing this article, Homebrew did not provide a pre-built binary package (because we migrated from Jenkins to TravisCI). We will provide the binary installation package under homebrew as soon as possible, but at least it works from the source code: brew update brew upgrade brew tap ethereum/ethereum brew install solidity If you need a specific version Solidity , you need to start from Github Install one on Homebrew formula, You can consult solidity.rb commits on Github submitted records, to find contains solidity.rb special submission of file changes. Then use brew install: brew unlink solidity # Install 0.4.8 brew install https://raw.githubusercontent.com/ethereum/homebrew-ethereum/77cce03da9f289e5a3ffe579840d3c5dc0a62717/solidity.rb Gentoo Linux the installation package is also provided below, which can be used emerge Install: emerge dev-lang/solidity Compile from source code Clone code library Run the following command to clone the source code: git clone --recursive https://github.com/ethereum/solidity.git cd solidity If you want to participate Solidity Development of, you can fork Solidity After the source code library, use your personal Fork Library as the second remote source: cd solidity git remote add personal git@github.com:[username]/solidity.git Solidity With Git Sub-modules, make sure they are fully loaded: git submodule update --init --recursive Prerequisite - macOS In macOS, make sure that the latest version is installed Xcode， Xcode contains Clang C++ compile， and Xcode IDE and other Apple development tools are OSX Compile C++ required for the application. If you have installed Xcode for the first time or just updated the new version of Xcode, you must agree to the use protocol of Xcode before using the command line to build: sudo xcodebuild -license accept Solidity is built under OS X. Install Homebrew Package Manager to install dependencies. If you want to start from scratch, here isMethod for uninstalling Homebrew Prerequisites - Windows In Windows build under Solidity , the dependency software package to be downloaded: Software Note Git for Windows_ C command line tool for obtaining source code from Github CMake_ Build a file generator across platforms Visual Studio 2017 Build Tools_ C compiler Visual Studio 2017_ (Optional) C++ Compiler and development environment If you already have IDE，only the compiler and related libraries are required, you can install Visual Studio 2017 Build Tools。 Visual Studio 2017 provider IDE and necessary compilers and libraries. So if you don't have one IDE and want to develop Solidity，then Visual Studio 2017 it will be a simple choice that allows you to get all the tools. Here is one in Visual Studio 2017 Build Tools or Visual Studio 2017 list of components to be installed in: Visual Studio C++ core features VC++ 2017 v141 toolset (x86,x64) Windows Universal CRT SDK Windows 8.1 SDK C++/CLI support External dependency On macOS, Windows, and other Linux distributions, there is a script that can install the required external dependencies with one click. It was originally a multi-step operation that requires manual participation, but now it only needs one line of command: ./scripts/install_deps.sh Run in Windows: scripts\\install_deps.bat Command line construction Make sure you have installed external dependencies (see above) Solidity uses CMake to configure the build. Linux, macOS, and other Unix systems are built in the same way: mkdir build cd build cmake .. && make There are also simpler ones: #note: 将安装 solc 和 soltest 到 usr/local/bin 目录 ./scripts/build.sh For Windows: mkdir build cd build cmake -G \"Visual Studio 15 2017 Win64\" .. The last sentence of this set of instructions will create a solidity.sln file. After double-clicking, Visual Studio is opened by default. We recommend that you create on RelWithDebugInfo configuration file. Or use the command to create: cmake --build . --config RelWithDebInfo CMake parameter If you are interested in the CMake command option, you can execute it cmake .. -LH view Detailed description of version number string The Solidity version name consists of four parts: Version number Pre-release version, usuallydevelop.YYYY.MM.DD or nightly.YYYY.MM.DD To commit.GITHASH submission number displayed in the format. Platform identification consisting of several platforms and compiler details If there is a local modification, the commit part has a suffix .mod。 These parts are combined according to the requirements of Semver. The pre-release version number of Solidity is equivalent to the pre-release version number of Semver. The Solidity submission number and platform identification form the build metadata of Semver. Release sample: 0.4.8+commit.60cc1668.Emscripten.clang. Pre-release layout sample: 0.4.9-nightly.2017.1.17+commit.6ecb4aa3.Emscripten.clang Version information details After the version is released, the patch version will increase because we assume that only patch-level changes will occur later. When changes are merged, the version should be adjusted according to semver and the intensity of the changes. Finally, the release version is always consistent with the version number of the current daily build version, but does not prerelease Indicator. for example: 0.4.0 release Version From now on, build version 0.4.1 every night Introduce non-destructive changes-do not change the version number Introduce disruptive changes-version jump to 0.5.0 Version 0.5.0 released This method and version pragma Run well together. "},"29_writeContract/":{"url":"29_writeContract/","title":"Write contract","keywords":"","body":"一. Project code management Project code base 二. Single crowdfunding contract implementation 1.Create empty contract CrowFunding Enter the item catalog and create the file basicFunding.sol And add the following code: pragma solidity ^0.4.24; contractCrowFunding { } 2.Basic attributes (state variables) State variable Type use creator address Project Initiation, responsible for contract creation, expense application, expense execution projectName string Name of the crowdfunding item supportBalance uint Crowdfunding holding amount targetBalance uint Crowdfunding project bid raising amount endTime uint Crowdfunding is cut off. If the amount of crowdfunding cannot be raised at this time, crowdfunding fails. 3.Constructor implementation pragma solidity ^0.4.24; contract CrowFunding { address public creator; // 发起人 string public projectName; // 项目名称 uint public supportBalance; // 参与众筹金额 uint public targetBalance; // 众筹目标金额 uint public endTime; // 众筹截止时间 constructor(string _projectName, uint _supportBalance, uint _targetBalance, uin t _durationInSeconds) public { creator = msg.sender; projectName = _projectName; supportBalance = _supportBalance; targetBalance = _targetBalance; //传递进来剩余的秒数，比如若众筹30天，则传入：30天 * 24小时 * 60分 * 60秒 = 2592000 endTime = now + _durationInSeconds; //2592000 } } Test 4.Participate in crowdfunding Implementation Add participant attributes address[] public investors; //people who participate in crowdfunding, namely investors Participating in crowdfunding means transferring money to the contract and adding the participants' addresses to the collection. The code is as follows: function invest() public payable { require(investorExistMap[msg.sender] == false);//每个人只能参与一次 require(msg.value == supportBalance); // 支持固定金额 investors.push(msg.sender); // 添加到众筹人数组中 investorExistMap[msg.sender] = true; // 标记当前账户为参与人 } In order to quickly verify whether an account is in an array of participants, we provide a mapping(address=>bool)to mark mapping the feature is that all keys exist by default, but the default value isfalse，if it does not exist, return false,we use the user address key,set the value true,to complete the index, mapping is a linear index, than using for loop traversal investors arrays are efficient and economical, so you need to add the following attributes: mapping(address => bool) public investorExistMap; //标记一个人是否参与了当前众筹 test Test, please operate in digital order after deployment Refund for crowdfunding failure (implementation) Refund means that all the money raised will be returned to investors one by one. Two auxiliary functions are added at the same time to facilitate testing. //众筹失败，退款 function drawBack() public { for (uint i = 0 ; i Test Cost request (implementation) Define structure If crowdfunding is successful and the project is started, a fee needs to be pointed out, which needs to include the following information: Purpose: What to buy? Cost: How much does it cost? Merchant address: from whom? Number of votes approved at present: how many people approve, more than half of them approve the expenditure Current status of this expense application: current status of this application: completed? To be approved? On behalf of the implementation? Mark the set of people who have voted: mapping(address =>bool), a mark set of people in favor, to prevent one person from voting for many times. Define the structure code based on the analysis: struct Request { string purpose; //买什么？ uint cost; //需要多少钱？ address shopAddress; // 向谁购买？ uint voteCount; // 多少人赞成了，超半数则批准支出 mapping(address => bool) investorVotedMap; //赞成人的标记集合，防止一人重复投票多次 RequestStatus status; //这个申请的当前状态：投票中？已批准？已完成？ } Define an enumeration to describe the application status: enum RequestStatus {Voting,Approved,Completed} Definition method This function is relatively simple. Create a new request structure and add it to the array. The code is as follows: Request[] public requests; //请求可能有多个，所以定义一个数组 function createRequest(string _purpose, uint _cost, address _shopAddress) public { Request memory request = Request({ purpose : _purpose, cost : _cost, shopAddress : _shopAddress, voteCount : 0, status : RequestStatus.Voting }); requests.push(request); //将新的请求添加至数组中 } Test In createRequest add parameters in: \"小胖子减肥\", 100, \"0xca35b7d915458ef540ade6068dfe2f44e8fa733c\" Search for the 0th request in the request, as shown in the following figure: Approval of payment application Implementation After the project Party initiates the application, it will be approved by the crowdfunding personnel, if the investors do not support it. Ignore it. The default value is false (not supported). If you want to support it, you need to perform an approval action. That is, modify the status of the data of the application structure, including: Check whether this person has voted. If not, vote is allowed. Otherwise, exit. voteCount data plus 1. Set the value of this voter's re-investorVotedMap mapping to true. The code is as follows: //批准⽀付申请 function approveRequest(uint256 index) public { // 1. 检验这个⼈是否投过票，若未投过，则允许投票，反之退出 // 2. voteCount数据加1。 // 3. 将该投票⼈在investorVotedMap映射中的值设置为true。 //⾸先要确保是参与众筹的⼈，否则⽆权投票 require(investExitMapping[msg.sender]); //根据索引找到特定的请求 Request storage req = requests[index]; //确保没有投过票，⼈⼿⼀票 require(req.investorVotedMap[msg.sender] == false); //如果已经完成，或者已经获得批准了，就不⽤投票了，当前投票不会影响决策。 require(req.status == RequestStatus.Voting); //⽀持票数加1 req.voteCount += 1; //标记为已投票 req.investorVotedMap[msg.sender] = true; if (req.voteCount * 2 > investors.length) { req.status == RequestStatus.Approved; } } Test View the request after approval, and the voteCount becomes 1 Complete expense request Implementation When more than half of the votes are voted, if the expenses are approved, the expenses can be executed by the project Party, or by the project Party, or by the contract automatically. We choose to execute it manually, because it is possible that the project Party changes and pays attention to it, and there is no need to purchase on the right side of the plan, so we transfer the rights to the project party. This function mainly does two things: 1.If the number of votes exceeds half, the transfer will be executed. 2.Update the status of the request Coding are as follows: function finalizeRequest(uint256 index) public onlyManager{ // 这个函数主要做两件事： // 1. 票数过半，则执⾏转账。 // 2. 更新request的状态。 Request storage req = requests[index]; //合约⾦额充⾜才可以执⾏ require(address(this).balance >= req.cost); //赞成⼈数过半 require(req.voteCount * 2 > investors.length); //转账 req.shopAddress.transfer(req.cost); //更新请求状态为已完成 req.status = RequestStatus.Completed; } Test Three people invest, one is in favor, two are against, and the execution of payment fails. ! Two people agree, the execution of the payment is successful To fully implement smart contracts, several methods need to be implemented and the mutual calling of contract methods. These can be learned directly from the source code. But the contract writing and testing are now in the above several basic methods. "},"30_frontRealize/":{"url":"30_frontRealize/","title":"Front-end development","keywords":"","body":"Initialize React project The front end is developed based on the React framework, so we first initialize the project. Initialize the project create-react-app funding-eth-react Streamline projects For the lottery project, only App.js and index.js are left under src, and the corresponding code is adjusted. import React, { Component } from 'react'; class App extends Component { render() { return ( Hello World ); } } export default App; Execute the following command: npm start Install dependency libraries npm install --save web3 npm install --save semantic-ui-react npm install --save semantic-ui-css Reference web3.js Implementation Create a folder named utils under src and create the file getWeb3.js internally import Web3 from 'web3'; let web3; if (typeof window.web3 !== 'undefined') { console.log('found injected web3'); web3 = new Web3(window.web3.currentProvider); } else { console.log('found local web3'); web3 = new Web3('http://localhost:7545'); } export default web3; Call crowdfunding contracts Deploy Funding to Simplechain test network Obtain the contract address: 0x8ff3a13157f1a0aa99beb84d393f1aac4dd470e3 Call Funding contract ABI Obtain a contract instance First, create the directory sipc under src and create the file contracts.js. The ABI format is in json format. You can copy the ABI to the address bar of the browser and format it into a row and then copy it back to save space. import web3 from '../utils/getWeb3'; //将ABI添加到这里 const fundingFactoryABI = [ { \"constant\": true, \"inputs\": [], \"name\": \"platformProv ider\", \"outputs\": [ { \"name\": \"\", \"type\": \"address\" } ], \"payable\": false, \"stateMu tability\": \"view\", \"type\": \"function\" }, { \"constant\": true, \"inputs\": [], \"name\": \"getInvestorFunding\", \"outputs\": [ { \"name\": \"\", \"type\": \"address[]\" } ], \"payable\" : false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": true, \"inpu ts\": [], \"name\": \"getCreatorFunding\", \"outputs\": [ { \"name\": \"\", \"type\": \"address[]\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constan t\": true, \"inputs\": [], \"name\": \"getAllFunding\", \"outputs\": [ { \"name\": \"\", \"type\": \"address[]\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": true, \"inputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"name\": \"crow FundingArray\", \"outputs\": [ { \"name\": \"\", \"type\": \"address\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": true, \"inputs\": [ { \"name\": \"\", \"type\": \"address\" }, { \"name\": \"\", \"type\": \"uint256\" } ], \"name\": \"crea torFundingMap\", \"outputs\": [ { \"name\": \"\", \"type\": \"address\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": false, \"inputs\": [ { \"name\": \"_projectName\", \"type\": \"string\" }, { \"name\": \"_supportMoney\", \"type\": \"uin t256\" }, { \"name\": \"_goalMoney\", \"type\": \"uint256\" }, { \"name\": \"_duration\", \"type\" : \"uint256\" } ], \"name\": \"createFunding\", \"outputs\": [], \"payable\": false, \"stateMu tability\": \"nonpayable\", \"type\": \"function\" }, { \"inputs\": [], \"payable\": false, \"s tateMutability\": \"nonpayable\", \"type\": \"constructor\" } ]; const fundingFactoryAddress = '0x8ff3a13157f1a0aa99beb84d393f1aac4dd470e3'; //创建fundingFactory合约实例 let fundingFactoryContract = new web3.eth.Contract(fundingFactoryABI, fundingFactor yAddress); let contracts = { fundingFactoryContract, } export default contracts; There are many modules in the whole front-end development. In the following interface development step diagram, we can see that the whole interface includes the crowdfunding I initiated, all the crowdfunding, and the crowdfunding I participated in and other modules. As shown below: The preceding steps have already implemented the basic framework of the entire front-end page and the contract call case. The development of other modules is similar to the preceding steps. No more detailed introduction, you can directly view the source code to learn. "},"31_mining.html":{"url":"31_mining.html","title":"sipc mining","keywords":"","body":"Mining is a way to obtain sipc and also a link to participate in the bottom layer of Simplechain ecology. Currently, there are 3 mining pools that support Simplechain mining. They are: Matpool Dxpool Simpool At present, the main types of mining machines that can mine are SimpleNode X1, as shown below: Purchase link: https://www.suanli.com/ "},"32_miningPool/":{"url":"32_miningPool/","title":"MinePool access","keywords":"","body":"Sipc currently supports three mining pools for mining, which are: Matpool Dxpool Simpool Simpool mining tutorial Mining method Method 1： Register an account for mining in Simpool, the official website of the mining pool; Method 2： Use simpleNode(V1.0.0 version) to connect to the mining pool for mining. Simpool mining Mine pool registration Register the mine pool account (do not enter the account name in Chinese); Account registration address: https://simpool.sipc.vip/enroll Enter account management to set the payment address (otherwise the system cannot make coins). Link mining pool mining: Special attention: name is followed by the miner user name, the best format is the account name. xxx (Miner name does not have Chinese) or directly the account name It is very important which account the miner belongs to, and the income is distributed according to the payment address under the corresponding account name. Download the files required by the GPU The address is here：https://github.com/simplechain-org/gpuminer/releases （Be sure to download the latest version, the latest version is more efficient! The latest version is 1.0.4） Decompress the modified file After downloading the compressed file, decompress it into a folder, as shown in the following figure: Click in, find the file start.bat, and edit it with Notepad: —— gpuplatform 1 choose card A for mining; —— gpuplatform 2 choose N card for mining; —— gpuplatform 3 choose hybrid multi-card mining. After modification, save it and turn it off. Double-click start.bat to link the mine pool. Screenshot after success: After accessing the mine pool, you can log on to your mine pool account on the mine pool official website to view your income. SimpleNode(V1.0.0 version) mining pool mining SimpleNode download address: https://www.simplechain.com/ , select the corresponding version to install according to your system, and start the application after the installation is successful Specific mining steps: Start SimpleNode, click the \"start mining\" button in the upper right corner, and the mining method pop-up window app. Mining method: Select \"mining pool mining\" in the popup window of mining method \"; Miner name: if you have not registered a Simpool account, you need to click the \"Click register\" button on the right side of the miner name to go to the Simpool registration page. After the registration is successful, return to the previous SimpleNode mining page; if you have registered a Simpool account, enter the miner name directly in the miner name editing box (Miner name does not contain Chinese) Graphics card type: select the type of graphics card, according to your computer's graphics card to choose (wrong choice, mining has no computing power) Special attention: When you register an account or add an account in Simpool, the account name must not be in Chinese. Miner name, the best format is the account name. xxx (account name is the account name in the Simpool) or directly the account name It is very important which account the miner belongs to, and the income is distributed according to the payment address under the corresponding account name. Click the OK button to mine. You can click view revenue in the upper right corner to view your revenue. "},"33_gpuMining/":{"url":"33_gpuMining/","title":"GPU Mining","keywords":"","body":"Window version Note: This GPU mining only supports linking mining pools SImpool address：https://simpool.vip GPU mining address：http://suo.im/5E6IrE Mining pool registration process: Step 1: register a mine pool account (the user name is preferably in English); Step 2: Enter account settings; Step 3: Design the payment address in the Personal Center (otherwise the system can't make coins); Special attention: The account name is very important. The name must be followed by the account user name after the mine pool. Download the files required by the GPU Download address: https://github.com/simplechain-org/gpuminer/releases（Be sure to download the latest version, the latest version is more efficient! The latest version is 1.0.3) Decompress the modified file Decompress the compressed file into a folder. Click in, find the file start.bat, and edit it with Notepad: After the modification, double-click start.bat to link the mine pool. The screenshot after the modification is successful: After accessing the mine pool, you can log on to your mine pool account on each mine pool official website to view your income. Mac version SimpleChain official GPU mining tutorial (MAC) Note: This GPU mining only supports linking mining pools Simpool website：https://simpool.vip Download the software required for GPU mining：http://suo.im/5E6IrE Mining pool registration process: Step 1: register a mine pool account (the user name is preferably in English); Step 2: Enter account settings; Step 3: Design the payment address in the Personal Center (otherwise the system can't make coins); Special attention The account name is very important. The name must be followed by the account user name after the mine pool. Download the files required by the GPU Download address：hhttp://suo.im/5E6IrE Decompress the modified file Decompress the compressed file into a file and put it on the desktop: Then open the command line mode and find the terminal and terminal in the utility tool: First cd desktop enter the desktop (the file you just downloaded is on the desktop by default), and then obtain the permission to operate the file you just downloaded, chmod +x gpuminer (If the file is on the desktop, you can paste it!): After obtaining the permission, enter the command to start the file: ./gpuminer –server simpool.vip:8801 –name abc(118.31.45.65:8801是矿池地址，每个矿池的地址不一样，abc是账户名称,一定填自己账户。)运行成功后： "},"34_SimPool/":{"url":"34_SimPool/","title":"Simpool Mining","keywords":"","body":"Simpool mining tutorial Mining method Mode 1 :: register an account for mining in Simpool, the official website of the mining pool. Mode 2:: use simpleNode(V1.0.0 version) to connect to the mining pool for mining. Mine pool registration Register the mine pool account (do not enter the account name in Chinese); Account registration address: https://simpool.sipc.vip/enroll Enter account management to set the payment address (otherwise the system cannot make coins). Link mining pool mining Special attention: name is followed by the miner user name, the best format is the account name. xxx (Miner name does not have Chinese) or directly the account name It is very important which account the miner belongs to, and the income is distributed according to the payment address under the corresponding account name. Download the files required by the GPU The address is here: https://github.com/simplechain-org/gpuminer/releases（Be sure to download the latest version, the latest version is more efficient!最新版本是1.0.4） Decompress the modified file Download the compressed file and decompress it into a folder. Click in, find the file start.bat, and edit it with Notepad: -gpuplatform 1 Select Card A for mining; -gpuplatform 2 choose N card for mining; -gpuplatform 3 select hybrid multi-card mining. After modification, save it and turn it off. Double-click start.bat to link the mine pool and take a screenshot. After accessing the mine pool, you can log on to your mine pool account on the mine pool official website to view your income. SimpleNode（V1.0.0 version）mining pool mining SimpleNode download address：https://www.simplechain.com/，select the corresponding version to install according to your system, and start the application after the installation is successful. Specific mining steps: 一. Start SimpleNode, click the \"start mining\" button in the upper right corner, and the mining method pop-up window appears 二. Mining method selection: Mining method: Select \"mining pool mining\" in the popup window of mining method \"; Miner name: if you have not registered a Simpool account, you need to click the \"Click register\" button on the right side of the miner name to go to the Simpool registration page. After the registration is successful, return to the previous SimpleNode mining page; if you have registered a Simpool account, enter the miner name directly in the miner name editing box (Miner name does not contain Chinese) Graphics card type: select the type of graphics card, according to your computer's graphics card to choose (wrong choice, mining has no computing power) Special attention: When you register an account or add an account in Simpool, the account name must not be in Chinese. Miner name, the best format is the account name. xxx (account name is the account name in the Simpool) or directly the account name It is very important which account the miner belongs to, and the income is distributed according to the payment address under the corresponding account name. 三. Click the OK button to mine. You can click view revenue in the upper right corner to view your revenue "},"35_SimpleNode_x1/":{"url":"35_SimpleNode_x1/","title":"SimpleNode x1 Mining","keywords":"","body":"After getting the mining machine, you need to complete the following three steps to make the mining machine run and dig out the benefits! Prepare SimpleNode software Install the miner driver (Windows system needs to be installed, MacOS and Linux do not need to be installed) Join the official Mine pool Simpool,start mining！ Prepare SimpleNode software Go to the official website of SimpleChain (www.simplechain.com), find SimpleNode, and download the corresponding version of the installer according to your computer system. Open SimpleNode installer and follow the prompts to complete the installation. After the installation, run SimpleNode After data synchronization is complete, follow the prompts to create an account or import an existing account. After creating an account, please make a backup to ensure the security of your funds! Install mining machine driver Windows system needs to be installed, MacOS and Linux do not need to be installed After creating the account, select \"Solo mining\" or \"mining pool mining\" after \"mining machine mining\" in SimpleNode software, and a prompt box will pop up. Click the blue word \"mining machine driver, automatically download the mining machine driver installation package. The miner driver installation package is a compressed file, please decompress the file. Decompress the file and click the \"stmicroel_virtual_131_64\" application to start installing the miner driver. Complete the installation of the driver of the mining machine according to the instructions of the installation wizard. Start Mining! After the installation of the driver is completed, insert the mining machine, and choose \"Solo mining\" or \"mining pool mining\" after \"mining machine mining\" in SimpleNode software again, then you can start the mining machine mining and a journey full of money! We recommend that you use the \"mining pool\" method to add the official mining pool Simpool，more benefits! To select this method, you need to register an account in the official mine pool Simpool. Click \"mining pool mining\" behind \"mining machine mining\", click \"blue\", click \"register\" to enter the registration page of the official mining pool Simpool Complete the Simpool account registration as prompted After the registration is successful, find \"account management\" in the left-side navigation pane and click to enter Click \"Add mining account\" in the upper right corner; You need to enter \"account name\" and \"SIPC payment address\" Account name: English uppercase letters and numbers are supported (Chinese characters are not supported!) SIPC payment address: This address is the receiving address of mining revenue. Please fill in your SIPC Wallet account address. Your Wallet account address can be viewed in SimpleNode; If you are using the official Chainbox wallet and sipc.vip digital resource platform, you can also fill in your address (note: Please fill in your own address that supports SIPC correctly, and the mining revenue will be transferred to this address!) After completing the operation in Simpool, return to SimpleNode software and click \"mining pool mining\" after \"mining machine mining\" again \", fill in the miner name (the miner name is the\" account name \"you just filled in when adding a mining account in Simpool), click OK, click OK, mining begins (the blue light of the mining machine is flashing)! "},"36_SIPC.html":{"url":"36_SIPC.html","title":"SIPC.VIP","keywords":"","body":"After getting the mining machine, you need to complete the following three steps to make the mining machine run and dig out the benefits! Prepare SimpleNode software Install the miner driver (Windows system needs to be installed, MacOS and Linux do not need to be installed) Join the official Mine pool Simpool,start mining! Prepare SimpleNode software Go to the official website of SimpleChain (www.simplechain.com), find SimpleNode, and download the corresponding version of the installer according to your computer system. Open SimpleNode installer and follow the prompts to complete the installation. After the installation, run SimpleNode After data synchronization is complete, follow the prompts to create an account or import an existing account. After creating an account, please make a backup to ensure the security of your funds! Install mining machine driver Windows system needs to be installed, MacOS and Linux do not need to be installed After creating the account, select \"Solo mining\" or \"mining pool mining\" after \"mining machine mining\" in SimpleNode software, and a prompt box will pop up. Click the blue word \"mining machine driver, automatically download the mining machine driver installation package. The miner driver installation package is a compressed file, please decompress the file. Decompress the file and click the \"stmicroel_virtual_131_64\" application to start installing the miner driver. Complete the installation of the driver of the mining machine according to the instructions of the installation wizard. Start Mining! After the installation of the driver is completed, insert the mining machine, and choose \"Solo mining\" or \"mining pool mining\" after \"mining machine mining\" in SimpleNode software again, then you can start the mining machine mining and a journey full of money! We recommend that you use the \"mining pool\" method to add the official mining pool Simpool，more benefits! To select this method, you need to register an account in the official mine pool Simpool. Click \"mining pool mining\" behind \"mining machine mining\", click \"blue\", click \"register\" to enter the registration page of the official mining pool Simpool Complete the Simpool account registration as prompted After the registration is successful, find \"account management\" in the left-side navigation pane and click to enter Click \"Add mining account\" in the upper right corner; You need to enter \"account name\" and \"SIPC payment address\" Account name: English uppercase letters and numbers are supported (Chinese characters are not supported!) SIPC payment address: This address is the receiving address of mining revenue. Please fill in your SIPC Wallet account address. Your Wallet account address can be viewed in SimpleNode; If you are using the official Chainbox wallet and sipc.vip digital resource platform, you can also fill in your address (note: Please fill in your own address that supports SIPC correctly, and the mining revenue will be transferred to this address!) After completing the operation in Simpool, return to SimpleNode software and click \"mining pool mining\" after \"mining machine mining\" again \", fill in the miner name (the miner name is the\" account name \"you just filled in when adding a mining account in Simpool), click OK, click OK, mining begins (the blue light of the mining machine is flashing)! "},"37_wallet/":{"url":"37_wallet/","title":"Sipc","keywords":"","body":" Open SimplechainWebsite,and then drop down to find the SimpleNode module, as shown in the following figure: Currently, there are three versions of the full-node wallet:windows,Mac OS, Linux。Download the corresponding version according to your computer (server) system, and follow the installation steps after downloading. The following is an example of Apple Computer: download Mac OS After unzipping the file, you can see the logo of the wallet. Then click open, as shown in the following figure: After opening the wallet, you will see the prompt on the wallet page:正在链接节点，as shown below: After connecting the node, we can see the desktop wallet prompt 正在同步区块数据。Click 跳过，you can directly enter the wallet. As shown below: After entering the wallet, if you have already used the wallet, you can choose to import the account, if this is the first time you use the wallet. You need to clickCreate Account，as shown below: If Select import account，there are three ways to import wallet, which arekeystore文件导入, keystore明文导入，私钥导入。You can import according to your own private key. If you use SimpleNode for the first time, you must create an account. Just set your own wallet 密码以及确认密码，the wallet is successfully created after confirmation. After successful creation, we can see the Wallet account address to prevent the wallet from being lost due to forgetting the password. So should 立即备份.As shown below： What I click here is 备份私钥，you can also choose to back up the keystore file. Then you can see the private key information of our backup. Then click open SimpleNode, then enter the wallet. After entering the wallet, you can see the total number of sipcs, the current synchronization block height, and the wallet address. Click the collection code to receive the SIPC, as shown in the following figure: Of course, it can also be used for transfer, click transaction on the transfer page, enter the corresponding recipient's address and transfer the number of SIPC. And adjust the Gas fee, then transfer the money. As shown below: "},"38_ChainBox/":{"url":"38_ChainBox/","title":"ChainBox","keywords":"","body":"Download ChainBox wallet Apple Android installation address: https://www.simplechain.com/download Or scan the QR code below to download. After the IOS installation is complete, please: 打开设置———通用———设备管理———Broadway International Sp . z.o.o———信任应用———回到桌面打开钱包APP———创建注册。 Create a registered wallet First enter the wallet name (both in Chinese and English), then enter the wallet password (at least 8 digits, including numbers and letters), then Gou Xuan the protocol, and finally click create wallet, the wallet is created. Wallet created successfully Backup wallet: write down the auxiliary words. Next, assist to verify whether the auxiliary words are correct or not (the auxiliary words can only be screenshots and cannot be copied). Enter the auxiliary words in sequence and confirm. --- Create successfully and jump to the wallet page If you want to enter the wallet page quickly -- Optional, jump to the wallet page directly without backup in the upper right corner --- back up the wallet in the wallet settings next time (it is strongly recommended to back up the wallet first) Import wallet (function key in upper left corner to enter) If you have ever downloaded a ChainBox wallet and created a wallet, you can choose to import your wallet. You can import it in any way, such as mnemonic words, official wallet (keystore), private key, and then reset the password. Wallet list (function key in upper left corner to enter) You can see at a glance the wallet assets and wallet addresses of multiple wallets that you have created or imported. You can also select a wallet you imported or created in the wallet overview. Wallet settings (function key in upper left corner to enter) You can change the wallet name and password; If you need to export the wallet, you can export the private key, keystore, and backup memo in the wallet settings. If you have extra wallet, you can also delete it from the bottom of the wallet settings if you want to delete it. Transfer/Collection (function key in the upper left corner to enter) Click SIPC in the wallet to enter the details page: transfer/Collection Click transfer: ordinary transfer/offline transfer (additional remarks the Data in the advanced transfer options is transfer notes, which are generally not written because of the significant increase in the gas fee of the note information) Ordinary transfer (hot wallet function): Fill in the address, quantity and miner fee of the other party. Enter the password next. Offline transfer (cold wallet function): Fill in transfer address, account Collection Address, transfer quantity and miner fee. General purpose: Contact/Message Center/check for updates (function key in the upper left corner to enter) Contact person: add common transfer address to facilitate the second transfer. Message Center: you can see the summary of transfer and collection information. Check for updates: Check for updates to the latest wallet version "},"39_blockBrowser/":{"url":"39_blockBrowser/","title":"Explore","keywords":"","body":"Visit the browser: Browser Address Open the Blockchain browser and switch to the Main NetWork or Test NetWork as needed. As shown below: Block search Information about all blocks-from Genesis blocks to all current blocks-can be found on this page, including the block height, its previous block, and the corresponding byte size. Transaction search You can search for transaction records on this page. You can find the information with the sending transaction address and receiving address, the number of sipcs transmitted, the block height of the transaction record, the corresponding hash and the production time. You can also use the search bar to find specific transactions for hashes. View uncle block On this page, you can view the height of each block, the block height corresponding to its uncle block, the block time, and the rewards of packaged miners and miners. As shown below: Verification contract If you want to verify the contract, enter the contract address to be verified, and select the contract compiler type and compiler version to verify the contract. As shown below: List of verified contracts Click the verify contract list to view the information of 20 verified contracts. The information shows the contract address, contract name, compiler, version, account balance, verification time, etc! There are three verification methods for contract verification: Single file verification method Multi-file authentication method Json file validation method Single file verification pragma solidity ^0.5.12; contract PayALL{ event PayLog(address name,uint reward); event PayLog2(address name); constructor() public payable{ } function() external payable{ emit PayLog(msg.sender, msg.value); } function setMethd() public payable { emit PayLog2(msg.sender); } } Paste source code: After the verification is passed： Multi-file verification Because in the contract writing process, the dependency of the file can refer to another file. // test1.sol文件 pragma solidity ^0.5.17; contract Hello { uint value; function hello() public pure returns(string memory){ return \"hello world_1\"; } function set(uint x) public { value = x; } } // test2.sol文件 pragma solidity ^0.5.17; import {Hello} from \"./test1.sol\" ; contract Test2 is Hello { function test() public pure returns(string memory){ return Hello.hello(); } } Execution result: This type of authentication is used for multi-file authentication. The verification method is as follows to obtain the deployed contract address: 0x6e1ace6e6cf09a4ab096f272cfc029c0a1d883ac Optimizationit refers to the number of contract compilation times. The number of optimized times is selected for contract deployment. Therefore, the corresponding number of times must be selected for verification. By default, no optimization is performed. Constructor Arguments ABI-encoded indicates whether the contract has construction parameters. The construction parameters are generated during deployment. You do not need to fill in the construction parameters for verification. Contract Library Address When it comes to library contracts, ordinary contracts are not filled in. Details of this type of verification will be added later. View verification successful Multi-file contract source code after current verification The source code is displayed in json format, including two file source codes. Json file validation: The Json file verification method is relatively copied. You need to know the compilation parameters of solidity. solidity compiles the json file passed by the user, provided that the json file meets the compilation requirements. Json file： { \"language\": \"Solidity\", \"sources\": { \"myFile.sol\": { \"content\": \"pragma solidity ^0.5.12;contract Multiply7 { event Print(uint); event CjLog(address, uint); uint public a ; uint public b ; constructor (uint _a, uint _b) public { a = _a; b = _b; } function multiply(uint input1) public view returns (uint) { return input1 * 6 + a + b; } function multiplyplus(uint input1, uint input2) public returns (uint) { emit Print(input1 * 6 * input2); emit CjLog(msg.sender, a+b); return input1 * 6 * input2 + a + b; }}\" } }, \"settings\": { \"metadata\": { \"useLiteralContent\": true }, \"outputSelection\": { \"*\": { \"*\": [ \"*\" ], \"\": [ \"ast\" ] } } } } Library contract verification First of all, understand what is a library contract Browser support library the contract verification of the library,Library during the deployment process, contracts are deployed in sequence and nested. All contracts are deployed with multiple contracts (including library libraries inside the contracts, which are deployed together) and multiple hash records are generated. Contract source code: /** *Submitted for verification at Etherscan.io on 2020-02-27 */ pragma solidity ^0.6.0; library SetHFG { // 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。 struct Data { mapping(uint => bool) flags; } // 注意第一个参数是“storage reference”类型，因此在调用中参数传递的只是它的存储地址而不是内容。 // 这是库函数的一个特性。如果该函数可以被视为对象的方法，则习惯称第一个参数为 `self` 。 function insert(Data storage self, uint value) public returns (bool) { if (self.flags[value]) return false; // 已经存在 self.flags[value] = true; Acc.hi(); return true; } the following is the deployment record: CHU as the main contract: 0x1c622ed2035acc8514259788caafb3cf69d9bbe3 The contract address of the Library is: Bcc：0x0da8bd0dd96f78ac6e155b2d5e9fb6d15ca89fad Fcc：0x7b05897e605a3878d3511069924d750ef3954da5 Acc：0x13a6cb372333394caa8ea0e5876a4a52167a95ce SetHFG: 0x5386710eb4d02b41e7a253d3ebb00ca8795c930f Verification way and single-file same, as shown below: Verification passed "},"40_tradePlateform.html":{"url":"40_tradePlateform.html","title":"Exchange docking","keywords":"","body":"Build SimpleChain nodes docker build Obtain an image: docker pull simplechain/sipe:latest Enable RPC docker run -it -p 8545:8545 -p 30312:30312 simplechain/sipe --rpc --rpcaddr \"0.0.0.0\" You can run the following command to check whether your node is successfully started: curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":68}' Source code construction Preliminary preparations: Go language environment (1.10 or above), C language compiler 1.Download SimpleChain You can clone a project locally through git or download directly from the https://github.com/simplechain-org/go- simplechain page. git clone https://github.com/simplechain-org/go-simplechain.git 2.Install sipe 1.Enter the go-simplechain root directory. cd go-simplechain 2.Use the make tool to install sipe. make sipe >>> /usr/local/go/bin/go install -ldflags -X main.gitCommit=9d73f67e1dc5587a95f52c13fee93be6434b42ac -s -v ./cmd/sipe github.com/simplechain-org/go-simplechain/core ... github.com/simplechain-org/go-simplechain/cmd/sipe Done building. Run \"/Users/yuanchao/go/src/github.com/simplechain-org/go-simplechain/build/bin/sipe\" to launch sipe. When the above output appears on the terminal, the make execution is successful. In this case, the sipe executable file is generated in the go-simplechain/build/bin directory. You can move it to any directory or add it to environment variables to facilitate the running of sipe programs. Start sipe 1.Create a folder for storing node data, if not mkdir chaindata 2.Start the sipe Master network node Enable the RPC service and specify the RPC listening address as 127.0.0.1, Port 8545 . The node data storage directory is chaindata ./sipe --rpc --rpcaddr 127.0.0.1 --rpcport 8545 --datadir chaindata When an output similar to the following appears, the startup is successful and the SimpleChain master Network block is synchronized. INFO [06-19|09:35:01.481] Maximum peer count ETH=25 LES=0 total=25 INFO [06-19|09:35:01.492] Starting peer-to-peer node instance=Sipe/v1.0.2-stable-0cbf2a41/darwin-amd64/go1.12.1 ... INFO [06-19|09:35:33.700] Block synchronisation started INFO [06-19|09:35:36.756] Imported new block headers count=192\\ elapsed=22.273ms number=192 hash=bb758a...bea1b6 ignored=0 Community node rpc address and port number: 47.110.48.207:8545 Test: //Request curl -X POST 47.110.48.207:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":68}' //Response { \"jsonrpc\": \"2.0\", \"id\": 68, \"result\": \"Sipe/v1.1.0-stable-0800d402/linux-amd64/go1.14.1\" } Connect to the SimpleChain node Create a sipc.js file and write the following code: const config = require('../../config') //Node serve compile information const Web3 = require('web3') module.exports = new Web3(config.uri) Create SimpleChain wallet service Now we are entering the development phase of the core features of Simplechain wallet service. Create a new Simplechain account The exchange and payment gateway need to generate a new address for the customer so that the user can recharge the service or pay for the product. Generate an unused sipc Address is the basic requirement of any digital asset service, so let's take a look at the specific implementation. First, create a command.js where we subscribe to messages in the queue. It mainly includes the following steps: Connect to the command topic and listen to the new create_account command When a new create_account command is received, a new key pair is created and stored in the password library. The account_created topic that generates the account_created message and sends it to the queue. The code is as follows: const web3 = require(\"./ethereum\") /** * Create a new ethereum address and return the address */ async function create_account(meta = {}) { // generate the address const account = await web3.eth.accounts.create() // disable checksum when storing the address const address = account.address.toLowerCase() // save the public address in Redis without any transactions received yet await redis.setAsync(`eth:address:public:${address}`, JSON.stringify({})) // Store the private key in a vault. // For demo purposes we use the same Redis instance, but this should be changed in production await redis.setAsync(`eth:address:private:${address}`, account.privateKey) return Object.assign({}, meta, {address: account.address}) } module.exports.listen_to_commands = listen_to_commands Handle new transactions We haven't finished our wallet yet. When the address we created receives the user's recharge, it should be notified. To this end, the web3 client of Simplechain provides the newBlockHeaders subscription mechanism. In addition, if our service goes down accidentally, the service will miss the blocks produced during the downtime. Therefore, we also need to check whether the wallet has been synchronized to the latest blocks on the network. Create sync_blocks.js file, write the following code: const web3 = require('./ethereum') /** * Sync blocks and start listening for new blocks * @param {Number} current_block_number - The last block processed * @param {Object} opts - A list of options with callbacks for events */ async function sync_blocks(current_block_number, opts) { // first sync the wallet to the latest block let latest_block_number = await web3.eth.getBlockNumber() let synced_block_number = await sync_to_block(current_block_number, latest_block_number, opts) // subscribe to new blocks web3.eth.subscribe('newBlockHeaders', (error, result) => error && console.log(error)) .on(\"data\", async function(blockHeader) { return await process_block(blockHeader.number, opts) }) return synced_block_number } // Load all data about the given block and call the callbacks if defined async function process_block(block_hash_or_id, opts) { // load block information by id or hash const block = await web3.eth.getBlock(block_hash_or_id, true) // call the onTransactions callback if defined opts.onTransactions ? opts.onTransactions(block.transactions) : null; // call the onBlock callback if defined opts.onBlock ? opts.onBlock(block_hash_or_id) : null; return block } // Traverse all unprocessed blocks between the current index and the lastest block number async function sync_to_block(index, latest, opts) { if (index >= latest) { return index; } await process_block(index + 1, opts) return await sync_to_block(index + 1, latest, opts) } module.exports = sync_blocks In the preceding code, we synchronize the latest block processed by the wallet service to the current latest block in the blockchain. Once we synchronize to the latest block, we begin to subscribe to the new Block event. For each block, we execute the following callback function to process the block header and the transaction list in the block: onTransactions onBlock Generally, the following processing steps are included: Monitor new blocks and get all transactions in the block Filter out transactions that are not related to the wallet address Send every related transaction to the queue Gather funds on the address to secure storage Update processed block number The final code is as follows: const web3 = require(\"web3\") //调用web3 const redis = require('./redis') //调用redis数据库，将区块数据获取下来存入redis数据库中 const queue = require('./queue') //调用消息队列 const sync_blocks = require('./sync_blocks') //同步区块 /** * Start syncing blocks and listen for new transactions on the blockchain */ async function start_syncing_blocks() { // start from the last block number processed or 0 (you can use the current block before deploying for the first time) let last_block_number = await redis.getAsync('eth:last-block') last_block_number = last_block_number || 0 // start syncing blocks sync_blocks(last_block_number, { // for every new block update the latest block value in redis onBlock: update_block_head, // for new transactions check each transaction and see if it's new onTransactions: async (transactions) => { for (let i in transactions) { await process_transaction(transactions[i]) } } }) } // save the lastest block on redis async function update_block_head(head) { return await redis.setAsync('eth:last-block', head) } // process a new transaction async function process_transaction(transaction) { const address = transaction.to.toLowerCase() const amount_in_ether = web3.utils.fromWei(transaction.value) // check if the receiving address has been generated by our wallet const watched_address = await redis.existsAsync(`eth:address:public:${address}`) if (watched_address !== 1) { return false } // then check if it's a new transaction that should be taken into account const transaction_exists = await redis.existsAsync(`eth:address:public:${address}`) if (transaction_exists === 1) { return false } // update the list of transactions for that address const data = await redis.getAsync(`eth:address:public:${address}`) let addr_data = JSON.parse(data) addr_data[transaction.hash] = { value: amount_in_ether } await redis.setAsync(`eth:address:public:${address}`, JSON.stringify(addr_data)) await redis.setAsync(`eth:transaction:${transaction.hash}`, transaction) // move funds to the cold wallet address // const cold_txid = await move_to_cold_storage(address, amount_in_ether) // send notification to the kafka server await queue_producer.send('transaction', [{ txid: transaction.hash, value: amount_in_ether, to: transaction.to, from: transaction.from, //cold_txid: cold_txid, }]) return true } module.exports = start_syncing_blocks Summary We have completed the design and implementation of Simplechain wallet service of the exchange. This service can also be improved from the following aspects: Add error handling Add command type Transaction Signature and transaction broadcast Deployment Contract "},"41_commityProduct.html":{"url":"41_commityProduct.html","title":"Community Project","keywords":"","body":"Simplechain, as an open-source community project, has long been supported by many community developers. The following are some excellent projects contributed by community development: SDK Java-SDK Python-SDK JavaScript-SDK Google plug-in wallet Plug-In wallet download and usage tutorial "},"42_commityActity.html":{"url":"42_commityActity.html","title":"Community Activity","keywords":"","body":"Hello! Welcome to Simplechain technology community, thank you for your support to Simplechain! Our community activities and incentive plans will be updated quarterly, please continue to pay attention. Participate in SimpleChain open source co-construction Welcome to join the Simplechain open source community. You can join the community in the following ways: Participate in code or document contribution： Fork，fork the project to your Github account; Clone，clone the project to the local development environment; Hack，hacking code or documents (create a new branch to complete the update); Push，push the committed branch to the remote Github account; PR，create a new pull request to complete the contribution; Dcoument， • write a document library, organize basic tools to use related documents; Participate in technical community sermon Article: Original articles related to Simplechain and successfully published the above in the Channel. Technical video: Clip short videos about Simplechain and publish them on relevant platforms. Community node building:Create a Simplechain node and expose the IP address and port number to the public for community developers to use directly. Active technical community:Guide topics in the technology community and activate the atmosphere of the technology community (such as Weibo Super Talk) Community project contribution There are mainly two forms of contribution to participating in community projects; Developers can choose their own development based on Simplechain. There is no need to communicate with the official, and there is no incentive for this. It is purely a personal behavior of community developers and has nothing to do with the Simplechain technology community. Developers think that a certain basic tool is necessary for the development of Simplechain, but it is not yet available. It can be fed back to the person in charge of the technical community, and the technical personnel think it is necessary after evaluation. Then it can be developed, and developers will also get certain token incentives. Community Task BUG Hunter Find the bug of Simplechain and submit it on github. After it is evaluated and confirmed by the core team, different rewards will be given according to the severity of the bug. Landing expert Enterprise landing Responsible for the cooperation between SimpleChain and enterprises, mainly responsible for the promotion and explanation of SimpleChain technology and implementation cases. Cooperation with enterprises and technical support work in the later cooperation process. After being evaluated by Simplechain foundation to reach the standard, it will receive rich bonus. Government Cooperation Connect Simplechain to cooperate with government projects and be responsible for communicating with the government. Provide SimpleChain-based blockchain training for government personnel and achieve government cooperation. After being evaluated by Simplechain foundation to reach the standard, it will receive rich bonus. Community KOL The SimpleChain technology community has been recruiting KOL for a long time. Developers are welcome to actively participate in the technology ecosystem of SimpleChian. Certain incentives will be given every quarter according to personal performance. The main work of community KOL is as follows: Organization developers, developed based on SimpleChain, and provided technical support. And the follow-up and promotion of the later project. Build a developer community, share technologies related to SimpleChain, and activate the community atmosphere. And developer relationship maintenance. Publish technical articles and technical videos. Become a content creator and output. "},"43_commityEnters/":{"url":"43_commityEnters/","title":"Community Entrance","keywords":"","body":"SimpleChain is a community-led and open-source public underlying blockchain platform. It is created by an open-source working group established by SimpleChain Foundation and members of the technology community. Simplechain resource list Github home page Technical documentation Deep Analysis Series Contribution code Feedback problem Application Case Collection Join the Simlechain community "},"44_case.html":{"url":"44_case.html","title":"Landing case","keywords":"","body":"SimpleChain（SIPC）is a public chain with the design concept of \"simple blockchain, mutual promotion and win-win. As a revolutionary blockchain application infrastructure design, blockchain supports the underlying consensus-POW algorithm of the main chain. Sub-chains support multiple consensus and performance requirements to ensure stable and safe operation, so as to meet the rich business application scenarios. The systematic tool module provides a simple configuration, deployment, and development environment for various application scenarios to implement simple blockchain. SimpleChain is exploring a broader space for blockchain applications and has made great achievements in multiple fields such as judicial registration, cultural copyright, game entertainment, and scenario payment. Since the launch of Simplechain's main network, community developers have made joint efforts. More and more applications are developed based on Simplechain. Here are some detailed implementation cases. Judicial deposit: As the first sub-chain of judicial field based on SimpleChain underlying technology, the exclusive technical support security network of \"The first case of Block Chain certificate storage in China\" is the security chain, in addition to reaching cooperation with several law firms and judicial authentication institutions, it has also established close contact with the three major domestic internet courts and the first Internet notary office in China, and its 5.0 version of the evaluation report of China Standard Institute will be released soon; Cultural copyright： In addition to the sub-chain security network (security chain) providing \"block chain +\" certificate storage services for domestic cultural media companies such as rights protection Knights, haojubang, and Babbitt, it has also reached deep cooperation with one-stop novel reading and copyright investment platform fun; Game Entertainment GWC, an overseas game platform, has established a system based on credit rating and quality rating of the game industry on SimpleChain. Participants can score the game and its production team to obtain corresponding game operation dividends; Philanthropy: The SimpleChain team and the entrepreneurship team of Zhejiang University have jointly created the world's first blockchain intelligent coffee machine, which has been successively put into shared office space, independent start-up companies and other places. Its system supports SIPC payment, without centralized payment tools such as WeChat and Alipay, you can enjoy the most convenient blockchain payment method. Philanthropy: SimplecChain, following the donation tracing platform of the digital Qin science and technology security network, donated more than ten thousand pieces of protective clothing to Wuhan Jiuzhou tongrenshou Hall nursing home, the Second Affiliated Hospital of Zhejiang University Medical College and other institutions to support front-line medical staff. Through the blockchain technology, the whole process of the circulation process and time node of donated goods and materials is recorded, recorded and tracked, providing the whole process of blockchain solutions for charitable donations in the epidemic situation. At the same time, it also reached a strategic cooperation agreement with Bithelp's global digital public welfare platform and jointly launched public welfare fund-raising activities. Social E-Commerce： SimpleChain helps boutique social e-commerce platforms build the \"blockchain + social e-commerce\" model all over the world, which connects the ecological relationships among platform merchants, e-commerce platforms, and community users, and changes the previous platform centralization model, the three-party interest ecology will be re-integrated. They will participate in the whole interest chain together and exist as an equal relationship. Asset encryption: SimpleChain cooperates with Keystore to promote the development of blockchain technology and applications. The two parties cooperate in the fields of asset trusteeship, node services, and market expansion, and jointly expand the enterprise-level encrypted asset service market. "},"45_faq.html":{"url":"45_faq.html","title":"FAQ","keywords":"","body":"Mine pool related issues 1.What should I fill in the receiving address? We recommend that you fill in the SIPC wallet address, because you have the private key of the currency, which is more secure. 2.What coins can SimPool dig ? Currently, SIPC mining is supported. 3. How to mine ？ The general steps are: register an account-create a mining account-configure a computer-view revenue. For specific steps, see SIPC mining tutorial. 4. How high is my computing power? The actual computing power after connecting the mining pool for mining is not necessarily equal to the nominal computing power, and the specific computing power displayed by the mining pool is the standard. 5. Why is my income decreasing? First confirm the following points: (1) whether the mining equipment operates normally; (2) whether the mining configuration is correct; (3) whether the network connection is normal; (4) whether the difficulty of mining changes (if the difficulty changes, the profit will fluctuate); And with the increase of mining equipment and the increase of the whole network computing power, the difficulty of mining will increase, the mining revenue of a single device will gradually decrease. 5. When will the daily income be settled? The hourly settlement is conducted once every hour, and then the coin is made at 12 a.m. the specific calculation method of personal income (per hour) is as follows: Mining pool revenue = average computing power of the mining pool/computing power of the whole network * The number of SIPC output per day of the whole network + super-fast revenue; Personal income = total personal acceptance/total network acceptance * mine pool income; 6. Why is the network unstable sometimes? Sometimes there will be technical adjustments, which are not stable, but generally can be solved in 30 to 2 hours. There may also be attacks, attacks against bitcoin networks, there are also attacks against mine pool servers. If it is a personal network problem, you need personal debugging to solve it or seek help from the network operator. 7. What if the computing power drops? Please check the following questions first: (1) whether the mining equipment operates normally; (2) whether the mining configuration is correct; (3) whether the network connection is normal; After the above troubleshooting, the computational power still decreases. Please find customer service in the Simpool group to solve the problem. 8. What is workload? What is the network difficulty? The workload refers to the contribution of the miner to the computing power for digging new blocks. The network difficulty refers to the computing difficulty of the whole network explosion block, which is dynamically adjusted according to the total computing power of all miners. 9. What are the settlement methods for the mine pool? At present, the mining pool adopts the PPLNS settlement method (full name: Pay Per Last N Shares), which means \"Pay the income according to the past N Shares\". This means that once all miners find a block, they will distribute the currency in the block according to the proportion of shares each person contributes. 10. Will the revenue be lost if the collection address is not set? If you do not fill in the receiving address, your revenue will be temporarily stored in the Simpool account. After you set the address, we will pay you the income after the address takes effect. 11. When using SimpleNode wallet to select mining pool for mining, how to set the parameters of advanced graphics card? Known video card tuning parameters: (1) NVIDIA GTX-750-Ti gpuplatform=2, memsize=1999, globalworksize=10240, localworksize=512, lookupgap=4 (2) AMD Ellesmere RX 570 gpuplatform=1, memsize=2048, globalworksize=8000, localworksize=64, lookupgap=2 (3) GeForce GT 1030 gpuplatform=2, memsize=2048, globalworksize=4096, localworksize=64, lookupgap=4 gpuplatform: AMD graphics card fill in 1, NVIDIA graphics card fill in 2 memsize: Filter graphics cards that are not less than the video memory capacity (default 2048MB), NVIDIA GTX-750-Ti video memory is 1999MB globalworksize: The parallel computing item is generally a multiple of 1024, and the maximum can not be greater than the Max work item sizes of the graphics card. However, when adjusting, AMD's RX570 setting 8000 has the highest efficiency. localworksize: The work item of each graphics card calculation unit is generally 64/128/256/512. globalworksize/localworksize cannot be greater than the Max work group size supported by the graphics card. lookupgap: This value is finally adjusted. The value range is 1/2/4/8. The default value is 2. Adjust the performance between video memory and video memory. When it is equal to 1, the memory used is the most. Based on this, 1/2 is used when it is equal to 2, and 1/8 is used when it is equal to 8. SimpleNode X1 1.Can an account be associated with several more mining machines？ Yes, as long as the power supply of the mining machine is guaranteed to be sufficient, multiple mining machines can be connected in series on one computer. If the Solo mining method is used, the profit will be directly transferred to the mining account address; If you use the mining pool mining method, the profit is transferred to the account address associated with the miner. 2.How to check the status of each mining machine after connecting multiple mining machines? If multiple mining machines are mining at the same time, click the small arrow behind \"stop mining\" on SimpleNode software to view the status of each mining machine. 3.How many mining machines can the network and computer at home drag at most? The network bandwidth has little impact on the mining machine, as long as the SimpleNode can be connected to the Simpool mining pool; As long as the power supply of the mining machine is guaranteed to be sufficient, each computer can be connected with multiple mining machines, generally, it can support about 2-3 sets at most; Additional external power supply is required. "},"46_supportOnline/":{"url":"46_supportOnline/","title":"Online technical support","keywords":"","body":"Developer Telegram Community: Technical support: "}}