{"./":{"url":"./","title":"引言","keywords":"","body":"Simplechan开发者文档 上链（SimpleChain）是一款以一主链多子链结构为设计理念的公链，通过多层级的分布式价值网络设计，支持多共识、多业务场景的区块链部署与拓展，支持跨链交易，支持子链满足千万级别TPS，涉及分布式计算、司法数字化、数字拍卖、不动产、数娱游戏、交易结算等多应用场景，共同构建新数字经济生态系统。随着SimpleChain的主网上线，我们看到越来约多的区块链爱好者和技术开发者参与到我们的技术社区和生态建设当中。欢迎更多的技术开发者加入到我们的技术社区。 我们的文档旨在服务开发者和社区爱好者，快速的了解并入门SimpleChain。文档由SimpleChain社区和 SimpleChain核心团队共同维护，因此欢迎你在这里做出自己的贡献！我们希望文档能够让大家更清晰地理解SimpleChain的技术和生态系统。 在开始SimpleChain网络开发之前，你需要做如下准备： 对区块链的基本概念有了解 具备一定的主流编程和开发基础 具备对SimpleChain基本属性的理解，和对你的商业业务需求的具体理解 我们诚挚的欢迎每一个加入SimpleChain社区的开发者朋友和基于SimpleChain做落地应用的组织。 "},"1_quickStart.html":{"url":"1_quickStart.html","title":"快速开始","keywords":"","body":"此页面为不同类型的用户提供了指南，方便开发者快速找到自己需要的内容。 如果你想了解SimpleChain的基本概念 在进入SimpleChain技术细节或在SimpleChain上开发智能合约之前，首先了解SimpleChain基本概念并对SimpleChain有一个透彻的了解是有帮助的。您可以了解有关SimpleChain的 帐户系统, 经济模式, 投票流程 一些基本概念。 如果你想使用SimpleChain 即使您不是开发人员，也可以加入SimpleChain社区并为SimpleChain日常操作做出贡献。 你可以看一下浏览器. 如果您是开发人员 对于开发人员来说，有很多材料可以帮助您。 运行并操作SimpleChain 您可以选择 运行本地单节点网络 或加入SimpleChain网络. 您可以使用命令行工具来操作SimpleChain. 智能合约开发 对于智能合约开发人员，您可以参考智能合约开发部分了解详细信息. 我们还为智能合约开发人员提供了一些示例，介绍了如何编写/部署/运行合约。 落地案例 这是使用SimpleChain开发的一个落地案例 SDK 和 API 还为开发人员提供了 SDK 和 API： Javascript SDK Java SDK Python SDK JSON RPC API 如果您对技术细节感兴趣 对于那些对技术细节感兴趣的人，您可以了解数据库基础结构, 网络层, 和虚拟机。您将能够通过这些文档了解SimpleChain的内部逻辑。 帮助 如果您有任何疑问，请随时从 Medium 或 Telegram论坛 获取帮助. "},"2_BuildNode/":{"url":"2_BuildNode/","title":"搭建节点","keywords":"","body":"Docker镜像搭建 获取镜像： docker pull simplechain/sipe:latest 启动节点： docker run -it -p 30312:30312 simplechain/sipe 开启RPC docker run -it -p 8545:8545 -p 30312:30312 simplechain/sipe --rpc --rpcaddr \"0.0.0.0\" 开启JavaScript控制台 docker run -it -p 30303:30303 simplechain/sipe console 将区块数据存储在指定目录 docker run -it -p 30312:30312 -v /path/on/host:/root/.simplechain simplechain/sipe 如果开启了RPC，可以通过以下命令查看自己的节点是否启动成功： curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":68}' 安装包搭建 打开Simplechain的[官网],然后下拉找到SimpleNode模块，如下图： 根据自己的服务器系统下载对应的版本，下载后按照提示安装就可以了，安装好以通过助记词创建钱包账户。然后就可以支付或者接收sipc，挖矿，以及发布合约。 账户 挖矿 合约 源码搭建 前期准备:Go 语言环境(1.10 或以上版本)、C 语言编译器 1.下载 SimpleChain 可以通过 git 将项目 clone 到本地，也可以在 https://github.com/simplechain-org/go- simplechain 页面直接下载。 git clone https://github.com/simplechain-org/go-simplechain.git 2.安装 sipe 1.进入 go-simplechain 根目录。 cd go-simplechain 2.使用 make 工具安装 sipe。 make sipe >>> /usr/local/go/bin/go install -ldflags -X main.gitCommit=9d73f67e1dc5587a95f52c13fee93be6434b42ac -s -v ./cmd/sipe github.com/simplechain-org/go-simplechain/core ... github.com/simplechain-org/go-simplechain/cmd/sipe Done building. Run \"/Users/yuanchao/go/src/github.com/simplechain-org/go-simplechain/build/bin/sipe\" to launch sipe. 当终端出现以上输出时，表示 make 执行成功，此时在 go-simplechain/build/bin 目录下 将会生成 sipe 可执行文件。可以将其移动到任何目录下或将其加入到环境变量中，以此 来便利得运行sipe程序。 启动sipe 1.创建用于存储节点数据的文件夹,如果不 mkdir chaindata 2.启动sipe主网节点 开启 RPC 服务并指定 RPC 监听地址为 127.0.0.1，端口 8545。节点数据存储目录为 chaindata ./sipe --rpc --rpcaddr 127.0.0.1 --rpcport 8545 --datadir chaindata 当出现类似以下输出时，表示启动成功，并开始同步 SimpleChain 主网区块。 INFO [06-19|09:35:01.481] Maximum peer count ETH=25 LES=0 total=25 INFO [06-19|09:35:01.492] Starting peer-to-peer node instance=Sipe/v1.0.2-stable-0cbf2a41/darwin-amd64/go1.12.1 ... INFO [06-19|09:35:33.700] Block synchronisation started INFO [06-19|09:35:36.756] Imported new block headers count=192\\ elapsed=22.273ms number=192 hash=bb758a...bea1b6 ignored=0 3.启动sipe控制台 新建终端窗口，通过以下命令开启一个连接到此节点的交互控制台。 sipe attach chaindata/sipe.ipc 4.创建账户 在启动的控制台下使用以下命令创建一个账户。 > personal.newAccount() Passphrase: Repeat passphrase: \"0xc8d8ba3bdba3a1e3ca1d6cd48106d84036f6c0bd\" //账户地址 创建成功后，控制台会返回账户地址，同时会在chaindata/keystore 生成账户的json文件，此文件可以通过密码解析获得账户私钥。 5.启用挖矿 重启sipe节点，启用挖矿，指定矿工地址为你创建的账户地址，挖矿线程数为1。 sipe --rpc --rpcaddr 127.0.0.1 --rpcport 8545 --datadir chaindata --mine --minerthreads=1 --etherbase=0xc8d8ba3bdba3a1e3ca1d6cd48106d84036f6c0bd 当然，你也可以通过控制台指定矿工地址并开启挖矿。 > miner.setEtherbase('0xc8d8ba3bdba3a1e3ca1d6cd48106d84036f6c0bd') > miner.start() "},"47_techniqueLanguage.html":{"url":"47_techniqueLanguage.html","title":"技术术语","keywords":"","body":"在开始了解Simplechain，以及方便后续更好的学习Simplechain的内容，我们需要了解一些常见的术语和名词。 专有名词 外部账户：EOAs（External Owned Accounts），关联个人掌握的私钥。可以用于发送交易（转移Sipc或发送消息），形同一张带数字ID的储蓄卡。 合约账户：Contracts Accounts，可以在Simplechain上存储合约代码与合约数据的账户，外部不能直接操作此账户。只能由外部账户直接或间接调用。 账户状态： account state，表示一个账户在Simplechain中的状态。账户状态在账户数据变化时变化。账户状态包含四项信息：nonce、余额、账户存储内容根哈希值、账户代码哈希值。状态数据不直接存储在区块上。 账户Nonce: 账户随机数，是账户的交易计数。以防止重放攻击。 智能合约：Smart Contract，Simplechain支持通过图灵完备的高级编程语言编写智能合约代码。部署在链上后，可以接受来自外部的交易请求和事件，以触发执行特定的合约代码逻辑，进一步生成新的交易和事件。甚至调用其他的智能合约。 世界状态：state，管理账户地址到账户状态的映射关系。所有账户的状态构成整个区块链状态。 交易：Transaction，是外部与Simplechain交互的唯一途径，必须由外部账户签名，矿工执行交易，最终打包到区块中。 交易收据：Receipt，是方便对交易进行零知识证明、索引和搜索，将交易执行过程中的一些特定信息编码为交易收据。 区块：block，是由一组交易和一些辅助信息（简称区块头）、其他区块头哈希构成的数据块。其他区块头哈希表示父区块或者叔背区块。 叔块：Uncle Block，不能成为主链一部分的孤儿区块，如果有幸被后来的区块收留进区块链就变成了叔块。收留了孤块的区块有额外的奖励。孤块一旦成为叔块，该区块统一可获得奖励。通过叔块奖励机制，来降低Simplechain软分叉和平衡网速慢的矿工利益。 随机数：nonce，记录在区块头中，努力工作的证明。 Gas：燃料是交易打包到区块时，在EVM运行所消耗的资源量的一种形象化概念，比喻需要燃料才能运行EVM。在Simplechain中，将CPU资源、存储资源按内置的规则，统一使用 Gas 作为资源单位表达。每执行一次虚拟机指令，均消耗一定的Gas。 GasPrice: 燃料价格，任何交易都需要包含一个愿意支付的燃料单价，最终根据交易消耗的燃料量，计算手续费(usedGas*gasPrice)支付给矿工。 价格预测：GPO(Gas Price Oracle)，Gas 价格预测，根据历史交易的GasPrice预测未来GasPrice走势。 技术术语 ZKP: Zero Knowledge Proof，零知识证明。 EVM：Ethereum Virtual Machine，虚拟机是执行交易的一个轻量级沙盒虚拟机。 Message：消息，是一个不能序列化的，并且只存在于Simplechain运行环境中的虚拟对象，一条消息主要包括：消息的发送方、接收方、gasLimit等等； 序列化：将数据使用RLP编码为一组字节数据，便于数据交换与存储。 RLP: 递归长度前缀编码，一种能够压缩数据的数据编码协议，在Simplechain中常用于序列化数据。 MPT：默克尔压缩前缀树， Merkle Patricia Tree，是一种经过改良的、融合了默克尔树和前缀树两种树结构优点的数据结构，是Simplechain中用来组织管理账户数据、生成交易集合哈希的重要数据结构。 Patricia Trie: 一种压缩前缀树，是一种更节省空间的树，对于 trie 的每个节点，如果该节点是其父节点唯一的儿子的话，就和父节点结合； Merkle Tree: 默克尔树，也称为 Hash Tree，默克尔树叶子节点的value是数据项的内容，或者是数据项的哈希值；非叶子节点的value根据其孩子节点的信息，然后按照Hash算法计算而得出的。 Whisper：密语，是一种依托于P2P的通信协议，通过 Whisper 协议，节点可以将信息发送给某个特定节点，实现双节点私聊和按主题在多个节点上通信。主要用于大规模的点对点数据发现、信号协商、最小传输通信、完全隐私保护的 DApp 而设计的。 Swarm： 是一个分布式存储平台和内容分发服务，是Simplechain web3 技术栈的本地基础层服务; LLL，Sperpent、Mutan和Solidity：用于编写智能合约代码的的编程语言，能被编译成EVM代码。 ERC20: 可以理解成 Simplechain 的一个 Token 协议规范，所有基于 Simplechain 开发的 Token 合约都遵守这个规范。遵守 ERC20 协议规范的 Token 可以被各种 Simplechain 钱包支持。 ERC721: 是在ERC20标准上建立的Token协议规范，是针对不可互换Token(non-fungible tokens 简称NFTs)做的智能合约标准。 "},"3_sipcCoin.html":{"url":"3_sipcCoin.html","title":"sipc代币","keywords":"","body":"Sipc是公有区块链平台SimpleChain的链上流通代币，发行于2019年初，代币发行总量为100000000枚。SimpleChain是一款以一主链多子链结构为设计理念的公链，支持多共识、多业务场景的区块链部署与拓展，支持跨链交易，支持子链满足千万级别TPS，涉及分布式计算、司法数字化、数字拍卖、不动产、数娱游戏、交易结算等多应用场景。 流通平台 ZT 支持钱包 SIPC ChainBox 行情工具 非小号 mytoken 支持矿池 Matpool Dxpool Simpool "},"4_PublishCoin/":{"url":"4_PublishCoin/","title":"发行代币","keywords":"","body":"如何在SimpleChain上发行数字资产 前提条件 实现链上发币的准备工作，包括: SimpleChain 的下载以及部署。 启动节点。 创建账户。 确保账户解锁并有 token。 准备工作 1.了解 ERC20 代币标准。 说明:在 SimpleChain 上实现代币需要遵循 ERC20 标准。 //ERC20Token.sol //ERC 合约标准，该标准规定在发 Token 之前，需要指定 token 的名称、标识、总量、实现合 //约标准函数等 pragma solidity ^0.4.26; contract ERC20Token { //获取 token 名称 function name() public constant returns (string name); //获取 token 标识 function symbol() public constant returns (string symbol); //获取 token 的最小分割量 function decimals() public constant returns (uint8 decimals); //获取 token 的总量 function totalSupply() public constant returns (uint256 totalSupply); //获取_owner 账户当前的 token 量 function balanceOf(address _owner) public constant returns (uint256 balance); //转账交易 function transfer(address _to, uint256 _value) public returns (bool success); //由_from 向_to 进行转账 function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); //许可_spender 能从调用合约方法的账户转出总量为_value 的 token function approve(address _spender, uint256 _value) public returns (bool success); //获取_spender 可以从账户_owner 中转出 token 的剩余数量 function allowance(address _owner, address _spender) public constant returns (uint remaining); //转账事件(transfer、transferFrom 会触发该事件) event Transfer(address indexed _from, address indexed _to, uint256 _value); //许可事件(approve 会触发该事件) event Approval(address indexed _owner, address indexed _spender, uint256 _value); } 2.编写符合ERC20标准的代币合约。 //Mytoken.sol pragma solidity ^0.4.26; import \"./ERC20Token.sol\"; contract MyToken is ERC20Token { string private _name; string private _symbol; uint8 private _decimals = 18; //此处建议为 18，代表最小单位为 0.1^18 uint256 private _totalSupply; //存储账户的 token 总量 mapping(address => uint256) private _balances; //存储前一个address允许后一个address转出token的剩余数量 mapping(address => mapping(address => uint256)) private _allowances; function MyToken(uint256 initialSupply, string tokenName, string tokenSymbol) public{ _name = tokenName; _symbol = tokenSymbol; _totalSupply = initialSupply * 10 ** uint256(_decimals); _balances[msg.sender] = _totalSupply; } function name() public constant returns (string name){ name = _name; } function symbol() public constant returns (string symbol){ symbol = _symbol; } function decimals() public constant returns (uint8 decimals){ decimals = _decimals; } function totalSupply() public constant returns (uint256 totalSupply){ totalSupply = _totalSupply; } function balanceOf(address _owner) public constant returns (uint256 balance){ balance = _balances[_owner]; } function transfer(address _to, uint256 _value) public returns (bool success){ require(_balances[msg.sender] >= _value); //保证发出交易的账户 token 足够完成转账 _balances[msg.sender] -= _value; _balances[_to] += value; Transfer(msg.sender, _to, _value); success = true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){ require(_balances[_from] >= _value); //保证_from 账户 token 足够完成转 账 require(_allowances[_from][msg.sender] >= _value); //保证_from 账户允许 执行账户转出的 token 剩余量足够 _balances[_from] -= _value; _allowances[_from][msg.sender] -= _value; _balances[_to] += _value; Transfer(_from, _to, _value); success = true; } } //许可_spender 能从调用合约方法的账户转出总量为_value 的 token function approve(address _spender, uint256 _value) public returns (bool success){ _allowances[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); success = true; } //获取_spender 可以从账户_owner 中转出 token 的剩余数量 function allowance(address _owner, address _spender) public constant returns (uint256 remaining){ remaining = _allowances[_owner][_spender]; } } 合约编译 使用浏览器打开 Remix Solidity IDE。 将 ERC20Token.sol 和 MyToken.sol 添加到 browser 文件夹下。 在网页右侧框选中 Compile 选项，选择合约编译器的版本(本文选择 0.4.26)。 点击 Start to compile 进行编译。 合约部署 选中 Run 选项，在 Environment 中选择 Web3 Provider。在弹出的选框中输入当前启 动的sipe节点端口。 选择已解锁且有 token 的 Account 地址。 选择 MyToken 合约，在 Deploy 栏中输入初始化参数:token 总量，token 名，token标识，点击Deploy。 等待一分钟左右至合约部署完成，在 Deployed Contracts 栏出现合约则说明部署完成。至此发币完成。 合约验证 执行合约的decimals，name，symbol，totalSupply方法查看代币是否创建成功。 执行transfer方法，展开transfer方法向其他账户进行转账并使用balanceOf查询是 否转账成功。 "},"5_concoct.html":{"url":"5_concoct.html","title":"配置","keywords":"","body":"SimpleChain的基础配置服务于链，启动SimpleChain节点，则需要将链配置载入。 因此，在SimpleChain中内置了主网(mainnet)、测试网(testnet)配置。 初始启动节点时，将根据不同的参数（–dev、–testnet）来默认加载不同链配置。 链配置 不同于传统软件，因为区块链的不可篡改性，要求对同一个区块，不管出块时的软件版本，还是n年后的软件版本。都需要保证软件对已出块区块做出相同操作。因此区块链的链配置，不得随意更改，还需要维护重要历史变更内容。 下面是链的核心配置信息，定义在 params/config.go 中： // ChainConfig is the core config which determines the blockchain settings. // ChainConfig is stored in the database on a per block basis. This means // that any network, identified by its genesis block, can have its own // set of configuration options. type ChainConfig struct { ChainID *big.Int `json:\"chainId\"` // chainId identifies the current chain and is used for replay protection SingularityBlock *big.Int `json:\"singularityBlock,omitempty\"` // Singularity switch block (nil = no fork, 0 = already on singularity) EWASMBlock *big.Int `json:\"ewasmBlock,omitempty\"` // EWASM switch block (nil = no fork, 0 = already activated) // Various consensus engines Ethash *EthashConfig `json:\"ethash,omitempty\"` Clique *CliqueConfig `json:\"clique,omitempty\"` Scrypt *ScryptConfig `json:\"scrypt,omitempty\"` DPoS *DPoSConfig `json:\"dpos,omitempty\"` Raft bool `json:\"raft,omitempty\"` Istanbul *IstanbulConfig `json:\"istanbul,omitempty\"` } 区块链的不可篡改性，非中心化程序使得区块链网络程序升级复杂化。从Simplechain的核心配置，可折射出整个Simplechain网络所经历的关键时刻。 如上的SimpleChain链配置，并非程序起初编写，而是随SimpleChain发展，在共识协议重大变更时积累而成。 下面是各项配置的作用说明： ChainID ChianID是当前链标识符，用于防止重放攻击。 SingularityBlock 硬分叉高度。意味着从此高度开始，新区块受新版本共识规则约束。因涉及共识变更，如果希望继续接受新区块则必须升级Simplechain程序，属于区块链硬分叉。 如果不愿意接受共识变更，则可以独立使用新的 ChainID 继续原共识，且必须独立维护版本。 EWASMBlock Ethash Ethash共识算法引擎配置，Ethash是以太坊的共识算法，它是一种PoW共识算法。可作为Simplechain子链的一种共识算法。 Clique Clique POA共识算法的共识引擎配置,PoA共识算法也是Simplechain可以选择的共识算法之一，在搭建测试链和私有链的时候可以选择该共识算法。 Scrypt Scrypt共识算法引擎配置，Scrypt是Simplechain主链的共识算法，该算法属于PoW共识算法。 DPoS DPoS共识算法引擎配置, DPoS是Simplechain子链的一种共识算法，因为Simplechain是一主多子的区块链架构，所以子链可以选择多种共识算法，DPos就是子链可以选择的一种共识算法。 Raft Raft共识算法引擎配置，Raft是Simplechain子链可以选择的一种共识算法,Raft通过选举一个高贵的领导人，然后给予他全部的管理复制日志的责任来实现一致性。 Istanbul IstanbulSimplechain的共识引擎配置 "},"6_genesis/":{"url":"6_genesis/","title":"创世块","keywords":"","body":"创世区块作为第零个区块，其他区块直接或间接引用到创世区块。 因此节点启动之初必须载入正确的创世区块信息，且不得任意修改。 SimpleChain允许通过创世配置文件来初始化创世区块，也可使用选择使用内置的多个网络环境的创世配置。 默认使用SimpleChain主网创世配置。 创世配置文件 如果你需要搭建SimpleChain私有链，那么了解创世配置是必须的，否则你大可不关心创世配置。 下面是一份 JSON 格式的创世配置示例： { \"config\": { \"chainId\": 100, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"alloc\" : {}, \"coinbase\" : \"0x0000000000000000000000000000000000000000\", \"difficulty\" : \"0x20000\", \"extraData\" : \"\", \"gasLimit\" : \"0x2fefd8\", \"nonce\" : \"0x0000000000000042\", \"mixhash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"timestamp\" : \"0x00\" } 根据配置用途可分为三大类： 1.链配置 config项是定义链配置，会影响共识协议，虽然链配置对创世影响不大，但新区块的出块规则均依赖链配置。 2.创世区块头信息配置 nonce：随机数，对应创世区块 Nonce 字段。 timestamp：UTC时间戳，对应创世区块 Time字段。 extraData：额外数据，对应创世区块 Extra 字段。 gasLimit：必填，燃料上限，对应创世区块 GasLimit 字段。 difficulty：必填，难度系数，对应创世区块 Difficulty 字段。搭建私有链时，需要根据情况选择合适的难度值，以便调整出块。 mixHash：一个哈希值，对应创世区块的MixDigest字段。和 nonce 值一起证明在区块上已经进行了足够的计算。 coinbase：一个地址，对应创世区块的Coinbase字段。 3.初始账户资产配置 alloc 项是创世中初始账户资产配置。在生成创世区块时，将此数据集中的账户资产写入区块中，相当于预挖矿。 这对开发测试和私有链非常好用，不需要挖矿就可以直接为任意多个账户分配资产。 创世区块加载流程 在运行 Simplechain 时需根据配置文件加载创世配置以及创世区块，并校验其合法性。 如果配置信息随意变更，易引起共识校验不通过等问题。只有在加载并检查通过时，才能继续运行程序。 上图是一个简要流程，下面分别讲解“加载创世配置”和“安装创世区块”两个子流程。 加载创世配置 应使用哪种创世配置，由用户在启动 Sipe 时决定。下图是创世配置选择流程图： 通过 Sipe 命令参数可选择不同网络配置，可以通过 networkid 选择，也可使用网络名称启用。 1.使用 networkid, 不同网络使用不同ID标识。 1=Frontier，主网环境，是默认选项。 2=Morden 测试网络，但已禁用。 3=Ropsten 测试网络。 4=Rinkeby 测试网络。 2.直接使用网络名称： testnet: Ropsten 测试网络。 rinkeby: Rinkeby 测试网络。 goerli: Görli 测试网络。 dev: 本地开发环境。 Sipe 启动时根据不同参数选择加载不同网络配置，并对应不同网络环境。如果不做任何选择，虽然在此不会做出选择，但在后面流程中会默认使用主网配置。 安装创世区块 首先，需要从数据库中根据区块高度 0 读取创世区块哈希。 如果不存在则说明本地属于第一次启动，直接使用运行时创世配置来构建创世区块。 属于首次，还需要存储创世区块和链配置。 如果存在，则需要使用运行时创世配置构建创世区块并和本次已存储的创世区块哈希进行对比。 一旦不一致，则返回错误，不得继续。 随后，还需要检查链配置。先从数据库获取链配置，如果不存在，则无需校验直接使用运行时链配置。 否则，需要检查运行时链配置是否正确，只有正确时才能替换更新。 但有一个例外：主网配置不得随意更改，由代码控制而非人为指定。 总的来说，Simplechain默认使用主网配置，只有在首次运行时才创建和存储创世区块，其他时候仅仅用于校验。 而链配置除主网外则在规则下可随时变更。 构建创建区块 上面我们已知晓总体流程，这里再细说下Simplechain是如何根据创世配置生成创世区块。 核心代码位于 core/genesis.go:229 func (g *Genesis) ToBlock(db ethdb.Database) *types.Block{ if db == nil { db = rawdb.NewMemoryDatabase() } statedb, _ := state.New(common.Hash{}, state.NewDatabase(db))//1 for addr, account := range g.Alloc { //2 statedb.AddBalance(addr, account.Balance) statedb.SetCode(addr, account.Code) statedb.SetNonce(addr, account.Nonce) for key, value := range account.Storage { statedb.SetState(addr, key, value) } } root := statedb.IntermediateRoot(false)//3 head := &types.Header{//4 Number: new(big.Int).SetUint64(g.Number), Nonce: types.EncodeNonce(g.Nonce), Time: g.Timestamp, ParentHash: g.ParentHash, Extra: g.ExtraData, GasLimit: g.GasLimit, GasUsed: g.GasUsed, Difficulty: g.Difficulty, MixDigest: g.Mixhash, Coinbase: g.Coinbase, Root: root, } //5 if g.GasLimit == 0 { head.GasLimit = params.GenesisGasLimit } if g.Difficulty == nil { head.Difficulty = params.GenesisDifficulty } statedb.Commit(false)//6 statedb.Database().TrieDB().Commit(root, true)//7 return types.NewBlock(head, nil, nil, nil)//8 } 上面代码是根据创世配置生成创世区块的代码逻辑，细节如下： 创世区块无父块，从零初始化全新的 state（后续文章会详细讲解 state对象）。 遍历配置中 Alloc 项账户集合数据，直接写入 state 中。 这里不单可以设置 balance，还可以设置 code、nonce 以及任意多个 storage 数据。 意味着创世时便可以直接部署智能合约。例如下面配置则在创世时部署了一个名为093f59f1d91017d30d8c2caa78feb5beb0d2cfaf 的智能合约。 \"alloc\": { \"093f59f1d91017d30d8c2caa78feb5beb0d2cfaf\": { \"balance\": \"0xffffffffffffffff\", \"nonce\": \"0x3\", \"code\":\"0x606060\", \"storage\":{ \"11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa\":\"1234ff\" } } } 将账户数据写入 state 后，便可以计算出 state 数据的默克尔树的根值，称之为 StateRoot。 此值记录在区块头 Root 字段中。 创世配置的一部分配置，则直接映射到区块头中，完成创世区块头的构建。 因为 GasLimit 和 Difficulty 直接影响到下一个区块出块处理。 因此未设置时使用默认配置(Difficulty=131072，GasLimit=4712388)。 提交 state，将 state 数据提交到底层的内存 trie 数据中。 将内存 trie 数据更新到 db 中。 这是多余的一步，因为提交到数据库是由外部进行，这里只需要负责生成区块。 利用区块头创建区块，且区块中无交易记录。 "},"7_account.html":{"url":"7_account.html","title":"账户","keywords":"","body":"对比比特币的 “UTXO” 余额模型，SimpleChain和Simplechain类似使用“账户”余额模型。 SimpleChain丰富了账户内容，除余额外还能自定义存放任意多数据。 并利用账户数据的可维护性，构建智能合约账户。 实际上SimpleChain是为了实现智能合约而提炼的账户模型。 以账户为单位，安全隔离数据。账户间信息相互独立，互不干扰。再配合SimpleChain虚拟机，让智能合约沙盒运行。 SimpleChain作为智能合约操作平台，将账户划分为两类：外部账户（EOAs）和合约账户（contract account）。 外部账户 EOAs-外部账户(external owned accouts)是由人们通过私钥创建的账户。 是真实世界的金融账户的映射，拥有该账户私钥的任何人都可以控制该账户。 如同银行卡，到ATM机取款时只需要密码输入正确即可交易。 这也是人类与Simplechain账本沟通的唯一媒介，因为SimpleChain中的交易需要签名， 而只能使用拥有私有外部账户签名。 外部账户特点总结： 拥有sipc余额。 能发送交易，包括转账和执行合约代码。 被私钥控制。 没有相关的可执行代码。 合约账户 含有合约代码的账户。 被外部账户或者合约创建，合约在创建时被自动分配到一个账户地址， 用于存储合约代码以及合约部署或执行过程中产生的存储数据。 合约账户地址是通过SHA3哈希算法产生，而非私钥。 因无私钥，因此无人可以拿合约账户当做外部账户使用。 只能通过外部账户来驱动合约执行合约代码。 下面是合约地址生成算法：Keccak256(rlp([sender,nonce])[12:] // crypto/crypto.go:74 func CreateAddress(b common.Address, nonce uint64) common.Address { data, _ := rlp.EncodeToBytes([]interface{}{b, nonce}) return common.BytesToAddress(Keccak256(data)[12:]) } 因为合约由其他账户创建，因此将创建者地址和该交易的随机数进行哈希后截取部分生成。 特别需要注意的是，在EIP1014中提出的另一种生成合约地址的算法。 其目的是为状态通道提供便利，通过确定内容输出稳定的合约地址。 在部署合约前就可以知道确切的合约地址。下面是算法方法:keccak256( 0xff ++ address ++ salt ++ keccak256(init_code))[12:]。 // crypto/crypto.go:81 func CreateAddress2(b common.Address, salt [32]byte, inithash []byte) common.Address { return common.BytesToAddress(Keccak256([]byte{0xff}, b.Bytes(), salt[:], inithash)[12:]) } 合约账户特点总结： 拥有sipc余额。 有相关的可执行代码（合约代码）。 合约代码能够被交易或者其他合约消息调用。 合约代码被执行时可再调用其他合约代码。 合约代码被执行时可执行复杂运算，可永久地改变合约内部的数据存储。 差异对比 综上，下面表格列出两类账户差异，合约账户更优于外部账户。 但外部账户是人们和Simplechain沟通的唯一媒介，和合约账户相辅相成。 项 外部账户 合约账户 私钥 private Key ✔️ ✖️ 余额 balance ✔️ ✔️ 代码 code ✖️ ✔️ 多重签名 ✖️ ✔️ 控制方式 私钥控制 通过外部账户执行合约 上面有列出多重签名，是因为SimpleChain外部账户只由一个独立私钥创建，无法进行多签。 但合约具有可编程性，可编写符合多重签名的逻辑，实现一个支持多签的账户。 账户数据结构 SimpleChain数据以账户为单位组织，账户数据的变更引起账户状态变化。 从而引起Simplechain状态变化。 在程序逻辑上两类账户的数据结构一致： 对应代码如下： // core/state/state_object.go:100 type Account struct { Nonce uint64 Balance *big.Int Root common.Hash CodeHash []byte } 但在数据存储上稍有不同，因为外部账户无内部存储数据和合约代码，因此外部账户数据中 StateRootHash 和 CodeHash 是一个空默认值。一旦属于空默认值，则不会存储对应物理数据库中。在程序逻辑上，存在code则为合约账户。即 CodeHash 为空值时，账户是一个外部账户，否则是合约账户。 上图是SimpleChain账户数据存储结构，账户内部实际只存储关键数据，而合约代码以及合约自身数据则通过对应的哈希值关联。因为每个账户对象，将作为一个SimpleChain账户树的一个叶子数据存储，不能太大。 在密码学领域，Nonce 代表一个只使用一次的数字。它往往是一个随机或伪随机数，以避免重复。 SimpleChain账户中加入 Nonce，可避免重放攻击，但不是随机产生。 账户 Nonce 起始值是 0，后续每触发一次账户执行则 Nonce 值计加一次。其中一处的计数逻辑如下： // core/state_transition.go:212 st.state.SetNonce(msg.From(), st.state.GetNonce(sender.Address())+1) 这样的附加好处是，一般可将 Nonce 当做账户的交易次数计数器使用，特别是对于合约账户可以准确的记录合约被调用次数。 而Balance则记录该账户所拥有的sipc数量，称为账户余额.转移资产(Transfer)是在一个账户的Balance上计加，在另外一个账户计减。 // core/evm.go:94 func Transfer(db vm.StateDB, sender, recipient common.Address, amount *big.Int) { db.SubBalance(sender, amount) db.AddBalance(recipient, amount) } // core/vm/evm.go:191 if !evm.Context.CanTransfer(evm.StateDB, caller.Address(), value) { return nil, gas, ErrInsufficientBalance } // core/vm/evm.go:214 evm.Transfer(evm.StateDB, caller.Address(), to.Address(), value) 当然必须保证转账方余额充足，在转移前需要CanTransfer检查， 如果余额充足，则执行Transfer转移Value数量的以太。 账户状态哈希值 StateRoot，是合约所拥有的方法、字段信息构成的一颗默克尔压缩前缀树（Merkle Patricia Tree）的根值，简单地讲是一颗二叉树的根节点值。合约状态中的任意一项细微变动都最终引起 StateRoot 变化，因此合约状态变化会反映在账户的StateRoot上。 同时，你可以直接利用 StateRoot 从 Leveldb 中快速读取具体的某个状态数据，如合约的创建者。 通过SimpleChainAPI web3.eth.getStorageAt 可读取合约中任意位置的数据。 下面，我们通过一段示例代码，感受SimpleChain数据存储。 import(...) var toAddr =common.HexToAddress var toHash =common.BytesToHash func main() { statadb, _ := state.New(common.Hash{}, state.NewDatabase(rawdb.NewMemoryDatabase()))// 1 acct1:=toAddr(\"0x0bB141C2F7d4d12B1D27E62F86254e6ccEd5FF9a\")// 2 acct2:=toAddr(\"0x77de172A492C40217e48Ebb7EEFf9b2d7dF8151B\") statadb.AddBalance(acct1,big.NewInt(100)) statadb.AddBalance(acct2,big.NewInt(888)) contract:=crypto.CreateAddress(acct1,statadb.GetNonce(acct1))//3 statadb.CreateAccount(contract) statadb.SetCode(contract,[]byte(\"contract code bytes\"))//4 statadb.SetNonce(contract,1) statadb.SetState(contract,toHash([]byte(\"owner\")),toHash(acct1.Bytes()))//5 statadb.SetState(contract,toHash([]byte(\"name\")),toHash([]byte(\"ysqi\"))) statadb.SetState(contract,toHash([]byte(\"online\")),toHash([]byte{1}) statadb.SetState(contract,toHash([]byte(\"online\")),toHash([]byte{}))//6 statadb.Commit(true)//7 fmt.Println(string(statadb.Dump()))//8 } 上面代码中，我们创建了三个账户，并且提交到数据库中。最终打印出当前数据中所有账户的数据信息： 一行代码涉及多个操作。首先是创建一个内存KV数据库，再包装为 stata 数据库实例， 最后利用一个空的DB级的StateRoot，初始化一个Simplechain statadb。 定义两个账户 acct1和acct2，并分别添加100和888到账户余额。 模拟合约账户的创建过程，由外部账户 acct1 创建合约账户地址，并将此地址载入 statadb。 在将合约代码加入刚刚创建的合约账户中，在写入合约代码的同时， 会利用crypto.Keccak256Hash(code)计算合约代码哈希，保留在账户数据中。 模拟合约执行过程，涉及修改合约状态，新增三项状态数据owner,name和online，分别对应不同值。 这里和前面不同的是，是给状态online赋值为空[]byte{}，因为所有状态的默认值均是[]byte{}， 在提交到数据库时，如Leveldb 认为这些状态无有效值，会从数据库文件中删除此记录。 因此，此操作实际是一个删除状态online操作。 上面所有操作，还都只是发生在 statdb 内存中，并未真正的写入数据库文件。 执行Commit，才会将关于 statadb 的所有变更更新到数据库文件中。 一旦提交数据，则可以使用 Dump 命令从数据库中查找此 stata 相关的所有数据，包括所有账户。 并以 JSON 格式返还。这里，我们将返还结果直接打印输出。 代码执行输出结果如下： { \"root\": \"3a25b0816cf007c0b878ca7a62ba35ee0337fa53703f281c41a791a137519f00\", \"accounts\": { \"0bb141c2f7d4d12b1d27e62f86254e6cced5ff9a\": { \"balance\": \"100\", \"nonce\": 0, \"root\": \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"codeHash\": \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"code\": \"\", \"storage\": {} }, \"77de172a492c40217e48ebb7eeff9b2d7df8151b\": { \"balance\": \"888\", \"nonce\": 0, \"root\": \"56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"codeHash\": \"c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470\", \"code\": \"\", \"storage\": {} }, \"80580f576731dc1e1dcc53d80b261e228c447cdd\": { \"balance\": \"0\", \"nonce\": 1, \"root\": \"1f6d937817f2ac217d8b123c4983c45141e50bd0c358c07f3c19c7b526dd4267\", \"codeHash\": \"c668dac8131a99c411450ba912234439ace20d1cc1084f8e198fee0a334bc592\", \"code\": \"636f6e747261637420636f6465206279746573\", \"storage\": { \"000000000000000000000000000000000000000000000000000000006e616d65\": \"8479737169\", \"0000000000000000000000000000000000000000000000000000006f776e6572\": \"940bb141c2f7d4d12b1d27e62f86254e6cced5ff9a\" } } } } 我们看到这些显示数据，直接对应我们刚刚的所有操作。 也只有合约账户才有 storage 和 code。而外部账户的codeHash和root值相同，是一个默认值。 "},"8_transaction/":{"url":"8_transaction/","title":"交易","keywords":"","body":"SimpleChain的交易(Transaction)是指由一个外部账户转移一定资产给某个账户， 或者发出一个消息指令到某个智能合约。 在SimpleChain网络中，交易执行属于一个事务。具有原子性、一致性、隔离性、持久性特点。 原子性： 是不可分割的最小执行单位，要么做，要么不做。 一致性： 同一笔交易执行，必然是将Simplechain账本从一个一致性状态变到另一个一致性状态。 隔离性： 交易执行途中不会受其他交易干扰。 持久性： 一旦交易提交，则对Simplechain账本的改变是永久性的。后续的操作不会对其有任何影响。 因为是事务型，因此我们需确保在执行事务前让交易符合一些设计要求。 交易必须唯一，能区分不同交易且同一笔交易不能重复提交到账本中。 交易内容不得变化，每个节点收到的交易都必须一致，交易执行时账本状态变化也是一致的。 交易必须被合法签名，只有已正确签名的交易才能被执行。 交易不能占用过多系统资源，影响其他交易执行。 对交易的设计要求，涉及软件系统的方方面面，但最基础部分还是交易数据本身。 交易数据结构 下图是SimpleChain交易数据结构，根据用途，我将其划分为四部分。 开头是一个 uint64 类型的数字，称之为随机数。用于撤销交易、防止双花和修改SimpleChain账户(账户数据结构)的 Nonce值。 第二部分是关于交易执行限制的设置，gas为愿意供SimpleChain虚拟机运行的燃料上限。 gasPrice 是愿意支付的燃料单价。gasPrcie * gas 则为愿意为这笔交易支付的最高手续费。 第三部分是交易发送者输入SimpleChain虚拟机执行此交易的初始信息： 虚拟机操作对象（接收方 To）、从交易发送方转移到操作对象的资产（Value），以及虚拟机运行时入参(input)。其中To为空时，意味着虚拟机无可操作对象，此时虚拟机将利用input内容部署一个新合约。 第四部分是交易发送方对交易的签名结果，可以利用交易内容和签名结果反向推导出签名者，即交易发送方地址。四部分内容的组合，解决了交易安全问题、实现了智能合约的互动方式以及提供了灵活可调整的交易手续费。 交易对象定义 具体到代码上，SimpleChain将交易对象定义为一个对外可访问的Transation对象和内嵌的对外部包不可见的txdata 。 小写的 txdata 是Go语言的特性。首字母小写，则相当于其他编程语言中的private 修饰符，表明该数据结构对外部包不可见。同样小写开头的对象字段(如 Transaction中的hash)，也表示外部包无法访问此字段。反之，首字母大写的类型、字段、方法等定义，视为public。 // core/types/transaction.go:38 type Transaction struct { data txdata // caches hash atomic.Value size atomic.Value from atomic.Value } type txdata struct { AccountNonce uint64 Price *big.Int GasLimit uint64 Recipient *common.Address Amount *big.Int Payload []byte // Signature values V *big.Int R *big.Int S *big.Int // This is only used when marshaling to JSON. Hash *common.Hash `json:\"hash\" rlp:\"-\"` } 首先看私有的txdata结构体中定义了交易消息中所有必要内容，依次对应前面所说的交易数据结构。有三点需要特别注意。 一是因涉及哈希运算，因此不能随意调整字段定义顺序，非特殊处理情况下必须按要求定义字段。所以txdata中定义的字段，是符合Simplechain交易消息内容顺序的。 二是在涉及货币计算时，不能因为精度缺失引起计算不准确问题。因此在Simplechain、比特币等所有区块链设计中，货币类型均是整数，但最小值1所代表的币值不一样。在SimpleChain中一个sipc等于10的18次方Amount，当要表示100亿sipc时，Amount等于10的27次方。已远远超过Uint64所能表示的范围(0-18446744073709551615)。因此SimpleChain一律采用Go标准包提供的大数 big.Int 进行货币运算和定义货币。这里的Price和Amount均是 big.Int 指针类型。另外，关于签名的三个值也是因为数字太大，而采用 big.Int 类型。 三是最后的Hash字段，这不属于交易内容的一部分，只是为了在交易的JSON中包含交易哈希。为了防止参与哈希运算，该字段被标记为rlp:\"-\"。其次，Transaction 还定义了三个缓存项：交易哈希值(hash)、交易大小(size)和交易发送方(from)。缓存的原因是使用频次高且CPU计算量大。 在区块链中最见的是哈希运算，所有链上数据基本都要参与哈希运算。而哈希运算是CPU密集型的，因此有必要对一些哈希运算等进行缓存，降低CPU计算量。首次计算完交易哈希值后，便缓存交易哈希到hash字段上。 func (tx *Transaction) Hash() common.Hash { if hash := tx.hash.Load(); hash != nil { return hash.(common.Hash) } v := rlpHash(tx) tx.hash.Store(v) return v } hash 是atomic.Value类型，这是Go标准包提供的原子操作对象。这样可防止并发引起多次哈希计算。首先原子加载哈希值，如果存在则返回。如果不存在，则对交易进行哈希计算(rlpHash，是SimpleChain的哈希算法)，将哈希结果保存并返回。 第二个缓存是交易大小(size)。交易大小是指交易信息进行RLP编码后的数据大小。代表交易网络传输大小、代表交易占区块大小、代表交易存储大小。 每笔交易进入交易池都需要检查交易大小是否超过 32KB。推送交易数据给其他节点时也需结合交易大小，在不超过网络消息最大限制(默认10MB)下分包推送数据。为避免重复计算开销，在第一次计算后便缓存。 func (tx *Transaction) Size() common.StorageSize { if size := tx.size.Load(); size != nil { return size.(common.StorageSize) } c := writeCounter(0) rlp.Encode(&c, &tx.data) tx.size.Store(common.StorageSize(c)) return common.StorageSize(c) } 如上，执行 rlp.Encode获得可得到数据大小，缓存结果并返回。 rlp 是Simplechain定义的一套区块链数据编码解码协议，而非采用常见的 gzip、json、Protobuf 编码格式。目的是为了尽可能地压缩数据，毕竟区块链数据结构中只有常见的几种数据类型，不需要复杂的协议涉及，即可满足要求。 最后一个缓存项是交易发送方(from)。交易的发送方，是根据签名反向计算过程，同样是CPU密集型运算。为了保证交易合法性，程序中到处都有涉及取交易发送方地址和校验发送方的合法性。只有正确的签名才能得到发送方地址。因此对交易发送方也进行缓存。 //core/types/transaction_signing.go:72 func Sender(signer Signer, tx *Transaction) (common.Address, error) { if sc := tx.from.Load(); sc != nil { sigCache := sc.(sigCache) if sigCache.signer.Equal(signer) { return sigCache.from, nil } } addr, err := signer.Sender(tx) if err != nil { return common.Address{}, err } tx.from.Store(sigCache{signer: signer, from: addr}) return addr, nil } 特殊指出是需要一个Signer进行解签名，同时通过Signer获取Sender，合法时缓存并返回。但在使用缓存内容时，还需要检查前后两个Signer是否一致，因为不一样的Signer 算法不一样，获得的交易签名者也不相同。 需要注意，上面三个缓存使用都在有一个前提条件：交易对象一旦创建，交易内容不得修改。这也是为何交易对象中单独定义在私有的txdata中，而非直接定义在 Transaction中的原因之一。如下图所示，只能通过调用交易对象方法获取交易内容，无任何途径修改一个现有交易对象内容。 交易对象方法介绍 交易对象 Transtion 除对外提供交易内容访问外，也定义了一些辅助方法。我们依次介绍下各个方法。 ChainId()和Protected() func (tx *Transaction) ChainId() *big.Int { return deriveChainId(tx.data.V) } func (tx *Transaction) Protected() bool { return isProtectedV(tx.data.V) } 从交易签名内容V中提取链ID。用于在获取交易签名者时判断签名合法性，一旦属于受保护Protected()的交易，则签名信息中必须包含当前链ID，否则属于非法交易。 RLP接口实现方法 func (tx *Transaction) EncodeRLP(w io.Writer) error { return rlp.Encode(w, &tx.data) } func (tx *Transaction) DecodeRLP(s *rlp.Stream) error { _, size, _ := s.Kind() err := s.Decode(&tx.data) if err == nil { tx.size.Store(common.StorageSize(rlp.ListSize(size))) } return err } 和其他面向对象语言不同，Go语言中只要对象有实现某个接口的所有方法，则认为该对象属于某接口类型。这里Transaction 实现了rlp包中的Encoder和Decoder两个接口。 //rlp/encode.go:36 type Encoder interface { EncodeRLP(io.Writer) error } type Decoder interface { DecodeRLP(*Stream) error } 意味在进行RLP编码解码时，将通过自定义实现的两个方法进行。RLP编码解码交易，实际是将交易内容 txdata 进行编码解码。同时在解码交易时，缓存交易大小。 JSON接口实现 func (tx *Transaction) MarshalJSON() ([]byte, error) { hash := tx.Hash() data := tx.data data.Hash = &hash return data.MarshalJSON() } func (tx *Transaction) UnmarshalJSON(input []byte) error { var dec txdata if err := dec.UnmarshalJSON(input); err != nil { return err } withSignature := dec.V.Sign() != 0 || dec.R.Sign() != 0 || dec.S.Sign() != 0 if withSignature { var V byte if isProtectedV(dec.V) { chainID := deriveChainId(dec.V).Uint64() V = byte(dec.V.Uint64() - 35 - 2*chainID) } else { V = byte(dec.V.Uint64() - 27) } if !crypto.ValidateSignatureValues(V, dec.R, dec.S, false) { return ErrInvalidSig } } *tx = Transaction{data: dec} return nil } 这是实现了json标准包的编码解码方法，主要是给web3 api 调用时返回符合要求的JSON格式数据。编码时附加交易哈希，解码时还校验签名格式的正确性。下面是一个完整交易JSON格式数据示例。 { \"nonce\": \"0x16\", \"gasPrice\": \"0x2\", \"gas\": \"0x1\", \"to\": \"0x0100000000000000000000000000000000000000\", \"value\": \"0x0\", \"input\": \"0x616263646566\", \"v\": \"0x25\", \"r\": \"0x3c46a1ff9d0dd2129a7f8fbc3e45256d85890d9d63919b42dac1eb8dfa443a32\", \"s\": \"0x6b2be3f225ae31f7ca18efc08fa403eb73b848359a63cd9fdeb61e1b83407690\", \"hash\": \"0xb848eb905affc383b4f431f8f9d3676733ea96bcae65638c0ada6e45038fb3a6\" } json里面所有数字类型的字段都是用十六进制数表示。这是为了统一所有数据格式，为大数 big.Int 服务。在web3js库中专门内置了bignumber库处理大数。 "},"9_block/":{"url":"9_block/","title":"区块","keywords":"","body":"Simplechain可以视为一个数据库，数据库数据的变更由交易催化。为了有效、有序管理交易，必须将一笔或多笔交易组成一个数据块，才能提交到数据库中。这个数据块即区块(Block)。一个区块不但包含了多笔交易，还记录一些额外数据，以便正确提交到数据库中。 下图是Simplechain区块数据结构与关系，讲解区块数据结构时不得不将其他数据一并呈现，只有掌握区块中各项数据来源才能真正了解区块链数据。 区块分为两部分：区块头(Header)和区块体(Body)。区块头信息量非常丰富，不但和上一个单元建立联系还记录了一些交易执行情况信息和矿工工作信息。在上图中涉及一个非常重要的概念 Trie，全名是默克尔压缩前缀树。 区块头数据解释 各个字段数据如下： parentHash 是一个哈希值，记录此区块直接引用的父区块哈希值。通过此记录，才能完整的将区块有序组织，形成一条区块链。并且可以防止父区块内容被修改，因为数据修改，区块哈希必然发生变化，因此一个区块直接或间接的强化了所有父辈区块，通过加密算法保证历史区块不可能被修改。 sha3Uncles 是一个哈希值，表示区块引用的多个叔辈区块。在区块体中也包含了多个叔辈的区块头信息，而sha3Uncles则是叔块集的 RLPHASH 哈希值。在比特币中只有成功挖出区块并被其他节点接受时才能获得奖励，是所有矿工在争取记账权和连带的奖励。而Simplechain稍有不同，不能成为主链一部分的孤儿区块，如果有幸被后来的区块收留进区块链就变成了叔块。收留了孤块的区块有额外的奖励。孤块一旦成为叔块，该区块统一可获得奖励。通过叔块奖励机制，来降低Simplechain软分叉和平衡网速慢的矿工利益。 miner 是一个地址，表示区块是此账户的矿工挖出，挖矿奖励将下发到此账户。 stateRoot 是一个哈希值，表示执行完此区块中的所有交易后Simplechain状态快照ID。因为Simplechain描述为一个状态机系统，因此快照ID称之为状态哈希值。又因为状态哈希是由所有账户状态按默克尔前缀树算法生成，因此称为状态默克尔树根值。 transactionsRoot 是一个哈希值，表示该区块中所有交易生成一颗默克尔树根节点哈希值。是一个密码学保证交易集合摘要。通过此Root可以直接校验某交易是否包含在此区块中。 receiptRoot 是一个哈希值，同样是默克尔树根节点哈希值。由区块交易在执行完成后生成的交易回执信息集合生成。 logsBloom 是一个256长度Byte数组。提取自receipt，用于快速定位查找交易回执中的智能合约事件信息。 difficulty 是 big.Int 值，表示此区块能被挖出的难度系数。 number 是 big.Int 值，表示此区块高度。用于对区块标注序号，在一条区块链上，区块高度必须是连续递增。 gasLimit 是 uint64 值，表示此区块所允许消耗的Gas燃料量。此数值根据父区块进行动态调整，调整的目的是调整区块所能包含的交易数量。 gasUsed 是uint64 值，表示此区块所有交易执行所实际消耗的Gas燃料量。 timestamp 是uint64 值，表示此区块创建的UTC时间戳，单位秒。因为Simplechain平均14.5s出一个区块(白皮书中研究是 12秒)，因此区块时间戳可以充当时间戳服务，但不能完全信任。 extraData 是一个长度不固定的Byte数组，最长32位。完全由矿工自定义，矿工一般会写一些公开推广类内容或者作为投票使用。 mixHash 是一个哈希值。用于校验区块是否正确挖出。实际上是区块头数据不包含nonce时的一个哈希值。 nonce 是一个8长度的Byte，实际是一个uint64 值。用于校验区块是否正确挖出，mixHash只有用一个正确的 nonce 才能进行PoW工作量证明。 关键代码 下面是Simplechain代码中定义的区块头和区块体结构定义代码，所有核心代码均在core/types/block.go文件中： //core/types/block.go:70 type Header struct { ParentHash common.Hash `json:\"parentHash\" gencodec:\"required\"` UncleHash common.Hash `json:\"sha3Uncles\" gencodec:\"required\"` Coinbase common.Address `json:\"miner\" gencodec:\"required\"` Root common.Hash `json:\"stateRoot\" gencodec:\"required\"` TxHash common.Hash `json:\"transactionsRoot\" gencodec:\"required\"` ReceiptHash common.Hash `json:\"receiptsRoot\" gencodec:\"required\"` Bloom Bloom `json:\"logsBloom\" gencodec:\"required\"` Difficulty *big.Int `json:\"difficulty\" gencodec:\"required\"` Number *big.Int `json:\"number\" gencodec:\"required\"` GasLimit uint64 `json:\"gasLimit\" gencodec:\"required\"` GasUsed uint64 `json:\"gasUsed\" gencodec:\"required\"` Time uint64 `json:\"timestamp\" gencodec:\"required\"` Extra []byte `json:\"extraData\" gencodec:\"required\"` MixDigest common.Hash `json:\"mixHash\"` Nonce BlockNonce `json:\"nonce\"` } type Body struct { Transactions []*Transaction Uncles []*Header } 创建一个区块需要调用函数 NewBlock： func NewBlock(header *Header, txs []*Transaction, uncles []*Header, receipts []*Receipt) *Block { b := &Block{header: CopyHeader(header), td: new(big.Int)} // TODO: panic if len(txs) != len(receipts) if len(txs) == 0 { b.header.TxHash = EmptyRootHash } else { b.header.TxHash = DeriveSha(Transactions(txs)) b.transactions = make(Transactions, len(txs)) copy(b.transactions, txs) } if len(receipts) == 0 { b.header.ReceiptHash = EmptyRootHash } else { b.header.ReceiptHash = DeriveSha(Receipts(receipts)) b.header.Bloom = CreateBloom(receipts) } if len(uncles) == 0 { b.header.UncleHash = EmptyUncleHash } else { b.header.UncleHash = CalcUncleHash(uncles) b.uncles = make([]*Header, len(uncles)) for i := range uncles { b.uncles[i] = CopyHeader(uncles[i]) } } return b } "},"10_transactionReceipt/":{"url":"10_transactionReceipt/","title":"交易回执","keywords":"","body":"不同于比特币，Simplechain作为智能合约平台。每一笔交易作为消息在Simplechain虚拟机中执行时，均会获得一个交易回执信息(Receipt)。这份交易回执记录了关于此笔交易的处理结果信息： 回执信息分为三部分：共识信息、交易信息、区块信息。下面分别介绍各类信息。 交易回执内容介绍 交易回执共识信息 共识意味在在校验区块合法性时，这部分信息也参与校验。这些信息参与校验的原因是确保交易必须在区块中的固定顺序中执行，且记录了交易执行后的状态信息。这样可强化交易顺序。 //core/state_processor.go:104 var root []byte if config.IsByzantium(header.Number) { statedb.Finalise(true) } else { root = statedb.IntermediateRoot(config.IsEIP158(header.Number)).Bytes() } //... receipt := types.NewReceipt(root, failed, *usedGas) CumulativeGasUsed： 区块中已执行的交易累计消耗的Gas，包含当前交易。 Logs: 当前交易执行所产生的智能合约事件列表。 Bloom：是从 Logs 中提取的事件布隆过滤器，用于快速检测某主题的事件是否存在于Logs中。 这些信息是如何参与共识校验的呢？实际上参与校验的仅仅是回执哈希，而回执哈希计算只包含这些信息。 首先，在校验时获取整个区块回执信息的默克尔树的根哈希值。再判断此哈希值是否同区块头定义内容相同。 //core/block_validator.go:92 receiptSha := types.DeriveSha(receipts) if receiptSha != header.ReceiptHash { return fmt.Errorf(\"invalid receipt root hash (remote: %x local: %x)\", header.ReceiptHash, receiptSha) } 而函数types.DeriveSha中生成根哈希值，是将列表元素（这里是交易回执）的RLP编码信息构成默克树，最终获得列表的哈希值。 //core/types/derive_sha.go:32 func DeriveSha(list DerivableList) common.Hash { keybuf := new(bytes.Buffer) trie := new(trie.Trie) for i := 0; i 交易回执实现了 RLP 编码接口。在方法EncodeRLP中是构建了一个私有的receiptRLP。 //core/types/receipt.go:119 func (r *Receipt) EncodeRLP(w io.Writer) error { return rlp.Encode(w, &receiptRLP{r.statusEncoding(), r.CumulativeGasUsed, r.Bloom, r.Logs}) } 交易回执交易信息 这部分信息记录的是关于回执所对应的交易信息，有： TxHash ： 交易回执所对应的交易哈希。 ContractAddress： 当这笔交易是部署新合约时，记录新合约的地址。 //core/state_processor.go:118 if msg.To() == nil { receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce()) } GasUsed: 这笔交易执行所消耗的Gas手续费 交易回执区块信息 这部分信息完全是为了方便外部读取交易回执，不但知道交易执行情况，还能方便的指定该交易属于哪个区块中第几笔交易。 BlockHash: 交易所在区块哈希。 BlockNumber: 交易所在区块高度。 TransactionIndex： 交易在区块中的序号。 这三项信息，主要是在数据库 Leveldb 中读取交易回执时，实时指定。 //core/rawdb/accessors_chain.go:315 receipts := make(types.Receipts, len(storageReceipts)) logIndex := uint(0) for i, receipt := range storageReceipts { //... receipts[i] = (*types.Receipt)(receipt) receipts[i].BlockHash = hash receipts[i].BlockNumber = big.NewInt(0).SetUint64(number) receipts[i].TransactionIndex = uint(i) } 交易回执构造 交易回执是在Simplechain虚拟机处理完交易后，根据结果整理出的交易执行结果信息。反映了交易执行前后Simplechain变化以及交易执行状态。 构造细节，已经在前面提及，不再细说。这里给出的完整的交易回执构造代码。 // core/state_processor.go:94 context := NewEVMContext(msg, header, bc, author) vmenv := vm.NewEVM(context, statedb, config, cfg) _, gas, failed, err := ApplyMessage(vmenv, msg, gp) if err != nil { return nil, 0, err } var root []byte if config.IsByzantium(header.Number) { statedb.Finalise(true) } else { root = statedb.IntermediateRoot(config.IsEIP158(header.Number)).Bytes() } *usedGas += gas receipt := types.NewReceipt(root, failed, *usedGas) receipt.TxHash = tx.Hash() receipt.GasUsed = gas if msg.To() == nil { receipt.ContractAddress = crypto.CreateAddress(vmenv.Context.Origin, tx.Nonce()) } receipt.Logs = statedb.GetLogs(tx.Hash()) receipt.Bloom = types.CreateBloom(types.Receipts{receipt}) receipt.BlockHash = statedb.BlockHash() receipt.BlockNumber = header.Number receipt.TransactionIndex = uint(statedb.TxIndex()) return receipt, gas, err 交易回执存储 交易回执作为交易执行中间产物，为了方便快速获取某笔交易的执行明细。Simplechain中有跟随区块存储时实时存储交易回执。但为了降低存储量，只存储了必要内容。 首先，在存储时，将交易回执对象转换为精简内容。 //core/rawdb/accessors_chain.go:338 storageReceipts := make([]*types.ReceiptForStorage, len(receipts)) for i, receipt := range receipts { storageReceipts[i] = (*types.ReceiptForStorage)(receipt) } 精简内容是专门为存储定义的一个结构ReceiptForStorage。存储时将交易回执集进行RLP编码存储。 //core/rawdb/accessors_chain.go:342 bytes, err := rlp.EncodeToBytes(storageReceipts) if err != nil { log.Crit(\"Failed to encode block receipts\", \"err\", err) } if err := db.Put(blockReceiptsKey(number, hash), bytes); err != nil { log.Crit(\"Failed to store block receipts\", \"err\", err) } 看ReceiptForStorage的EncodeRLP方法就知道存储了哪些内容 //core/types/receipt.go:179 func (r *ReceiptForStorage) EncodeRLP(w io.Writer) error { enc := &receiptStorageRLP{ PostStateOrStatus: (*Receipt)(r).statusEncoding(), CumulativeGasUsed: r.CumulativeGasUsed, TxHash: r.TxHash, ContractAddress: r.ContractAddress, Logs: make([]*LogForStorage, len(r.Logs)), GasUsed: r.GasUsed, } for i, log := range r.Logs { enc.Logs[i] = (*LogForStorage)(log) } return rlp.Encode(w, enc) } 根据EncodeRLP方法实现，可以得出在存储时仅仅存储了部分内容，且 Logs 内容同样进行了特殊处理LogForStorage "},"11_constructDesign/":{"url":"11_constructDesign/","title":"架构设计","keywords":"","body":"Simplechain的整体架构如下图： 顶层架构设计上 区块链可以简单的分为三个层次，协议层、扩展层和应用层。其中，协议层又可以分为存储层和网络层，它们相互独立但又不可分割。 Simplechain最上层的是DApp，它是整个区块链的展示层，通过Web3.js和智能合约层进行交换，如Simplechain使用的是web3-js，区块链的应用层可以是移动端，web端，或是是融合进现有的服务器，把当前的业务服务器当成应用层。 所有的智能合约都运行在EVM（虚拟机）上，并会用到RPC（Remote Procedure Call Protocol，远程过程调用直观说法就是A通过网络调用B的过程方法）。 在EVM和RPC下面是Simplechain的四大核心内容，包括：blockChain, 共识算法，挖矿以及网络层。除了DApp外，其他的所有部分都在Simplechain的客户端sipe里。 从数据结构来看 协议层，是最底层的技术。这个层次通常是一个完整的区块链产品，类似于我们电脑的操作系统，它维护着网络节点，仅提供Api供调用。网络编程、分布式算法、加密签名、数据存储技术等4个方面，分布式算法基本上属于业务逻辑上的实现，什么语言都可以做到，加密签名技术是直接简单的使用，数据库技术也主要在使用层面。 存储层：一个区块（Block） + 链表及区块链数据结构。Simplechain中使用的数据库是levelDB。 网络层：p2p网络，P2P网络的实现和并发处理才是开发的难点，所以对于那些网络编程能力强，对并发处理简单的语言，Nodejs开发区块链应用，逐渐变得更加流行，Go语言就开始很火了。 共识层：也就是激励层，通过挖矿机制，制定区块链的获取货币的方式。比如比特币用的是POW(Proof of Work工作量证明机制)：电脑的性能越好，越容易获取到货币奖励。还有POS(Proof of Stake权益证明机制)：类似于众筹分红的概念，会根据你持有的货币数量和时间，给持有者发放利息。 扩展层：类似于电脑的驱动程序，Simplechain中这部分包括了EVM(虚拟机)和智能合约两部分。是为了让区块链产品更加实用，比如Simplechain的“智能合约”的概念，这是典型的扩展层面的应用开发。 合约层：以往的区块链是没有这一层的。所以最初的区块链只能进行交易，而无法用于其他的领域或是进行其他的逻辑处理。但是合约层的出现，及智能合约”就是“可编程合约”，或者叫做“合约智能化”，其中的“智能”是执行上的智能，也就是说达到某个条件，合约自动执行使得在其他领域使用区块链成为了现实。 应用层：类似于电脑中的各种软件程序，区块链的展示层。DAPP产品其实也是这个层面的应用，将智能合约发布到区块链上，人们通过地址对这个区块进行访问继而和智能合约交互，Simplechain使用的web3-js.区块链的应用层可以是移动端，web端，或是是融合进现有的服务器，把当前的业务服务器当成应用层。基于此开发的DAPP其实就是在智能合约基础上封装了一层Web应用，发行代币等都是在这个层面，通过DAPP提供的Web应用和智能合约交互。 聚合链架构 SimpleChain设计了一主链多子链的聚合链结构，支持多种业务场景的区块链部署与扩展。SimpleChain主链采用成熟的PoW机制，而子链可根据业务需求设置适合自己场景的共识算法，通过原子交换或跨链节点与主链形成双向锚定的方式，与其他子链进行跨链交易。这种主子链机制可帮助子链在满足每秒数千级别性能的前提下同时获得SimpleChain主链所提供的最终一致性保障。 ​Simplechain子链既可以是公链，也可以是联盟链，其链结构与主链类似（见区块链架构设计），但因业务需求不同，可以采用不同的共识算法，达到数千的TPS性能，或者其他的定制开发功能。 ​主链和子链之间通过跨链协议达到互相锚定，信息互通和资金流动的目的。跨链协议（见跨链协议）采用自由公证人机制，全网生态的任何用户皆可参与和监督，切实发挥社区自理能力，有效保障跨链信息可靠，交易安全有序。同时Simplechain基金会开展了主子链经济模型研究，建立一套Simplechain生态系统持续健康发展的激励机制，在该机制的作用下，主子链生态将协同融合，互相促进，共同发展。 "},"12_structAndStore/":{"url":"12_structAndStore/","title":"数据结构和存储","keywords":"","body":"Simplechain的区块、交易等数据最终都是存储在Level DB数据库中。Level DB 数据库是一个键值对（ key-value ）数据库， key一般与散列相关，value则是存储内容的RLP编码。 一、KV存储LevelDB MPT树 MPT(Merkle Patricia Trie)，是一种用hash索引数据的前缀树。 从宏观上来说，MPT树是一棵前缀树，用key查询value。通过key去查询value，就是用key去在MPT树上进行索引，在经过多个中间节点后，最终到达存储数据的叶子节点。 从细节上来说，MPT树，是一棵Merkle树，每个树上节点的索引，都是这个节点的hash值。在用key查找value的时候，是根据key在某节点内部，获取下一个需要跳转的节点的hash值，拿到下一个节点的hash值，才能从底层的数据库中取出下一个节点的数据，之后，再用key，去下一个节点中查询下下个节点的hash值，直至到达value所在的叶子节点。 当MPT树上某个叶子节点的数据更新后，此叶子节点的hash也会更新，随之而来的，是这个叶子节点回溯到根节点的所有中间节点的hash都会更新。最终，MPT根节点的hash也会更新。当要索引这个新的数据时，用MPT新的根节点hash，从底层数据库查出新的根节点，再往后一层层遍历，最终找到新的数据。而如果要查询历史数据，则可用老的树根hash，从底层数据库取出老的根节点，再往下遍历，就可查询到历史的数据。 MPT树的实现图（图片来自以太坊黄皮书） 账户State 在Simplechain上，数据是以account为单位存储的，每个account内，保存着这个合约(用户)的代码、参数、nonce等数据。account的数据，通过account的地址（address）进行索引。 随着account数据的改变，account的hash也进行改变。于此同时，MPT的根的hash也会改变。不同的时候，account的数据不同，对应的MPT的根就不同。此处，以太坊把这层含义进行了具体化，提出了“状态”的概念。把MPT根的hash，叫state root。不同的state root，对应着不同的“状态”，对应查询到不同的MPT根节点，再用account的address从不同的MPT根节点查询到此状态下的account数据。不同的state，拿到的MPT根节点不同，查询的account也许会有不同。 state root是区块中的一个字段，每个区块对应着不同的“状态”。区块中的交易会对account进行操作，进而改变account中的数据。不同的区块下，account的数据有所不同，即此区块的状态有所不同，具体的，是state root不同。从某个区块中取出这个区块的state root，查询到MPT的根节点，就能索引到这个区块当时account的数据历史。 (图片来自以太坊白皮书) 二、索引存储StormDB StormDB(a simple and powerful toolkit for BoltDB)是一种基于boltDB实现的数据库，它支持索引与搜索查询，相对于传统关系数据库MySQL、Oracle等，StormDB使用单一文件存储，没有单独的服务，更加轻量便于系统移植，SImplechain使用它来存储跨链交易。 名词解释 Bucket 自定义对象的存储单元 Id 存储对象的主键索引，唯一不可重复 Index 排序索引，目前只支持数值类型的字段排序(int8, int16, int32, int64, uint8, uint16, uint32, uint64)，其他类型皆使用编码后字节比较的方式来进行排序。 Unique 唯一哈希索引 Options 查询选项，支持Limit(限制条数)、OrderBy(根据字段排序)、Skip(跳过的条数)等 Matcher 查询的传入条件，支持Eq、Gt(greater than)、Lt(less than)、And、Or、Not、Re(正则匹配)等 举例 以跨链交易存储结构为例，解释上述名词。 type CrossTransactionIndexed struct { PK uint64 `storm:\"id,increment\"` CtxId common.Hash `storm:\"unique\"` From common.Address `storm:\"index\"` To common.Address `storm:\"index\"` TxHash common.Hash `storm:\"index\"` Price *big.Float `storm:\"index\"` Status uint8 `storm:\"index\"` Value *big.Int BlockNum uint64 `storm:\"index\"` BlockHash common.Hash DestinationId *big.Int DestinationValue *big.Int `storm:\"index\"` Input []byte V []*big.Int R []*big.Int S []*big.Int } 解释如下： storm:\"id,increment\"：表示此字段为主键，increment表示在插入时自动递增 storm:\"unique\"：表示此字段使用不可重复的哈希索引 storm:\"index\"：表示此字段使用排序索引 CRUD与事务 插入对象 user := User{ ID: 10, Group: \"staff\", Email: \"john@provider.com\", Name: \"John\", Age: 21, CreatedAt: time.Now(), } err := db.Save(&user) // err == nil user.ID++ err = db.Save(&user) // err == storm.ErrAlreadyExists 更新对象 // Update multiple fields err := db.Update(&User{ID: 10, Name: \"Jack\", Age: 45}) // Update a single field err := db.UpdateField(&User{ID: 10}, \"Age\", 0) 删除对象 err := db.DeleteStruct(&user) 删除Bucket err := db.Drop(&User) //OR err := db.Drop(\"User\") 查询对象 var users []User err := db.Find(\"Group\", \"staff\", &users, storm.Skip(10)) err = db.Find(\"Group\", \"staff\", &users, storm.Limit(10)) err = db.Find(\"Group\", \"staff\", &users, storm.Reverse()) err = db.Find(\"Group\", \"staff\", &users, storm.Limit(10), storm.Skip(10), storm.Reverse()) err = db.All(&users, storm.Limit(10), storm.Skip(10), storm.Reverse()) err = db.AllByIndex(\"CreatedAt\", &users, storm.Limit(10), storm.Skip(10), storm.Reverse()) err = db.Range(\"Age\", 10, 21, &users, storm.Limit(10), storm.Skip(10), storm.Reverse()) 条件查询 query := db.Select(q.Gte(\"Age\", 7), q.Lte(\"Age\", 77)) var users []User err = query.Find(&users) 使用事务 tx, err := db.Begin(true) if err != nil { return err } defer tx.Rollback() accountA.Amount -= 100 accountB.Amount += 100 err = tx.Save(accountA) if err != nil { return err } err = tx.Save(accountB) if err != nil { return err } return tx.Commit() 三、高效内存多索引存储 为了适应不同要求的索引类型以及效率需求，单独使用stormDB已难以满足，因此在内存中引入多索引结构来存储高读写频次的数据。 哈希索引 Simplechain中使用的哈希索引皆为键值唯一的哈希索引，因此直接使用map存储。 插入与更新 idx := make(map[Key]Value) idx[key]=value 删除 delete(idx,key) 读取 if v,ok := idx[key]; ok {//...} 排序索引 Simplechain使用红黑树作为排序索引，用于存储任意有顺序要求的数据类型。 初始化 //comparator:key的比较方法 //isMulti:是否允许key值重复 redblacktree.NewWith(container.UInt64Comparator, true) 插入与更新 idx.Put(key,value) 查询 //返回迭代器，在multi模式下，返回lowerbound itr := idx.Get(key) 删除key //在multi模式下，删除此key关联的所有value idx.Remove(key) 删除特定对象 //获得key的lowerBound与upperBound迭代器，遍历删除满足条件的对象 for it:=idx.LowerBound(key); it!=idx.UpperBound(key); it.Next() { if ... { idx.RemoveOne(itr) break } } "},"50_togetherStep.html":{"url":"50_togetherStep.html","title":"数据同步优化","keywords":"","body":"同步基础流程 同步，是区块链节点非常重要的功能。它是共识的辅助，给共识提供必需的运行条件。同步分为交易的同步和状态的同步。交易的同步，确保了每笔交易能正确的到达每个节点上。状态的同步，能确保区块落后的节点能正确的回到最新的状态。只有持有最新区块状态的节点，才能参与到共识中去。 交易同步 交易同步，是让区块链的上的交易尽可能的到达所有的节点。为共识中将交易打包成区块提供基础。 一笔交易（tx1），从客户端上发往某个节点，节点在接收到交易后，会将交易放入自身的交易池（Tx Pool）中供共识去打包。与此同时，节点会将交易广播给其它的节点，其它节点收到交易后，也会将交易放到自身的交易池中。交易在发送的过程中，会有丢失的情况，为了能让交易尽可能的到达所有的节点，收到广播过来交易的节点，会根据一定的策略，选择其它的节点，再进行一次广播。 交易广播策略 如果每个节点都没有限制的转发/广播收到的交易，带宽将被占满，出现交易广播雪崩的问题。为了避免交易广播的雪崩，Simplechain根据经验，选择了较为精巧的交易广播策略。在尽可能保证交易可达性的前提下，尽量的减少重复的交易广播。 对于SDK来的交易，广播给所有的节点 一条交易在一个节点上，只广播一次，当收到了重复的交易，不会进行二次广播 通过上述的策略，能够尽量的让交易到达所有的节点，但也会在极小的概率下出现某交易无法到达某节点的情况。此情况是允许的。交易尽可能到达更多的节点，是为了让此交易尽快的被打包、共识、确认，尽量的让交易能够更快的得到执行的结果。当交易未到达某个节点时，只会使得交易的执行时间变长，不会影响交易的正确性。 状态同步 状态同步，是让区块链节点的状态保持在最新。区块链的状态的新旧，是指区块链节点当前持有数据的新旧，即节点持有的当前区块块高的高低。若一个节点的块高是区块链的最高块高，则此节点就拥有区块链的最新状态。只有拥有最新状态的节点，才能参与到共识中去，进行下一个新区块的共识。 在一个全新的节点加入到区块链上，或一个已经断网的节点恢复了网络时，此节点的区块落后于其它节点，状态不是最新的。此时就需要进行状态同步。如图，需要状态同步的节点（Node 1），会主动向其它节点请求下载区块。整个下载的过程会将下载的负载分散到多个节点上。 状态同步与下载队列 区块链节点在运行时，会定时向其它节点广播自身的最高块高。节点收到其它节点广播过来的块高后，会和自身的块高进行比较，若自身的块高落后于此块高，就会启动区块下载流程。 区块的下载通过请求的方式完成。进入下载流程的节点，会随机的挑选满足要求的节点，发送需要下载的区块区间。收到下载请求的节点，会根据请求的内容，回复相应的区块。 收到回复区块的节点，在本地维护一个下载队列，用来对下载下来的区块进行缓冲和排序。下载队列是一个以块高为顺序的优先队列。下载下来的区块，会不断的插入到下载队列中，当队列中的区块能连接上节点当前本地的区块链，则将区块从下载队列中取出，真正的连接到当前本地的区块链上。 同步场景举例 交易同步 一笔交易被广播到所有节点的过程： 一笔交易通过channel或RPC发送到某节点上 收到交易的节点全量广播此交易给其它节点 其它节点收到交易后，为了保险起见，选择25%的节点再广播一次 节点收到广播过的交易，不会再次广播 状态同步 节点出块时的广播逻辑 某个节点出块 此节点将自己最新的状态（最新块高，最高块哈希，创世块哈希）广播给所有的节点 其它的节点收到peer的状态后，更新在本地管理的peer数据 "},"13_p2pNetwork.html":{"url":"13_p2pNetwork.html","title":"p2p网络","keywords":"","body":"设计目标 Simplechain P2P模块提供高效、通用和安全的网络通信基础功能，支持区块链消息的单播、组播和广播，支持区块链节点状态同步，支持多种协议。 P2P主要功能 区块链节点标识: 通过区块链节点标识唯一标识一个区块链节点，在区块链网络上通过区块链节点标识对区块链节点进行寻址 管理网络连接: 维持区块链网络上区块链节点间的TCP长连接，自动断开异常连接，自动发起重连 消息收发: 在区块链网络的区块链节点间，进行消息的单播、组播或广播 状态同步: 在区块链节点间同步状态 Simplechain节点标识 Simplechain的节点标识由ECC算法的公钥生成，每个区块链节点必须有唯一的ECC密钥对，节点标识在区块链网络中唯一标识一个区块链节点。通常情况下，一个节点要加入区块链网络，需要ECC格式的节点密钥node.key文件。 Simplechain节点除了有唯一区块链节点标识，还能关注Topic，供寻址使用。Simplechain节点寻址： 区块链节点标识寻址： 通过区块链节点标识，在区块链网络中定位唯一的区块链节点。 Topic寻址： 通过Topic，在区块链网络中定位一组关注该Topic的节点。 管理网络连接 Simplechain节点之间，会自动发起和维持TCP长连接，在系统故障、网络异常时，主动发起重连。节点间建立连接时，会使用CA证书进行认证 连接建立流程 participant 节点A participant 节点B 节点A->>节点A: 加载密钥 节点B->>节点B: 加载密钥 节点A->>节点B: 发起连接 节点B->>节点A: 连接成功 节点B->节点A: 发起SSL握手 节点B->节点A: 握手成功，建立SSL连接 消息收发 节点间消息支持单播、组播和广播 单播，单个节点向单个区块链节点发送消息，通过区块链节点标识寻址 组播，单个节点向一组区块链节点发送消息，通过Topic寻址 广播，单个节点向所有区块链节点发送消息 单播流程 sequenceDiagram participant 节点A participant 节点B 节点A->>节点A: 根据节点ID，筛选在线节点 节点A->>节点B: 发送消息 节点B->>节点A: 消息回包 组播流程 sequenceDiagram participant 节点A participant 节点B participant 节点C participant 节点D 节点A->>节点A: 根据Topic 1，选择节点B、C 节点A->>节点B: 发送消息 节点A->>节点C: 发送消息 节点B->>节点B: 根据Topic 2，选择节点C、D 节点B->>节点C: 发送消息 节点B->>节点D: 发送消息 节点C->>节点C: 根据Topic 3，选择节点D 节点C->>节点D: 发送消息 广播流程 sequenceDiagram participant 节点A participant 节点B participant 节点C participant 节点D 节点A->>节点A: 遍历所有节点ID 节点A->>节点B: 发送消息 节点A->>节点C: 发送消息 节点A->>节点D: 发送消息 节点B->>节点B: 遍历所有节点ID 节点B->>节点C: 发送消息 节点B->>节点D: 发送消息 节点C->>节点C: 遍历所有节点ID 节点C->>节点D: 发送消息 状态同步 每个节点会维护自身的状态，并将状态的Seq在全网定时广播，与其它节点同步 sequenceDiagram participant 节点A participant 节点B 节点A->节点B: 广播seq 节点A->>节点A: 判断节点B的seq是否变化 节点A->>节点B: seq变化，发起状态查询请求 节点B->>节点A: 返回节点状态 节点A->>节点A: 更新节点B的状态和seq "},"14_consensus/":{"url":"14_consensus/","title":"共识机制","keywords":"","body":"共识机制是区块链事务达成分布式共识的算法。由于点对点网络下存在着或高或低的网络延迟，所以各个节点接收到的事务的先后顺序可能不一样，因此区块链系统需要设计一种机制让节点对在差不多时间内发生的事务的先后顺序实现共识，这就是共识机制。 PoW共识算法 PoW 即通过工作结果来证明你完成了相应的工作哈希函数的特征： 免碰撞，即不存在输入值不同，经过散列变换，而散列值相同的情况。 隐匿性，即给定一个散列值，想要反向逆推出输入值，在计算上是不可行的。 不存在比穷举更好的方法，以使得散列值落在特定的范围。POW算法原理：节点通过不断地更换随机数来探寻合适的哈希值，当节点最先计算出合适的哈希值，它所打包的块如果通过其他共识节点的验证，则会被加入到区块链中。 Scrypt算法简介 Simplechain 采用的挖矿算法是Scrypt算法。Scrypt是内存依赖型的POW算法，它是一种符合PoW共识机制的算法。Scrypt算法过程中也需要计算哈希值，但是，Scrypt计算过程中需要使用较多的内存资源。 Scrypt算法过程 Scrypt算法使用的几个函数环环相扣，本节按函数从里到外的调用顺序描述。 Salsa20/8 #define R(a,b) (((a) > (32 - (b)))) void salsa20_word_specification(uint32 out[16],uint32 in[16]) { int i; uint32 x[16]; for (i = 0;i 0;i -= 2) { x[ 4] ^= R(x[ 0]+x[12], 7); x[ 8] ^= R(x[ 4]+x[ 0], 9); x[12] ^= R(x[ 8]+x[ 4],13); x[ 0] ^= R(x[12]+x[ 8],18); x[ 9] ^= R(x[ 5]+x[ 1], 7); x[13] ^= R(x[ 9]+x[ 5], 9); x[ 1] ^= R(x[13]+x[ 9],13); x[ 5] ^= R(x[ 1]+x[13],18); x[14] ^= R(x[10]+x[ 6], 7); x[ 2] ^= R(x[14]+x[10], 9); x[ 6] ^= R(x[ 2]+x[14],13); x[10] ^= R(x[ 6]+x[ 2],18); x[ 3] ^= R(x[15]+x[11], 7); x[ 7] ^= R(x[ 3]+x[15], 9); x[11] ^= R(x[ 7]+x[ 3],13); x[15] ^= R(x[11]+x[ 7],18); x[ 1] ^= R(x[ 0]+x[ 3], 7); x[ 2] ^= R(x[ 1]+x[ 0], 9); x[ 3] ^= R(x[ 2]+x[ 1],13); x[ 0] ^= R(x[ 3]+x[ 2],18); x[ 6] ^= R(x[ 5]+x[ 4], 7); x[ 7] ^= R(x[ 6]+x[ 5], 9); x[ 4] ^= R(x[ 7]+x[ 6],13); x[ 5] ^= R(x[ 4]+x[ 7],18); x[11] ^= R(x[10]+x[ 9], 7); x[ 8] ^= R(x[11]+x[10], 9); x[ 9] ^= R(x[ 8]+x[11],13); x[10] ^= R(x[ 9]+x[ 8],18); x[12] ^= R(x[15]+x[14], 7); x[13] ^= R(x[12]+x[15], 9); x[14] ^= R(x[13]+x[12],13); x[15] ^= R(x[14]+x[13],18); } for (i = 0;i scryptBlockMix Parameters: r Block size parameter. Input: B[0] || B[1] || ... || B[2 * r - 1] Input octet string (of size 128 * r octets), treated as 2 * r 64-octet blocks, where each element in B is a 64-octet block. Output: B'[0] || B'[1] || ... || B'[2 * r - 1] Output octet string. Steps: 1. X = B[2 * r - 1] 2. for i = 0 to 2 * r - 1 do T = X xor B[i] X = Salsa (T) Y[i] = X end for 3. B' = (Y[0], Y[2], ..., Y[2 * r - 2], Y[1], Y[3], ..., Y[2 * r - 1]) scryptROMix Input: r Block size parameter. B Input octet vector of length 128 * r octets. N CPU/Memory cost parameter, must be larger than 1, a power of 2, and less than 2^(128 * r / 8). Output: B' Output octet vector of length 128 * r octets. Steps: 1. X = B 2. for i = 0 to N - 1 do V[i] = X X = scryptBlockMix (X) end for 3. for i = 0 to N - 1 do j = Integerify (X) mod N where Integerify (B[0] ... B[2 * r - 1]) is defined as the result of interpreting B[2 * r - 1] as a little-endian integer. T = X xor V[j] X = scryptBlockMix (T) end for 4. B' = X scrypt Input: P Passphrase, an octet string. S Salt, an octet string. N CPU/Memory cost parameter, must be larger than 1, a power of 2, and less than 2^(128 * r / 8). r Block size parameter. p Parallelization parameter, a positive integer less than or equal to ((2^32-1) * hLen) / MFLen where hLen is 32 and MFlen is 128 * r. dkLen Intended output length in octets of the derived key; a positive integer less than or equal to (2^32 - 1) * hLen where hLen is 32. Output: DK Derived key, of length dkLen octets. Steps: 1. Initialize an array B consisting of p blocks of 128 * r octets each: B[0] || B[1] || ... || B[p - 1] = PBKDF2-HMAC-SHA256 (P, S, 1, p * 128 * r) 2. for i = 0 to p - 1 do B[i] = scryptROMix (r, B[i], N) end for 3. DK = PBKDF2-HMAC-SHA256 (P, B[0] || B[1] || ... || B[p - 1], 1, dkLen) 挖矿算法中，选取的参数为： P：区块头； S：区块头； N：固定为1024； r：固定为1； p：固定为1； dkLen：固定为32，即输出长度为32个字节。 因此，莱特币的区块头哈希值为 powhash = scrypt(blockheader, blockheader, 1024, 1, 1, 32)。可以参考莱特币获取区块头哈希的Go语言版本实现。 // Copyright (c) 2013-2016 The btcsuite developers // Use of this source code is governed by an ISC // license that can be found in the LICENSE file. package wire import ( \"bytes\" \"io\" \"time\" \"golang.org/x/crypto/scrypt\" \"github.com/ltcsuite/ltcd/chaincfg/chainhash\" ) // MaxBlockHeaderPayload is the maximum number of bytes a block header can be. // Version 4 bytes + Timestamp 4 bytes + Bits 4 bytes + Nonce 4 bytes + // PrevBlock and MerkleRoot hashes. const MaxBlockHeaderPayload = 16 + (chainhash.HashSize * 2) // BlockHeader defines information about a block and is used in the bitcoin // block (MsgBlock) and headers (MsgHeaders) messages. type BlockHeader struct { // Version of the block. This is not the same as the protocol version. Version int32 // Hash of the previous block header in the block chain. PrevBlock chainhash.Hash // Merkle tree reference to hash of all transactions for the block. MerkleRoot chainhash.Hash // Time the block was created. This is, unfortunately, encoded as a // uint32 on the wire and therefore is limited to 2106. Timestamp time.Time // Difficulty target for the block. Bits uint32 // Nonce used to generate the block. Nonce uint32 } // blockHeaderLen is a constant that represents the number of bytes for a block // header. const blockHeaderLen = 80 // BlockHash computes the block identifier hash for the given block header. func (h *BlockHeader) BlockHash() chainhash.Hash { // Encode the header and double sha256 everything prior to the number of // transactions. Ignore the error returns since there is no way the // encode could fail except being out of memory which would cause a // run-time panic. buf := bytes.NewBuffer(make([]byte, 0, MaxBlockHeaderPayload)) _ = writeBlockHeader(buf, 0, h) return chainhash.DoubleHashH(buf.Bytes()) } // PowHash returns the litecoin scrypt hash of this block header. This value is // used to check the PoW on blocks advertised on the network. func (h *BlockHeader) PowHash() (*chainhash.Hash, error) { var powHash chainhash.Hash buf := bytes.NewBuffer(make([]byte, 0, MaxBlockHeaderPayload)) _ = writeBlockHeader(buf, 0, h) scryptHash, err := scrypt.Key(buf.Bytes(), buf.Bytes(), 1024, 1, 1, 32) if err != nil { return nil, err } copy(powHash[:], scryptHash) return &powHash, nil } // BtcDecode decodes r using the bitcoin protocol encoding into the receiver. // This is part of the Message interface implementation. // See Deserialize for decoding block headers stored to disk, such as in a // database, as opposed to decoding block headers from the wire. func (h *BlockHeader) BtcDecode(r io.Reader, pver uint32, enc MessageEncoding) error { return readBlockHeader(r, pver, h) } // BtcEncode encodes the receiver to w using the bitcoin protocol encoding. // This is part of the Message interface implementation. // See Serialize for encoding block headers to be stored to disk, such as in a // database, as opposed to encoding block headers for the wire. func (h *BlockHeader) BtcEncode(w io.Writer, pver uint32, enc MessageEncoding) error { return writeBlockHeader(w, pver, h) } // Deserialize decodes a block header from r into the receiver using a format // that is suitable for long-term storage such as a database while respecting // the Version field. func (h *BlockHeader) Deserialize(r io.Reader) error { // At the current time, there is no difference between the wire encoding // at protocol version 0 and the stable long-term storage format. As // a result, make use of readBlockHeader. return readBlockHeader(r, 0, h) } // Serialize encodes a block header from r into the receiver using a format // that is suitable for long-term storage such as a database while respecting // the Version field. func (h *BlockHeader) Serialize(w io.Writer) error { // At the current time, there is no difference between the wire encoding // at protocol version 0 and the stable long-term storage format. As // a result, make use of writeBlockHeader. return writeBlockHeader(w, 0, h) } // NewBlockHeader returns a new BlockHeader using the provided version, previous // block hash, merkle root hash, difficulty bits, and nonce used to generate the // block with defaults for the remaining fields. func NewBlockHeader(version int32, prevHash, merkleRootHash *chainhash.Hash, bits uint32, nonce uint32) *BlockHeader { // Limit the timestamp to one second precision since the protocol // doesn't support better. return &BlockHeader{ Version: version, PrevBlock: *prevHash, MerkleRoot: *merkleRootHash, Timestamp: time.Unix(time.Now().Unix(), 0), Bits: bits, Nonce: nonce, } } // readBlockHeader reads a bitcoin block header from r. See Deserialize for // decoding block headers stored to disk, such as in a database, as opposed to // decoding from the wire. func readBlockHeader(r io.Reader, pver uint32, bh *BlockHeader) error { return readElements(r, &bh.Version, &bh.PrevBlock, &bh.MerkleRoot, (*uint32Time)(&bh.Timestamp), &bh.Bits, &bh.Nonce) } // writeBlockHeader writes a bitcoin block header to w. See Serialize for // encoding block headers to be stored to disk, such as in a database, as // opposed to encoding for the wire. func writeBlockHeader(w io.Writer, pver uint32, bh *BlockHeader) error { sec := uint32(bh.Timestamp.Unix()) return writeElements(w, bh.Version, &bh.PrevBlock, &bh.MerkleRoot, sec, bh.Bits, bh.Nonce) } POA共识算法 POA产生的背景 如果你想使用Simplechain搭建一个联盟/私有链, 并要求该链交易成本更低甚至没有, 交易延时更低,并发更高, 还拥有完全的控制权(意味着被攻击概率更低). 目前Simplechain采用PoW是不能满足要求的。 首先, pow存在51%攻击问题, 恶意挖矿者超过全网算力的51%后基本上就能完全控制整个网络. 由于链无法被更改, 已上链的数据也无法更改, 但恶意挖矿者也可以做一些DoS攻击阻止合法交易上链,考虑到具有相同创世块的旷工都能加入你的网络, 潜在的安全隐患会长期存在. 其次, PoW大量的电力资源消耗也是需要作为后续成本考虑. PoS可以解决部分Pow问题, 比如节约电力,在一定程度上保护了51％的攻击(恶意旷工会被惩罚), 但从控制权和安全考虑还有欠缺, 因为PoS还是允许任何符合条件的旷工加入。 POA的特点 PoA是依靠预设好的授权节点(signers)，负责产生block. 可以由已授权的signer选举(投票超过50%)加入新的signer。 即使存在恶意signer,他最多只能攻击连续块(数量是 (SIGNER_COUNT / 2) + 1) 中的1个,期间可以由其他signer投票踢出该恶意signer。 可指定产生block的时间。 POA的工作流程如下 在创世块中指定一组初始授权的signers, 所有地址 保存在创世块Extra字段中 启动挖矿后, 该组signers开始对生成的block进行 签名并广播. 签名结果 保存在区块头的Extra字段中 Extra中更新当前高度已授权的 所有signers的地址 ,因为有新加入或踢出的signer 每一高度都有一个signer处于IN-TURN状态, 其他signer处于OUT-OF-TURN状态, IN-TURN的signer签名的block会 立即广播 , OUT-OF-TURN的signer签名的block会 延时 一点随机时间后再广播, 保证IN-TURN的签名block有更高的优先级上链 如果需要加入一个新的signer, signer通过API接口发起一个proposal, 该proposal通过复用区块头 Coinbase(新signer地址)和Nonce(\"0xffffffffffffffff\") 字段广播给其他节点. 所有已授权的signers对该新的signer进行\"加入\"投票, 如果赞成票超过signers总数的50%, 表示同意加入 如果需要踢出一个旧的signer, 所有已授权的signers对该旧的signer进行\"踢出\"投票, 如果赞成票超过signers总数的50%, 表示同意踢出 Simplechain中如何选择POA共识算法 下载生成新的genesis区块文件，下载地址 下载完成以后，通过命令执行生成创世区块的文件,在生成创世区块文件的过程中，可以选择自己想要的共识算法。如下图： "},"15_virtualMache/":{"url":"15_virtualMache/","title":"虚拟机","keywords":"","body":"在Simplechain上，用户通过运行部署在Simplechain上的合约，完成需要共识的操作。Simplechain虚拟机，是智能合约代码的执行器。所以当智能合约被编译成二进制文件后，被部署到Simplechain上。用户通过调用智能合约的接口，来触发智能合约的执行操作。EVM执行智能合约的代码，修改当前区块链上的数据（状态）。被修改的数据，会被共识，确保一致性。 SVMC 可以从Simplechain中将EVM剥离出来，形成一个独立的模块。EVM与节点的交互，抽象出SVMC接口标准。通过SVMC接口标准，节点可以对接多种虚拟机，而不仅限于传统的基于solidity的虚拟机。 传统的solidity虚拟机，在Simplechain中称为interpreter，下文主要解释interpreter的实现。 SVMC 接口 SVMC主要定义了两种调用的接口： Instance接口：节点调用EVM的接口 Callback接口：EVM回调节点的接口 EVM本身不保存状态数据，节点通过instance接口操作EVM，EVM反过来，调Callback接口，对节点的状态进行操作。 Instance 接口 定义了节点对虚拟机的操作，包括创建，销毁，设置等。 接口定义在evmc_instance（evmc.h）中 abi_version name version destroy execute set_tracer set_option Callback接口 定义了EVM对节点的操作，主要是对state读写、区块信息的读写等。 接口定义在evmc_context_fn_table（evmc.h）中。 evmc_account_exists_fn account_exists evmc_get_storage_fn get_storage evmc_set_storage_fn set_storage evmc_get_balance_fn get_balance evmc_get_code_size_fn get_code_size evmc_get_code_hash_fn get_code_hash evmc_copy_code_fn copy_code evmc_selfdestruct_fn selfdestruct evmc_call_fn call evmc_get_tx_context_fn get_tx_context evmc_get_block_hash_fn get_block_hash evmc_emit_log_fn emit_log EVM 执行 EVM 指令 solidity是合约的执行语言，solidity被solc编译后，变成类似于汇编的EVM指令。Interpreter定义了一套完整的指令集。solidity被编译后，生成二进制文件，二进制文件就是EVM指令的集合，交易以二进制的形式发往节点，节点收到后，通过SVMC调用EVM执行这些指令。在EVM中，用代码模拟实现了这些指令的逻辑。 Solidity是基于堆栈的语言，EVM在执行二进制时，也是以堆栈的方式进行调用。 算术指令举例 一条ADD指令，在EVM中的代码实现如下。SP是堆栈的指针，从栈顶第一和第二个位置（SP[0]、SP[1]）拿出数据，进行加和后，写入结果堆栈SPP的顶端SPP[0]。 CASE(ADD) { ON_OP(); updateIOGas(); // pops two items and pushes their sum mod 2^256. m_SPP[0] = m_SP[0] + m_SP[1]; } 跳转指令举例 JUMP指令，实现了二进制代码间的跳转。首先从堆栈顶端SP[0]取出待跳转的地址，验证一下是否越界，放到程序计数器PC中，下一个指令，将从PC指向的位置开始执行。 CASE(JUMP) { ON_OP(); updateIOGas(); m_PC = verifyJumpDest(m_SP[0]); } 状态读指令举例 SLOAD可以查询状态数据。大致过程是，从堆栈顶端SP[0]取出要访问的key，把key作为参数，然后调evmc的callback函数get_storage() ，查询相应的key对应的value。之后将读到的value写到结果堆栈SPP的顶端SPP[0]。 CASE(SLOAD) { m_runGas = m_rev >= EVMC_TANGERINE_WHISTLE ? 200 : 50; ON_OP(); updateIOGas(); evmc_uint256be key = toEvmC(m_SP[0]); evmc_uint256be value; m_context->fn_table->get_storage(&value, m_context, &m_message->destination, &key); m_SPP[0] = fromEvmC(value); } 状态写指令举例 SSTORE指令可以将数据写到节点的状态中，大致过程是，从栈顶第一和第二个位置（SP[0]、SP[1]）拿出key和value，把key和value作为参数，调用evmc的callback函数set_storage() ，写入节点的状态。 CASE(SSTORE) { ON_OP(); if (m_message->flags & EVMC_STATIC) throwDisallowedStateChange(); static_assert( VMSchedule::sstoreResetGas fn_table->set_storage(m_context, &m_message->destination, &key, &value); if (status == EVMC_STORAGE_ADDED) { // Charge additional amount for added storage item. m_runGas = VMSchedule::sstoreSetGas - VMSchedule::sstoreResetGas; updateIOGas(); } } 合约调用指令举例 CALL指令能够根据地址调用另外一个合约。首先，EVM判断是CALL指令，调用caseCall()，在caseCall()中，用caseCallSetup()从堆栈中拿出数据，封装成msg，作为参数，调用evmc的callback函数call。Eth在被回调call()后，启动一个新的EVM，处理调用，之后将新的EVM的执行结果，通过call()```的参数返回给当前的EVM，当前的EVM将结果写入结果堆栈SSP中，调用结束。合约创建的逻辑与此逻辑类似。 CASE(CALL) CASE(CALLCODE) { ON_OP(); if (m_OP == Instruction::DELEGATECALL && m_rev flags & EVMC_STATIC && m_SP[2] != 0) throwDisallowedStateChange(); m_bounce = &VM::caseCall; } BREAK void VM::caseCall() { m_bounce = &VM::interpretCases; evmc_message msg = {}; // Clear the return data buffer. This will not free the memory. m_returnData.clear(); bytesRef output; if (caseCallSetup(msg, output)) { evmc_result result; m_context->fn_table->call(&result, m_context, &msg); m_returnData.assign(result.output_data, result.output_data + result.output_size); bytesConstRef{&m_returnData}.copyTo(output); m_SPP[0] = result.status_code == EVMC_SUCCESS ? 1 : 0; m_io_gas += result.gas_left; if (result.release) result.release(&result); } else { m_SPP[0] = 0; m_io_gas += msg.gas; } ++m_PC; } 总结 EVM是一个状态执行的机器，输入是solidity编译后的二进制指令和节点的状态数据，输出是节点状态的改变。Simplechain通过EVMC实现了多种虚拟机的兼容。 "},"16_runMechanism/":{"url":"16_runMechanism/","title":"运行机制","keywords":"","body":"Simplechain模型说明 Simplechain的本质就是一个基于交易的状态机(transaction-based state machine)。在计算机科学中，一个状态机是指可以读取一系列的输入，然后根据这些输入，会转换成一个新的状态出来的东西。 根据Simplechain的状态机，我们从创世纪状态(genesis state)开始。在网络中还没有任何交易的产生状态。当交易被执行后，这个创世纪状态就会转变成最终状态。在任何时刻，这个最终状态都代表着Simplechain当前的状态。 Simplechain的状态有百万个交易。这些交易都被“组团”到一个区块中。一个区块包含了一系列的交易，每个区块都与它的前一个区块链接起来。 为了让一个状态转换成下一个状态，交易必须是有效的。为了让一个交易被认为是有效的，它必须要经过一个验证过程，此过程也就是挖矿。挖矿就是一组节点（即电脑）用它们的计算资源来创建一个包含有效交易的区块出来。 为了让一个区块添加到主链上，一个矿工必须要比其他矿工更快的提供出这个“证明”。通过矿工提供的一个数学机制的“证明”来证实每个区块的过程称之为工作量证明(proof of work)。 证实了一个新区块的矿工都会被奖励一定价值的奖赏。奖赏是什么？Simplechain使用一种内在数字代币—Sipc作为奖赏。每次矿工证明了一个新区块，那么就会产生一个新的Sipc并被奖励给矿工。 不论什么时候只要多个路径产生了，一个”分叉“就会出现。我们通常都想避免分叉，因为它们会破坏系统，强制人们去选择哪条链是他们相信的链。 为了确定哪个路径才是最有效的以及防止多条链的产生，Simplechain使用了一个叫做“GHOST协议(GHOST protocol.)”的数学机制。 GHOST = Greedy Heaviest Observed Subtree 简单来说，GHOST协议就是让我们必须选择一个在其上完成计算最多的路径。一个方法确定路径就是使用最近一个区块（叶子区块）的区块号，区块号代表着当前路径上总的区块数（不包含创世纪区块）。区块号越大，路径就会越长，就说明越多的挖矿算力被消耗在此路径上以达到叶子区块。使用这种推理就可以允许我们赞同当前状态的权威版本。 "},"17_unusual.html":{"url":"17_unusual.html","title":"处理异常","keywords":"","body":"调用合约时报错 可能的问题： 一般的问题是合约执行失败导致，合约执行失败时Simplechain提示报错原因一般不是太直观，可能与错误无关。 1.合约账户中代币和余额不足； 2.当前操作账户是否有权限； 3.合约执行失败。 spring boot应用程序使用web3j 可以直接使用web3j-spring-boot-starter 其中依赖的spring boot依赖包，不用重复依赖spring boot包 org.web3j web3j-spring-boot-starter 1.6.0 spring boot应用程序中是用web3J依赖报错？？ 我在demo中使用的gradle依赖web3j，功能完成没有问题，在正式项目中使用maven依赖web3j包相同的代码却报错，一直找不到具体问题。 使用maven依赖web3j 3.5.0后报错，换成web3j 3.6.0还是报同样的错误，报错信息如下： at java.net.URLClassLoader.findClass(URLClassLoader.java:382) ~[na:1.8.0_191] at java.lang.ClassLoader.loadClass(ClassLoader.java:424) ~[na:1.8.0_191] at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:349) ~[na:1.8.0_191] at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ~[na:1.8.0_191] at org.web3j.crypto.Sign.(Sign.java:34) ~[crypto-3.5.0.jar:na] at org.web3j.crypto.ECKeyPair.create(ECKeyPair.java:68) ~[crypto-3.5.0.jar:na] at org.web3j.crypto.Credentials.create(Credentials.java:36) ~[crypto-3.5.0.jar:na] 解决办法： 经排查原因是因为maven下载web3j依赖时下载的不完整导致有些文件没有下载完整，ec包不存在， 删除maven本地仓库中已下载的web3j依赖包，然后下载maven工具，在项目目录中使用命令清除、安装依赖 ->mvn clean ->mvn install 打开Idea,刷新项目就可以正常编译运行了。 we3j编译 .sol文件时文件中使用 “import ./safeERC20.sol” 时编译会报错，找不到import文件。 解决办法是把import的contract或libary 写到当前文件中。 "},"18_contract/":{"url":"18_contract/","title":"智能合约","keywords":"","body":"Simplechain的智能合约并非现实中常见的合同，而是存在区块链上，可以被触发执行的一段程序代码，这些代码实现了某种预定的规则，是存在于Simplechain执行环境中的“自治代理”。Simplechain的账户与合约如图 1 所示。 Simplechain的智能合约设计很简明。 任何人都可以在Simplechain区块链上开发智能合约，这些智能合约的代码是存在于Simplechain的账户中的，这类存有代码的账户叫合约账户。对应地，由密钥控制的账户可称为外部账户。 Simplechain的智能合约程序，是在Simplechain虚拟机上运行的。 合约账户不能自己启动运行自己的智能合约。要运行一个智能合约，需要由外部账户对合约账户发起交易，从而启动其中的代码的执行。 Simplechain和比特币的一个重大不同是，Simplechain提供了图灵完备的编程语言（Solidity）和相应的运行环境（EVM）。所谓图灵完备，指的是这个脚本编程语言可以运行所有可能的计算，而比特币的UTXO模型和脚本只能运行部分计算。 Simplechain比较流行的智能合约语言是Solidity，Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。 "},"19_understandSolidity/":{"url":"19_understandSolidity/","title":"深入理解Solidity","keywords":"","body":"Solidity源文件结构 源文件中可以包含任意多个合约定义、导入指令和杂注指令。 版本杂注 为了避免未来被可能引入不兼容变更的编译器所编译，源文件可以（也应该）被所谓的版本杂注所注解。我们力图把这类变更做到尽可能小，特别是，我们需要以一种当修改语义时必须同步修改语法的方式引入变更，当然这有时候也难以做到。因此，至少对含重大变更的版本，通读变更日志永远是好办法。这些版本的版本号始终是 0.x.0 或者 x.0.0 的形式。 版本杂注使用如下:: pragma solidity ^0.4.0; 这样，源文件将既不允许低于 0.4.0 版本的编译器编译，也不允许高于（包含） 0.5.0 版本的编译器编译（第二个条件因使用 ^ 被添加）。这种做法的考虑是，编译器在 0.5.0 版本之前不会有重大变更，所以可确保源代码始终按预期被编译。上面例子中不固定编译器的具体版本号，因此编译器的补丁版也可以使用。 可以使用更复杂的规则来指定编译器的版本，表达式遵循 npm 版本语义。 Pragma 是 pragmatic information 的简称，微软 Visual C++ 文档 中译为杂注。Solidity 中沿用 C ，C++ 等中的编译指令概念，用于告知编译器 如何 编译。 ——译者注 导入其他源文件 语法与语义 虽然 Solidity 不知道 \"default export\" 为何物，但是 Solidity 所支持的导入语句，其语法同 JavaScript（从 ES6 起）非常类似。 ES6 即 ECMAScript 6.0，ES6是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布。 ——译者注 在全局层面上，可使用如下格式的导入语句： import \"filename\"; 此语句将从 “filename” 中导入所有的全局符号到当前全局作用域中（不同于 ES6，Solidity 是向后兼容的）。 import * as symbolName from \"filename\"; 创建一个新的全局符号 symbolName，其成员均来自 \"filename\" 中全局符号。 import {symbol1 as alias, symbol2} from \"filename\"; 创建新的全局符号 alias 和 symbol2，分别从 \"filename\" 引用 symbol1 和 symbol2 。 另一种语法不属于 ES6，但或许更简便： import \"filename\" as symbolName; 这条语句等同于 import * as symbolName from \"filename\";。 路径 上文中的 filename 总是会按路径来处理，以 / 作为目录分割符、以 . 标示当前目录、以 .. 表示父目录。 当 . 或 .. 后面跟随的字符是 / 时，它们才能被当做当前目录或父目录。 只有路径以当前目录 . 或父目录 .. 开头时，才能被视为相对路径。 用 import \"./x\" as x; 语句导入当前源文件同目录下的文件 x 。 如果用 import \"x\" as x; 代替，可能会引入不同的文件（在全局 include directory 中）。 最终导入哪个文件取决于编译器（见下文）到底是怎样解析路径的。 通常，目录层次不必严格映射到本地文件系统， 它也可以映射到能通过诸如 ipfs，http 或者 git 发现的资源。 在实际的编译器中使用 当运行编译器时，它不仅能指定如何发现路径的第一个元素，还可指定路径前缀 |remapping|。 例如，github.com/ethereum/dapp-bin/library 会被重映射到 /usr/local/dapp-bin/library ， 此时编译器将从重映射位置读取文件。如果重映射到多个路径，优先尝试重映射路径最长的一个。 这允许将比如 \"\" 被映射到 \"/usr/local/include/solidity\" 来进行“回退重映射”。 同时，这些重映射可取决于上下文，允许你配置要导入的包，比如同一个库的不同版本。 solc: 对于 solc（命令行编译器），这些重映射以 context:prefix=target 形式的参数提供。 其中，context: 和 =target 部分是可选的（此时 target 默认为 prefix ）。 所有重映射的值都是被编译过的常规文件（包括他们的依赖），这个机制完全是向后兼容的（只要文件名不包含 = 或 : ）， 因此这不是一个破坏性修改。 在 content 目录或其子目录中的源码文件中，所有导入语句里以 prefix 开头的导入文件都将被用 target 替换 prefix 来重定向。 举个例子，如果你已克隆 github.com/ethereum/dapp-bin/ 到本地 /usr/local/dapp-bin ， 可在源文件中使用： import \"github.com/ethereum/dapp-bin/library/iterable_mapping.sol\" as it_mapping; 然后运行编译器： solc github.com/ethereum/dapp-bin/=/usr/local/dapp-bin/ source.sol 举个更复杂的例子，假设你依赖了一些使用了非常旧版本的 dapp-bin 的模块。 旧版本的 dapp-bin 已经被 checkout 到 /usr/local/dapp-bin_old ，此时你可使用： solc module1:github.com/ethereum/dapp-bin/=/usr/local/dapp-bin/ \\ module2:github.com/ethereum/dapp-bin/=/usr/local/dapp-bin_old/ \\ source.sol 这样， module2 中的所有导入都指向旧版本，而 module1 中的导入则获取新版本。 注意， solc 只允许包含来自特定目录的文件：它们必须位于显式地指定的源文件目录（或子目录）中，或者重映射的目标目录（或子目录）中。 如果你想直接用绝对路径来包含文件，只需添加重映射 =/。 如果有多个重映射指向一个有效文件，那么具有最长公共前缀的重映射会被选用。 Remix: Remix 提供一个为 github 源代码平台的自动重映射，它将通过网络自动获取文件：比如，你可以使用 import \"github.com/ethereum/dapp-bin/library/iterable_mapping.sol\" as it_mapping; 导入一个 map 迭代器。 未来， Remix 可能支持其他源代码平台。 注释 可以使用单行注释（//）和多行注释（/*...*/） // 这是一个单行注释。 /* 这是一个 多行注释。 */ 此外，有另一种注释称为 natspec 注释，其文档还尚未编写。 它们是用三个反斜杠（///）或双星号开头的块（/** ... */）书写，它们应该直接在函数声明或语句上使用。 可在注释中使用 Doxygen 样式的标签来文档化函数、 标注形式校验通过的条件，和提供一个当用户试图调用一个函数时显示给用户的 确认文本。 在下面的例子中，我们记录了合约的标题、两个入参和两个返回值的说明： pragma solidity ^0.4.0; /** @title 形状计算器。 */ contract shapeCalculator { /** @dev 求矩形表明面积与周长。 * @param w 矩形宽度。 * @param h 矩形高度。 * @return s 求得表面积。 * @return p 求得周长。 */ function rectangle(uint w, uint h) returns (uint s, uint p) { s = w * h; p = 2 * (w + h); } } 合约结构 在 Solidity 中，合约类似于面向对象编程语言中的类。 每个合约中可以包含 状态变量，函数，函数修饰器，事件，结构类型 和 枚举类型的声明，且合约可以从其他合约继承。 状态变量 状态变量是永久地存储在合约存储中的值。 pragma solidity ^0.4.0; contract SimpleStorage { uint storedData; // 状态变量 // ... } 有效的状态变量类型参阅 类型 章节， 对状态变量可见性有可能的选择参阅 可见性和getter函数 。 函数 函数是合约中代码的可执行单元。 pragma solidity ^0.4.0; contract SimpleAuction { function bid() public payable { // 函数 // ... } } 函数调用可发生在合约内部或外部，且函数对其他合约有不同程度的可见性（ 可见性和getter函数）。 函数修饰器 函数修饰器可以用来以声明的方式改良函数语义（参阅合约章节中 函数）。 pragma solidity ^0.4.22; contract Purchase { address public seller; modifier onlySeller() { // 修饰器 require( msg.sender == seller, \"Only seller can call this.\" ); _; } function abort() public onlySeller { // Modifier usage // ... } } 事件 事件是能方便地调用Simplechain虚拟机日志功能的接口。 pragma solidity ^0.4.21; contract SimpleAuction { event HighestBidIncreased(address bidder, uint amount); // 事件 function bid() public payable { // ... emit HighestBidIncreased(msg.sender, msg.value); // 触发事件 } } 有关如何声明事件和如何在 dapp 中使用事件的信息，参阅合约章节中的 事件。 结构类型 结构是可以将几个变量分组的自定义类型（参阅类型章节中的 结构体）。 pragma solidity ^0.4.0; contract Ballot { struct Voter { // 结构 uint weight; bool voted; address delegate; uint vote; } } 枚举类型 枚举可用来创建由一定数量的“常量值”构成的自定义类型（参阅类型章节中的 枚举类型）。 pragma solidity ^0.4.0; contract Purchase { enum State { Created, Locked, Inactive } // 枚举 } 类型 Solidity 是一种静态类型语言，这意味着每个变量（状态变量和局部变量）都需要在编译时指定变量的类型（或至少可以推导出变量类型——参考下文的 :ref:type-deduction ）。 Solidity 提供了几种基本类型，可以用来组合出复杂类型。 除此之外，类型之间可以在包含运算符号的表达式中进行交互。 关于各种运算符号，可以参考 :ref:order 。 值类型 以下类型也称为值类型，因为这些类型的变量将始终按值来传递。 也就是说，当这些变量被用作函数参数或者用在赋值语句中时，总会进行值拷贝。 布尔类型 bool ：可能的取值为字面常数值 true 和 false 。 运算符： ! （逻辑非） && （逻辑与， \"and\" ） || （逻辑或， \"or\" ） == （等于） != （不等于） 运算符 || 和 && 都遵循同样的短路（ short-circuiting ）规则。就是说在表达式 f(x) || g(y) 中， 如果 f(x) 的值为 true ，那么 g(y) 就不会被执行，即使会出现一些副作用。 整型 int / uint ：分别表示有符号和无符号的不同位数的整型变量。 支持关键字 uint8 到 uint256 （无符号，从 8 位到 256 位）以及 int8 到 int256，以 8 位为步长递增。 uint 和 int 分别是 uint256 和 int256 的别名。 运算符： 比较运算符： ， ， == ， != ， >= ， > （返回布尔值） 位运算符： & ， | ， ^ （异或）， ~ （位取反） 算数运算符： + ， - ， 一元运算 - ， 一元运算 + ， * ， / ， % （取余） ， ** （幂）， （左移位） ， >> （右移位） 除法总是会截断的（仅被编译为 EVM 中的 DIV 操作码）， 但如果操作数都是 :ref:字面常数（literals） （或者字面常数表达式），则不会截断。 除以零或者模零运算都会引发运行时异常。 移位运算的结果取决于运算符左边的类型。 表达式 x 与 x * 2**y 是等价的， x >> y 与 x / 2**y 是等价的。这意味对一个负数进行移位会导致其符号消失。 按负数位移动会引发运行时异常。 .. warning:: 由有符号整数类型负值右移所产生的结果跟其它语言中所产生的结果是不同的。 在 Solidity 中，右移和除是等价的，因此对一个负数进行右移操作会导致向 0 的取整（截断）。 而在其它语言中， 对负数进行右移类似于（向负无穷）取整。 定长浮点型 Solidity 还没有完全支持定长浮点型。可以声明定长浮点型的变量，但不能给它们赋值或把它们赋值给其他变量。 fixed / ufixed：表示各种大小的有符号和无符号的定长浮点型。 在关键字 ufixedMxN 和 fixedMxN 中，M 表示该类型占用的位数，N 表示可用的小数位数。 M 必须能整除 8，即 8 到 256 位。 N 则可以是从 0 到 80 之间的任意数。 ufixed 和 fixed 分别是 ufixed128x19 和 fixed128x19 的别名。 运算符： 比较运算符：， ， ==， !=， >=， > （返回值是布尔型） 算术运算符：+， -， 一元运算 -， 一元运算 +， *， /， % （取余数） .. note:: 浮点型（在许多语言中的 float 和 double 类型，更准确地说是 IEEE 754 类型）和定长浮点型之间最大的不同点是， 在前者中整数部分和小数部分（小数点后的部分）需要的位数是灵活可变的，而后者中这两部分的长度受到严格的规定。 一般来说，在浮点型中，几乎整个空间都用来表示数字，但只有少数的位来表示小数点的位置。 地址类型 address：地址类型存储一个 20 字节的值（Simplechain地址的大小）。 地址类型也有成员变量，并作为所有合约的基础。 运算符： ， ， ==， !=， >= 和 > 从 0.5.0 版本开始，合约不会从地址类型派生，但仍然可以显式地转换成地址类型。 地址类型成员变量 balance 和 transfer 快速参考，请见 :ref:address_related。 可以使用 balance 属性来查询一个地址的余额， 也可以使用 transfer 函数向一个地址发送 |ether| （以 wei 为单位）： address x = 0x123; address myAddress = this; if (x.balance = 10) x.transfer(10); 如果 x 是一个合约地址，它的代码（更具体来说是它的 fallback 函数，如果有的话）会跟 transfer 函数调用一起执行（这是 EVM 的一个特性，无法阻止）。 如果在执行过程中用光了 gas 或者因为任何原因执行失败，|ether| 交易会被打回，当前的合约也会在终止的同时抛出异常。 send send 是 transfer 的低级版本。如果执行失败，当前的合约不会因为异常而终止，但 send 会返回 false。 在使用 send 的时候会有些风险：如果调用栈深度是 1024 会导致发送失败（这总是可以被调用者强制），如果接收者用光了 gas 也会导致发送失败。所以为了保证 |ether| 发送的安全，一定要检查 send 的返回值，使用 transfer 或者更好的办法：使用一种接收者可以取回资金的模式。 call， callcode 和 delegatecall 此外，为了与不符合 |ABI| 的合约交互，于是就有了可以接受任意类型任意数量参数的 call 函数。 这些参数会被打包到以 32 字节为单位的连续区域中存放。 其中一个例外是当第一个参数被编码成正好 4 个字节的情况。 在这种情况下，这个参数后边不会填充后续参数编码，以允许使用函数签名。 address nameReg = 0x72ba7d8e73fe8eb666ea66babc8116a41bfb10e2; nameReg.call(\"register\", \"MyName\"); nameReg.call(bytes4(keccak256(\"fun(uint256)\")), a); call 返回的布尔值表明了被调用的函数已经执行完毕（true）或者引发了一个 EVM 异常（false）。 无法访问返回的真实数据（为此我们需要事先知道编码和大小）。 可以使用 .gas() |modifier| 调整提供的 gas 数量: namReg.call.gas(1000000)(\"register\", \"MyName\"); 类似地，也能控制提供的 |ether| 的值 : nameReg.call.value(1 ether)(\"register\", \"MyName\"); 最后一点，这些 |modifier| 可以联合使用。每个修改器出现的顺序不重要 : nameReg.call.gas(1000000).value(1 ether)(\"register\", \"MyName\"); 目前还不能在重载函数中使用 gas 或者 value。一种解决方案是给 gas 和值引入一个特例，并重新检查它们是否在重载的地方出现。 类似地，也可以使用 delegatecall：区别在于只使用给定地址的代码，其它属性（存储，余额，……）都取自当前合约。delegatecall 的目的是使用存储在另外一个合约中的库代码。用户必须确保两个合约中的存储结构都适用于 delegatecall。在 homestead 版本之前，只有一个功能类似但作用有限的 callcode 的函数可用，但它不能获取委托方的 msg.sender 和 msg.value。 这三个函数 call， delegatecall 和 callcode 都是非常低级的函数，应该只把它们当作 最后一招 来使用，因为它们破坏了 Solidity 的类型安全性。 所有合约都继承了地址（address）的成员变量，因此可以使用 this.balance 查询当前合约的余额。 不鼓励使用 callcode，在未来也会将其移除。 这三个函数都属于低级函数，需要谨慎使用。具体来说，任何未知的合约都可能是恶意的。你在调用一个合约的同时就将控制权交给了它，它可以反过来调用你的合约，因此，当调用返回时要为你的状态变量的改变做好准备。 定长字节数组 关键字有：bytes1， bytes2， bytes3， ...， bytes32。byte 是 bytes1 的别名。 运算符： 比较运算符：， ， ==， !=， >=， > （返回布尔型） 位运算符： &， |， ^ （按位异或）， ~ （按位取反）， （左移位）， >> （右移位） 索引访问：如果 x 是 bytesI 类型，那么 x[k] （其中 0 ）返回第 k 个字节（只读）。 该类型可以和作为右操作数的任何整数类型进行移位运算（但返回结果的类型和左操作数类型相同），右操作数表示需要移动的位数。 进行负数位移运算会引发运行时异常。 成员变量： .length 表示这个字节数组的长度（只读）. 可以将 byte[] 当作字节数组使用，但这种方式非常浪费存储空间，准确来说，是在传入调用时，每个元素会浪费 31 字节。 更好地做法是使用 bytes。 变长字节数组 bytes: 变长字节数组，参见 :ref:arrays。它并不是值类型。 string: 变长 UTF-8 编码字符串类型，参见 :ref:arrays。并不是值类型。 地址字面常数（Address Literals） 比如像 0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF 这样的通过了地址校验和测试的十六进制字面常数属于 address 类型。长度在 39 到 41 个数字的，没有通过校验和测试而产生了一个警告的十六进制字面常数视为正常的有理数字面常数。 混合大小写的地址校验和格式定义在 EIP-55中。 有理数和整数字面常数 整数字面常数由范围在 0-9 的一串数字组成，表现成十进制。例如，69 表示数字 69。 Solidity 中是没有八进制的，因此前置 0 是无效的。 十进制小数字面常数带有一个 .，至少在其一边会有一个数字。比如：1.，.1，和 1.3。 科学符号也是支持的，尽管指数必须是整数，但底数可以是小数。比如：2e10， -2e10， 2e-10， 2.5e1。 数值字面常数表达式本身支持任意精度，除非它们被转换成了非字面常数类型（也就是说，当它们出现在非字面常数表达式中时就会发生转换）。 这意味着在数值常量表达式中, 计算不会溢出而除法也不会截断。 例如， (2**800 + 1) - 2**800 的结果是字面常数 1 （属于 uint8 类型），尽管计算的中间结果已经超过了 |evm| 的机器字长度。 此外， .5 * 8 的结果是整型 4 （尽管有非整型参与了计算）。 只要操作数是整型，任意整型支持的运算符都可以被运用在数值字面常数表达式中。 如果两个中的任一个数是小数，则不允许进行位运算。如果指数是小数的话，也不支持幂运算（因为这样可能会得到一个无理数）。 Solidity 对每个有理数都有对应的数值字面常数类型。整数字面常数和有理数字面常数都属于数值字面常数类型。 除此之外，所有的数值字面常数表达式（即只包含数值字面常数和运算符的表达式）都属于数值字面常数类型。 因此数值字面常数表达式 1 + 2 和 2 + 1 的结果跟有理数三的数值字面常数类型相同。 在早期版本中，整数字面常数的除法也会截断，但在现在的版本中，会将结果转换成一个有理数。即 5 / 2 并不等于 2，而是等于 2.5。 数值字面常数表达式只要在非字面常数表达式中使用就会转换成非字面常数类型。在下面的例子中，尽管我们知道 b 的值是一个整数，但 2.5 + a 这部分表达式并不进行类型检查，因此编译不能通过。 uint128 a = 1; uint128 b = 2.5 + a + 0.5; 字符串字面常数 字符串字面常数是指由双引号或单引号引起来的字符串（\"foo\" 或者 'bar'）。 不像在 C 语言中那样带有结束符；\"foo\" 相当于 3 个字节而不是 4 个。 和整数字面常数一样，字符串字面常数的类型也可以发生改变，但它们可以隐式地转换成 bytes1，……，bytes32，如果合适的话，还可以转换成 bytes 以及 string。 字符串字面常数支持转义字符，例如 \\n，\\xNN 和 \\uNNNN。\\xNN 表示一个 16 进制值，最终转换成合适的字节，而 \\uNNNN 表示 Unicode 编码值，最终会转换为 UTF-8 的序列。 十六进制字面常数 十六进制字面常数以关键字 hex 打头，后面紧跟着用单引号或双引号引起来的字符串（例如，hex\"001122FF\"）。 字符串的内容必须是一个十六进制的字符串，它们的值将使用二进制表示。 十六进制字面常数跟字符串字面常数很类似，具有相同的转换规则。 枚举类型 pragma solidity ^0.4.16; contract test { enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill } ActionChoices choice; ActionChoices constant defaultChoice = ActionChoices.GoStraight; function setGoStraight() public { choice = ActionChoices.GoStraight; } // 由于枚举类型不属于 |ABI| 的一部分，因此对于所有来自 Solidity 外部的调用， // \"getChoice\" 的签名会自动被改成 \"getChoice() returns (uint8)\"。 // 整数类型的大小已经足够存储所有枚举类型的值，随着值的个数增加， // 可以逐渐使用 `uint16` 或更大的整数类型。 function getChoice() public view returns (ActionChoices) { return choice; } function getDefaultChoice() public pure returns (uint) { return uint(defaultChoice); } } 函数类型 函数类型是一种表示函数的类型。可以将一个函数赋值给另一个函数类型的变量，也可以将一个函数作为参数进行传递，还能在函数调用中返回函数类型变量。 函数类型有两类：- 内部（internal） 函数和 外部（external） 函数： 内部函数只能在当前合约内被调用（更具体来说，在当前代码块内，包括内部库函数和继承的函数中），因为它们不能在当前合约上下文的外部被执行。 调用一个内部函数是通过跳转到它的入口标签来实现的，就像在当前合约的内部调用一个函数。 外部函数由一个地址和一个函数签名组成，可以通过外部函数调用传递或者返回。 函数类型表示成如下的形式 :: function () {internal|external} [pure|constant|view|payable] [returns ()] 与参数类型相反，返回类型不能为空 —— 如果函数类型不需要返回，则需要删除整个 returns 部分。 函数类型默认是内部函数，因此不需要声明 internal 关键字。 与此相反的是，合约中的函数本身默认是 public 的，只有当它被当做类型名称时，默认才是内部函数。 有两种方法可以访问当前合约中的函数：一种是直接使用它的名字，f ，另一种是使用 this.f 。 前者适用于内部函数，后者适用于外部函数。 如果当函数类型的变量还没有初始化时就调用它的话会引发一个异常。 如果在一个函数被 delete 之后调用它也会发生相同的情况。 如果外部函数类型在 Solidity 的上下文环境以外的地方使用，它们会被视为 function 类型。 该类型将函数地址紧跟其函数标识一起编码为一个 bytes24 类型。。 请注意，当前合约的 public 函数既可以被当作内部函数也可以被当作外部函数使用。 如果想将一个函数当作内部函数使用，就用 f 调用，如果想将其当作外部函数，使用 this.f 。 除此之外，public（或 external）函数也有一个特殊的成员变量称作 selector，可以返回ABI 函数选择器 pragma solidity ^0.4.16; contract Selector { function f() public view returns (bytes4) { return this.f.selector; } } 如果使用内部函数类型的例子:: pragma solidity ^0.4.16; library ArrayUtils { // 内部函数可以在内部库函数中使用， // 因为它们会成为同一代码上下文的一部分 function map(uint[] memory self, function (uint) pure returns (uint) f) internal pure returns (uint[] memory r) { r = new uint[](self.length); for (uint i = 0; i 另外一个使用外部函数类型的例子:: pragma solidity ^0.4.11; contract Oracle { struct Request { bytes data; function(bytes memory) external callback; } Request[] requests; event NewRequest(uint); function query(bytes data, function(bytes memory) external callback) public { requests.push(Request(data, callback)); NewRequest(requests.length - 1); } function reply(uint requestID, bytes response) public { // 这里要验证 reply 来自可信的源 requests[requestID].callback(response); } } contract OracleUser { Oracle constant oracle = Oracle(0x1234567); // 已知的合约 function buySomething() { oracle.query(\"USD\", this.oracleResponse); } function oracleResponse(bytes response) public { require(msg.sender == address(oracle)); // 使用数据 } } Lambda 表达式或者内联函数的引入在计划内，但目前还没支持。 引用类型 比起之前讨论过的值类型，在处理复杂的类型（即占用的空间超过 256 位的类型）时，我们需要更加谨慎。 由于拷贝这些类型变量的开销相当大，我们不得不考虑它的存储位置，是将它们保存在 memory（并不是永久存储）中， 还是 storage（保存状态变量的地方）中。 数据位置 所有的复杂类型，即 数组 和 结构 类型，都有一个额外属性，“数据位置”，说明数据是保存在 memory 中还是 storage 中。根据上下文不同，大多数时候数据有默认的位置，但也可以通过在类型名后增加关键字 storage 或 memory 进行修改。函数参数（包括返回的参数）的数据位置默认是 memory，局部变量的数据位置默认是 storage，状态变量的数据位置强制是 storage （这是显而易见的）。 也存在第三种数据位置， calldata ，这是一块只读的，且不会永久存储的位置，用来存储函数参数。外部函数的参数（非返回参数）的数据位置被强制指定为 calldata ，效果跟 memory 差不多。 数据位置的指定非常重要，因为它们影响着赋值行为： 在 storage 和 memory 之间两两赋值，或者 storage 向状态变量（甚至是从其它状态变量）赋值都会创建一份独立的拷贝。然而状态变量向局部变量赋值时仅仅传递一个引用，而且这个引用总是指向状态变量，因此后者改变的同时前者也会发生改变。另一方面，从一个 memory 存储的引用类型向另一个 memory 存储的引用类型赋值并不会创建拷贝。 pragma solidity ^0.4.0; contract C { uint[] x; // x 的数据存储位置是 storage // memoryArray 的数据存储位置是 memory function f(uint[] memoryArray) public { x = memoryArray; // 将整个数组拷贝到 storage 中，可行 var y = x; // 分配一个指针（其中 y 的数据存储位置是 storage），可行 y[7]; // 返回第 8 个元素，可行 y.length = 2; // 通过 y 修改 x，可行 delete x; // 清除数组，同时修改 y，可行 // 下面的就不可行了；需要在 storage 中创建新的未命名的临时数组， / // 但 storage 是“静态”分配的： // y = memoryArray; // 下面这一行也不可行，因为这会“重置”指针， // 但并没有可以让它指向的合适的存储位置。 // delete y; g(x); // 调用 g 函数，同时移交对 x 的引用 h(x); // 调用 h 函数，同时在 memory 中创建一个独立的临时拷贝 } function g(uint[] storage storageArray) internal {} function h(uint[] memoryArray) public {} } 总结 强制指定的数据位置： 外部函数的参数（不包括返回参数）： calldata 状态变量： storage 默认数据位置： 函数参数（包括返回参数）： memory 所有其它局部变量： storage 数组 数组可以在声明时指定长度，也可以动态调整大小。 对于 storage 的数组来说，元素类型可以是任意的（即元素也可以是数组类型，映射类型或者结构体）。 对于 memory 的数组来说，元素类型不能是映射类型，如果作为 public 函数的参数，它只能是 ABI 类型。 一个元素类型为 T，固定长度为 k 的数组可以声明为 T[k]，而动态数组声明为 T[]。 举个例子，一个长度为 5，元素类型为 uint 的动态数组的数组，应声明为 uint[][5] （注意这里跟其它语言比，数组长度的声明位置是反的）。 要访问第三个动态数组的第二个元素，你应该使用 x[2][1]（数组下标是从 0 开始的，且访问数组时的下标顺序与声明时相反，也就是说，x[2] 是从右边减少了一级）。。 bytes 和 string 类型的变量是特殊的数组。 bytes 类似于 byte[]，但它在 calldata 中会被“紧打包”（译者注：将元素连续地存在一起，不会按每 32 字节一单元的方式来存放）。 string 与 bytes 相同，但（暂时）不允许用长度或索引来访问。 .. note:: 如果想要访问以字节表示的字符串 s，请使用 bytes(s).length / bytes(s)[7] = 'x';。 注意这时你访问的是 UTF-8 形式的低级 bytes 类型，而不是单个的字符。 可以将数组标识为 public，从而让 Solidity 创建一个 getter。 之后必须使用数字下标作为参数来访问 getter。 创建内存数组 可使用 new 关键字在内存中创建变长数组。 与 storage 数组相反的是，你 不能 通过修改成员变量 length 改变 memory 数组的大小。 pragma solidity ^0.4.16; contract C { function f(uint len) public pure { uint[] memory a = new uint[](7); bytes memory b = new bytes(len); // 这里我们有 a.length == 7 以及 b.length == len a[6] = 8; } } 数组字面常数 / 内联数组 数组字面常数是写作表达式形式的数组，并且不会立即赋值给变量。 pragma solidity ^0.4.16; contract C { function f() public pure { g([uint(1), 2, 3]); } function g(uint[3] _data) public pure { // ... } } 数组字面常数是一种定长的 |memory| 数组类型，它的基础类型由其中元素的普通类型决定。 例如，[1, 2, 3] 的类型是 uint8[3] memory，因为其中的每个字面常数的类型都是 uint8。 正因为如此，有必要将上面这个例子中的第一个元素转换成 uint 类型。 目前需要注意的是，定长的 memory 数组并不能赋值给变长的 memory 数组，下面是个反例： // 这段代码并不能编译。 pragma solidity ^0.4.0; contract C { function f() public { // 这一行引发了一个类型错误，因为 unint[3] memory // 不能转换成 uint[] memory。 uint[] x = [uint(1), 3, 4]; } } 已经计划在未来移除这样的限制，但目前数组在 ABI 中传递的问题造成了一些麻烦。 成员 length: 数组有 length 成员变量表示当前数组的长度。动态数组可以在 storage（而不是 memory ）中通过改变成员变量 .length 改变数组大小。并不能通过访问超出当前数组长度的方式实现自动扩展数组的长度。一经创建，memory 数组的大小就是固定的（但却是动态的，也就是说，它依赖于运行时的参数）。 push: 变长的 |storage| 数组以及 bytes 类型（而不是 string 类型）都有一个叫做 push 的成员函数，它用来附加新的元素到数组末尾。这个函数将返回新的数组长度。 在外部函数中目前还不能使用多维数组。 由于 |evm| 的限制，不能通过外部函数调用返回动态的内容。例如，如果通过 web3.js 调用 contract C { function f() returns (uint[]) { ... } } 中的 f 函数，它会返回一些内容，但通过 Solidity 不可以。 目前唯一的变通方法是使用大型的静态数组。 pragma solidity ^0.4.16; contract ArrayContract { uint[2**20] m_aLotOfIntegers; // 注意下面的代码并不是一对动态数组， // 而是一个数组元素为一对变量的动态数组（也就是数组元素为长度为 2 的定长数组的动态数组）。 bool[2][] m_pairsOfFlags; // newPairs 存储在 memory 中 —— 函数参数默认的存储位置 function setAllFlagPairs(bool[2][] newPairs) public { // 向一个 storage 的数组赋值会替代整个数组 m_pairsOfFlags = newPairs; } function setFlagPair(uint index, bool flagA, bool flagB) public { // 访问一个不存在的数组下标会引发一个异常 m_pairsOfFlags[index][0] = flagA; m_pairsOfFlags[index][1] = flagB; } function changeFlagArraySize(uint newSize) public { // 如果 newSize 更小，那么超出的元素会被清除 m_pairsOfFlags.length = newSize; } function clear() public { // 这些代码会将数组全部清空 delete m_pairsOfFlags; delete m_aLotOfIntegers; // 这里也是实现同样的功能 m_pairsOfFlags.length = 0; } bytes m_byteData; function byteArrays(bytes data) public { // 字节的数组（语言意义中的 byte 的复数 ``bytes``）不一样，因为它们不是填充式存储的， // 但可以当作和 \"uint8[]\" 一样对待 m_byteData = data; m_byteData.length += 7; m_byteData[3] = byte(8); delete m_byteData[2]; } function addFlag(bool[2] flag) public returns (uint) { return m_pairsOfFlags.push(flag); } function createMemoryArray(uint size) public pure returns (bytes) { // 使用 `new` 创建动态 memory 数组： uint[2][] memory arrayOfPairs = new uint[2][](size); // 创建一个动态字节数组： bytes memory b = new bytes(200); for (uint i = 0; i 结构体 Solidity 支持通过构造结构体的形式定义新的类型，以下是一个结构体使用的示例： pragma solidity ^0.4.11; contract CrowdFunding { // 定义的新类型包含两个属性。 struct Funder { address addr; uint amount; } struct Campaign { address beneficiary; uint fundingGoal; uint numFunders; uint amount; mapping (uint => Funder) funders; } uint numCampaigns; mapping (uint => Campaign) campaigns; function newCampaign(address beneficiary, uint goal) public returns (uint campaignID) { campaignID = numCampaigns++; // campaignID 作为一个变量返回 // 创建新的结构体示例，存储在 storage 中。我们先不关注映射类型。 campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0); } function contribute(uint campaignID) public payable { Campaign storage c = campaigns[campaignID]; // 以给定的值初始化，创建一个新的临时 memory 结构体， // 并将其拷贝到 storage 中。 // 注意你也可以使用 Funder(msg.sender, msg.value) 来初始化。 c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value}); c.amount += msg.value; } function checkGoalReached(uint campaignID) public returns (bool reached) { Campaign storage c = campaigns[campaignID]; if (c.amount 上面的合约只是一个简化版的众筹合约，但它已经足以让我们理解结构体的基础概念。 结构体类型可以作为元素用在映射和数组中，其自身也可以包含映射和数组作为成员变量。 尽管结构体本身可以作为映射的值类型成员，但它并不能包含自身。这个限制是有必要的，因为结构体的大小必须是有限的。 注意在函数中使用结构体时，一个结构体是如何赋值给一个局部变量（默认存储位置是 storage）的。在这个过程中并没有拷贝这个结构体，而是保存一个引用，所以对局部变量成员的赋值实际上会被写入状态。 当然，你也可以直接访问结构体的成员而不用将其赋值给一个局部变量，就像这样， campaigns[campaignID].amount = 0。 映射 映射类型在声明时的形式为 mapping(_KeyType => _ValueType)。 其中 _KeyType 可以是除了映射、变长数组、合约、枚举以及结构体以外的几乎所有类型。 _ValueType 可以是包括映射类型在内的任何类型。 映射可以视作 哈希表，它们在实际的初始化过程中创建每个可能的 key，并将其映射到字节形式全是零的值：一个类型的默认值。然而下面是映射与哈希表不同的地方： 在映射中，实际上并不存储 key，而是存储它的 keccak256 哈希值，从而便于查询实际的值。 正因为如此，映射是没有长度的，也没有 key 的集合或 value 的集合的概念。只有状态变量（或者在 internal 函数中的对于存储变量的引用）可以使用映射类型。。 可以将映射声明为 public，然后来让 Solidity 创建一个getter。_KeyType 将成为 getter 的必须参数，并且 getter 会返回 _ValueType。_ValueType 也可以是一个映射。这时在使用 getter 时将将需要递归地传入每个 _KeyType 参数。 pragma solidity ^0.4.0; contract MappingExample { mapping(address => uint) public balances; function update(uint newBalance) public { balances[msg.sender] = newBalance; } } contract MappingUser { function f() public returns (uint) { MappingExample m = new MappingExample(); m.update(100); return m.balances(this); } } 映射不支持迭代，但可以在此之上实现一个这样的数据结构。例子可以参考: 可迭代的映射 涉及 LValues 的运算符 如果 a 是一个 LValue（即一个变量或者其它可以被赋值的东西），以下运算符都可以使用简写： a += e 等同于 a = a + e。 其它运算符 -=， *=， /=， %=， |=， &= 以及 ^= 都是如此定义的。 a++ 和 a-- 分别等同于 a += 1 和 a -= 1，但表达式本身的值等于 a 在计算之前的值。 与之相反，--a 和 ++a 虽然最终 a 的结果与之前的表达式相同，但表达式的返回值是计算之后的值。 删除 delete a 的结果是将 a 的类型在初始化时的值赋值给 a。即对于整型变量来说，相当于 a = 0， 但 delete 也适用于数组，对于动态数组来说，是将数组的长度设为 0，而对于静态数组来说，是将数组中的所有元素重置。 如果对象是结构体，则将结构体中的所有属性重置。 delete 对整个映射是无效的（因为映射的键可以是任意的，通常也是未知的）。 因此在你删除一个结构体时，结果将重置所有的非映射属性，这个过程是递归进行的，除非它们是映射。 然而，单个的键及其映射的值是可以被删除的。 理解 delete a 的效果就像是给 a 赋值很重要，换句话说，这相当于在 a 中存储了一个新的对象。 pragma solidity ^0.4.0; contract DeleteExample { uint data; uint[] dataArray; function f() public { uint x = data; delete x; // 将 x 设为 0，并不影响数据 delete data; // 将 data 设为 0，并不影响 x，因为它仍然有个副本 uint[] storage y = dataArray; delete dataArray; // 将 dataArray.length 设为 0，但由于 uint[] 是一个复杂的对象，y 也将受到影响， // 因为它是一个存储位置是 storage 的对象的别名。 // 另一方面：\"delete y\" 是非法的，引用了 storage 对象的局部变量只能由已有的 storage 对象赋值。 } } 基本类型之间的转换 隐式转换 如果一个运算符用在两个不同类型的变量之间，那么编译器将隐式地将其中一个类型转换为另一个类型（不同类型之间的赋值也是一样）。一般来说，只要值类型之间的转换在语义上行得通，而且转换的过程中没有信息丢失，那么隐式转换基本都是可以实现的： uint8 可以转换成 uint16，int128 转换成 int256，但 int8 不能转换成 uint256（因为 uint256 不能涵盖某些值，例如，-1）。更进一步来说，无符号整型可以转换成跟它大小相等或更大的字节类型，但反之不能。任何可以转换成 uint160 的类型都可以转换成 address 类型。 显式转换 如果某些情况下编译器不支持隐式转换，但是你很清楚你要做什么，这种情况可以考虑显式转换。 注意这可能会发生一些无法预料的后果，因此一定要进行测试，确保结果是你想要的！ 下面的示例是将一个 int8 类型的负数转换成 uint： int8 y = -3; uint x = uint(y); 这段代码的最后，x 的值将是 0xfffff..fd （64 个 16 进制字符），因为这是 -3 的 256 位补码形式。 如果一个类型显式转换成更小的类型，相应的高位将被舍弃: uint32 a = 0x12345678; uint16 b = uint16(a); // 此时 b 的值是 0x5678 类型推断 为了方便起见，没有必要每次都精确指定一个变量的类型，编译器会根据分配该变量的第一个表达式的类型自动推断该变量的类型: uint24 x = 0x123; var y = x; 这里 y 的类型将是 uint24。不能对函数参数或者返回参数使用 var。 类型只能从第一次赋值中推断出来，因此以下代码中的循环是无限的，原因是i 的类型是 uint8，而这个类型变量的最大值比 2000 小。for (var i = 0; i 单元和全局变量 sipc单位 sipc单位之间的换算就是在数字后边加上 wei、 finney、 szabo 或 ether 来实现的，如果后面没有单位，缺省为 Wei。例如 2 ether == 2000 finney 的逻辑判断值为 true。 时间单位 秒是缺省时间单位，在时间单位之间，数字后面带有 seconds、 minutes、 hours、 days、 weeks 和 years 的可以进行换算，基本换算关系如下： 1 == 1 seconds 1 minutes == 60 seconds 1 hours == 60 minutes 1 days == 24 hours 1 weeks == 7 days 1 years == 365 days 由于闰秒造成的每年不都是 365 天、每天不都是 24 小时 leap seconds，所以如果你要使用这些单位计算日期和时间，请注意这个问题。因为闰秒是无法预测的，所以需要借助外部的预言机（oracle，是一种链外数据服务，译者注）来对一个确定的日期代码库进行时间矫正。 years 后缀已经不推荐使用了，因为从 0.5.0 版本开始将不再支持。 这些后缀不能直接用在变量后边。如果想用时间单位（例如 days）来将输入变量换算为时间，你可以用如下方式来完成： function f(uint start, uint daysAfter) public { if (now >= start + daysAfter * 1 days) { // ... } } 特殊变量和函数 在全局命名空间中已经存在了（预设了）一些特殊的变量和函数，他们主要用来提供关于区块链的信息或一些通用的工具函数。 .. index:: abi, block, coinbase, difficulty, encode, number, block;number, timestamp, block;timestamp, msg, data, gas, sender, value, now, gas price, origin 区块和交易属性 block.blockhash(uint blockNumber) returns (bytes32)：指定区块的区块哈希——仅可用于最新的 256 个区块且不包括当前区块；而 blocks 从 0.4.22 版本开始已经不推荐使用，由 blockhash(uint blockNumber) 代替 block.coinbase (address): 挖出当前区块的矿工地址 block.difficulty (uint): 当前区块难度 block.gaslimit (uint): 当前区块 gas 限额 block.number (uint): 当前区块号 block.timestamp (uint): 自 unix epoch 起始当前区块以秒计的时间戳 gasleft() returns (uint256)：剩余的 gas msg.data (bytes): 完整的 calldata msg.gas (uint): 剩余 gas - 自 0.4.21 版本开始已经不推荐使用，由 gesleft() 代替 msg.sender (address): 消息发送者（当前调用） msg.sig (bytes4): calldata 的前 4 字节（也就是函数标识符） msg.value (uint): 随消息发送的 wei 的数量 now (uint): 目前区块时间戳（block.timestamp） tx.gasprice (uint): 交易的 gas 价格 tx.origin (address): 交易发起者（完全的调用链） 对于每一个外部函数调用，包括 msg.sender 和 msg.value 在内所有 msg 成员的值都会变化。这里包括对库函数的调用。 不要依赖 block.timestamp、 now 和 blockhash 产生随机数，除非你知道自己在做什么。 时间戳和区块哈希在一定程度上都可能受到挖矿矿工影响。例如，挖矿社区中的恶意矿工可以用某个给定的哈希来运行赌场合约的 payout 函数，而如果他们没收到钱，还可以用一个不同的哈希重新尝试。当前区块的时间戳必须严格大于最后一个区块的时间戳，但这里唯一能确保的只是它会是在权威链上的两个连续区块的时间戳之间的数值。 基于可扩展因素，区块哈希不是对所有区块都有效。你仅仅可以访问最近 256 个区块的哈希，其余的哈希均为零。 ABI 编码函数 abi.encode(...) returns (bytes)：ABI对给定参数进行编码 abi.encodePacked(...) returns (bytes)：对给定参数执行紧打包编码 abi.encodeWithSelector(bytes4 selector, ...) returns (bytes)：ABI对给定参数进行编码，并以给定的函数选择器作为起始的 4 字节数据一起返回 abi.encodeWithSignature(string signature, ...) returns (bytes)：等价于 abi.encodeWithSelector(bytes4(keccak256(signature), ...) 这些编码函数可以用来构造函数调用数据，而不用实际进行调用。此外，keccak256(abi.encodePacked(a, b)) 是更准确的方法来计算在未来版本不推荐使用的 keccak256(a, b)。 更多详情请参考ABI和 紧打包编码。 错误处理 assert(bool condition): 如果条件不满足，则使当前交易没有效果 — 用于检查内部错误。 require(bool condition): 如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误。 require(bool condition, string message): 如果条件不满足则撤销状态更改 - 用于检查由输入或者外部组件引起的错误，可以同时提供一个错误消息。 revert(): 终止运行并撤销状态更改。 revert(string reason): 终止运行并撤销状态更改，可以同时提供一个解释性的字符串。 数学和密码学函数 addmod(uint x, uint y, uint k) returns (uint):计算 (x + y) % k，加法会在任意精度下执行，并且加法的结果即使超过 2**256 也不会被截取。从 0.5.0 版本的编译器开始会加入对 k != 0 的校验（assert）。 mulmod(uint x, uint y, uint k) returns (uint):计算 (x * y) % k，乘法会在任意精度下执行，并且乘法的结果即使超过 2**256 也不会被截取。从 0.5.0 版本的编译器开始会加入对 k != 0 的校验（assert）。 keccak256(...) returns (bytes32): 计算 :ref:(tightly packed) arguments 的 Ethereum-SHA-3 （Keccak-256）哈希。 sha256(...) returns (bytes32):计算 :ref:(tightly packed) arguments 的 SHA-256 哈希。 sha3(...) returns (bytes32):等价于 keccak256。 ripemd160(...) returns (bytes20):计算 :ref:(tightly packed) arguments 的 RIPEMD-160 哈希。 ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address) ：利用椭圆曲线签名恢复与公钥相关的地址，错误返回零值。example usage 上文中的tightly packed是指不会对参数值进行 padding 处理（就是说所有参数值的字节码是连续存放的，译者注），这意味着下边这些调用都是等价的： keccak256(\"ab\", \"c\") keccak256(\"abc\") keccak256(0x616263) keccak256(6382179) keccak256(97, 98, 99) 如果需要 padding，可以使用显式类型转换：keccak256(\"\\x00\\x12\") 和 keccak256(uint16(0x12)) 是一样的。 请注意，常量值会使用存储它们所需要的最少字节数进行打包。例如：keccak256(0) == keccak256(uint8(0))，keccak256(0x12345678) == keccak256(uint32(0x12345678))。 在一个私链上，你很有可能碰到由于 sha256、ripemd160 或者 ecrecover 引起的 Out-of-Gas。原因是因为这些密码学函数在Simplechain虚拟机中以“预编译合约”形式存在的，且在第一次收到消息后才被真正存在（尽管合约代码是EVM中已存在的硬编码）。因此发送到不存在的合约的消息非常昂贵，所以实际的执行会导致 Out-of-Gas 错误。在你实际使用你的合约之前，给每个合约发送一点儿Sipc，比如 1 Wei。这在官方网络或测试网络上不是问题。 地址相关 .balance (uint256):以 Wei 为单位的 :ref:address 的余额。 .transfer(uint256 amount):向 :ref:address 发送数量为 amount 的 Wei，失败时抛出异常，发送 2300 gas 的矿工费，不可调节。 .send(uint256 amount) returns (bool):向 :ref:address 发送数量为 amount 的 Wei，失败时返回 false，发送 2300 gas 的矿工费用，不可调节。 .call(...) returns (bool):发出低级函数 CALL，失败时返回 false，发送所有可用 gas，可调节。 .callcode(...) returns (bool)：发出低级函数 CALLCODE，失败时返回 false，发送所有可用 gas，可调节。 .delegatecall(...) returns (bool):发出低级函数 DELEGATECALL，失败时返回 false，发送所有可用 gas，可调节。 更多信息，参考 :ref:address 部分： 使用 send 有很多危险：如果调用栈深度已经达到 1024（这总是可以由调用者所强制指定），转账会失败；并且如果接收者用光了 gas，转账同样会失败。为了保证以太币转账安全，总是检查 send 的返回值，利用 transfer 或者下面更好的方式： 用这种接收者取回钱的模式。 如果在通过低级函数 delegatecall 发起调用时需要访问存储中的变量，那么这两个合约的存储中的变量定义顺序需要一致，以便被调用的合约代码可以正确地通过变量名访问合约的存储变量。这当然不是指像在高级的库函数调用时所传递的存储变量指针那样的情况。 不鼓励使用 callcode，并且将来它会被移除。 合约相关 this (current contract's type):当前合约，可以明确转换为 :ref:address。 selfdestruct(address recipient):销毁合约，并把余额发送到指定 :ref:address。 suicide(address recipient):与 selfdestruct 等价，但已不推荐使用。 此外，当前合约内的所有函数都可以被直接调用，包括当前函数。 表达式和控制结构 输入参数和输出参数 与 Javascript 一样，函数可能需要参数作为输入;而与 Javascript 和 C 不同的是，它们可能返回任意数量的参数作为输出。 输入参数 输入参数的声明方式与变量相同。但是有一个例外，未使用的参数可以省略参数名。 例如，如果我们希望合约接受有两个整数形参的函数的外部调用，我们会像下面这样写 pragma solidity ^0.4.16; contract Simple { function taker(uint _a, uint _b) public pure { // 用 _a 和 _b 实现相关功能. } } 输出参数 输出参数的声明方式在关键词 returns 之后，与输入参数的声明方式相同。 例如，如果我们需要返回两个结果：两个给定整数的和与积，我们应该写作 pragma solidity ^0.4.16; contract Simple { function arithmetics(uint _a, uint _b) public pure returns (uint o_sum, uint o_product) { o_sum = _a + _b; o_product = _a * _b; } } 输出参数名可以被省略。输出值也可以使用 return 语句指定。 return 语句也可以返回多值，参阅：ref:multi-return。 返回的输出参数被初始化为 0；如果它们没有被显式赋值，它们就会一直为 0。 输入参数和输出参数可以在函数体中用作表达式。因此，它们也可用在等号左边被赋值。 控制结构 JavaScript 中的大部分控制结构在 Solidity 中都是可用的，除了 switch 和 goto。因此 Solidity 中有 if，else，while，do，for，break，continue，return，? : 这些与在 C 或者 JavaScript 中表达相同语义的关键词。 用于表示条件的括号 不可以 被省略，单语句体两边的花括号可以被省略。注意，与 C 和 JavaScript 不同， Solidity 中非布尔类型数值不能转换为布尔类型，因此 if (1) { ... } 的写法在 Solidity 中 无效 。 返回多个值 当一个函数有多个输出参数时， return (v0, v1, ...,vn) 写法可以返回多个值。不过元素的个数必须与输出参数的个数相同。 函数调用 内部函数调用 当前合约中的函数可以直接（“从内部”）调用，也可以递归调用，就像下边这个荒谬的例子一样 pragma solidity ^0.4.16; contract C { function g(uint a) public pure returns (uint ret) { return f(); } function f() internal pure returns (uint ret) { return g(7) + f(); } } 这些函数调用在 EVM 中被解释为简单的跳转。这样做的效果就是当前内存不会被清除，也就是说，通过内部调用在函数之间传递内存引用是非常有效的。 外部函数调用 表达式 this.g(8); 和 c.g(2); （其中 c 是合约实例）也是有效的函数调用，但是这种情况下，函数将会通过一个消息调用来被“外部调用”，而不是直接的跳转。 请注意，不可以在构造函数中通过 this 来调用函数，因为此时真实的合约实例还没有被创建。 如果想要调用其他合约的函数，需要外部调用。对于一个外部调用，所有的函数参数都需要被复制到内存。 当调用其他合约的函数时，随函数调用发送的 Wei 和 gas 的数量可以分别由特定选项 .value() 和 .gas() 指定:: pragma solidity ^0.4.0; contract InfoFeed { function info() public payable returns (uint ret) { return 42; } } contract Consumer { InfoFeed feed; function setFeed(address addr) public { feed = InfoFeed(addr); } function callFeed() public { feed.info.value(10).gas(800)(); } } payable 修饰符要用于修饰 info，否则，.value() 选项将不可用。 注意，表达式 InfoFeed(addr) 进行了一个的显式类型转换，说明”我们知道给定地址的合约类型是 InfoFeed “并且这不会执行构造函数。 显式类型转换需要谨慎处理。绝对不要在一个你不清楚类型的合约上执行函数调用。 我们也可以直接使用 function setFeed(InfoFeed _feed) { feed = _feed; } 。 注意一个事实，feed.info.value(10).gas(800) 只（局部地）设置了与函数调用一起发送的 Wei 值和 gas 的数量，只有最后的圆括号执行了真正的调用。 如果被调函数所在合约不存在（也就是账户中不包含代码）或者被调用合约本身抛出异常或者 gas 用完等，函数调用会抛出异常。 任何与其他合约的交互都会强加潜在危险，尤其是在不能预先知道合约代码的情况下。 当前合约将控制权移交给被调用合约，而被调用合约可能做任何事。即使被调用合约从一个已知父合约继承，继承的合约也只需要有一个正确的接口就可以了。 被调用合约的实现可以完全任意，因此会带来危险。此外，请小心万一它再调用你系统中的其他合约，或者甚至在第一次调用返回之前返回到你的调用合约。 这意味着被调用合约可以通过它自己的函数改变调用合约的状态变量。。一个建议的函数写法是，例如，在你合约中状态变量进行各种变化后再调用外部函数，这样，你的合约就不会轻易被滥用的重入 (reentrancy) 所影响 具名调用和匿名函数参数 如果它们被包含在 {} 中，函数调用参数也可以按照任意顺序由名称给出， 如以下示例中所示。参数列表必须按名称与函数声明中的参数列表相符，但可以按任意顺序排列。 pragma solidity ^0.4.0; contract C { function f(uint key, uint value) public { // ... } function g() public { // 具名参数 f({value: 2, key: 3}); } } 省略函数参数名称 未使用参数的名称（特别是返回参数）可以省略。这些参数仍然存在于堆栈中，但它们无法访问。 pragma solidity ^0.4.16; contract C { // 省略参数名称 function func(uint k, uint) public pure returns(uint) { return k; } } 通过 new 创建合约 使用关键字 new 可以创建一个新合约。待创建合约的完整代码必须事先知道，因此递归的创建依赖是不可能的。 pragma solidity ^0.4.0; contract D { uint x; function D(uint a) public payable { x = a; } } contract C { D d = new D(4); // 将作为合约 C 构造函数的一部分执行 function createD(uint arg) public { D newD = new D(arg); } function createAndEndowD(uint arg, uint amount) public payable { //随合约的创建发送 ether D newD = (new D).value(amount)(arg); } } 如示例中所示，使用 .value（） 选项创建 D 的实例时可以转发 Ether，但是不可能限制 gas 的数量。如果创建失败（可能因为栈溢出，或没有足够的余额或其他问题），会引发异常。 表达式计算顺序 表达式的计算顺序不是特定的（更准确地说，表达式树中某节点的字节点间的计算顺序不是特定的，但它们的结算肯定会在节点自己的结算之前）。该规则只能保证语句按顺序执行，布尔表达式的短路执行。更多相关信息，请参阅：:ref:order。 赋值 解构赋值和返回多值 Solidity 内部允许元组 (tuple) 类��，也就是一个在编译时元素数量固定的对象列表，列表中的元素可以是不同类型的对象。这些元组可以用来同时返回多个数值，也可以用它们来同时给多个新声明的变量或者既存的变量（或通常的 LValues）： pragma solidity >0.4.23 直到 0.4.24 版本，给具有更少的元素数的元组赋值都可以可能的，无论是在左边还是右边（比如在最后空出若干元素）。现在，这已经不推荐了，赋值操作的两边应该具有相同个数的组成元素。 数组和结构体的复杂性 赋值语义对于像数组和结构体这样的非值类型来说会有些复杂。 为状态变量 赋值 经常会创建一个独立副本。另一方面，对局部变量的赋值只会为基本类型（即 32 字节以内的静态类型）创建独立的副本。如果结构体或数组（包括 bytes 和 string）被从状态变量分配给局部变量，局部变量将保留对原始状态变量的引用。对局部变量的第二次赋值不会修改状态变量，只会改变引用。赋值给局部变量的成员（或元素）则 改变 状态变量。 作用域和声明 变量声明后将有默认初始值，其初始值字节表示全部为零。任何类型变量的“默认值”是其对应类型的典型“零状态”。例如， bool 类型的默认值是 false 。 uint 或 int 类型的默认值是 0 。对于静态大小的数组和 bytes1 到 bytes32 ，每个单独的元素将被初始化为与其类型相对应的默认值。 最后，对于动态大小的数组， bytes 和 string 类型，其默认缺省值是一个空数组或字符串。 Solidity 中的作用域规则遵循了 C99（与其他很多语言一样）：变量将会从它们被声明之后可见，直到一对 { } 块的结束。作为一个例外，在 for 循环语句中初始化的变量，其可见性仅维持到 for 循环的结束。 那些定义在代码块之外的变量，比如函数、合约、自定义类型等等，并不会影响它们的作用域特性。这意味着你可以在实际声明状态变量的语句之前就使用它们，并且递归地调用函数。 基于以上的规则，下边的例子不会出现编译警告，因为那两个变量虽然名字一样，但却在不同的作用域里。 pragma solidity >0.4.24; contract C { function minimalScoping() pure public { { uint same2 = 0; } { uint same2 = 0; } } } 作为 C99 作用域规则的特例，请注意在下边的例子里，第一次对 x 的赋值会改变上一层中声明的变量值。如果外层声明的变量被“影子化”（就是说被在内部作用域中由一个同名变量所替代）你会得到一个警告。 pragma solidity >0.4.24; contract C { function f() pure public returns (uint) { uint x = 1; { x = 2; // 这个赋值会影响在外层声明的变量 uint x; } return x; // x has value 2 } } 在 Solidity 0.5.0 之前的版本，作用域规则都沿用了 Javascript 的规则，即一个变量可以声明在函数的任意位置，都可以使他在整个函数范围内可见。而这种规则会从 0.5.0 版本起被打破。从 0.5.0 版本开始，下面例子中的代码段会导致编译错误。 // 这将无法编译通过 pragma solidity >0.4.24; contract C { function f() pure public returns (uint) { x = 2; uint x; return x; } } 错误处理：Assert, Require, Revert and Exceptions Solidity 使用状态恢复异常来处理错误。这种异常将撤消对当前调用（及其所有子调用）中的状态所做的所有更改，并且还向调用者标记错误。 便利函数 assert 和 require 可用于检查条件并在条件不满足时抛出异常。assert 函数只能用于测试内部错误，并检查非变量。 require 函数用于确认条件有效性，例如输入变量，或合约状态变量是否满足条件，或验证外部合约调用返回的值。 如果使用得当，分析工具可以评估你的合约，并标示出那些会使 assert 失败的条件和函数调用。 正常工作的代码不会导致一个 assert 语句的失败；如果这发生了，那就说明出现了一个需要你修复的 bug。 还有另外两种触发异常的方法：revert 函数可以用来标记错误并恢复当前的调用。 revert 调用中包含有关错误的详细信息是可能的，这个消息会被返回给调用者。已经不推荐的关键字 throw 也可以用来替代 revert() （但无法返回错误消息）。 从 0.4.13 版本开始，throw 这个关键字被弃用，并且将来会被逐渐淘汰。 当子调用发生异常时，它们会自动“冒泡”（即重新抛出异常）。这个规则的例外是 send 和低级函数 call ， delegatecall 和 callcode --如果这些函数发生异常，将返回 false ，而不是“冒泡”。 作为 EVM 设计的一部分，如果被调用合约帐户不存在，则低级函数 call ，delegatecall 和 callcode 将返回 success。因此如果需要使用低级函数时，必须在调用之前检查被调用合约是否存在。异常捕获还未实现 在下例中，你可以看到如何轻松使用require检查输入条件以及如何使用assert检查内部错误，注意，你可以给 require 提供一个消息字符串，而 assert 不行。 pragma solidity ^0.4.22; contract Sharer { function sendHalf(address addr) public payable returns (uint balance) { require(msg.value % 2 == 0, \"Even value required.\"); uint balanceBeforeTransfer = this.balance; addr.transfer(msg.value / 2); //由于转移函数在失败时抛出异常并且不能在这里回调，因此我们应该没有办法仍然有一半的钱。 assert(this.balance == balanceBeforeTransfer - msg.value / 2); return this.balance; } } 下列情况将会产生一个 assert 式异常： 如果你访问数组的索引太大或为负数（例如 x[i] 其中 i >= x.length 或 i ）。 如果你访问固定长度 bytesN 的索引太大或为负数。 如果你用零当除数做除法或模运算（例如 5 / 0 或 23 % 0 ）。 如果你移位负数位。 如果你将一个太大或负数值转换为一个枚举类型。 如果你调用内部函数类型的零初始化变量。 如果你调用 assert 的参数（表达式）最终结算为 false。 下列情况将会产生一个 require 式异常： 调用 throw 。 如果你调用 require 的参数（表达式）最终结算为 false 。 如果你通过消息调用调用某个函数，但该函数没有正确结束（它耗尽了 gas，没有匹配函数，或者本身抛出一个异常），上述函数不包括低级别的操作 call ， send ， delegatecall 或者 callcode 。低级操作不会抛出异常，而通过返回 false 来指示失败。 如果你使用 new 关键字创建合约，但合约没有正确创建（请参阅上条有关”未正确完成“的定义）。 如果你对不包含代码的合约执行外部函数调用。 如果你的合约通过一个没有 payable 修饰符的公有函数（包括构造函数和 fallback 函数）接收 Ether。 如果你的合约通过公有 getter 函数接收 Ether 。 如果 .transfer() 失败。 在内部， Solidity 对一个 require 式的异常执行回退操作（指令 0xfd ）并执行一个无效操作（指令 0xfe ）来引发 assert 式异常。在这两种情况下，都会导致 EVM 回退对状态所做的所有更改。回退的原因是不能继续安全地执行，因为没有实现预期的效果。因为我们想保留交易的原子性，所以最安全的做法是回退所有更改并使整个交易（或至少是调用）不产生效果。请注意， assert 式异常消耗了所有可用的调用 gas ，而从 Metropolis 版本起 require 式的异常不会消耗任何 gas。 下边的例子展示了如何在 revert 和 require 中使用错误字符串： pragma solidity ^0.4.22; contract VendingMachine { function buy(uint amount) payable { if (amount > msg.value / 2 ether) revert(\"Not enough Ether provided.\"); // 下边是等价的方法来做同样的检查： require( amount 这里提供的字符串应该是经过 :ref:ABI 编码 之后的，因为它实际上是调用了 Error(string) 函数。在上边的例子里，revert(\"Not enough Ether provided.\"); 会产生如下的十六进制错误返回值： 0x08c379a0 // Error(string) 的函数选择器 0x0000000000000000000000000000000000000000000000000000000000000020 // 数据的偏移量（32） 0x000000000000000000000000000000000000000000000000000000000000001a // 字符串长度（26） 0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // 字符串数据（\"Not enough Ether provided.\" 的 ASCII 编码，26字节） 合约 Solidity 合约类似于面向对象语言中的类。合约中有用于数据持久化的状态变量，和可以修改状态变量的函数。 调用另一个合约实例的函数时，会执行一个 EVM 函数调用，这个操作会切换执行时的上下文，这样，前一个合约的状态变量就不能访问了。 创建合约 可以通过Simplechain交易“从外部”或从 Solidity 合约内部创建合约。 一些集成开发环境，例如 Remix, 通过使用一些用户界面元素使创建过程更加流畅。在Simplechain上编程创建合约最好使用 JavaScript API web3.j。现在，我们已经有了一个叫做 web3.eth.Contract 的方法能够更容易的创建合约。 创建合约时，会执行一次构造函数（与合约同名的函数）。构造函数是可选的。只允许有一个构造函数，这意味着不支持重载。 在内部，构造函数参数在合约代码之后通ABI 编码传递，但是如果你使用 web3.js则不必关心这个问题。 如果一个合约想要创建另一个合约，那么创建者必须知晓被创建合约的源代码(和二进制代码)。 这意味着不可能循环创建依赖项。 pragma solidity ^0.4.16; contract OwnedToken { // TokenCreator 是如下定义的合约类型. // 不创建新合约的话，也可以引用它。 TokenCreator creator; address owner; bytes32 name; // 这是注册 creator 和设置名称的构造函数。 function OwnedToken(bytes32 _name) public { // 状态变量通过其名称访问，而不是通过例如 this.owner 的方式访问。 // 这也适用于函数，特别是在构造函数中，你只能像这样（“内部地”）调用它们， // 因为合约本身还不存在。 owner = msg.sender; // 从 `address` 到 `TokenCreator` ，是做显式的类型转换 // 并且假定调用合约的类型是 TokenCreator，没有真正的方法来检查这一点。 creator = TokenCreator(msg.sender); name = _name; } function changeName(bytes32 newName) public { // 只有 creator （即创建当前合约的合约）能够更改名称 —— 因为合约是隐式转换为地址的， // 所以这里的比较是可行的。 if (msg.sender == address(creator)) name = newName; } function transfer(address newOwner) public { // 只有当前所有者才能发送 token。 if (msg.sender != owner) return; // 我们也想询问 creator 是否可以发送。 // 请注意，这里调用了一个下面定义的合约中的函数。 // 如果调用失败（比如，由于 gas 不足），会立即停止执行。 if (creator.isTokenTransferOK(owner, newOwner)) owner = newOwner; } } contract TokenCreator { function createToken(bytes32 name) public returns (OwnedToken tokenAddress) { // 创建一个新的 Token 合约并且返回它的地址。 // 从 JavaScript 方面来说，返回类型是简单的 `address` 类型，因为 // 这是在 ABI 中可用的最接近的类型。 return new OwnedToken(name); } function changeName(OwnedToken tokenAddress, bytes32 name) public { // 同样，`tokenAddress` 的外部类型也是 `address` 。 tokenAddress.changeName(name); } function isTokenTransferOK(address currentOwner, address newOwner) public view returns (bool ok) { // 检查一些任意的情况。 address tokenAddress = msg.sender; return (keccak256(newOwner) & 0xff) == (bytes20(tokenAddress) & 0xff); } } 可见性和 getter 函数 由于 Solidity 有两种函数调用（内部调用不会产生实际的 EVM 调用或称为“消息调用”，而外部调用则会产生一个 EVM 调用），函数和状态变量有四种可见性类型。函数可以指定为 external ，public ，internal 或者 private，默认情况下函数类型为 public。 对于状态变量，不能设置为 external ，默认是 internal 。 external ：外部函数作为合约接口的一部分，意味着我们可以从其他合约和交易中调用。 一个外部函数 f 不能从内部调用（即 f 不起作用，但 this.f() 可以）。 当收到大量数据的时候，外部函数有时候会更有效率。 public ：public 函数是合约接口的一部分，可以在内部或通过消息调用。对于公共状态变量，会自动生成一个 getter 函数（见下面）。 internal ：这些函数和状态变量只能是内部访问（即从当前合约内部或从它派生的合约访问），不使用 this 调用。 private ：private 函数和状态变量仅在当前定义它们的合约中使用，并且不能被派生合约使用。 合约中的所有内容对外部观察者都是可见的。设置一些 private 类型只能阻止其他合约访问和修改这些信息，但是对于区块链外的整个世界它仍然是可见的。 可见性标识符的定义位置，对于状态变量来说是在类型后面，对于函数是在参数列表和返回关键字中间。 pragma solidity ^0.4.16; contract C { function f(uint a) private pure returns (uint b) { return a + 1; } function setData(uint a) internal { data = a; } uint public data; } 在下面的例子中，D 可以调用 c.getData（） 来获取状态存储中 data 的值，但不能调用 f 。 合约 E 继承自 C ，因此可以调用 compute。 // 下面代码编译错误 pragma solidity ^0.4.0; contract C { uint private data; function f(uint a) private returns(uint b) { return a + 1; } function setData(uint a) public { data = a; } function getData() public returns(uint) { return data; } function compute(uint a, uint b) internal returns (uint) { return a+b; } } contract D { function readData() public { C c = new C(); uint local = c.f(7); // 错误：成员 `f` 不可见 c.setData(3); local = c.getData(); local = c.compute(3, 5); // 错误：成员 `compute` 不可见 } } contract E is C { function g() public { C c = new C(); uint val = compute(3, 5); // 访问内部成员（从继承合约访问父合约成员） } } Getter 函数 编译器自动为所有 public 状态变量创建 getter 函数。对于下面给出的合约，编译器会生成一个名为 data 的函数， 该函数不会接收任何参数并返回一个 uint ，即状态变量 data 的值。可以在声明时完成状态变量的初始化。 pragma solidity ^0.4.0; contract C { uint public data = 42; } contract Caller { C c = new C(); function f() public { uint local = c.data(); } } getter 函数具有外部可见性。如果在内部访问 getter（即没有 this. ），它被认为一个状态变量。 如果它是外部访问的（即用 this. ），它被认为为一个函数。 pragma solidity ^0.4.0; contract C { uint public data; function x() public { data = 3; // 内部访问 uint val = this.data(); // 外部访问 } } 下一个例子稍微复杂一些： pragma solidity ^0.4.0; contract Complex { struct Data { uint a; bytes3 b; mapping (uint => uint) map; } mapping (uint => mapping(bool => Data[])) public data; } 这将会生成以下形式的函数 :: function data(uint arg1, bool arg2, uint arg3) public returns (uint a, bytes3 b) { a = data[arg1][arg2][arg3].a; b = data[arg1][arg2][arg3].b; } 请注意，因为没有好的方法来提供映射的键，所以结构中的映射被省略。 函数 |modifier| 使用 |modifier| 可以轻松改变函数的行为。 例如，它们可以在执行函数之前自动检查某个条件。 |modifier| 是合约的可继承属性， 并可能被派生合约覆盖。 pragma solidity ^0.4.11; contract owned { function owned() public { owner = msg.sender; } address owner; // 这个合约只定义一个修饰器，但并未使用： 它将会在派生合约中用到。 // 修饰器所修饰的函数体会被插入到特殊符号 _; 的位置。 // 这意味着如果是 owner 调用这个函数，则函数会被执行，否则会抛出异常。 modifier onlyOwner { require(msg.sender == owner); _; } } contract mortal is owned { // 这个合约从 `owned` 继承了 `onlyOwner` 修饰符，并将其应用于 `close` 函数， // 只有在合约里保存的 owner 调用 `close` 函数，才会生效。 function close() public onlyOwner { selfdestruct(owner); } } contract priced { // 修改器可以接收参数： modifier costs(uint price) { if (msg.value >= price) { _; } } } contract Register is priced, owned { mapping (address => bool) registeredAddresses; uint price; function Register(uint initialPrice) public { price = initialPrice; } // 在这里也使用关键字 `payable` 非常重要，否则函数会自动拒绝所有发送给它的以太币。 function register() public payable costs(price) { registeredAddresses[msg.sender] = true; } function changePrice(uint _price) public onlyOwner { price = _price; } } contract Mutex { bool locked; modifier noReentrancy() { require(!locked); locked = true; _; locked = false; } // 这个函数受互斥量保护，这意味着 `msg.sender.call` 中的重入调用不能再次调用 `f`。 // `return 7` 语句指定返回值为 7，但修改器中的语句 `locked = false` 仍会执行。 function f() public noReentrancy returns (uint) { require(msg.sender.call()); return 7; } } 如果同一个函数有多个 modifier，它们之间以空格隔开，modifier会依次检查执行。 在早期的 Solidity 版本中，有 |modifier| 的函数，return 语句的行为表现不同。 modifier 或函数体中显式的 return 语句仅仅跳出当前的 modifier 和函数体。 返回变量会被赋值，但整个执行逻辑会从前一个 |modifier| 中的定义的 “_” 之后继续执行。 modifier的参数可以是任意表达式，在此上下文中，所有在函数中可见的符号，在 modifier 中均可见。在 modifier 中引入的符号在函数中不可见（可能被重载改变）。 Constant 状态变量 状态变量可以被声明为 constant。在这种情况下，只能使用那些在编译时有确定值的表达式来给它们赋值。任何通过访问 storage，区块链数据（例如 now, this.balance 或者 block.number）或执行数据（ msg.gas ）或对外部合约的调用来给它们赋值都是不允许的。在内存分配上有边界效应（side-effect）的表达式是允许的，但对其他内存对象产生边界效应的表达式则不行。内建（built-in）函数 keccak256，sha256，ripemd160，ecrecover，addmod 和 mulmod 是允许的（即使他们确实会调用外部合约）。 允许带有边界效应的内存分配器的原因是这将允许构建复杂的对象，比如查找表（lookup-table）。 此功能尚未完全可用。编译器不会为这些变量预留存储，它们的每次出现都会被替换为相应的常量表达式（这将可能被优化器计算为实际的某个值）。不是所有类型的状态变量都支持用 constant 来修饰，当前支持的仅有值类型和字符串。 pragma solidity ^0.4.0; contract C { uint constant x = 32**22 + 8; string constant text = \"abc\"; bytes32 constant myHash = keccak256(\"abc\"); } 函数 View 函数 可以将函数声明为 view 类型，这种情况下要保证不修改状态。 下面的语句被认为是修改状态： 修改状态变量。 产生事件。 创建其它合约。 使用selfdestruct。 通过调用发送以太币。 调用任何没有标记为 view 或者 pure 的函数。 使用低级调用。 使用包含特定操作码的内联汇编。 pragma solidity ^0.4.16; contract C { function f(uint a, uint b) public view returns (uint) { return a * (b + 42) + now; } } constant 是 view 的别名。 Getter 方法被标记为 view。 编译器没有强制 view 方法不能修改状态。 Pure 函数 函数可以声明为 pure ，在这种情况下，承诺不读取或修改状态。除了上面解释的状态修改语句列表之外，以下被认为是从状态中读取： 读取状态变量。 访问 this.balance 或者 .balance。 访问 block，tx， msg 中任意成员 （除 msg.sig 和 msg.data 之外）。 调用任何未标记为 pure 的函数。 使用包含某些操作码的内联汇编。 pragma solidity ^0.4.16; contract C { function f(uint a, uint b) public pure returns (uint) { return a * (b + 42); } } 编译器没有强制 pure 方法不能读取状态。 Fallback 函数 合约可以有一个未命名的函数。这个函数不能有参数也不能有返回值。如果在一个到合约的调用中，没有其他函数与给定的函数标识符匹配（或没有提供调用数据），那么这个函数（fallback 函数）会被执行。 除此之外，每当合约收到以太币（没有任何数据），这个函数就会执行。此外，为了接收以太币，fallback 函数必须标记为 payable。如果不存在这样的函数，则合约不能通过常规交易接收以太币。 在这样的上下文中，通常只有很少的 gas 可以用来完成这个函数调用（准确地说，是 2300 gas），所以使 fallback 函数的调用尽量廉价很重要。请注意，调用 fallback 函数的交易（而不是内部调用）所需的 gas 要高得多，因为每次交易都会额外收取 21000 gas 或更多的费用，用于签名检查等操作。 具体来说，以下操作会消耗比 fallback 函数更多的 gas： 写入存储 创建合约 调用消耗大量 gas 的外部函数 发送以太币 请确保您在部署合约之前彻底测试您的 fallback 函数，以确保执行成本低于 2300 个 gas。 即使 fallback 函数不能有参数，仍然可以使用 msg.data 来获取随调用提供的任何有效数据。 一个没有定义 fallback 函数的合约，直接接收以太币（没有函数调用，即使用 send 或 transfer）会抛出一个异常，并返还以太币（在 Solidity v0.4.0 之前行为会有所不同）。所以如果你想让你的合约接收以太币，必须实现 fallback 函数。 一个没有 payable fallback 函数的合约，可以作为 coinbase transaction （又名 miner block reward ）的接收者或者作为 selfdestruct 的目标来接收以太币。 一个合约不能对这种以太币转移做出反应，因此也不能拒绝它们。这是 EVM 在设计时就决定好的，而且 Solidity 无法绕过这个问题。 这也意味着 this.balance 可以高于合约中实现的一些手工记帐的总和（即在 fallback 函数中更新的累加器）。 pragma solidity ^0.4.0; contract Test { // 发送到这个合约的所有消息都会调用此函数（因为该合约没有其它函数）。 // 向这个合约发送以太币会导致异常，因为 fallback 函数没有 `payable` 修饰符 function() public { x = 1; } uint x; } // 这个合约会保留所有发送给它的以太币，没有办法返还。 contract Sink { function() public payable { } } contract Caller { function callTest(Test test) public { test.call(0xabcdef01); // 不存在的哈希 // 导致 test.x 变成 == 1。 // 以下将不会编译，但如果有人向该合约发送以太币，交易将失败并拒绝以太币。 // test.send(2 ether）; } } 函数重载 合约可以具有多个不同参数的同名函数。这也适用于继承函数。以下示例展示了合约 A 中的重载函数 f。 pragma solidity ^0.4.16; contract A { function f(uint _in) public pure returns (uint out) { out = 1; } function f(uint _in, bytes32 _key) public pure returns (uint out) { out = 2; } } 重载函数也存在于外部接口中。如果两个外部可见函数仅区别于 Solidity 内的类型而不是它们的外部类型则会导致错误。 ```bash // 以下代码无法编译 pragma solidity ^0.4.16; contract A { function f(B _in) public pure returns (B out) { out = _in; } function f(address _in) public pure returns (address out) { out = _in; } } contract B { } 以上两个 f 函数重载都接受了 ABI 的地址类型，虽然它们在 Solidity 中被认为是不同的。 重载解析和参数匹配 通过将当前范围内的函数声明与函数调用中提供的参数相匹配，可以选择重载函数。 如果所有参数都可以隐式地转换为预期类型，则选择函数作为重载候选项。如果一个候选都没有，解析失败。 返回参数不作为重载解析的依据。 pragma solidity ^0.4.16; contract A { function f(uint8 _in) public pure returns (uint8 out) { out = _in; } function f(uint256 _in) public pure returns (uint256 out) { out = _in; } } 调用 f(50) 会导致类型错误，因为 50 既可以被隐式转换为 uint8 也可以被隐式转换为 uint256。另一方面，调用 f(256) 则会解析为 f(uint256) 重载，因为 256 不能隐式转换为 uint8。 事件 事件允许我们方便地使用 EVM 的日志基础设施。我们可以在 dapp 的用户界面中监听事件，EVM 的日志机制可以反过来“调用”用来监听事件的 Javascript 回调函数。 事件在合约中可被继承。当他们被调用时，会使参数被存储到交易的日志中 —— 一种区块链中的特殊数据结构。这些日志与地址相关联，被并入区块链中，只要区块可以访问就一直存在（在 Frontier 和 Homestead 版本中会被永久保存，在 Serenity 版本中可能会改动)。日志和事件在合约内不可直接被访问（甚至是创建日志的合约也不能访问）。 对日志的 SPV（Simplified Payment Verification）证明是可能的，如果一个外部实体提供了一个带有这种证明的合约，它可以检查日志是否真实存在于区块链中。但需要留意的是，由于合约中仅能访问最近的 256 个区块哈希，所以还需要提供区块头信息。 最多三个参数可以接收 indexed 属性，从而使它们可以被搜索：在用户界面上可以使用 indexed 参数的特定值来进行过滤。 如果数组（包括 string 和 bytes）类型被标记为索引项，则它们的 keccak-256 哈希值会被作为 topic 保存。除非你用 anonymous 说明符声明事件，否则事件签名的哈希值是 topic 之一。同时也意味着对于匿名事件无法通过名字来过滤。所有非索引参数都将存储在日志的数据部分中。 索引参数本身不会被保存。你只能搜索它们的值（来确定相应的日志数据是否存在），而不能获取它们的值本身。 pragma solidity ^0.4.0; contract ClientReceipt { event Deposit( address indexed _from, bytes32 indexed _id, uint _value ); function deposit(bytes32 _id) public payable { // 我们可以过滤对 `Deposit` 的调用，从而用 Javascript API 来查明对这个函数的任何调用（甚至是深度嵌套调用）。 Deposit(msg.sender, _id, msg.value); } } 使用 JavaScript API 调用事件的用法如下： var abi = /* abi 由编译器产生 */; var ClientReceipt = web3.eth.contract(abi); var clientReceipt = ClientReceipt.at(\"0x1234...ab67\" /* 地址 */); var event = clientReceipt.Deposit(); // 监视变化 event.watch(function(error, result){ // 结果包括对 `Deposit` 的调用参数在内的各种信息。 if (!error) console.log(result); }); // 或者通过回调立即开始观察 var event = clientReceipt.Deposit(function(error, result) { if (!error) console.log(result); }); 日志的底层接口 通过函数 log0，log1， log2， log3 和 log4 可以访问日志机制的底层接口。logi 接受 i + 1 个 bytes32 类型的参数。其中第一个参数会被用来做为日志的数据部分，其它的会做为 topic。上面的事件调用可以以相同的方式执行。 pragma solidity ^0.4.10; contract C { function f() public payable { bytes32 _id = 0x420042; log3( bytes32(msg.value), bytes32(0x50cb9fe53daa9737b786ab3646f04d0150dc50ef4e75f59509d83667ad5adb20), bytes32(msg.sender), _id ); } } 其中的长十六进制数的计算方法是 keccak256(\"Deposit(address,hash256,uint256)\")，即事件的签名。 其它学习事件机制的资源 Javascript 文档 事件使用例程 如何在 js 中访问它们 继承 通过复制包括多态的代码，Solidity 支持多重继承。所有的函数调用都是虚拟的，这意味着最远的派生函数会被调用，除非明确给出合约名称。当一个合约从多个合约继承时，在区块链上只有一个合约被创建，所有基类合约的代码被复制到创建的合约中。 总的来说，Solidity 的继承系统与 Python的继承系统，非常相似，特别是多重继承方面。 下面的例子进行了详细的说明。 pragma solidity ^0.4.16; contract owned { function owned() { owner = msg.sender; } address owner; } // 使用 is 从另一个合约派生。派生合约可以访问所有非私有成员，包括内部函数和状态变量， // 但无法通过 this 来外部访问。 contract mortal is owned { function kill() { if (msg.sender == owner) selfdestruct(owner); } } // 这些抽象合约仅用于给编译器提供接口。 // 注意函数没有函数体。 // 如果一个合约没有实现所有函数，则只能用作接口。 contract Config { function lookup(uint id) public returns (address adr); } contract NameReg { function register(bytes32 name) public; function unregister() public; } // 可以多重继承。请注意，owned 也是 mortal 的基类， // 但只有一个 owned 实例（就像 C++ 中的虚拟继承）。 contract named is owned, mortal { function named(bytes32 name) { Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970); NameReg(config.lookup(1)).register(name); } // 函数可以被另一个具有相同名称和相同数量/类型输入的函数重载。 // 如果重载函数有不同类型的输出参数，会导致错误。 // 本地和基于消息的函数调用都会考虑这些重载。 function kill() public { if (msg.sender == owner) { Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970); NameReg(config.lookup(1)).unregister(); // 仍然可以调用特定的重载函数。 mortal.kill(); } } } // 如果构造函数接受参数， // 则需要在声明（合约的构造函数）时提供， // 或在派生合约的构造函数位置以修饰器调用风格提供（见下文）。 contract PriceFeed is owned, mortal, named(\"GoldFeed\") { function updateInfo(uint newInfo) public { if (msg.sender == owner) info = newInfo; } function get() public view returns(uint r) { return info; } uint info; } 注意，在上边的代码中，我们调用 mortal.kill() 来“转发”销毁请求。这样做法是有问题的，在下面的例子中可以看到:: pragma solidity ^0.4.0; contract owned { function owned() public { owner = msg.sender; } address owner; } contract mortal is owned { function kill() public { if (msg.sender == owner) selfdestruct(owner); } } contract Base1 is mortal { function kill() public { /* 清除操作 1 */ mortal.kill(); } } contract Base2 is mortal { function kill() public { /* 清除操作 2 */ mortal.kill(); } } contract Final is Base1, Base2 { } 调用 Final.kill() 时会调用最远的派生重载函数 Base2.kill，但是会绕过 Base1.kill，主要是因为它甚至都不知道 Base1 的存在。解决这个问题的方法是使用 super: pragma solidity ^0.4.0; contract owned { function owned() public { owner = msg.sender; } address owner; } contract mortal is owned { function kill() public { if (msg.sender == owner) selfdestruct(owner); } } contract Base1 is mortal { function kill() public { /* 清除操作 1 */ super.kill(); } } contract Base2 is mortal { function kill() public { /* 清除操作 2 */ super.kill(); } } contract Final is Base1, Base2 { } 如果 Base2 调用 super 的函数，它不会简单在其基类合约上调用该函数。 相反，它在最终的继承关系图谱的下一个基类合约中调用这个函数，所以它会调用 Base1.kill()（注意最终的继承序列是——从最远派生合约开始：Final, Base2, Base1, mortal, ownerd）。在类中使用 super 调用的实际函数在当前类的上下文中是未知的，尽管它的类型是已知的。 这与普通的虚拟方法查找类似。 基类构造函数的参数 派生合约需要提供基类构造函数需要的所有参数。这可以通过两种方式来完成:: pragma solidity ^0.4.0; contract Base { uint x; function Base(uint _x) public { x = _x; } } contract Derived is Base(7) { function Derived(uint _y) Base(_y * _y) public { } } 一种方法直接在继承列表中调用基类构造函数（is Base(7)）。另一种方法是像 |modifier| 使用方法一样，作为派生合约构造函数定义头的一部分，（Base(_y * _y))。如果构造函数参数是常量并且定义或描述了合约的行为，使用第一种方法比较方便。如果基类构造函数的参数依赖于派生合约，那么必须使用第二种方法。如果像这个简单的例子一样，两个地方都用到了，优先使用 |modifier| 风格的参数。 多重继承与线性化 编程语言实现多重继承需要解决几个问题。 一个问题是钻石问题 Solidity 借鉴了 Python 的方式并且使用 C3 线性化 强制一个由基类构成的 DAG（有向无环图）保持一个特定的顺序。 这最终反映为我们所希望的唯一化的结果，但也使某些继承方式变为无效。尤其是，基类在 is 后面的顺序很重要。在下面的代码中，Solidity 会给出“ Linearization of inheritance graph impossible ”这样的错误。 // 以下代码编译出错 pragma solidity ^0.4.0; contract X {} contract A is X {} contract C is A, X {} 代码编译出错的原因是 C 要求 X 重写 A （因为定义的顺序是 A, X ）， 但是 A 本身要求重写 X，无法解决这种冲突。 可以通过一个简单的规则来记忆：以从“最接近的基类”（most base-like）到“最远的继承”（most derived）的顺序来指定所有的基类。 继承有相同名字的不同类型成员 当继承导致一个合约具有相同名字的函数和 |modifier| 时，这会被认为是一个错误。 当事件和 |modifier| 同名，或者函数和事件同名时，同样会被认为是一个错误。 有一种例外情况，状态变量的 getter 可以覆盖一个 public 函数。 抽象合约 合约函数可以缺少实现，如下例所示（请注意函数声明头由 ; 结尾）: pragma solidity ^0.4.0; contract Feline { function utterance() public returns (bytes32); } 这些合约无法成功编译（即使它们除了未实现的函数还包含其他已经实现了的函数），但他们可以用作基类合约:: pragma solidity ^0.4.0; contract Feline { function utterance() public returns (bytes32); } contract Cat is Feline { function utterance() public returns (bytes32) { return \"miaow\"; } } 如果合约继承自抽象合约，并且没有通过重写来实现所有未实现的函数，那么它本身就是抽象的。 接口 接口类似于抽象合约，但是它们不能实现任何函数。还有进一步的限制： 无法继承其他合约或接口。 无法定义构造函数。 无法定义变量。 无法定义结构体 无法定义枚举。 将来可能会解除这里的某些限制。 接口基本上仅限于合约 ABI 可以表示的内容，并且 ABI 和接口之间的转换应该不会丢失任何信息。 接口由它们自己的关键字表示： pragma solidity ^0.4.11; interface Token { function transfer(address recipient, uint amount) public; } 就像继承其他合约一样，合约可以继承接口。 库 库与合约类似，它们只需要在特定的地址部署一次，并且它们的代码可以通过 EVM 的 DELEGATECALL(Homestead 之前使用 CALLCODE 关键字)特性进行重用。这意味着如果库函数被调用，它的代码在调用合约的上下文中执行，即 this 指向调用合约，特别是可以访问调用合约的存储。因为每个库都是一段独立的代码，所以它仅能访问调用合约明确提供的状态变量（否则它就无法通过名字访问这些变量）。因为我们假定库是无状态的，所以如果它们不修改状态（也就是说，如果它们是 view 或者 pure 函数），库函数仅可以通过直接调用来使用（即不使用 DELEGATECALL 关键字），特别是，除非能规避 Solidity 的类型系统，否则是不可能销毁任何库的。 库可以看作是使用他们的合约的隐式的基类合约。虽然它们在继承关系中不会显式可见，但调用库函数与调用显式的基类合约十分类似（如果 L 是库的话，可以使用 L.f() 调用库函数）。此外，就像库是基类合约一样，对所有使用库的合约，库的 internal 函数都是可见的。 当然，需要使用内部调用约定来调用内部函数，这意味着所有内部类型，内存类型都是通过引用而不是复制来传递。为了在 EVM 中实现这些，内部库函数的代码和从其中调用的所有函数都在编译阶段被拉取到调用合约中，然后使用一个 JUMP 调用来代替 DELEGATECALL。 下面的示例说明如何使用库（但也请务必看看 :ref:using for 有一个实现 set 更好的例子）。 pragma solidity ^0.4.16; library Set { // 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。 struct Data { mapping(uint => bool) flags; } // 注意第一个参数是“storage reference”类型，因此在调用中参数传递的只是它的存储地址而不是内容。 // 这是库函数的一个特性。如果该函数可以被视为对象的方法，则习惯称第一个参数为 `self` 。 function insert(Data storage self, uint value) public returns (bool) { if (self.flags[value]) return false; // 已经存在 self.flags[value] = true; return true; } function remove(Data storage self, uint value) public returns (bool) { if (!self.flags[value]) return false; // 不存在 self.flags[value] = false; return true; } function contains(Data storage self, uint value) public view returns (bool) { return self.flags[value]; } } contract C { Set.Data knownValues; function register(uint value) public { // 不需要库的特定实例就可以调用库函数， // 因为当前合约就是“instance”。 require(Set.insert(knownValues, value)); } // 如果我们愿意，我们也可以在这个合约中直接访问 knownValues.flags。 } 当然，你不必按照这种方式去使用库：它们也可以在不定义结构数据类型的情况下使用。函数也不需要任何存储引用参数，库可以出现在任何位置并且可以有多个存储引用参数。 调用 Set.contains，Set.insert 和 Set.remove 都被编译为外部调用（ DELEGATECALL ）。如果使用库，请注意实际执行的是外部函数调用。msg.sender， msg.value 和 this 在调用中将保留它们的值，（在 Homestead 之前，因为使用了 CALLCODE，改变了 msg.sender 和 msg.value)。 以下示例展示了如何在库中使用内存类型和内部函数来实现自定义类型，而无需支付外部函数调用的开销： pragma solidity ^0.4.16; library BigInt { struct bigint { uint[] limbs; } function fromUint(uint x) internal pure returns (bigint r) { r.limbs = new uint[](1); r.limbs[0] = x; } function add(bigint _a, bigint _b) internal pure returns (bigint r) { r.limbs = new uint[](max(_a.limbs.length, _b.limbs.length)); uint carry = 0; for (uint i = 0; i 0)) carry = 1; else carry = 0; } if (carry > 0) { // 太差了，我们需要增加一个 limb uint[] memory newLimbs = new uint[](r.limbs.length + 1); for (i = 0; i b ? a : b; } } contract C { using BigInt for BigInt.bigint; function f() public pure { var x = BigInt.fromUint(7); var y = BigInt.fromUint(uint(-1)); var z = x.add(y); } } 由于编译器无法知道库的部署位置，我们需要通过链接器将这些地址填入最终的字节码中 （请参阅 :ref:commandline-compiler 以了解如何使用命令行编译器来链接字节码）。 如果这些地址没有作为参数传递给编译器，编译后的十六进制代码将包含 __Set______ 形式的占位符（其中 Set 是库的名称）。可以手动填写地址来将那 40 个字符替换为库合约地址的十六进制编码。 与合约相比，库的限制： 没有状态变量 不能够继承或被继承 不能接收以太币 （将来有可能会解除这些限制） 库的调用保护 如果库的代码是通过 CALL 来执行，而不是 DELEGATECALL 或者 CALLCODE 那么执行的结果会被回退，除非是对 view 或者 pure 函数的调用。EVM 没有为合约提供检测是否使用 CALL 的直接方式，但是合约可以使用 ADDRESS 操作码找出正在运行的“位置”。生成的代码通过比较这个地址和构造时的地址来确定调用模式。 更具体地说，库的运行时代码总是从一个 push 指令开始，它在编译时是 20 字节的零。当部署代码运行时，这个常数 被内存中的当前地址替换，修改后的代码存储在合约中。在运行时，这导致部署时地址是第一个被 push 到堆栈上的常数， 对于任何 non-view 和 non-pure 函数，调度器代码都将对比当前地址与这个常数是否一致。 Using For 指令 using A for B; 可用于附加库函数（从库 A）到任何类型（B）。 这些函数将接收到调用它们的对象作为它们的第一个参数（像 Python 的 self 变量）。 using A for *; 的效果是，库 A 中的函数被附加在任意的类型上。在这两种情况下，所有函数都会被附加一个参数，即使它们的第一个参数类型与对象的类型不匹配。 函数调用和重载解析时才会做类型检查。using A for B; 指令仅在当前作用域有效，目前仅限于在当前合约中，后续可能提升到全局范围。通过引入一个模块，不需要再添加代码就可以使用包括库函数在内的数据类型。 让我们用这种方式将libraries中的 set 例子重写:: pragma solidity ^0.4.16; // 这是和之前一样的代码，只是没有注释。 library Set { struct Data { mapping(uint => bool) flags; } function insert(Data storage self, uint value) public returns (bool) { if (self.flags[value]) return false; // 已经存在 self.flags[value] = true; return true; } function remove(Data storage self, uint value) public returns (bool) { if (!self.flags[value]) return false; // 不存在 self.flags[value] = false; return true; } function contains(Data storage self, uint value) public view returns (bool) { return self.flags[value]; } } contract C { using Set for Set.Data; // 这里是关键的修改 Set.Data knownValues; function register(uint value) public { // Here, all variables of type Set.Data have // corresponding member functions. // The following function call is identical to // `Set.insert(knownValues, value)` // 这里， Set.Data 类型的所有变量都有与之相对应的成员函数。 // 下面的函数调用和 `Set.insert(knownValues, value)` 的效果完全相同。 require(knownValues.insert(value)); } } 也可以像这样扩展基本类型: pragma solidity ^0.4.16; library Search { function indexOf(uint[] storage self, uint value) public view returns (uint) { for (uint i = 0; i 注意，所有库调用都是实际的 EVM 函数调用。这意味着如果传递内存或值类型，都将产生一个副本，即使是 self 变量。]使用存储引用变量是唯一不会发生拷贝的情况。 Solidity汇编 Solidity 定义了一种汇编语言，在没有 Solidity 的情况下也可以使用。这种汇编语言也可以嵌入到 Solidity 源代码中当作“内联汇编”使用。 我们从如何使用内联汇编开始，介绍它如何区别于独立汇编语言，然后详细讲述这种汇编语言。 内联汇编 为了实现更细粒度的控制，尤其是为了通过编写库来增强语言，可以利用接近虚拟机的语言将内联汇编与 Solidity 语句结合在一起使用。 由于 EVM 是基于栈的虚拟机，因此通常很难准确地定位栈内插槽（存储位置）的地址，并为操作码提供正确的栈内位置来获取参数。 Solidity 的内联汇编试图通过提供以下特性来解决这个问题以及手工编写汇编代码时可能出现的问题： 函数风格操作码： mul(1, add(2, 3)) 而不是 push1 3 push1 2 add push1 1 mul 汇编局部变量： let x := add(2, 3) let y := mload(0x40) x := add(x, y) 可以访问外部变量： function f(uint x) public { assembly { x := sub(x, 1) } } 标签： let x := 10 repeat: x := sub(x, 1) jumpi(repeat, eq(x, 0)) 循环： for { let i := 0 } lt(i, x) { i := add(i, 1) } { y := mul(2, y) } if 语句： if slt(x, 0) { x := sub(0, x) } switch 语句： switch x case 0 { y := mul(x, 2) } default { y := 0 } 函数调用： function f(x) -> y { switch x case 0 { y := 1 } default { y := mul(x, f(sub(x, 1))) } } 现在我们详细讲解内联汇编语言。 内联汇编是一种在底层访问Simplechain虚拟机的语言。这抛弃了很多 Solidity 提供的重要安全特性。 TODO：写出在内联汇编中作用域规则的细微差别，以及在使用库合约的内部函数时产生的复杂性。此外，还要编写有关编译器定义的符号。 例子 下面例子展示了一个库合约的代码，它可以取得另一个合约的代码，并将其加载到一个 bytes 变量中。 这对于“常规 Solidity”来说是根本不可能的，汇编库合约则可以通过这种方式来增强语言特性。 pragma solidity ^0.4.0; library GetCode { function at(address _addr) public view returns (bytes o_code) { assembly { // 获取代码大小，这需要汇编语言 let size := extcodesize(_addr) // 分配输出字节数组 – 这也可以不用汇编语言来实现 // 通过使用 o_code = new bytes（size） o_code := mload(0x40) // 包括补位在内新的“memory end” mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f)))) // 把长度保存到内存中 mstore(o_code, size) // 实际获取代码，这需要汇编语言 extcodecopy(_addr, add(o_code, 0x20), 0, size) } } } 在优化器无法生成高效代码的情况下，内联汇编也可能更有好处。请注意，由于编译器无法对汇编语句进行相关的检查，所以编写汇编代码肯定更加困难； 因此只有在处理一些相对复杂的问题时才需要使用它，并且你需要明确知道自己要做什么。 pragma solidity ^0.4.16; library VectorSum { // 因为目前的优化器在访问数组时无法移除边界检查， // 所以这个函数的执行效率比较低。 function sumSolidity(uint[] _data) public view returns (uint o_sum) { for (uint i = 0; i 语法 和 Solidity 一样，Assembly 也会解析注释、文字和标识符，所以你可以使用通常的 // 和 /* */ 来进行注释。 内联汇编程序由 assembly { ... } 来标记，在这些大括号内可以使用以下内容（更多详细信息请参阅后面部分）。 字面常数，也就是 0x123、42 或 \"abc\" （不超过 32 个字符的字符串） 操作码（在“instruction style”内），比如 mload sload dup1 sstore，操作码列表请看后面 函数风格操作码，比如 add(1，mlod(0)) 标签，比如 name: 变量声明，比如 let x := 7、let x := add(y, 3) 或者 let x （初始值将被置为 empty(0)） 标识符（标签或者汇编局部变量以及用作内联汇编时的外部变量），比如 jump(name)、3 x add 赋值（在“instruction style”内），比如 3 =: x 函数风格赋值，比如 x := add(y，3) 一些控制局部变量作用域的语句块，比如 {let x := 3 { let y := add(x，1) }} 操作码 参考操作码： 如果一个操作码需要参数（总是来自堆栈顶部），它们会在括号中给出。请注意：参数顺序可以看作是在非函数风格中逆序（下面会解释）。标有 - 的操作码不会向栈中压入（push）数据，标有 * 的操作码有特殊操作，而所有其他操作码都只会将一个数据压入（push）栈中。 用 F、H、B 或 C 标记的操作码代表它们从 Frontier、Homestead、Byzantium 或 Constantinople 开始被引入。Constantinople 目前仍在计划中，所以标记为 C 的指令目前都会导致一个非法指令异常。在下表中，mem[a...b) 表示从位置 a 开始至（不包括）位置 b 的内存字节数，storage[p] 表示位置 p 处的存储内容。 pushi 和 jumpdest 这两个操作码不能直接用。 在语法表中，操作码是作为预定义标识符提供的。 Instruction symbol Bool Explanation stop - F 停止执行，与 return(0,0) 等价 add(x, y) F x + y sub(x, y) F x - y mul(x, y) F x * y div(x, y) F x / y sdiv(x, y) F x / y，以二进制补码作为符号 mod(x, y) F x % y smod(x, y) F x % y，以二进制补码作为符号 exp(x, y) F x 的 y 次幂 not(x) F ~x，对 x 按位取反 lt(x, y) F 如果 x gt(x, y) F 如果 x > y 为 1，否则为 0 slt(x, y) F 如果 x sgt(x, y) F 如果 x > y 为 1，否则为 0，以二进制补码作为符号 eq(x, y) F 如果 x == y 为 1，否则为 0 iszero(x) F 如果 x == 0 为 1，否则为 0 and(x, y) F x 和 y 的按位与 or(x, y) F x 和 y 的按位或 xor(x, y) F x 和 y 的按位异或 byte(n, x) F x 的第 n 个字节，这个索引是从 0 开始的 shl(x, y) C 将 y 逻辑左移 x 位 shr(x, y) C 将 y 逻��右移 x 位 sar(x, y) C 将 y 算术右移 x 位 addmod(x, y, m) F 任意精度的 (x + y) % m mulmod(x, y, m) F 任意精度的 (x * y) % m signextend(i, x) F 对 x 的最低位到第 (i * 8 + 7) 进行符号扩展 keccak256(p, n) F keccak(mem[p...(p + n))) jump(label) - F 跳转到标签 / 代码位置 jumpi(label, cond) - F 如果条件为非零，跳转到标签 pc F 当前代码位置 pop(x) - F 删除（弹出）栈顶的 x 个元素 dup1 ... dup16 F 将栈内第 i 个元素（从栈顶算起）复制到栈顶 swap1 ... swap16 * F 将栈顶元素和其下第 i 个元素互换 mload(p) F mem[p...(p + 32)) mstore(p, v) - F mem[p...(p + 32)) := v mstore8(p, v) - F mem[p] := v & 0xff （仅修改一个字节） sload(p) F storage[p] sstore(p, v) - F storage[p] := v msize F 内存大小，即最大可访问内存索引 gas F 执行可用的 gas address F 当前合约 / 执行上下文的地址 balance(a) F 地址 a 的余额，以 wei 为单位 caller F 调用发起者（不包括 delegatecall） callvalue F 随调用发送的 Wei 的数量 calldataload(p) F 位置 p 的调用数据（32 字节） calldatasize F 调用数据的字节数大小 calldatacopy(t, f, s) - F 从调用数据的位置 f 的拷贝 s 个字节到内存的位置 t codesize F 当前合约 / 执行上下文地址的代码大小 codecopy(t, f, s) - F 从代码的位置 f 开始拷贝 s 个字节到内存的位置 t extcodesize(a) F 地址 a 的代码大小 extcodecopy(a, t, f, s) - F 和 codecopy(t, f, s) 类似，但从地址 a 获取代码 returndatasize B 最后一个 returndata 的大小 returndatacopy(t, f, s) - B 从 returndata 的位置 f 拷贝 s 个字节到内存的位置 t create(v, p, s) F 用 mem[p...(p + s)) 中的代码创建一个新合约、发送 v wei 并返回新地址 create2(v, n, p, s) C 用 mem[p...(p + s)) 中的代码，在地址keccak256( . n . keccak256(mem[p...(p + s)))创建新合约、发送 v wei 并返回新地址上 call(g, a, v, in,insize, out, outsize) F 使用 mem[in...(in + insize)) 作为输入数据，提供 g gas 和 v wei 对地址 a 发起消息调用，输出结果数据保存在 mem[out...(out + outsize))，发生错误（比如 gas 不足）时返回 0，正确结束返回 1 callcode(g, a, v, in,insize, out, outsize) F 与 call 等价，但仅使用地址 a 中的代码 且保持当前合约的执行上下文 delegatecall(g, a, in,insize, out, outsize) F 与 callcode 等价且保留 caller 和 callvalue staticcall(g, a, in,insize, out, outsize) F 与 call(g, a, 0, in, insize, out, outsize) 等价,但不允许状态修改 return(p, s) - F 终止运行，返回 mem[p...(p + s)) 的数据 revert(p, s) - B 终止运行，撤销状态变化，返回 mem[p...(p + s)) 的数据 selfdestruct(a) - F 终止运行，销毁当前合约并且把资金发送到地址 a invalid - F 以无效指令终止运行 log0(p, s) - F 以 mem[p...(p + s)) 的数据产生不带 topic 的日志 log1(p, s, t1) - F 以 mem[p...(p + s)) 的数据和 topic t1 产生日志 log2(p, s, t1, t2) - F 以 mem[p...(p + s)) 的数据和 topic t1、t2 产生日志 log3(p, s, t1, t2, t3) - F 以 mem[p...(p + s)) 的数据和 topic t1、t2、t3 产生日志 log4(p, s, t1, t2, t3, t4) - F 以 mem[p...(p + s)) 的数据和 topic t1、t2、t3 和 t4 产生日志 origin F 交易发起者地址 gasprice F 交易所指定的 gas 价格 blockhash(b) F 区块号 b 的哈希 - 目前仅适用于不包括当前区块的最后 256 个区块 coinbase F 当前的挖矿收益者地址 timestamp F 从当前 epoch 开始的当前区块时间戳（以秒为单位） number F 当前区块号 difficulty F 当前区块难度 gaslimit F 当前区块的 gas 上限 字面常量 你可以直接键入十进制或十六进制符号来作为整型常量使用，这会自动生成相应的 PUSHi 指令。 下面的代码将计算 2 加 3（等于 5），然后计算其与字符串 “abc” 的按位与。字符串在存储时为左对齐，且长度不能超过 32 字节。 assembly { 2 3 add \"abc\" and } 函数风格 你可以像使用字节码那样在操作码之后键入操作码。例如，把 3 与内存位置 0x80 处的数据相加就是 3 0x80 mload add 0x80 mstore 由于通常很难看到某些操作码的实际参数是什么，所以 Solidity 内联汇编还提供了一种“函数风格”表示法，同样功能的代码可以写做 mstore(0x80, add(mload(0x80), 3)) 函数风格表达式内不能使用指令风格的写法，即 1 2 mstore(0x80, add) 是无效汇编语句， 它必须写成 mstore(0x80, add(2, 1)) 这种形式。对于不带参数的操作码，括号可以省略。 注意，在函数风格写法中参数的顺序与指令风格相反。如果使用函数风格写法，第一个参数将会位于栈顶。 访问外部变量和函数 通过简单使用它们名称就可以访问 Solidity 变量和其他标识符。对于内存变量，这会将地址而不是值压入栈中。 存储变量是不同的，因为存储变量的值可能不占用完整的存储槽，因此其“地址”由存储槽和槽内的字节偏移量组成。 为了获取变量 x 所使用的存储槽，你可以使用 x_slot，并用的 x_offset 获取其字节偏移量。 在赋值语句中（见下文），我们甚至可以使用 Solidity 局部变量来赋值。 对于内联汇编而言的外部函数也可以被访问：汇编会将它们的入口标签（带有虚拟函数解析）压入栈中。Solidity 中的调用语义为： 调用者压入 return label、arg1、arg2、...、argn 被调用方返回 ret1、ret2、...、retm 这个特性使用起来还是有点麻烦，因为在调用过程中堆栈偏移量发生了根本变化，因此对局部变量的引用将会出错。 pragma solidity ^0.4.11; contract C { uint b; function f(uint x) public returns (uint r) { assembly { r := mul(x, sload(b_slot)) // 因为偏移量为 0，所以可以忽略 } } } 如果你访问一个实际数据位数小于 256 位的数据类型（比如 uint64、address、bytes16 或 byte），不要对这种类型经过编码后未使用的数据位上的数值做任何假设。尤其是不要假设它们肯定为 0。安全起见，在某个上下文中使用这种数据之前，请一定先将其数据清空为 0，这非常重要：uint32 x = f(); assembly { x := and(x, 0xffffffff) /* now use x */ }要清空有符号类型，你可以使用 signextend 操作码。 标签 标签已经不推荐使用。请使用函数、循环、if 或 switch 语句。 EVM 汇编的另一个问题是 jump 和 jumpi 函数使用绝对地址，这些绝对地址很容易改变。 Solidity 内联汇编提供了标签，以便更容易地使用 jump。注意，标签具有底层特征，使用循环、if 和 switch 指令（参见下文）而不使用标签也能写出高效汇编代码。 以下代码用来计算斐波那契数列中的一个元素。 { let n := calldataload(4) let a := 1 let b := a loop: jumpi(loopend, eq(n, 0)) a add swap1 n := sub(n, 1) jump(loop) loopend: mstore(0, a) return(0, 0x20) } 请注意：只有汇编程序知道当前栈高度时，才能自动访问堆栈变量。如果 jump 源和目标的栈高度不同，访问将失败。 虽然我们可以这么使用 jump，但在这种情况下，你不应该去访问任何栈里的变量（即使是汇编变量）。 此外，栈高度分析器还可以通过操作码（而不是根据控制流）检查代码操作码，因此在下面的情况下，汇编程序对标签 two 处的堆栈高度会产生错误的印象： { let x := 8 jump(two) one: // 这里的栈高度是 2（因为我们压入了 x 和 7）， // 但因为汇编程序是按顺序读取代码的， // 它会认为栈高度是 1。 // 在这里访问栈变量 x 会导致错误。 x := 9 jump(three) two: 7 // 把某个数据压入栈中 jump(one) three: } 汇编局部变量声明 你可以使用 let 关键字来声明只在内联汇编中可见的变量，实际上只在当前的 {...} 块中可见。 下面发生的事情应该是：let 指令将创建一个为变量保留的新数据槽，并在到达块末尾时自动删除。 你需要为变量提供一个初始值，它可以只是 0，但它也可以是一个复杂的函数风格表达式。 pragma solidity ^0.4.16; contract C { function f(uint x) public view returns (uint b) { assembly { let v := add(x, 1) mstore(0x80, v) { let y := add(sload(v), 1) b := y } // y 会在这里被“清除” b := add(b, v) } // v 会在这里被“清除” } } 赋值 可以给汇编局部变量和函数局部变量赋值。请注意：当给指向内存或存储的变量赋值时，你只是更改指针而不是数据。 有两种赋值方式：函数风格和指令风格。对于函数风格赋值（变量 := 值），你需要在函数风格表达式中提供一个值，它恰好可以产生一个栈里的值； 对于指令风格赋值（=: 变量），则仅从栈顶部获取数据。对于这两种方式，冒号均指向变量名称。赋值则是通过用新值替换栈中的变量值来实现的。 { let v := 0 // 作为变量声明的函数风格赋值 let g := add(v, 2) sload(10) =: v // 指令风格的赋值，将 sload(10) 的结果赋给 v } 指令风格的赋值已经不推荐。 If if 语句可以用于有条件地执行代码，且没有“else”部分；如果需要多种选择，你可以考虑使用“switch”（见下文）。 { if eq(value, 0) { revert(0, 0) } } 代码主体的花括号是必需的。 Switch 作为“if/else”的非常初级的版本，你可以使用 switch 语句。它计算表达式的值并与几个常量进行比较。选出与匹配常数对应的分支。 与某些编程语言容易出错的情况不同，控制流不会从一种情形继续执行到下一种情形。我们可以设定一个 fallback 或称为 default 的默认情况。 { let x := 0 switch calldataload(4) case 0 { x := calldataload(0x24) } default { x := calldataload(0x44) } sstore(0, div(x, 2)) } Case 列表里面不需要大括号，但 case 主体需要。 循环 汇编语言支持一个简单的 for-style 循环。For-style 循环有一个头，它包含初始化部分、条件和迭代后处理部分。 条件必须是函数风格表达式，而另外两个部分都是语句块。如果起始部分声明了某个变量，这些变量的作用域将扩展到循环体中（包括条件和迭代后处理部分）。 下面例子是计算某个内存区域中的数值总和。 { let x := 0 for { let i := 0 } lt(i, 0x100) { i := add(i, 0x20) } { x := add(x, mload(i)) } } For 循环也可以写成像 while 循环一样：只需将初始化部分和迭代后处理两部分留空。 { let x := 0 let i := 0 for { } lt(i, 0x100) { } { // while(i 函数 汇编语言允许定义底层函数。底层函数需要从栈中取得它们的参数（和返回 PC），并将结果放入栈中。调用函数的方式与执行函数风格操作码相同。函数可以在任何地方定义，并且在声明它们的语句块中可见。函数内部不能访问在函数之外定义的局部变量。这里没有严格的 return 语句。如果调用会返回多个值的函数，则必须使用 a，b：= f(x) 或 let a，b：= f(x) 的方式把它们赋值到一个元组。 下面例子通过平方和乘法实现了幂运算函数。 { function power(base, exponent) -> result { switch exponent case 0 { result := 1 } case 1 { result := base } default { result := power(mul(base, base), div(exponent, 2)) switch mod(exponent, 2) case 1 { result := mul(base, result) } } } } 注意事项 内联汇编语言可能具有相当高级的外观，但实际上它是非常低级的编程语言。函数调用、循环、if 语句和 switch 语句通过简单的重写规则进行转换， 然后，汇编程序为你做的唯一事情就是重新组织函数风格操作码、管理 jump 标签、计算访问变量的栈高度，还有在到达语句块末尾时删除局部汇编变量的栈数据。 特别是对于最后两种情况，汇编程序仅会按照代码的顺序计算栈的高度，而不一定遵循控制流程；了解这一点非常重要。此外，swap 等操作只会交换栈内的数据，而不是变量位置。 Solidity 惯例 与 EVM 汇编语言相比，Solidity 能够识别小于 256 位的类型，例如 uint24。为了提高效率，大多数算术运算只将它们视为 256 位数字，仅在必要时才清除未使用的数据位，即在将它们写入内存或执行比较之前才会这么做。这意味着，如果从内联汇编中访问这样的变量，你必须先手工清除那些未使用的数据位。 Solidity 以一种非常简单的方式管理内存：在 0x40 的位置有一个“空闲内存指针”。如果你打算分配内存，只需从此处开始使用内存，然后相应地更新指针即可。内存的开头 64 字节可以用来作为临时分配的“暂存空间”。“空闲内存指针”之后的 32 字节位置（即从 0x60 开始的位置）将永远为 0，可以用来初始化空的动态内存数组。 在 Solidity 中，内存数组的元素总是占用 32 个字节的倍数（是的，甚至对于 byte[] 都是这样，只有 bytes 和 string 不是这样）。多维内存数组就是指向内存数组的指针。动态数组的长度存储在数组的第一个槽中，其后才是数组元素。 静态内存数组没有长度字段，但很快就会增加，这是为了可以更好地进行静态数组和动态数组之间的转换，所以请不要依赖这点。 独立汇编 以上内联汇编描述的汇编语言也可以单独使用，实际上，计划是将其用作 Solidity 编译器的中间语言。在这种意义下，它试图实现以下几个目标： 1、即使代码是由 Solidity 的编译器生成的，用它编写的程序应该也是可读的。 2、从汇编到字节码的翻译应该尽可能少地包含“意外”。 3、控制流应该易于检测，以帮助进行形式化验证和优化。 为了实现第一个和最后一个目标，汇编提供了高级结构：如 for 循环、if 语句、switch 语句和函数调用。 应该可以编写不使用明确的 SWAP、DUP、JUMP 和 JUMPI 语句的汇编程序，因为前两个混淆了数据流，而最后两个混淆了控制流。 此外，形式为 mul(add(x, y), 7) 的函数风格语句优于如 7 y x add mul 的指令风格语句，因为在第一种形式中更容易查看哪个操作数用于哪个操作码。 第二个目标是通过采用一种非常规则的方式来将高级高级指令结构便以为字节码。 汇编程序执行的唯一非局部操作是用户自定义标识符（函数、变量、...）的名称查找，它遵循非常简单和固定的作用域规则并从栈中清除局部变量。 作用域：在其中声明的标识符（标签、变量、函数、汇编）仅在声明的语句块中可见（包括当前语句块中的嵌套语句块）。 即使它们在作用范围内，越过函数边界访问局部变量也是非法的。阴影化是禁止的。在声明之前不能访问局部变量，但标签、函数和汇编是可以的。 汇编是特殊的语句块，例如用于返回运行时代码或创建合约等。在子汇编外部的汇编语句块中声明的标示符在子汇编中全都不可见。 如果控制流经过块尾部，则会插入与在当前语句块中声明的局部变量数量相匹配的 pop 指令。无论何时引用局部变量，代码生成器都需要知道在当前栈的相对位置， 因此，需要跟踪当前所谓的栈高度。由于所有在语句块内声明的局部变量都会在语句块结束时被清楚，所以语句块前后的栈高度应该相同。如果情况并非如此，则会发出警告。 使用 switch、for 和函数应该可以编写复杂的代码，而无需手工调用 jump 或 jumpi。这将允许改进的形式化验证和优化更简单地分析控制流程。 此外，如果允许手动跳转，计算栈高度将会更加复杂。栈中所有局部变量的位置都需要明确知晓，否则在语句块结束时就无法自动获得局部变量的引用从而正确地清除它们。 例子： 我们将参考一个从 Solidity 到汇编指令的实例。考虑以下 Solidity 程序的运行时字节码:: pragma solidity ^0.4.16; contract C { function f(uint x) public pure returns (uint y) { y = 1; for (uint i = 0; i 将会生成如下汇编指令:: { mstore(0x40, 0x60) // 保存“空闲内存指针” // 函数选择器 switch div(calldataload(0), exp(2, 226)) case 0xb3de648b { let r := f(calldataload(4)) let ret := $allocate(0x20) mstore(ret, r) return(ret, 0x20) } default { revert(0, 0) } // 内存分配器 function $allocate(size) -> pos { pos := mload(0x40) mstore(0x40, add(pos, size)) } // 合约函数 function f(x) -> y { y := 1 for { let i := 0 } lt(i, x) { i := add(i, 1) } { y := mul(2, y) } } } 汇编语法 解析器任务如下： 将字节流转换为符号流，丢弃 C ++ 风格的注释（对源代码引用存在特殊注释，我们这里不解释它）。 根据下面的语法，将符号流转换为 AST。 注册语句块中定义的标识符（注释到 AST 节点），并注明变量从哪个地方开始可以访问。 汇编词法分析器遵循由 Solidity 自己定义的规则。 空格用于分隔所有符号，它由空格字符、制表符和换行符组成。注释格式是常规的 JavaScript/C++ 风格，并被解释为空格。 Grammar:: AssemblyBlock = '{' AssemblyItem* '}' AssemblyItem = Identifier | AssemblyBlock | AssemblyExpression | AssemblyLocalDefinition | AssemblyAssignment | AssemblyStackAssignment | LabelDefinition | AssemblyIf | AssemblySwitch | AssemblyFunctionDefinition | AssemblyFor | 'break' | 'continue' | SubAssembly AssemblyExpression = AssemblyCall | Identifier | AssemblyLiteral AssemblyLiteral = NumberLiteral | StringLiteral | HexLiteral Identifier = [a-zA-Z_$] [a-zA-Z_0-9]* AssemblyCall = Identifier '(' ( AssemblyExpression ( ',' AssemblyExpression )* )? ')' AssemblyLocalDefinition = 'let' IdentifierOrList ( ':=' AssemblyExpression )? AssemblyAssignment = IdentifierOrList ':=' AssemblyExpression IdentifierOrList = Identifier | '(' IdentifierList ')' IdentifierList = Identifier ( ',' Identifier)* AssemblyStackAssignment = '=:' Identifier LabelDefinition = Identifier ':' AssemblyIf = 'if' AssemblyExpression AssemblyBlock AssemblySwitch = 'switch' AssemblyExpression AssemblyCase* ( 'default' AssemblyBlock )? AssemblyCase = 'case' AssemblyExpression AssemblyBlock AssemblyFunctionDefinition = 'function' Identifier '(' IdentifierList? ')' ( '->' '(' IdentifierList ')' )? AssemblyBlock AssemblyFor = 'for' ( AssemblyBlock | AssemblyExpression ) AssemblyExpression ( AssemblyBlock | AssemblyExpression ) AssemblyBlock SubAssembly = 'assembly' Identifier AssemblyBlock NumberLiteral = HexNumber | DecimalNumber HexLiteral = 'hex' ('\"' ([0-9a-fA-F]{2})* '\"' | '\\'' ([0-9a-fA-F]{2})* '\\'') StringLiteral = '\"' ([^\"\\r\\n\\\\] | '\\\\' .)* '\"' HexNumber = '0x' [0-9a-fA-F]+ DecimalNumber = [0-9]+ "},"20_contractPattern.html":{"url":"20_contractPattern.html","title":"合约模版","keywords":"","body":"一些金典的合约模版可以帮助开发者快速学习Solidity,并快速上手开发。基于Simplechain做出优秀的Dapp应用。 投票 以下的合约相当复杂，但展示了很多Solidity的功能。它实现了一个投票合约。 当然，电子投票的主要问题是如何将投票权分配给正确的人员以及如何防止被操纵。 我们不会在这里解决所有的问题，但至少我们会展示如何进行委托投票，同时，计票又是 自动和完全透明的 。 我们的想法是为每个（投票）表决创建一份合约，为每个选项提供简称。然后作为合约的创造者——即主席，将给予每个独立的地址以投票权。地址后面的人可以选择自己投票，或者委托给他们信任的人来投票。在投票时间结束时，winningProposal() 将返回获得最多投票的提案。 pragma solidity ^0.4.22; /// @title 委托投票 contract Ballot { // 这里声明了一个新的复合类型用于稍后的变量 // 它用来表示一个选民 struct Voter { uint weight; // 计票的权重 bool voted; // 若为真，代表该人已投票 address delegate; // 被委托人 uint vote; // 投票提案的索引 } // 提案的类型 struct Proposal { bytes32 name; // 简称（最长32个字节） uint voteCount; // 得票数 } address public chairperson; // 这声明了一个状态变量，为每个可能的地址存储一个 `Voter`。 mapping(address => Voter) public voters; // 一个 `Proposal` 结构类型的动态数组 Proposal[] public proposals; /// 为 `proposalNames` 中的每个提案，创建一个新的（投票）表决 constructor(bytes32[] proposalNames) public { chairperson = msg.sender; voters[chairperson].weight = 1; //对于提供的每个提案名称， //创建一个新的 Proposal 对象并把它添加到数组的末尾。 for (uint i = 0; i winningVoteCount) { winningVoteCount = proposals[p].voteCount; winningProposal_ = p; } } } // 调用 winningProposal() 函数以获取提案数组中获胜者的索引，并以此返回获胜者的名称 function winnerName() public view returns (bytes32 winnerName_) { winnerName_ = proposals[winningProposal()].name; } } 可能的优化 当前，为了把投票权分配给所有参与者，需要执行很多交易。你有没有更好的主意？ 秘密竞价（盲拍） 在本节中，我们将展示如何轻松地在Simplechain上创建一个秘密竞价的合约。 我们将从公开拍卖开始，每个人都可以看到出价，然后将此合约扩展到盲拍合约， 在竞标期结束之前无法看到实际出价。 简单的公开拍卖 以下简单的拍卖合约的总体思路是每个人都可以在投标期内发送他们的出价。 出价已经包含了资金/以太币，来将投标人与他们的投标绑定。 如果最高出价提高了（被其他出价者的出价超过），之前出价最高的出价者可以拿回她的钱。在投标期结束后，受益人需要手动调用合约来接收他的钱 - 合约不能自己激活接收。 pragma solidity ^0.4.22; contract SimpleAuction { // 拍卖的参数。 address public beneficiary; // 时间是unix的绝对时间戳（自1970-01-01以来的秒数） // 或以秒为单位的时间段。 uint public auctionEnd; // 拍卖的当前状态 address public highestBidder; uint public highestBid; //可以取回的之前的出价 mapping(address => uint) pendingReturns; // 拍卖结束后设为 true，将禁止所有的变更 bool ended; // 变更触发的事件 event HighestBidIncreased(address bidder, uint amount); event AuctionEnded(address winner, uint amount); // 以下是所谓的 natspec 注释，可以通过三个斜杠来识别。 // 当用户被要求确认交易时将显示。 /// 以受益者地址 `_beneficiary` 的名义， /// 创建一个简单的拍卖，拍卖时间为 `_biddingTime` 秒。 constructor( uint _biddingTime, address _beneficiary ) public { beneficiary = _beneficiary; auctionEnd = now + _biddingTime; } /// 对拍卖进行出价，具体的出价随交易一起发送。 /// 如果没有在拍卖中胜出，则返还出价。 function bid() public payable { // 参数不是必要的。因为所有的信息已经包含在了交易中。 // 对于能接收以太币的函数，关键字 payable 是必须的。 // 如果拍卖已结束，撤销函数的调用。 require( now highestBid, \"There already is a higher bid.\" ); if (highestBid != 0) { // 返还出价时，简单地直接调用 highestBidder.send(highestBid) 函数， // 是有安全风险的，因为它有可能执行一个非信任合约。 // 更为安全的做法是让接收方自己提取金钱。 pendingReturns[highestBidder] += highestBid; } highestBidder = msg.sender; highestBid = msg.value; emit HighestBidIncreased(msg.sender, msg.value); } /// 取回出价（当该出价已被超越） function withdraw() public returns (bool) { uint amount = pendingReturns[msg.sender]; if (amount > 0) { // 这里很重要，首先要设零值。 // 因为，作为接收调用的一部分， // 接收者可以在 `send` 返回之前，重新调用该函数。 pendingReturns[msg.sender] = 0; if (!msg.sender.send(amount)) { // 这里不需抛出异常，只需重置未付款 pendingReturns[msg.sender] = amount; return false; } } return true; } /// 结束拍卖，并把最高的出价发送给受益人 function auctionEnd() public { // 对于可与其他合约交互的函数（意味着它会调用其他函数或发送以太币）， // 一个好的指导方针是将其结构分为三个阶段： // 1. 检查条件 // 2. 执行动作 (可能会改变条件) // 3. 与其他合约交互 // 如果这些阶段相混合，其他的合约可能会回调当前合约并修改状态， // 或者导致某些效果（比如支付以太币）多次生效。 // 如果合约内调用的函数包含了与外部合约的交互， // 则它也会被认为是与外部合约有交互的。 // 1. 条件 require(now >= auctionEnd, \"Auction not yet ended.\"); require(!ended, \"auctionEnd has already been called.\"); // 2. 生效 ended = true; emit AuctionEnded(highestBidder, highestBid); // 3. 交互 beneficiary.transfer(highestBid); } } 秘密竞拍(盲拍） 之前的公开拍卖接下来将被扩展为一个秘密竞拍。 秘密竞拍的好处是在投标结束前不会有时间压力。 在一个透明的计算平台上进行秘密竞拍听起来像是自相矛盾，但密码学可以实现它。 在 投标期间 ，投标人实际上并没有发送她的出价，而只是发送一个哈希版本的出价。 由于目前几乎不可能找到两个（足够长的）值，其哈希值是相等的，因此投标人可通过该方式提交报价。 在投标结束后，投标人必须公开他们的出价：他们不加密的发送他们的出价，合约检查出价的哈希值是否与投标期间提供的相同。 另一个挑战是如何使拍卖同时做到 绑定和秘密 : 唯一能阻止投标者在她赢得拍卖后不付款的方式是，让她将钱连同出价一起发出。 但由于资金转移在Simplechain中不能被隐藏，因此任何人都可以看到转移的资金。 下面的合约通过接受任何大于最高出价的值来解决这个问题。 当然，因为这只能在披露阶段进行检查，有些出价可能是 无效 的， 并且，这是故意的(与高出价一起，它甚至提供了一个明确的标志来标识无效的出价): 投标人可以通过设置几个或高或低的无效出价来迷惑竞争对手。 pragma solidity >0.4.23 Bid[]) public bids; address public highestBidder; uint public highestBid; // 可以取回的之前的出价 mapping(address => uint) pendingReturns; event AuctionEnded(address winner, uint highestBid); /// 使用 modifier 可以更便捷的校验函数的入参。 /// `onlyBefore` 会被用于后面的 `bid` 函数： /// 新的函数体是由 modifier 本身的函数体，并用原函数体替换 `_;` 语句来组成的。 modifier onlyBefore(uint _time) { require(now _time); _; } constructor( uint _biddingTime, uint _revealTime, address _beneficiary ) public { beneficiary = _beneficiary; biddingEnd = now + _biddingTime; revealEnd = biddingEnd + _revealTime; } /// 可以通过 `_blindedBid` = keccak256(value, fake, secret) /// 设置一个秘密竞拍。 /// 只有在出价披露阶段被正确披露，已发送的以太币才会被退还。 /// 如果与出价一起发送的以太币至少为 “value” 且 “fake” 不为真，则出价有效。 /// 将 “fake” 设置为 true ，然后发送满足订金金额但又不与出价相同的金额是隐藏实际出价的方法。 /// 同一个地址可以放置多个出价。 function bid(bytes32 _blindedBid) public payable onlyBefore(biddingEnd) { bids[msg.sender].push(Bid({ blindedBid: _blindedBid, deposit: msg.value })); } /// 披露你的秘密竞拍出价。 /// 对于所有正确披露的无效出价以及除最高出价以外的所有出价，你都将获得退款。 function reveal( uint[] _values, bool[] _fake, bytes32[] _secret ) public onlyAfter(biddingEnd) onlyBefore(revealEnd) { uint length = bids[msg.sender].length; require(_values.length == length); require(_fake.length == length); require(_secret.length == length); uint refund; for (uint i = 0; i = value) { if (placeBid(msg.sender, value)) refund -= value; } // 使发送者不可能再次认领同一笔订金 bid.blindedBid = bytes32(0); } msg.sender.transfer(refund); } // 这是一个 \"internal\" 函数， 意味着它只能在本合约（或继承合约）内被调用 function placeBid(address bidder, uint value) internal returns (bool success) { if (value 0) { // 这里很重要，首先要设零值。 // 因为，作为接收调用的一部分， // 接收者可以在 `transfer` 返回之前重新调用该函数。（可查看上面关于‘条件 -> 影响 -> 交互’的标注） pendingReturns[msg.sender] = 0; msg.sender.transfer(amount); } } /// 结束拍卖，并把最高的出价发送给受益人 function auctionEnd() public onlyAfter(revealEnd) { require(!ended); emit AuctionEnded(highestBidder, highestBid); ended = true; beneficiary.transfer(highestBid); } } 安全的远程购买 pragma solidity ^0.4.22; contract Purchase { uint public value; address public seller; address public buyer; enum State { Created, Locked, Inactive } State public state; //确保 `msg.value` 是一个偶数。 //如果它是一个奇数，则它将被截断。 //通过乘法检查它不是奇数。 constructor() public payable { seller = msg.sender; value = msg.value / 2; require((2 * value) == msg.value, \"Value has to be even.\"); } modifier condition(bool _condition) { require(_condition); _; } modifier onlyBuyer() { require( msg.sender == buyer, \"Only buyer can call this.\" ); _; } modifier onlySeller() { require( msg.sender == seller, \"Only seller can call this.\" ); _; } modifier inState(State _state) { require( state == _state, \"Invalid state.\" ); _; } event Aborted(); event PurchaseConfirmed(); event ItemReceived(); ///中止购买并回收以太币。 ///只能在合约被锁定之前由卖家调用。 function abort() public onlySeller inState(State.Created) { emit Aborted(); state = State.Inactive; seller.transfer(address(this).balance); } /// 买家确认购买。 /// 交易必须包含 `2 * value` 个以太币。 /// 以太币会被锁定，直到 confirmReceived 被调用。 function confirmPurchase() public inState(State.Created) condition(msg.value == (2 * value)) payable { emit PurchaseConfirmed(); buyer = msg.sender; state = State.Locked; } /// 确认你（买家）已经收到商品。 /// 这会释放被锁定的以太币。 function confirmReceived() public onlyBuyer inState(State.Locked) { emit ItemReceived(); // 首先修改状态很重要，否则的话，由 `transfer` 所调用的合约可以回调进这里（再次接收以太币）。 state = State.Inactive; // 注意: 这实际上允许买方和卖方阻止退款 - 应该使用取回模式。 buyer.transfer(value); seller.transfer(address(this).balance); } } "},"21_buildTest.html":{"url":"21_buildTest.html","title":"搭建测试链","keywords":"","body":"1.创建创世块文件 新建文件 genesis.json，内容如下。 { \"config\": { \"chainId\": 100, \"homesteadBlock\": 0, \"eip155Block\": 0, \"eip158Block\": 0 }, \"alloc\" : {}, \"coinbase\" : \"0x0000000000000000000000000000000000000000\", \"difficulty\" : \"0x20000\", \"extraData\" : \"\", \"gasLimit\" : \"0x2fefd8\", \"nonce\" : \"0x0000000000000042\", \"mixhash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"parentHash\" : \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"timestamp\" : \"0x00\" } 其中chainId为此测试网络的ID，主网的ID为1，difficulty为挖矿难度，为方便测试网络的运行，难度设置较低。 2.启动节点一 1.创建节点一的存储目录 nodedata1 mkdir nodedata1 2.使用 genesis.json 初始化节点一的创世区块 sipe init --datadir nodedata1 genesis.json 3.启动节点，指定 networkid，节点通信时须保证指定的networkid相同 sipe --datadir nodedata1 --port 30312 --rpc --rpcaddr 127.0.0.1 --rpcport 8541 --networkid 10001 console 4. 在开启的控制台中查看节点信息，获取本节点enode > admin.nodeInfo { enode: \"enode://05a9c3bd1f6716a1806e677b8337d4e1eb4b9f57d8f94d11bcf4870fd8d5d943b9591 1a3c51f40714f33a307049d8c0c1a7019a71d099a27c6a939a85a809110@[::]:30312\", id: \"05a9c3bd1f6716a1806e677b8337d4e1eb4b9f57d8f94d11bcf4870fd8d5d943b95911a3c51f4 0714f33a307049d8c0c1a7019a71d099a27c6a939a85a809110\", ip: \"::\", listenAddr: \"[::]:30312\", name: \"Sipe/v1.0.2-stable-0cbf2a41/darwin-amd64/go1.12.1\", ports: { discovery: 30312, listener: 30312 }, protocols: { eth: { config: { chainId: 100, eip150Hash: \"0x0000000000000000000000000000000000000000000000000000000000000000\", eip155Block: 0, eip158Block: 0, homesteadBlock: 0 }, difficulty: 131072, genesis: \"0x5e1fc79cb4ffa4739177b5408045cd5d51c6cf766133f23f7cd72ee1f8d790e0\", head: \"0x5e1fc79cb4ffa4739177b5408045cd5d51c6cf766133f23f7cd72ee1f8d790e0\", network: 10001 }} } 3.启动节点二 1. 创建节点一的存储目录nodedata2 mkdir nodedata2 2. 使用 genesis.json初始化节点一的创世区块。 sipe init --datadir nodedata2 genesis.json 3. 启动节点，保证 networdid与节点一相同，注意配置bootnodes时将节点一获取的enode的[::]替换为节点一的IP地址，即127.0.0.1。 sipe --datadir nodedata2 --port 30313 --rpc --rpcaddr 127.0.0.1 --rpcport 8542 --networkid 10001 --bootnodes \"enode://05a9c3bd1f6716a1806e677b8337d4e1eb4b9f57d8f94d11bcf4870fd8d5d943b9591 1a3c51f40714f33a307049d8c0c1a7019a71d099a27c6a939a85a809110@127.0.0.1:30312\" console 4. 查看关联节点信息，返回结果不为空即确认节点二与节点一连接成功。 > admin.peers [{ caps: [\"eth/63\"], id: \"05a9c3bd1f6716a1806e677b8337d4e1eb4b9f57d8f94d11bcf4870fd8d5d943b95911a3c51f4 0714f33a307049d8c0c1a7019a71d099a27c6a939a85a809110\", name: \"Sipe/v1.0.2-stable-0cbf2a41/darwin-amd64/go1.12.1\", network: { inbound: false, localAddress: \"127.0.0.1:58388\", remoteAddress: \"127.0.0.1:30312\", static: false, trusted: false }, protocols: { eth: { difficulty: 131072, head: \"0x5e1fc79cb4ffa4739177b5408045cd5d51c6cf766133f23f7cd72ee1f8d790e0\", version: 63 } } }] 3.在测试网络中挖矿 1.在节点一创建账号，并将其设置为矿工地址 > personal.newAccount() Passphrase: Repeat passphrase:=\"0x7f53309f95559c52d08f18724c0b24aa758d1953\" > miner.setEtherbase('0x7f53309f95559c52d08f18724c0b24aa758d1953') true 2.在节点一启动挖矿 > miner.start() INFO [06-19|10:53:15.918] Updated mining threads threads=0 INFO [06-19|10:53:15.918] Transaction pool price threshold updated price=1000000000 INFO [06-19|10:53:15.918] Starting mining operation null > INFO [06-19|10:53:15.918] Commit new mining work number=1 txs=0 uncles=0 elapsed=207.516μs INFO [06-19|10:53:47.601] Successfully sealed new block number=1 hash=755f08...62e560 INFO [06-19|10:53:47.607] 🔨 mined potential block number=1 hash=755f08...62e560 3.在节点二确认同步区块 INFO [06-19|10:53:49.246] Block synchronisation started INFO [06-19|10:53:49.538] Imported new block headers count=2 elapsed=6.482ms number=2 hash=c7c0a9...79db3e ignored=0 INFO [06-19|10:53:49.539] Imported new chain segment blocks=2 txs=0 mgas=0.000 elapsed=766.945μs mgasps=0.000 number=2 hash=c7c0a9...79db3e cache=1.20kB INFO [06-19|10:53:49.556] Imported new state entries count=3 elapsed=90.308μs processed=3 pending=0 retry=0 duplicate=0 unexpected=0 INFO [06-19|10:53:49.601] Fast sync complete, auto disabling INFO [06-19|10:53:59.119] Imported new chain segment blocks=1 txs=0 mgas=0.000 elapsed=1.212ms mgasps=0.000 number=3 hash=6dd8b2...194509 cache=1.81kB 4.在测试网络中转账 1. 使用控制台创建另一个账户。 > personal.newAccount() Passphrase: Repeat passphrase: \"0xf9143e3b7de8ce91e463e30480f5afe84d3067ba\" 2. 转账前使用密码解锁转账人账户。 > personal.unlockAccount('0x7f53309f95559c52d08f18724c0b24aa758d1953') Unlock account 0x7f53309f95559c52d08f18724c0b24aa758d1953 Passphrase: true 3. 发送交易进行转账，其中from为转账人，这里是矿工地址，to为收款人，value是转账额度。 > eth.sendTransaction({from:\"0x7f53309f95559c52d08f18724c0b24aa758d1953\",to:\"0xf9143e 3b7de8ce91e463e30480f5afe84d3067ba\",value:web3.toWei(10,\"ether\")}) \"0x5a6fbb3161329ca2591b7ecbcaca8a15a94cac5d402fce929f24504c76b8b7bb\" 4. 确认到账。 > eth.getBalance('0xf9143e3b7de8ce91e463e30480f5afe84d3067ba') 10000000000000000000 "},"22_sipcApi.html":{"url":"22_sipcApi.html","title":"Sip API","keywords":"","body":"Sipc API方法列表： web3_clientVersion web3_sha3 net_version net_listening net_peerCount eth_protocolVersion eth_syncing eth_coinbase eth_mining eth_hashrate eth_gasPrice eth_accounts eth_blockNumber eth_getBalance eth_getStorageAt eth_getBlockTransactionCountByHash eth_getBlockTransactionCountByNumb eth_getUncleCountByBlockHash eth_getUncleCountByBlockNumber eth_getCode eth_sign eth_sendTransaction eth_sendRawTransaction eth_call eth_estimateGas eth_getBlockByHash eth_getBlockByNumber eth_getTransactionByNUmber eth_getUncleByBlockHashAndIndex eth_getUncleByBlockNumberAndIndex eth_newFilter eth_newBlockFilter eth_newPendingTransactionFilter eth_uninstallFilter eth_getFilterChanges eth_getFilterLogs eth_getLogs eth_getWork eth_submitWork eth_submitHashrate eth_blockNumber JSON-RPC Endpoint Default JSON-RPC endpoints: Client URL Go http://localhost:8545 默认区块参数 以下方法有一个额外的默认区块参数: eth_getBalance eth.getCode eth.getTransactionCount eth_getStorageAt eth_call 当请求作用于simplechain的状态时，最后一个默认的区块参数决定了区块的高度。 以下选项可用于默认区块参数: HEX String -整数区块数 String \"earliest\" 最早的/创世块 String \"latest\" - 最新挖出来的区块 String \"pending\" - 对于待处理状态/交易 web3_clientVersion 返回当前的客户端版本 参数 无 返回 string: 当前客户端版本 示例 // Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":68}' //Result { \"id\":67, \"jsonrpc\":\"2.0\", \"result\": \"Mist/v0.9.3/darwin/go1.4.1\" } web3_sha3 返回给定数据的keccak-256（不是标准化的sha3-256） 参数 string: 要计算 SHA3 哈希的数据必须是（hex string） 返回值 string: 指定字符串的 SHA3 结果 示例 // Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"web3_sha3\",\"params\":[\"0x68656c6c6f20776f726c64\"],\"id\":64}' //Result { \"id\":64, \"jsonrpc\": \"2.0\", \"result\": \"0x47173285a8d7341e5e972fc677286384f802f8ef42a5ec5f03bbfa254cb01fad\" } net_version 返回当前连接网络的ID 参数 无 返回值 String: 当前连接网络的ID,\"1\": Simplechain主网,\"3\": 测试网络; 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"net_version\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\":67, \"result\": \"3\" } net_listening 返回客户端是否处于监听网络连接状态，如果处于监听则返回true,否则返回false. 参数 无 返回值 bool: 客户端处于监听状态时返回 true，否则返回 false 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"net_listening\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\":\"2.0\", \"id\":67, \"result\":true } net_peerCount 返回当前连接到客户端的节点数。 参数 无 返回值 Quantity: 已经连接的节点数 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"net_peerCount\",\"params\":[],\"id\":74}' //Response { \"id\":74, \"jsonrpc\": \"2.0\", \"result\": \"0xf\" } eth_protocolVersion 返回当前simplechain的协议版本。 参数 无 返回 String 当前simplechain的协议版本. 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_protocolVersion\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\":\"2.0\", \"id\":67, \"result\":\"0x40\" } eth_syncing 返回包含有关同步状态的数据的对象 或者false 数参 无 返回值 Object|Boolean, 同步状态对象或 false。同步对象的结构如下: startingBlock: QUANTITY - 开始块 currentBlock: QUANTITY - 当前块，同eth_blockNumber highestBlock: QUANTITY - 预估最高块 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_syncing\",\"params\":[],\"id\":1}' //Response //在同步过程中 { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": { startingBlock: '0x384', currentBlock: '0x386', highestBlock: '0x454' } } //未同步则结果如下: { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": false } eth_coinbase 返回客户端矿工地址。 参数 无 返回值 Data: 20 bytes - 当前 coinbase 地址 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_coinbase\",\"params\":[],\"id\":64}' //Response { \"id\":64, \"jsonrpc\": \"2.0\", \"result\": \"0x407d73d8a49eeb85d32cf465507dd71d507100c1\" } eth_mining 如果客户端在挖矿则返回true, 否则返回false。 参数 无 返回值 boolean 当客户端在挖矿时返回 true，否则返回 false。 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_mining\",\"params\":[],\"id\":71}' //Response { \"id\":71, \"jsonrpc\": \"2.0\", \"result\": true } eth_hashrate 返回节点挖矿时每秒可算出的哈希率。 参数 无 返回 quantity: 每秒算出的哈希率 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_hashrate\",\"params\":[],\"id\":71}' //Response { \"jsonrpc\": \"2.0\", \"id\":71, \"result\": \"0x38a\" } eth_gasPrice 返回当前每一gas价格，单位:wei。 参数 无 返回值 quantity:整数，以 wei为单位的当前 gas 价格 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_gasPrice\",\"params\":[],\"id\":73}' //Response { \"jsonrpc\": \"2.0\", \"id\":73, \"result\": \"0x09184e72a000\" // 10000000000000 } eth_accounts 返回客户端持有的地址列表。 参数 无 返回 string[]:字符串数组，客户端持有的地址字符串列表。 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_accounts\",\"params\":[],\"id\":1}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": [\"0x407d73d8a49eeb85d32cf465507dd71d507100c1\"] } eth_blockNumber 返回最新块的块号（区块高度） 参数 无 返回 客户端所在的当前块号的整数 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":1}' //Response { \"jsonrpc\":\"2.0\", \"id\":1, \"result\":\"0x5a0d\" } eth_getBalance 返回指定地址账户的余额。 参数 data20 字节，要检查余额的地址 quantity|tag - 整数块编号，或者字符串\"latest\", \"earliest\" 或 \"pending\" 返回值 quantity:当前余额，单位:wei 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBalance\",\"params\":[\"0x51e766a7f073955c8061073bbba60b10bf12d48a\", \"latest\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0x0234c8a3397aab58\" // 158972490234375000 } eth_getTransactionCount 返回指定地址发生的交易数量。 参数 DATA: 20 字节，地址 QUANTITY|TAG 整数块编号，或字符串\"latest\"、\"earliest\"或\"pending\" 返回 QUANTITY 从指定地址发出的交易数量，整数。 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionCount\",\"params\":[\"0xd79b8287a827e1387e6f0ff6d300fc663e10f592\",\"latest\"],\"id\":1}' //Response { \"jsonrpc\":\"2.0\", \"id\":1, \"result\":\"0x1303\" } // 1 eth_getBlockTransactionCountByHash 使用哈希返回指定块内的交易数量。 参数 DATA: 32 字节，块哈希 返回 QUANTITY 指定块内的交易数量，整数 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockTransactionCountByHash\",\"params\":[\"0x268343647d0fcf63628446a29959feccf57136dac58fd1c17e0df3babafce3b6\"],\"id\":1}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x2\" } eth_getBlockTransactionCountByNumber 返回与给定块号匹配的块中的交易数。 参数 QUANTITY|TAG: 整数块编号，或字符串\"earliest\"、\"latest\"或\"pending\" 返回 QUANTITY: 指定块内的交易数量 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockTransactionCountByNumber\",\"params\":[\"0x11c7\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0xa\" } eth_getUncleCountByBlockHash 从与给定块哈希匹配的块中返回叔块数。 参数 QUANTITY DATA, 32 字节，块哈希 返回值 QUANTITY: DATA，指定块的叔数，整数 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getUncleCountByBlockHash\",\"params\":[\"0x58052e3424b8c03643a3cd3595cad1a6104ab195cc78108318699f2bfa429d8f\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0x1\" } eth_getUncleCountByBlockNumber 从与给定块号匹配的块中返回块中的叔块数。 参数 QUANTITY|TAG -区块数, 或者字符串 \"latest\", \"earliest\" or \"pending\" 返回 QUANTITY: DATA，指定块的叔数，整数 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getUncleCountByBlockNumber\",\"params\":[\"0x1bb\"],\"id\":1}' //Response { \"jsonrpc\":\"2.0\", \"id\":1, \"result\":\"0x1\" } eth_getCode 返回指定地址的代码。 参数 string: DATA ,20 字节，地址 string QUANTITY|TAG, 整数块编号，或字符串\"latest\"、\"earliest\" 或\"pending\" 返回 string DATA: 指定地址处的代码 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getCode\",\"params\":[\"0xe558562c906c69787b8fabb6d0efb3f1163a20e4\",\"latest\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0x\" } eth_sign 通过向消息添加前缀，可以将计算出的签名识别为特定于simplechain的签名。这可以防止恶意DAPP在签署任意数据（如事务）并使用签名来冒充受害者时的误用。 注意: 必须先解锁要签名的地址. 参数 DATA 20字节，地址 DATA 要签名的消息 返回值 DATA 数据的签名 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sign\",\"params\":[\"0xb014763d71459855510255647be8cf39b0e82acb\",\"0xdeadbeaf\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0xa3f20717a250c2b0b729b7e5becbff67fdaef7e0699da4de7ca5895b02a170a12d887fd3b17bfdce3481f10bea41f45ba9f709d39ce8325427b57afcfc994cee1b\" } eth_sendTransaction 创建一个新的消息调用交易，如果数据字段中包含代码，则创建一个合约。 参数 from: DATA, 20 字节 - 发送交易的源地址 to: DATA, 20 字节 - 交易的目标地址，当创建新合约时可选 gas: QUANTITY - 交易执行可用 gas 量，可选整数，默认值 90000，未用 gas 将返还。 gasPrice: QUANTITY - gas 价格，可选，默认值:待定(To-Be-Determined) value: QUANTITY - 交易发送的金额，可选整数 data: DATA - 合约的编译代码或被调用方法的签名及编码参数 nonce: QUANTITY - nonce，可选。可以使用同一个 nonce 来重写挂起的交易 返回 DATA:32 字节 - 交易哈希，如果交易还未生效则返回 0 值哈希。当创建合约时，在交易生效后，使用 eth_getTransactionReceipt 调用获取合约地址。 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendTransaction\", \"params\":[{ \"from\": \"0xb014763d71459855510255647be8cf39b0e82acb\", \"to\": \"0xac49f5e5b9161e0cb42372c90183d8428b060ff1\", \"gas\": \"0x76c0\", \"gasPrice\": \"0x9184e72a000\", \"value\": \"0x9184e72a\", \"data\": \"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675\" }],\"id\":1}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\" } eth_sendRawTransaction 为已签名的交易创建新的消息调用交易或合约创建。 参数 DATA: 签名的交易数据 返回值 DATA: 32字节，交易哈希，如果交易未生效则返回全0哈希。当创建合约时，在交易生效后，使用eth_getTransactionReceipt获取合约地址。 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_sendRawTransaction\",\"params\":[\"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675\"],\"id\":1}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\" } eth_call 立刻执行一个新的消息调用，无需在区块链上创建交易。 参数 from: DATA, 20 Bytes - 发送交易的原地址，可选 to: DATA, 20 Bytes - 交易目标地址 gas: QUANTITY - 交易可用 gas 量，可选。eth_call 不消耗 gas，但是某些 执行环节需要这个参数 gasPrice: QUANTITY - gas 价格，可选 value: QUANTITY - 交易发送的 sipc 数量，可选 data: DATA - 方法签名和编码参数的哈希，可选 string: QUANTITY|TAG - 整数块编号，或字符串\"latest\"、\"earliest\"或\"pending\" 返回值 result: DATA- 所执行合约的返回值 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_call\",\"params\":[\"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675\" ],\"id\":1}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x\" } eth_estimateGas 执行并估算一个交易需要的gas用量。该次交易不会写入区块链。注意，由于多种原因，例如EVM的机制及节点的性能，估算的数值可能比实际用量大的多。 参数 from: DATA, 20 Bytes - 发送交易的原地址，可选 to: DATA, 20 Bytes - 交易目标地址 gas: QUANTITY - 交易可用 gas 量，可选。eth_call 不消耗 gas，但是某些 执行环节需要这个参数 gasPrice: QUANTITY - gas 价格，可选 value: QUANTITY - 交易发送的 sipc 数量，可选 data: DATA - 方法签名和编码参数的哈希，可选 string: QUANTITY|TAG - 整数块编号，或字符串\"latest\"、\"earliest\"或\"pending\" 返回值 result: QUANTITY - gas用量估算值 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_estimateGas\",\"params\":[{ \"from\": \"0xb014763d71459855510255647be8cf39b0e82acb\", \"to\": \"0xac49f5e5b9161e0cb42372c90183d8428b060ff1\", \"gas\": \"0x76c0\", \"gasPrice\": \"0x9184e72a000\", \"value\": \"0x9184e72a\", \"data\": \"0xd46e8dd67c5d32be8d46e8dd67c5d32be8058bb8eb970870f072445675058bb8eb970870f072445675\" }],\"id\":1}' //response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x5cec\" // 21000 } eth_getBlockByHash 根据给定的哈希返回有关块的信息。 参数 DATA, 32个字节 - 区块的哈希 Boolean - 如果为true，则返回完整的交易对象，否则仅返回交易哈希 返回值 number: QUANTITY - 块编号，挂起块为 null hash: DATA, 32 Bytes - 块哈希，挂起块为 null parentHash: DATA, 32 Bytes - 父块的哈希 nonce: DATA, 8 Bytes - 生成的 pow 哈希，挂起块为 null sha3Uncles: DATA, 32 Bytes - 块中叔数据的 SHA3 哈希 logsBloom: DATA, 256 Bytes - 块日志的 bloom 过滤器，挂起块为null ansactionsRoot: DATA, 32 Bytes - 块中的交易树根节点 stateRoot: DATA, 32 Bytes - 块最终状态树的根节点 receiptsRoot: DATA, 32 Bytes - 块交易收据树的根节点 miner: DATA, 20 Bytes - 挖矿奖励的接收账户 difficulty: QUANTITY - 块难度，整数 totalDifficulty: QUANTITY - 截止到本块的链上总难度 extraData: DATA - 块额外数据 size: QUANTITY - 本块字节数 gasLimit: QUANTITY - 本块允许的最大 gas 用量 gasUsed: QUANTITY - 本块中所有交易使用的总 gas 用量 timestamp: QUANTITY - 块时间戳 transactions: Array - 交易对象数组，或 32 字节长的交易哈希数组 uncles: Array - 叔哈希数组 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByHash\",\"params\":[\"0xbe024aeab6138b6adffd616314c707e2af8d165f871c8068d1a4a9c38a59c69b\", true],\"id\":1}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": { \"number\": \"0x1b4\", // 436 \"hash\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\", \"parentHash\": \"0x9646252be9520f6e71339a8df9c55e4d7619deeb018d2a3f2d21fc165dde5eb5\", \"nonce\": \"0xe04d296d2460cfb8472af2c5fd05b5a214109c25688d3704aed5484f9a7792f2\", \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\", \"logsBloom\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\", \"transactionsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"stateRoot\": \"0xd5855eb08b3387c0af375e9cdb6acfc05eb8f519e419b874b6ff2ffda7ed1dff\", \"miner\": \"0x4e65fda2159562a496f9f3522f89122a3088497a\", \"difficulty\": \"0x027f07\", // 163591 \"totalDifficulty\": \"0x027f07\", // 163591 \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000 000000000\", \"size\": \"0x027f07\", // 163591 \"gasLimit\": \"0x9f759\", // 653145 \"gasUsed\": \"0x9f759\", // 653145 \"timestamp\": \"0x54e34e8e\" // 1424182926 \"transactions\": [{...},{ ... }] \"uncles\": [\"0x1606e5...\", \"0xd5145a9...\"] } } eth_getBlockByNumber 根据区块数（区块高度）返回有关块的信息。 参数 QUANTITY|TAG 区块数, 或者字符串 \"earliest\", \"latest\" or \"pending\" Boolean - 如果为true，则返回完整的交易对象；如果为false，则仅返回交易的哈希值。 返回 number: QUANTITY - 块编号，挂起块为 null hash: DATA, 32 Bytes - 块哈希，挂起块为 null parentHash: DATA, 32 Bytes - 父块的哈希 nonce: DATA, 8 Bytes - 生成的 pow 哈希，挂起块为 null sha3Uncles: DATA, 32 Bytes - 块中叔数据的 SHA3 哈希 logsBloom: DATA, 256 Bytes - 块日志的 bloom 过滤器，挂起块为null ansactionsRoot: DATA, 32 Bytes - 块中的交易树根节点 stateRoot: DATA, 32 Bytes - 块最终状态树的根节点 receiptsRoot: DATA, 32 Bytes - 块交易收据树的根节点 miner: DATA, 20 Bytes - 挖矿奖励的接收账户 difficulty: QUANTITY - 块难度，整数 totalDifficulty: QUANTITY - 截止到本块的链上总难度 extraData: DATA - 块额外数据 size: QUANTITY - 本块字节数 gasLimit: QUANTITY - 本块允许的最大 gas 用量 gasUsed: QUANTITY - 本块中所有交易使用的总 gas 用量 timestamp: QUANTITY - 块时间戳 transactions: Array - 交易对象数组，或 32 字节长的交易哈希数组 uncles: Array - 叔哈希数组 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getBlockByNumber\",\"params\":[\"0x6bcd\", true],\"id\":1}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": { \"number\": \"0x1b4\", // 436 \"hash\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\", \"parentHash\": \"0x9646252be9520f6e71339a8df9c55e4d7619deeb018d2a3f2d21fc165dde5eb5\", \"nonce\": \"0xe04d296d2460cfb8472af2c5fd05b5a214109c25688d3704aed5484f9a7792f2\", \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\", \"logsBloom\": \"0xe670ec64341771606e55d6b4ca35a1a6b75ee3d5145a99d05921026d1527331\", \"transactionsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"stateRoot\": \"0xd5855eb08b3387c0af375e9cdb6acfc05eb8f519e419b874b6ff2ffda7ed1dff\", \"miner\": \"0x4e65fda2159562a496f9f3522f89122a3088497a\", \"difficulty\": \"0x027f07\", // 163591 \"totalDifficulty\": \"0x027f07\", // 163591 \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000 000000000\", \"size\": \"0x027f07\", // 163591 \"gasLimit\": \"0x9f759\", // 653145 \"gasUsed\": \"0x9f759\", // 653145 \"timestamp\": \"0x54e34e8e\" // 1424182926 \"transactions\": [{...},{ ... }] \"uncles\": [\"0x1606e5...\", \"0xd5145a9...\"] } } eth_getTransactionByHash 返回有关交易哈希请求的交易的信息 参数 DATA, 32个字节 - 交易的哈希 返回 blockHash: DATA, 32 Bytes -此交易所在的区块的哈希。当它还处于待定状态时为null。 blockNumber: QUANTITY - 此交易所在的区块的高度. 当它还处于待定状态时为null。 from: DATA, 20 个字节 -交易发起者的地址。 gas: QUANTITY -交易发起者提供的gas数。 gasPrice: QUANTITY - 发送者提供的gas的价格，以wei为单位。 hash: DATA, 32个字节 -交易的哈希 input: DATA - 随交易一起发送的数据。 nonce: QUANTITY - 发送方在此之前进行的交易数。 to: DATA, 20个字节 -接受者的地址，当交易是一个合约创建的时候，它的值为null。 transactionIndex: QUANTITY - 交易在块中的索引位置的整数。当它为待定状态时为null。 value: QUANTITY - 转账的数额，以wei为单位。 v: QUANTITY - ECDSA recovery id r: DATA, 32 Bytes - ECDSA signature r s: DATA, 32 Bytes - ECDSA signature s 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionByHash\",\"params\":[\"0x8e63b031ac4f3a9c38642d69a86f73368fee539d9351e4eb312b5cfb6cd4f3e6\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"blockHash\": \"0xbe024aeab6138b6adffd616314c707e2af8d165f871c8068d1a4a9c38a59c69b\", \"blockNumber\": \"0x6bcd\", \"from\": \"0xd79b8287a827e1387e6f0ff6d300fc663e10f592\", \"gas\": \"0x5c20\", \"gasPrice\": \"0x218711a00\", \"hash\": \"0x8e63b031ac4f3a9c38642d69a86f73368fee539d9351e4eb312b5cfb6cd4f3e6\", \"input\": \"0xd3182ceafbaf2da3503237a4f60b74e30756e78f310d2b97761c38db06753c99353535363530\", \"nonce\": \"0xecc\", \"to\": \"0xd79b8287a827e1387e6f0ff6d300fc663e10f592\", \"transactionIndex\": \"0x3\", \"value\": \"0xde0b6b3a7640000\", \"v\": \"0x26\", \"r\": \"0x5076aebd122ba56eaa0d40a44ce950ac792851e97e1a4afcf660afbc8d1e625a\", \"s\": \"0x7a7af2b80ccbdce36363b338b96a3f6c96aafa7057ea586a4dae0e30da607747\" } } eth_getTransactionByBlockHashAndIndex 返回指定块内具有指定索引序号的交易。 参数 DATA, 32 字节 - 块哈希 QUANTITY, 交易在块内的索引序号 返回 hash: DATA, 32 字节 - 交易哈希 nonce: QUANTITY - 本次交易之前发送方已经生成的交易数量 blockHash: DATA, 32 字节 - 交易所在块的哈希，对于挂起块，该值为 null blockNumber: QUANTITY - 交易所在块的编号，对于挂起块，该值为 null transactionIndex: QUANTITY - 交易在块中的索引位置，挂起块该值为 null from: DATA, 20 字节 - 交易发送方地址 to: DATA, 20 字节 - 交易接收方地址，对于合约创建交易，该值为 null value: QUANTITY - 发送的 sipc 数量，单位:wei gasPrice: QUANTITY - 发送方提供的 gas 价格，单位:wei gas: QUANTITY - 发送方提供的 gas 可用量 input: DATA - 随交易发送的数据 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionByBlockHashAndIndex\",\"params\":[\"0xbe024aeab6138b6adffd616314c707e2af8d165f871c8068d1a4a9c38a59c69b\", \"0x3\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"blockHash\": \"0xbe024aeab6138b6adffd616314c707e2af8d165f871c8068d1a4a9c38a59c69b\", \"blockNumber\": \"0x6bcd\", \"from\": \"0xd79b8287a827e1387e6f0ff6d300fc663e10f592\", \"gas\": \"0x5c20\", \"gasPrice\": \"0x218711a00\", \"hash\": \"0x8e63b031ac4f3a9c38642d69a86f73368fee539d9351e4eb312b5cfb6cd4f3e6\", \"input\": \"0xd3182ceafbaf2da3503237a4f60b74e30756e78f310d2b97761c38db06753c99353535363530\", \"nonce\": \"0xecc\", \"to\": \"0xd79b8287a827e1387e6f0ff6d300fc663e10f592\", \"transactionIndex\": \"0x3\", \"value\": \"0xde0b6b3a7640000\", \"v\": \"0x26\", \"r\": \"0x5076aebd122ba56eaa0d40a44ce950ac792851e97e1a4afcf660afbc8d1e625a\", \"s\": \"0x7a7af2b80ccbdce36363b338b96a3f6c96aafa7057ea586a4dae0e30da607747\" } } eth_getTransactionByBlockNumberAndIndex 按区块数（区块高度）和交易索引位置返回有关交易的信息。 参数 QUANTITY|TAG - 整数块编号，或字符串\"earliest\"、\"latest\" 或\"pending\" QUANTITY - 交易索引序号 返回值 hash: DATA, 32 字节 - 交易哈希 nonce: QUANTITY - 本次交易之前发送方已经生成的交易数量 blockHash: DATA, 32 字节 - 交易所在块的哈希，对于挂起块，该值为 null blockNumber: QUANTITY - 交易所在块的编号，对于挂起块，该值为 null transactionIndex: QUANTITY - 交易在块中的索引位置，挂起块该值为 null from: DATA, 20 字节 - 交易发送方地址 to: DATA, 20 字节 - 交易接收方地址，对于合约创建交易，该值为 null value: QUANTITY - 发送的 sipc 数量，单位:wei gasPrice: QUANTITY - 发送方提供的 gas 价格，单位:wei gas: QUANTITY - 发送方提供的 gas 可用量 input: DATA - 随交易发送的数据 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionByBlockNumberAndIn dex\",\"params\":[\"0x29c\", \"0x0\"],\"id\":1}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": { \"hash\":\"0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1d105 5b\", \"nonce\":\"0x\", \"blockHash\": \"0xbeab0aa2411b7ab17f30a99d3cb9c6ef2fc5426d6ad6fd9e2a26a6aed1d1055b\", \"blockNumber\": \"0x15df\", // 5599 \"transactionIndex\": \"0x1\", // 1 \"from\":\"0x407d73d8a49eeb85d32cf465507dd71d507100c1\", \"to\":\"0x85h43d8a49eeb85d32cf465507dd71d507100c1\", \"value\":\"0x7f110\", // 520464 \"gas\": \"0x7f110\", // 520464 \"gasPrice\":\"0x09184e72a000\", \"input\":\"0x603880600c6000396000f300603880600c6000396000f3603880600c6000396000f360\", } } eth_getTransactionReceipt 根据交易哈希返回一个交易的收据,注意:收据不可用于待处理的交易。 参数 DATA, 32字节，交易哈希 返回 transactionHash: DATA, 32 字节 - 交易哈希 transactionIndex: QUANTITY - 交易在块内的索引序号 blockHash: DATA, 32 字节 - 交易所在块的哈希 blockNumber: QUANTITY - 交易所在块的编号 from: DATA, 20 字节 - 交易发送方地址 to: DATA, 20 字节 - 交易接收方地址，对于合约创建交易该值为 null cumulativeGasUsed: QUANTITY - 交易所在块消耗的 gas 总量 gasUsed: QUANTITY - 该次交易消耗的 gas 用量 contractAddress: DATA, 20 字节 - 对于合约创建交易，该值为新创建的合 约地址，否则为 null logs: Array - 本次交易生成的日志对象数组 logsBloom: DATA, 256 字节 - bloom 过滤器，轻客户端用来快速提取相关日志 root: DATA 32 字节，后交易状态根(pre Byzantium) status: QUANTITY ，1 (成功) 或 0 (失败) 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getTransactionReceipt\",\"params\":[\"0x b903239f8543d04b5dc1ba6579132b143087c68db1b2168786408fcbce568238\"],\"id\":1}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": { transactionHash: '0xb903239f8543d04b5dc1ba6579132b143087c68db1b216878640 8fcbce568238', transactionIndex: '0x1', // 1 blockNumber: '0xb', // 11 blockHash: '0xc6ef2fc5426d6ad6fd9e2a26abeab0aa2411b7ab17f30a99d3cb96aed1 d1055b', cumulativeGasUsed: '0x33bc', // 13244 gasUsed: '0x4dc', // 1244 contractAddress: '0xb60e8dd61c5d32be8058bb8eb970870f07233155', // or null, if none was created logs: [{ // logs as returned by getFilterLogs, etc. }, ...], logsBloom: \"0x00...0\", // 256 byte bloom filter status: '0x1' } } eth_getUncleByBlockHashAndIndex 根据哈希和叔块索引位置返回有关块的叔块的信息。 参数 DATA, 32字节,块哈希 QUANTITY, 叔索引位置 返回值 number: QUANTITY - 块编号，挂起块为 null hash: DATA, 32 Bytes - 块哈希，挂起块为 null parentHash: DATA, 32 Bytes - 父块的哈希 nonce: DATA, 8 Bytes - 生成的 pow 哈希，挂起块为 null sha3Uncles: DATA, 32 Bytes - 块中叔数据的 SHA3 哈希 logsBloom: DATA, 256 Bytes - 块日志的 bloom 过滤器，挂起块为null ansactionsRoot: DATA, 32 Bytes - 块中的交易树根节点 stateRoot: DATA, 32 Bytes - 块最终状态树的根节点 receiptsRoot: DATA, 32 Bytes - 块交易收据树的根节点 miner: DATA, 20 Bytes - 挖矿奖励的接收账户 difficulty: QUANTITY - 块难度，整数 totalDifficulty: QUANTITY - 截止到本块的链上总难度 extraData: DATA - 块额外数据 size: QUANTITY - 本块字节数 gasLimit: QUANTITY - 本块允许的最大 gas 用量 gasUsed: QUANTITY - 本块中所有交易使用的总 gas 用量 timestamp: QUANTITY - 块时间戳 transactions: Array - 交易对象数组，或 32 字节长的交易哈希数组 uncles: Array - 叔哈希数组 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getUncleByBlockHashAndIndex\",\"params\":[\"0x58052e3424b8c03643a3cd3595cad1a6104ab195cc78108318699f2bfa429d8f\",'0x0'],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"difficulty\": \"0x267c3\", \"extraData\": \"0xd983010000847369706588676f312e31312e318664617277696e\", \"gasLimit\": \"0x12804\", \"gasUsed\": \"0x0\", \"hash\": \"0x7937f1ac55c87d4fb649c17d0c9411e8837d32e10bf5e8723611120b50154c16\", \"logsBloom\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"miner\": \"0x41da014ee4c2f583ba222344c095a631e739f2f1\", \"mixHash\": \"0xa50630bdd5800368de83fa719373ccceaaf69e56f07d32db11b2069c2af9a611\", \"nonce\": \"0x4f0713dd54bb9301\", \"number\": \"0x1b5\", \"parentHash\": \"0xf2ad2fbdd67936df73c447eabb49965d2bced51df9c1a80545b001600547d81a\", \"receiptsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\", \"size\": \"0x21b\", \"stateRoot\": \"0xbfb096cd9832414ad738ff806dcfb1e48d9836c00d130b723a3bb808098b1099\", \"timestamp\": \"0x5c2e3b64\", \"totalDifficulty\": null, \"transactionsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"uncles\": [] } } 注意: 叔块不包含单独的交易。 eth_getUncleByBlockNumberAndIndex 根据区块数（区块高度）和叔块索引位置返回有关叔块的信息. 参数 QUANTITY|TAG - 整数块编号，或字符串\"earliest\"、\"latest\" 或\"pending\" QUANTITY – 叔块在块内的索引序号 返回 number: QUANTITY - 块编号，挂起块为 null hash: DATA, 32 Bytes - 块哈希，挂起块为 null parentHash: DATA, 32 Bytes - 父块的哈希 nonce: DATA, 8 Bytes - 生成的 pow 哈希，挂起块为 null sha3Uncles: DATA, 32 Bytes - 块中叔数据的 SHA3 哈希 logsBloom: DATA, 256 Bytes - 块日志的 bloom 过滤器，挂起块为null ansactionsRoot: DATA, 32 Bytes - 块中的交易树根节点 stateRoot: DATA, 32 Bytes - 块最终状态树的根节点 receiptsRoot: DATA, 32 Bytes - 块交易收据树的根节点 miner: DATA, 20 Bytes - 挖矿奖励的接收账户 difficulty: QUANTITY - 块难度，整数 totalDifficulty: QUANTITY - 截止到本块的链上总难度 extraData: DATA - 块额外数据 size: QUANTITY - 本块字节数 gasLimit: QUANTITY - 本块允许的最大 gas 用量 gasUsed: QUANTITY - 本块中所有交易使用的总 gas 用量 timestamp: QUANTITY - 块时间戳 transactions: Array - 交易对象数组，或 32 字节长的交易哈希数组 uncles: Array - 叔哈希数组 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getUncleByBlockNumberAndIndex\",\"params\":[\"0x1bb\",\"0x0\"],\"id\":1}' //Response { \"jsonrpc\": \"2.0\", \"id\": 1, \"result\": { \"difficulty\": \"0x267c3\", \"extraData\": \"0xd983010000847369706588676f312e31312e318664617277696e\", \"gasLimit\": \"0x12804\", \"gasUsed\": \"0x0\", \"hash\": \"0x7937f1ac55c87d4fb649c17d0c9411e8837d32e10bf5e8723611120b50154c16\", \"logsBloom\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"miner\": \"0x41da014ee4c2f583ba222344c095a631e739f2f1\", \"mixHash\": \"0xa50630bdd5800368de83fa719373ccceaaf69e56f07d32db11b2069c2af9a611\", \"nonce\": \"0x4f0713dd54bb9301\", \"number\": \"0x1b5\", \"parentHash\": \"0xf2ad2fbdd67936df73c447eabb49965d2bced51df9c1a80545b001600547d81a\", \"receiptsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"sha3Uncles\": \"0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347\", \"size\": \"0x21b\", \"stateRoot\": \"0xbfb096cd9832414ad738ff806dcfb1e48d9836c00d130b723a3bb808098b1099\", \"timestamp\": \"0x5c2e3b64\", \"totalDifficulty\": null, \"transactionsRoot\": \"0x56e81f171bcc55a6ff8345e692c0f86e5b48e01b996cadc001622fb5e363b421\", \"uncles\": [] } } 注意: 叔块不包含单独的交易 ------ eth_newFilter 根据过滤器器选项创建过滤器对象，以便在状态更改（日志）时通知。要检查状态是否已更改，请调用eth getfilterchanges。 关于指定主题过滤器的说明: 关于特定主题过滤器的说明:主题是顺序相关的。如果一个交易的日志有主题[A, ，那么将被以下的主题过滤器匹配: []任何主题 [A]先匹配A主题 [null,B]先匹配其他主题，再匹配B主题 [A,B]先匹配A主题，再匹配B主题，最后匹配其他主题 [[A,B][A,B]\"先匹配A主题或B主题，再匹配A主题或B主题,最后匹配其他主题\"] 参数 fromBlock: QUANTITY|TAG - 可选，默认值:\"latest\"。整数块编号，或字符串\"latesr\"表示最后挖出的块，\"pending\"或\"earliest\"用于未挖出的交易。 toBlock: QUANTITY|TAG - 可选，默认值:\"latest\"。整数块编号，或字符串\"latesr\"表示最后挖出的块，\"pending\"或\"earliest\"用于未挖出的交易。 address: DATA|Array, 20 字节 - 可选，合约地址或生成日志的一组地址 topics: Array of DATA, - 可选，32 字节主题数组，每个主题可以是数组或使用 or 选项连接 返回 QUANTITY，过滤器编号 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_newBlockFilter\",\"params\":[],\"id\":73}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0x1\" // 1 } eth_newBlockFilter 在节点中创建一个过滤器，以便当新块生成时进行通知。要检查状态是否变化，请调用eth_getFilterChanges. 参数 无 返回 QUANTITY 过滤器编号 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_newBlockFilter\",\"params\":[],\"id\":73}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": \"0x1\" // 1 } eth_newPendingTransactionFilter 在节点中创建一个过滤器，以便当产生挂起交易时进行通知。要检查状态是否发生变化，请调用eth_getFilterChanges。 参数 无 返回值 QUANTITY, 过滤器编号 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_newPendingTransactionFilter\",\"para ms\":[],\"id\":73}' //Response { \"id\":1, \"jsonrpc\": \"2.0\", \"result\": \"0x1\" // 1 } eth_uninstallFilter 卸载具有指定编号的过滤器。当不在需要监听时，总是需要执行该调用。另外，过滤器如果在一定时间内未接收到eth_getFilterChanges调用会自动超时。 参数 QUANTITY, 过滤器编号 返回 Boolean, 如果成功卸载则返回true,否则返回false 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_uninstallFilter\",\"params\":[\"0xb\"],\"id\":7 3}' //Response { \"jsonrpc\": \"2.0\", \"id\":1, \"result\": true } eth_getFilterChanges 轮询指定的过滤器，并返回自上次轮询之后新生成的日志数组。 参数 QUANTITY, 过滤器编号 返回值 Array, 日志对象数组，如果没有新生成的日志，则返回空数组。 使用eth_newBlockerFilter创建的过滤器将返回块哈希(32 字节)，例如[\")x3454645634534\"]。 使用eth_newPendingTransactionFilter创建的过滤器将返回交易哈希 (32 字节)，例如[\"0x6345343454645...\"]。 使用eth_newFilter创建的过滤器，日志对象具有如下数参数： removed: TAG - 如果日志已被删除则返回 true，如果是有效日志则返回false logIndex: QUANTITY - 日志在块内的索引序号。对于挂起日志，该值为 null transactionIndex: QUANTITY - 创建日志的交易索引序号，对于挂起日志，该值为 null transactionHash: DATA, 32 字节 - 创建该日志的交易的哈希。对于挂起日志，该值为 null blockHash: DATA, 32 字节 - 该日志所在块的哈希。对于挂起日志，该值为null blockNumber: QUANTITY - 该日志所在块的编号。对于挂起日志，该值为 null address: DATA, 20 字节 - 该日志的源地址 data: DATA - 包含该日志的一个或多个 32 字节无索引参数 topics: Array of DATA -0~4 个 32 字节索引日志参数的数据。在 solidity 中，第一个主题是事件签名，例如 Deposit(address,bytes32,uint256)，除非你声明的是匿名事件 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getFilterChanges\",\"params\":[\"0x16\"],\" id\":73}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": [{ \"logIndex\": \"0x1\", // 1 \"blockNumber\":\"0x1b4\", // 436 \"blockHash\": \"0x8216c5785ac562ff41e2dcfdf5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"transactionHash\": \"0xdf829c5a142f1fccd7d8216c5785ac562ff41e2dcfdf5785ac562f f41e2dcf\", \"transactionIndex\": \"0x0\", // 0 \"address\": \"0x16c5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"data\":\"0x0000000000000000000000000000000000000000000000000000000000000 000\", \"topics\": [\"0x59ebeb90bc63057b6515673c3ecf9438e5058bca0f92585014eced636878c9a5\"] },{... }] } eth_getFilterLogs 返回与给定ID匹配的过滤器的所有日志的数组. 参数 QUANTITY, 过滤器编号 返回 removed: TAG - 如果日志已被删除则返回true，如果是有效日志则返回false logIndex: QUANTITY - 日志在块内的索引序号。对于挂起日志，该值为null transactionIndex: QUANTITY - 创建日志的交易索引序号，对于挂起日志，该值为null transactionHash: DATA, 32 字节 - 创建该日志的交易的哈希。对于挂起日志，该值为null blockHash: DATA, 32 字节 - 该日志所在块的哈希。对于挂起日志，该值为null blockNumber: QUANTITY - 该日志所在块的编号。对于挂起日志，该值为null address: DATA, 20 字节 - 该日志的源地址 data: DATA - 包含该日志的一个或多个32字节无索引参数 topics: Array of DATA -0~4 个 32字节索引日志参数的数据。在 solidity 中，第一个主题是事件签名，例如 Deposit(address,bytes32,uint256)，除非你声明的是匿名事件 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getFilterLogs\",\"params\":[\"0x16\"],\"id\": 74}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": [{ \"logIndex\": \"0x1\", // 1 \"blockNumber\":\"0x1b4\", // 436 \"blockHash\": \"0x8216c5785ac562ff41e2dcfdf5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"transactionHash\": \"0xdf829c5a142f1fccd7d8216c5785ac562ff41e2dcfdf5785ac562f f41e2dcf\", \"transactionIndex\": \"0x0\", // 0 \"address\": \"0x16c5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"data\":\"0x0000000000000000000000000000000000000000000000000000000000000 000\", \"topics\": [\"0x59ebeb90bc63057b6515673c3ecf9438e5058bca0f92585014eced636878c9a5\"] },{... }] } eth_getLogs 返回与给定过滤器对象匹配的所有日志的数组。 参数 fromBlock: QUANTITY|TAG - 可选，默认值:\"latest\"。整数块编号，或字符串\"latesr\"表示最后挖出的块，\"pending\"或\"earliest\"用于未挖出的交易。 toBlock: QUANTITY|TAG - 可选，默认值:\"latest\"。整数块编号，或字符串\"latesr\"表示最后挖出的块，\"pending\"或\"earliest\"用于未挖出的交易。 address: DATA|Array, 20 字节 - 可选，合约地址或生成日志的一组地址 topics: Array of DATA, - 可选，32字节主题数组，每个主题可以是数组或使用or选项连接 返回值 Array, 日志对象数组，如果没有新生成的日志，则返回空数组。 使用eth_newBlockerFilter创建的过滤器将返回块哈希(32 字节)，例如[\")x3454645634534\"]。 使用eth_newPendingTransactionFilter创建的过滤器将返回交易哈希 (32 字节)，例如[\"0x6345343454645...\"]。 使用eth_newFilter创建的过滤器，日志对象具有如下数参数： removed: TAG - 如果日志已被删除则返回 true，如果是有效日志则返回false logIndex: QUANTITY - 日志在块内的索引序号。对于挂起日志，该值为 null transactionIndex: QUANTITY - 创建日志的交易索引序号，对于挂起日志，该值为 null transactionHash: DATA, 32 字节 - 创建该日志的交易的哈希。对于挂起日志，该值为 null blockHash: DATA, 32 字节 - 该日志所在块的哈希。对于挂起日志，该值为null blockNumber: QUANTITY - 该日志所在块的编号。对于挂起日志，该值为 null address: DATA, 20 字节 - 该日志的源地址 data: DATA - 包含该日志的一个或多个 32 字节无索引参数 topics: Array of DATA -0~4 个 32 字节索引日志参数的数据。在 solidity 中，第一个主题是事件签名，例如 Deposit(address,bytes32,uint256)，除非你声明的是匿名事件 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getLogs\",\"params\":[{\"topics\":[\"0x0000 00000000000000000000a94f5374fce5edbc8e2a8697c15331677e6ebf0b\"]}],\"id\":74}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": [{ \"logIndex\": \"0x1\", // 1 \"blockNumber\":\"0x1b4\", // 436 \"blockHash\": \"0x8216c5785ac562ff41e2dcfdf5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"transactionHash\": \"0xdf829c5a142f1fccd7d8216c5785ac562ff41e2dcfdf5785ac562f f41e2dcf\", \"transactionIndex\": \"0x0\", // 0 \"address\": \"0x16c5785ac562ff41e2dcfdf829c5a142f1fccd7d\", \"data\":\"0x0000000000000000000000000000000000000000000000000000000000000 000\", \"topics\": [\"0x59ebeb90bc63057b6515673c3ecf9438e5058bca0f92585014eced636878c9a5\"] },{... }] } eth_getWork 返回当前块的哈希、seedhash和要满足的边界条件 参数 无 返回值 DATA, 32 字节 - 当前块头的 pow-hash DATA, 32 字节 - 用于 DAG 的种子哈希 DATA, 32 字节 - 边界条件，目标， 2^256 / difficulty //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getWork\",\"params\":[],\"id\":73}' //Response { \"id\":1, \"jsonrpc\":\"2.0\", \"result\": [ \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef\", \"0x5EED00000000000000000000000000005EED0000000000000000000000000000\", \"0xd1ff1c01710000000000000000000000d1ff1c01710000000000000000000000\" ] } eth_submitWork 用于提交POW解决方案。 参数 DATA, 8 字节 - nonce，64 位 DATA, 32 字节 - 头部的 pow 哈希，256 位  DATA, 32 字节 - 混合摘要，256 位 返回 Boolean, 如果提交的方案有效则返回true，否则返回false //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\", \"method\":\"eth_submitWork\", \"params\":[\"0x000000 0000000001\", \"0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890a bcdef\", \"0xD1GE5700000000000000000000000000D1GE5700000000000000000000000 000\"],\"id\":73}' //Response { \"id\":73, \"jsonrpc\":\"2.0\", \"result\": true } eth_submitHashrate 用于提交挖矿的哈希速率。 参数 hashRate - 哈希速率，采用 16 进制字符串表示，32 字节 ID, String - 随机 16 进制字符串，32 字节，用于标识客户端的编号 返回 Boolean, 如果提交成功则返回 true，否则返回 false 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\", \"method\":\"eth_submitHashrate\", \"params\":[\"0x000 0000000000000000000000000000000000000000000000000000000500000\", \"0x59daa2 6581d0acd1fce254fb7e85952f4c09d0915afd33d3886cd914bc7d283c\"],\"id\":73}' //Response { \"id\":73, \"jsonrpc\":\"2.0\", \"result\": true } eth_blockNumber 返回最新块的编号。 参数 无 返回值 QUANTITY, 节点当前块编号 示例 //Request curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"eth_blockNumber\",\"params\":[],\"id\":83}' //Response { \"id\":83, \"jsonrpc\": \"2.0\", \"result\": \"0x4b7\" // 1207 } "},"23_crossChainApi.html":{"url":"23_crossChainApi.html","title":"跨链API","keywords":"","body":"跨链API接口列表 eth_ctxQuery eth_ctxOwner eth_ctxOwnerByPage eth_ctxContent eth_ctxContent eth_getRemoteCtx eth_ctxStats eth_poolStats JSON-RPC Endpoint Default JSON-RPC endpoints: Client URL Go http://localhost:8545 eth_ctxQuery 通过TxHash跨链交易单。 参数 DATA, 32个字节 - 交易的哈希 返回 value: QUANTITY, 交易数额。 ctxId: DATA, 32个字节- 该交易ID。 txHash: DATA 32个字节- 交易的哈希。 from: DATA, 20个字节 -交易发送者的地址 blockHash: DATA, 32个字节- 该交易所在的区块的哈希。 destinationId: QUANTITY - 跨链目的链ID。 destinationValue: QUANTITY, 目的链币种数额 input: DATA, 交易的input数据。 v: Array - 交易多签V值数组。 r: Array - 交易多签R值数组。 s: Array - 交易多签S值数组。 示例 //request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxQuery\",\"params\":[\"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\"],\"id\":67}' //response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } } eth_ctxOwner 通过跨链发起人查询交易列表。 参数 ADDRESS, 20个字节 - 交易的发起地址 返回 local: 本地跨链列表 time: 跨链交易所在区块的时间戳 value: QUANTITY, 交易数额。 ctxId: DATA, 32个字节- 该交易ID。 txHash: DATA 32个字节- 交易的哈希。 from: DATA, 20个字节 -交易发送者的地址 blockHash: DATA, 32个字节- 该交易所在的区块的哈希。 destinationId: QUANTITY - 跨链目的链ID。 destinationValue: QUANTITY, 目的链币种数额 input: DATA, 交易的input数据。 v: Array - 交易多签V值数组。 r: Array - 交易多签R值数组。 s: Array - 交易多签S值数组。 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxOwner\",\"params\":[\"0x3db32cdacb1ba339786403b50568f4915892938a\"],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"local\": { \"221\": [ { \"value\": \"0xde0b6b3a7640000\", \"status\": 0, \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"time\": \"0x5ebb9cd2\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } ] } } } eth_ctxOwnerByPage 通过跨链发起人查询交易列表。 参数 ADDRESS, 20个字节 - 交易的发起地址 PAGESIZE, 每页的交易数量 STARTPAGE, 从第几页开始(初始页为第0页) 返回 data:OBJECT - 本地跨链列表: time: 跨链交易所在区块的时间戳 value: QUANTITY, 交易数额。 ctxId: DATA, 32个字节- 该交易ID。 txHash: DATA 32个字节- 交易的哈希。 from: DATA, 20个字节 -交易发送者的地址 blockHash: DATA, 32个字节- 该交易所在的区块的哈希。 destinationId: QUANTITY - 跨链目的链ID。 destinationValue: QUANTITY, 目的链币种数额 input: DATA, 交易的input数据。 v: Array - 交易多签V值数组。 r: Array - 交易多签R值数组。 s: Array - 交易多签S值数组。 total:QUANTITY - 总交易数量 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxOwner\",\"params\":[\"0x3db32cdacb1ba339786403b50568f4915892938a\"],\"id\":67}' //Respinse { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"data\": { \"221\": [ { \"value\": \"0xde0b6b3a7640000\", \"status\": 0, \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"time\": \"0x5ebb9cd2\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } ] }, \"total\": 1 } } eth_ctxContent 返回当前所有跨链交易单。 参数 无 返回 local - 本地链跨链交易列表 remote - 跨链目的链交易列表 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxContent\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"local\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } ] }, \"remote\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0xf9747951a56fb6392d1c2bddedf5f9cb0f380a43ac7e6345aa2fea73646e14d6\", \"txHash\": \"0x43f6150c0c308d2b5325f4f6f5820f00862a14beb2e961780eec518b4f6497c1\", \"from\": \"0x8029fcfc954ff7be80afd4db9f77f18c8aa1ecbc\", \"blockHash\": \"0x5391c792a14a3ec6be49201dbbf6a023fbb03025e0c600990107276dc3574ff5\", \"destinationId\": \"0xdd\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0xb003\", \"0xb003\" ], \"r\": [ \"0xae8928d14f2d6389803e29d94be0c1a7ef517818cf1a8a2305b282fb9f7cbf68\", \"0xb7d137e78069d4d2ad39940a4d2a82363fbff32920125853c5feef0b87e91cb4\" ], \"s\": [ \"0x7ab9cd7f753f4fc1c89a66df1ef8cf6d3c37aaa678164bb4df3fed8b19fc234f\", \"0x6d36ffed2dcf26278518def89a92e01b74f81e2ff12ecb29b0fc2b49db70566b\" ] } ] } } } eth_ctxContentByPage 分页返回当前所有跨链交易单。 参数 LOCALSIZE, - 本地跨链列表每页条数。 LOCALPAGE, - 本地跨链列表从第几页开始(初始页为第0页)。 REMOTESIZE, - 远端跨链列表每页条数。 REMOTEPAGE, - 远端跨链列表从第几页开始(初始页为第0页)。 返回 local - 本地链跨链交易列表 remote - 跨链目的链交易列表 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxContentByPage\",\"params\":[1,0,1,0],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"local\": { \"data\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } ] }, \"total\": 1 }, \"remote\": { \"data\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0xf9747951a56fb6392d1c2bddedf5f9cb0f380a43ac7e6345aa2fea73646e14d6\", \"txHash\": \"0x43f6150c0c308d2b5325f4f6f5820f00862a14beb2e961780eec518b4f6497c1\", \"from\": \"0x8029fcfc954ff7be80afd4db9f77f18c8aa1ecbc\", \"blockHash\": \"0x5391c792a14a3ec6be49201dbbf6a023fbb03025e0c600990107276dc3574ff5\", \"destinationId\": \"0xdd\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0xb003\", \"0xb003\" ], \"r\": [ \"0xae8928d14f2d6389803e29d94be0c1a7ef517818cf1a8a2305b282fb9f7cbf68\", \"0xb7d137e78069d4d2ad39940a4d2a82363fbff32920125853c5feef0b87e91cb4\" ], \"s\": [ \"0x7ab9cd7f753f4fc1c89a66df1ef8cf6d3c37aaa678164bb4df3fed8b19fc234f\", \"0x6d36ffed2dcf26278518def89a92e01b74f81e2ff12ecb29b0fc2b49db70566b\" ] } ] }, \"total\": 2 } } } eth_getLocalCtx 分页获取本地跨链交易列表。 参数 PAGESIZE, 每页的交易数量 STARTPAGE, 从第几页开始(初始页为第0页) 返回 data:OBJECT - 本地跨链列表: value: QUANTITY, 交易数额。 ctxId: DATA, 32个字节- 该交易ID。 txHash: DATA 32个字节- 交易的哈希。 from: DATA, 20个字节 -交易发送者的地址 blockHash: DATA, 32个字节- 该交易所在的区块的哈希。 destinationId: QUANTITY - 跨链目的链ID。 destinationValue: QUANTITY, 目的链币种数额 input: DATA, 交易的input数据。 v: Array - 交易多签V值数组。 r: Array - 交易多签R值数组。 s: Array - 交易多签S值数组。 total:QUANTITY - 总交易数量 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getLocalCtx\",\"params\":[1,0],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"data\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0x7bf717aba73c062b9ffc8a8afb78db1cf0e05be1d2728f4fa6b1fd5225a24194\", \"txHash\": \"0xd99bd3a1d9b79a2c5564abf698b6da2dcb478d42e97ceb161d31d043fa86b842\", \"from\": \"0x3db32cdacb1ba339786403b50568f4915892938a\", \"blockHash\": \"0xf72950c97f05a563aa54af8d6e84e7ae7b3a40c99cc100102658a69c7190808b\", \"destinationId\": \"0x57f0\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0x1de\", \"0x1de\" ], \"r\": [ \"0xcfc9d48d8c0425329245c1768fb42140584ad7afa71c4d05c755bce77970c6d\", \"0x56e5a3205ceefe7e688adcab2f3c71f5245b4d1f2ae0465bd15a462a045b6dcc\" ], \"s\": [ \"0x5e25bcc98cbc23b86250a974b911c7dc5d628365b85855a50873be7c26a07be3\", \"0x1a3726f533b935183599c7480df03bbec6ced583330a8aedfb5ac50ab9e7f7a5\" ] } ] }, \"total\": 1 } } eth_getRemoteCtx 分页获取本地跨链交易列表。 参数 PAGESIZE, 每页的交易数量 STARTPAGE, 从第几页开始(初始页为第0页) 返回 data:OBJECT - 本地跨链列表: value: QUANTITY, 交易数额。 ctxId: DATA, 32个字节- 该交易ID。 txHash: DATA 32个字节- 交易的哈希。 from: DATA, 20个字节 -交易发送者的地址 blockHash: DATA, 32个字节- 该交易所在的区块的哈希。 destinationId: QUANTITY - 跨链目的链ID。 destinationValue: QUANTITY, 目的链币种数额 input: DATA, 交易的input数据。 v: Array - 交易多签V值数组。 r: Array - 交易多签R值数组。 s: Array - 交易多签S值数组。 total:QUANTITY - 总交易数量 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_getRemoteCtx\",\"params\":[1,0],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"data\": { \"22512\": [ { \"value\": \"0xde0b6b3a7640000\", \"ctxId\": \"0xf9747951a56fb6392d1c2bddedf5f9cb0f380a43ac7e6345aa2fea73646e14d6\", \"txHash\": \"0x43f6150c0c308d2b5325f4f6f5820f00862a14beb2e961780eec518b4f6497c1\", \"from\": \"0x8029fcfc954ff7be80afd4db9f77f18c8aa1ecbc\", \"blockHash\": \"0x5391c792a14a3ec6be49201dbbf6a023fbb03025e0c600990107276dc3574ff5\", \"destinationId\": \"0xdd\", \"destinationValue\": \"0xde0b6b3a7640000\", \"input\": \"0x\", \"v\": [ \"0xb003\", \"0xb003\" ], \"r\": [ \"0xae8928d14f2d6389803e29d94be0c1a7ef517818cf1a8a2305b282fb9f7cbf68\", \"0xb7d137e78069d4d2ad39940a4d2a82363fbff32920125853c5feef0b87e91cb4\" ], \"s\": [ \"0x7ab9cd7f753f4fc1c89a66df1ef8cf6d3c37aaa678164bb4df3fed8b19fc234f\", \"0x6d36ffed2dcf26278518def89a92e01b74f81e2ff12ecb29b0fc2b49db70566b\" ] } ] }, \"total\": 2 } } eth_ctxStats 获取跨链交易条数。 参数 无 返回 local: - 本地跨链条数: remote: - 远程链跨链条数: 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_ctxStats\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"local\": 1, \"remote\": 2 } } eth_poolStats 获取跨链待确认交易池交易条数。 参数 无 返回 pending: - 本地已确认跨链条数: queue: - 远程同步跨链条数: 示例 //Request curl localhost:8545 -X POST -H \"Content-Type:application/json\" -d '{\"jsonrpc\":\"2.0\",\"method\":\"eth_poolStats\",\"params\":[],\"id\":67}' //Response { \"jsonrpc\": \"2.0\", \"id\": 67, \"result\": { \"pending\": 0, \"queue\": 0 } } "},"24_chromeWallet/":{"url":"24_chromeWallet/","title":"SimPlug","keywords":"","body":"下载钱包 下载 插件钱包下载地址 解压 安装钱包 1.打开google 浏览器，打开扩展程序 2.将安装包安装到扩展程序中 3.安装完以后打开钱包 4.打开钱包，选择主网或是测试网，如果已有钱包就直接导入，如果没有账户就直接创建账户。 5.创建账户，备份私钥就可以进入自己的插件钱包。 钱包调用方法 前置条件 需要运行插件的应用（以下简称开发者）根据window.hasSimplug来判断插件是否可用。 开发者需要在页面中放置一个id为\"run_contract_btn\"的按钮触发simplug的事件。 开发者需要在页面中放置一个id为\"run_contract_data\"的隐藏input向sumpulg发送交易data。 操作过程 用户点击或者脚本触发点击id为\"run_contract_btn\"的按钮。 与此同时开发者需要在页面中设置id为\"run_contract_data\"的input的值为需要发送交易的data。 插件会自动唤醒调用交易。 "},"25_sdk/":{"url":"25_sdk/","title":"SDK","keywords":"","body":"SimpleChain区块链向外部暴露了接口，外部业务程序能够通过SimpleChain提供的SDK来调用这些接口。开发者只需要根据自身业务程序的要求，选择相应语言的SDK，用SDK提供的API进行编程，即可实现对区块链的操作。 对接应用 目前，SDK接口可实现的功能包括（但不限于）： 合约操作 合约编译、部署、查询 交易发送、上链通知、参数解析、回执解析 链管理 链状态查询、链参数设置 组员管理 权限设置 多种语言SDK 目前，SimpleChain 提供的SDK包括： Java SDK（稳定、功能强大) Python SDK（简单轻便） Node-js SDK（简单轻便） "},"48_crossChain/":{"url":"48_crossChain/","title":"跨链方案","keywords":"","body":"自由公证人机制 跨链交互根据所跨越的区块链底层技术平台的不同可以分为同构链跨链和异构链跨链：同构链之间安全机制、共识算法、网络拓扑、区块生成验证逻辑都一致，它们之间的跨链交互相对简单。而异构链的跨链交互相对复杂，比如Simplechain采用 PoW 算法而EOS 采用POS共识算法，它两区块的组成形式和确定性保证机制均有很大不同，直接跨链交互机制不易设计。异构链之间的跨链交互一般需要第三方辅助服务辅助跨链交互。所以设计跨链方案的时候需要设计一套综合 对比目前主流的跨链方案和对跨链的综合性能进行对比 ，以及考虑到后期的方案升级。Simplechain技术团队在公证人机制上设计了自己的跨链方案————自由公证人机制 。为什么选用该跨链技术方案呢？ 在“公证人“模式当中，单一的\"公证人\" 机制以相对中心化的方式运行的，因为在\"公证人\"机制对于效率的要求要高于去中心化，这就导致单一的公证人体系存在很明显的黑箱风险。但是我们Simplechain的\"自由公证人机制\"恰恰弥补了\"公证人\"机制的缺陷，它在不同的区块链平台选择受信任节点的过程中加入了抵押，以及相应的惩罚机制。如果有节点作恶，将会受到相应的惩罚，网络中的\"公证人\"将会自动被新的公证人顶替掉。所以自由公证人机制可以有效的保证整个跨链过程的完全去中心化，高效和安全。 如果说早期的跨链方案主要目标是资产转移的话，那么SIPC的的跨链方案不仅仅是资产转移，更关注的是跨链基础设施。主要强调资产可以智能合约实现。SIPC的跨链技术立志成为高性能，去中心化的跨链基础设施，同时接入各种跨链应用，着重商业落地。该跨链方案可以使得SIPC在金融领域，政务链，企业区块链解决方案等方向有很强的优势，助力SIPC技术生态成为一套行业区块链解决方案。 以下是SimpleChain跨链方案结构示意图： 该跨链结构包含公证人机制，主子链实现高效通信，通过公证人机制实现资产跨链。比如可以将SimpleChain主链的区块头部信息写入SimpleChain子链的区块里，SimpleChain主链与SimpleChain子链使用相同的共识验证方法，实现两条链之间的通信。通过公证人机制，使用受信任的分布式节点(公证人/node1或公证人/node2)向SimpleChain子链记录证明SimpleChain主链链上发生的交易，通信实现资产跨链交互。简单理解就是SimpleChain主链和SimpleChain子链使用共同信任的分布式节点(node1或者node2)充当公证人，SimpleChain主链和SimpleChain子链就可以间接信任，完成资产交换。 下图是SimpleChain跨链交易的流程图： 跨链交易流程如下： 步骤1：子网用户A向跨链交易合约打币。A需支付上链手续费TPC给子网矿工并为步骤5交易手续费预充值。 步骤2：锚定矿工群同步区块，识别步骤1中的交易上链，待交易确认后，发起并完成多重签名，形成有效的多重签名信息。 步骤3：用户B收到步骤2的多重签名消息，向跨链合约发交易接单。接单交易中会包含多签广播信息，该交易需B支付上链手续费给主网矿工。交易确认后A获得主网货币。 步骤4：锚定矿工群同步区块，识别步骤3中的交易上链，待交易确认后，向子网进程发指令。 步骤5：锚定矿工子网进程收到步骤4的指令后，向跨链合约发起交易，在合约中完成多重签名。交易确认后B获得TPC。 “自由公正人”机制优势 SIPC跨链方案优势如下： (1) 去中心化 锚定节点分散在区块链分布式网络中，使用多重签名达成共识 锚定节点群对外开放，普通节点可申请成为锚定节点，为跨链交易提供服务； 同过取消身份资格对做弊的锚定节点进行惩罚。 (2) 公开透明 基于区块链上的直接交易，数据公开透明，可追溯，可验证； 跨链程序开源，社区可自发组织部署，参与跨链交易的服务竞争和支撑 区块互相锚定，全网数据互通； 定期统计分析，对外公布跨链交易的业务数据结果 (3) 操作简便 跨链钱包一站式管理所有链上资产； 仿交易所的跨链交易操作，符合用户习惯，用户基数大； 完成一次跨链交易，用户仅需一次操作； 交易成本低，一次跨链交易仅需0.01Token; (4) 安全可靠 基于去中心化的多重签名技术，实现数据可信传播； 签名使用椭圆曲线密钥签名，破解难道大 部分锚定节点宕机不影响跨链交易正常进行； 链与链交互简单，交易效率高。 (5) 拓展性强 跨链技术支撑多对多的跨链部署，可以实现多条链的资源互通； 基于该跨链技术理论上可以无限发布子链并融入上链生态； 众多子链模版，采用主流共识协议，以符合不同的业务需求； "},"26_smallChain.html":{"url":"26_smallChain.html","title":"子链模版","keywords":"","body":"部署DPOS共识子链网络 1. 创世区块 { \"config\": { \"chainId\": 10388, \"dpos\": { \"period\": 3, \"epoch\": 300, \"maxSignersCount\": 21, \"minVoterBalance\": 100000000000000000000, \"genesisTimestamp\": 1554004800, \"signers\": [ \"3d50e12fa9c76e4e517cd4ace1b36c453e6a9bcd\", \"f97df7fe5e064a9fe4b996141c2d9fb8a3e2b53e\", \"ef90068860527015097cd031bd2425cb90985a40\" ], \"pbft\": false, \"voterReward\": true } }, \"nonce\": \"0x0\", \"timestamp\": \"0x5ca03b40\", \"extraData\": \"0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000\", \"gasLimit\": \"0x47b760\", \"difficulty\": \"0x1\", \"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"alloc\": { \"3d50e12fa9c76e4e517cd4ace1b36c453e6a9bcd\": { \"balance\": \"0x21e19e0c9bab2400000\" }, \"ef90068860527015097cd031bd2425cb90985a40\": { \"balance\": \"0x21e19e0c9bab2400000\" }, \"f97df7fe5e064a9fe4b996141c2d9fb8a3e2b53e\": { \"balance\": \"0x21e19e0c9bab2400000\" } }, \"number\": \"0x0\", \"gasUsed\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\" } period dpos出块间隔时间，单位为秒 epoch dpos间隔多少个块定期清除投票（清除后需要投票者重新发起投票交易) maxSignersCount dpos最大允许的生产者数量 minVoterBalance dpos最小允许的投票额度，单位为Wei voterReward dpos投票者能否获得奖励（若开启，则在生产者出块时投票者也能获得分红） genesisTimestamp dpos允许初始块出块的时间，并通过此时间计算后续出块的时间与生产者 signers dpos初始生产者列表 pbft dpos是否在每轮出块后使用pbft的方式确认每一个区块 alloc dpos初始生产者抵押投票数额 2. 子链初始化流程 方式一. 使用sipe初始化 1.创建或导入生产者账户 ```shell script sipe --datadir=dposdata account new 2.将创建或导入的生产者地址写入genesis.json中，同时写入初始投票数额（参考1.创世区块） 3.初始化子链节点 ```shell script sipe --datadir=dposdata --role=subchain init genesis.json 方式二. 使用consensus工具一键初始化集群 在cmd/consensus目录下运行init_dpos.sh ```shell script cd cmd/consensus ./init_dpos.sh --numNodes 3 + `numNodes` 生成集群节点数量 初始化完成后，会在`cmd/consensus/dposdata`目录下建立对应节点文件 ### 3. 子链启动流程 1. 启动节点 ```bash sipe --datadir=dposdata --mine --etherbase= --unlock= --password= --port=30303 --role=subchain --v5disc 连接其他节点 sipe --datadir=dposdata --mine --etherbase= --unlock= --password= --port=30304 --role=subchain --v5disc --bootnodesv5={enode1} --bootnodesv4={enode1} 4. 投票与提案 4.1 发起投票交易 > eth.sendTransaction({from:\"\",to:\"\",value:0,data:web3.toHex(\"dpos:1:event:vote\")}) 4.2 发起取消投票交易 > eth.sendTransaction({from:\"\",to:\"\",value:0,data:web3.toHex(\"dpos:1:event:devote\")}) 4.3 发起更改矿工奖励的提案 将矿工区块奖励比例改为666‰ > eth.sendTransaction({from:\"\",to:\"\",value:0,data:web3.toHex(\"dpos:1:event:proposal:proposal_type:3:mrpt:666\")}) 4.4 发起更改最小允许投票额度的提案 将最小允许投票额度改为10 ether > eth.sendTransaction({from:\"\",to:\"\",value:0,data:web3.toHex(\"dpos:1:event:proposal:proposal_type:6:mvb:10\")}) 4.5 通过或反对提案 yes通过提案，no反对提案 > eth.sendTransaction({from:\"\",to:\"\",value:0,data:web3.toHex(\"dpos:1:event:declare:hash::decision:yes\")}) 5. 查看共识状态 > dpos.getSnapshot() candidates 矿工候选者名单 confirmedNumber 确认的区块高度 historyHash 最近两轮出块的块hash，用来计算新一轮的生产者出块顺序 minerReward 每个块生产者获得的奖励千分比，若开启voterReward，剩下的为投票者的奖励 signers 列举生产者名单与出块顺序 punished 列举每个生产者因未按时出块受到的惩罚信息 tally 列举每个候选人的总得票数 votes 列举投票信息 voters 投票人发起投票的区块高度 proposals 提案列表 部署PBFT共识子链网络 1. 创世区块 { \"config\": { \"chainId\": 10388, \"istanbul\": { \"epoch\": 30000, \"policy\": 0 } }, \"nonce\": \"0x0\", \"timestamp\": \"0x0\", \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000000000000f843f83f941c46d10e91eafaac430718df3658b1a496b827bd94b67ee9395542b227c99941eb4168e3f3c6502dd8949d6510b637970085962c908c69e63e9d36a36cb480c0\", \"gasLimit\": \"0xe0000000\", \"difficulty\": \"0x1\", \"mixHash\": \"0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"alloc\": {}, \"number\": \"0x0\", \"gasUsed\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\" } epoch pbft间隔多少个块定期清除投票 policy pbft提议者轮询方式，0为roundRobin（按顺序更换），1为sticky（提议者未出错时不更换提议者） mixHash pbft区块须将mixHash指定为0x63746963616c2062797a616e74696e65206661756c7420746f6c6572616e6365 extraData pbft初始生产者计算后得到的header.extra alloc pbft暂无区块奖励，因此需要提前分配代币 2. 子链初始化流程 方式一. 使用sipe初始化 1.创建或导入生产者账户 ```shell script sipe --datadir=pbftdata account new 2.使用consensus工具生成extraData，写入到genesis.json中（参考1.创世区块） ```shell script cd cmd/consensus ./init_pbft.sh --numNodes 1 --validator 3.初始化子链节点 ```shell script sipe --datadir=pbftdata --role=subchain init genesis.json 4. 将节点的nodekey写入到pbftdata/static-nodes.json中（nodekey公钥为生产者公钥） #### 方式二. 使用consensus工具一键初始化集群 在cmd/consensus目录下运行init_pbft.sh ```bash cd cmd/consensus ./init_pbft.sh --numNodes 3 --ip 127.0.0.1 127.0.0.2 127.0.0.3 --port 21001 21002 21003 numNodes 生成集群节点数量 ip 指定节点的ip列表（默认ip为127.0.0.1） port 指定节点的端口列表（默认端口为21001~2100x，x为numNodes） 初始化完成后，会在cmd/consensus/pbftdata目录下建立对应节点文件 3. 子链启动流程 sipe --datadir=pbftdata --istanbul.requesttimeout=10000 --istanbul.blockperiod=5 --syncmode=full --mine --minerthreads=1 --port=21001 --role=subchain port 需要和static-nodes.json中配置的enode保持一致 istanbul.requesttimeout pbft每个view的过期时间，单位毫秒，默认值为10000 istanbul.blockperiod pbft出块间隔，单位秒，默认值为1 4.查看共识状态 ```shell script istanbul.getSnapshot() ``` validators pbft区块生产者名单 votes 新增validator或移除validator的投票 tally 总投票情况 部署RAFT共识子链网络 1. 创世区块 { \"config\": { \"chainId\": 10, \"raft\": true }, \"nonce\": \"0x0\", \"timestamp\": \"0x0\", \"extraData\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"gasLimit\": \"0xe0000000\", \"difficulty\": \"0x0\", \"mixHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\", \"coinbase\": \"0x0000000000000000000000000000000000000000\", \"alloc\": { \"1e69ebb349e802e25c7eb3b41adb6d18a4ae8591\": { \"balance\": \"0x21e19e0c9bab2400000\" }, \"73ce1d55593827ab5a680e750e347bf57485a511\": { \"balance\": \"0x21e19e0c9bab2400000\" }, \"b8564a5657fa7dc51605b58f271b5bafad93b984\": { \"balance\": \"0x21e19e0c9bab2400000\" } }, \"number\": \"0x0\", \"gasUsed\": \"0x0\", \"parentHash\": \"0x0000000000000000000000000000000000000000000000000000000000000000\" } raft true为使用raft共识 alloc raft共识只有存在交易的时候才打包区块，因此需要提前分配代币 2. 子链初始化流程 方式一. 使用sipe初始化 1.创建或导入生产者账户 sipe --datadir=raftdata account new 2.初始化子链节点 sipe --datadir=raftdata --role=subchain init genesis.json 4.将节点的nodekey写入raftdata/static-nodes.json中（nodekey公钥为生产者公钥） 方式二. 使用consensus工具一键初始化集群 在cmd/consensus目录下运行init_pbft.sh cd cmd/consensus ./init_raft.sh --numNodes 3 --ip 127.0.0.1 127.0.0.2 127.0.0.3 --port 21001 21002 21003 --raftport 50401 50402 50403 numNodes 生成集群节点数量 ip 指定节点的ip列表（默认ip为127.0.0.1） port 指定节点的端口列表（默认端口为21001~2100x，x为numNodes） raftport 指定节点的raft通信端口列表（默认端口为50401~5040x，x为numNodes） 初始化完成后，会在cmd/consensus/raftdata目录下建立对应节点文件 3. 子链启动流程 sipe --datadir=raftdata --raft --port=21001 --raftport=50401 --role=subchain port 需要和static-nodes.json中配置的enode保持一致 raft 使用raft模式 raftport raft端口号，需要和static-nodes.json中配置的enode保持一致 4.查看共识状态 > istanbul.getSnapshot() validators pbft区块生产者名单 votes 新增validator或移除validator的投票 tally 总投票情况 "},"49_crossChainOrder/":{"url":"49_crossChainOrder/","title":"跨链流程","keywords":"","body":"Simplechain是一个主子链架构的混合公链，不同链之间的资产跨平台越迁就会涉及到跨链操作。下面是跨链的详细流程： 下载ChainBox 根据自己移动设备系统下载对应的ChainBox安装包，注册钱包后保管好自己的私钥。找到钱包地址，复制钱包地址。如下图： 领取测试资产 打开水龙头，水龙头地址：测试网水龙头 将上一步复制的钱包地址输入到水龙头中，就可以领取测试币。如下图： 进行跨链交易 跨链入口 打开钱包进入首页，钱包资产中显示该钱包在上链生态中的所有币及其折价（如下图） 点击某一项钱包资产（TEST）进入主链交易页面（如下图） 点击上图中的“跨链”按钮进入交易对选择界面（如下图），这里暂时只提供一个交易对。 点击SUB进入跨链交易市场。下图中跨链列表显示主子链间的订单，红色单价的纪录为主链发往子链的订单，绿色单价的记录为子链发往主链的订单。跨链列表按单价由高到低排列，更多的记录可点击Tab页面可接单和发单列表查询展示。当前委托页面显示的是当前账号参与的跨链交易订单，点击全部可以显示所有委托订单和历史跨链交易记录。 接单： 点击上图红色线框中的接单即可成交一笔跨链交易。该笔交易的意思是您卖出1个TEST，获得10个SUB，单价为0.1SUB/TEST。参见下图 输入钱包密码后点“确认”发出一笔链上交易，待交易确认后即可成交（约6分钟）。 点击“全部”—>“历史记录”可以看见刚刚成交的跨链交易记录，如下图： 浏览器查看交易详情 查看跨链记录： 查看交易详情： 浏览器查看详情： 回到钱包首页发现子链币增长了10 SUB，手续费0.001 TEST，远小于普通交易所的0.2%的手续费率 。 发单 点击跨链交易市场中的“发单”按钮，进入发单流程。 点击“下一步”，输入密码后点“确认”。 交易发送成功后，待交易确认后（约3分钟），我们可以发现在账号的当前委托页面新增了一条记录，此刻全网用户均可查询到该笔委托，说明发单成功。用户的TEST减少1个 撤单 选择上面的委托记录，点击“撤单”，进入撤单流程。 输入密码，点击“确认”，发送交易，待交易确认后（约6分钟）。用户委托列表空了，历史记录中新增了一条撤单记录。 回到首页，刚刚减少的TEST也回来了。 "},"27_dappFlow/":{"url":"27_dappFlow/","title":"Dapp流程梳理","keywords":"","body":"Dapp开发案例是基于Simplechain开发一个公益众筹项目，下面是整个众筹项目开发的流程梳理。 在remix中写合约并测试 下载安装remix，并尝试写合约方法。并进行测试。 创建React的空工程 创间React的空工程主要包含两条命令，首先要安装create-react-app这条命令： nstall-过create-react-app 它会安装你的node所需要依赖的目录，然后创建项目: ./create-react-app 创建好项目以后，可以使用一下的命令对项目进行初始化的清理工作： npm run start 创建comple.js文件 创建compile.js文件，然后安装solc编译器，命令如下： npm install solc 安装完了solc以后，就可以调用solc.compile(sourceCode,1)对源码进行编译。编译完成后导出编译过的bytecode(字节码)，interface. 创建js文件 搭建界面，调用web3,以及与区块链进行数据交互都需要js方法去实现，所以这一步需要创建多个js文件。具体需要创建的js文件如下图： 发起合约功能 发起合约功能主要有两个具体逻辑需要实现，一个是interaction中写具体方法，另一个是在CreateFundingTab中完成调用。 发起参与众筹功能 发起参与众筹功能的实现具体主要有三个。一个如下： 在主界面传递一个回调函数onItemClick给CardList，用于返回用户点击的合约的详情 在CardList中传给MyCard 在MyCard中，当触发onClick的时候，调用这个onItemClick，返回相应的detail 通过上面这个三步方法可以得到合约的地址以及得到支持的金额。 第二个是在interaction中写具体方法，最后一个是在CreatorFundingTab中完成调用。图如下： "},"28_editor.html":{"url":"28_editor.html","title":"编译器","keywords":"","body":"Remix 推荐使用 Remix 来开发简单合约和快速学习 Solidity。 Remix 可在线使用，而无需安装任何东西。如果你想离线使用，可按 https://github.com/ethereum/browser-solidity/tree/gh-pages 的页面说明下载 zip 文件来使用。 该页面有进一步详细说明如何安装 Solidity 命令行编译器到你计算机上。如果你刚好要处理大型合约，或者需要更多的编译选项，那么你应该选择使用命令行编译器 solc。 npm / Node.js 使用 npm 可以便捷地安装Solidity编译器solcjs。但该 solcjs 程序的功能相对于本页下面的所有其他选项都要少。在commandline-compiler 一章中，我们假定你使用的是完整功能的编译器。 所以，如果你是从 npm 安装 solcjs ，就此打住，直接跳到 solc-js去了解。 注意: solc-js 项目是利用 Emscripten 从 C++ 版的 solc 跨平台编译为 JavaScript 的，因此，可在 JavaScript 项目中使用 solcjs（如同 Remix）。 具体介绍请参考 solc-js 代码库。 npm install -g solc 在命令行中，使用 solcjs 而非 solc 。solcjs 的命令行选项同 solc 和一些工具（如 geth )是不兼容的，因此不要期望 solcjs 能像 solc 一样工作。 Docker 我们为编译器提供了最新的docker构建。 stable 仓库里的是已发布的版本，nightly仓库则是在开发分支中的带有不稳定变更的版本。 docker run ethereum/solc:stable solc --version 目前，docker 镜像只含有 solc 的可执行程序，因此你需要额外的工作去把源代码和输出目录连接起来。 二进制包 可在 solidity/releases 下载 Solidity 的二进制安装包。 对于 Ubuntu ，我们也提供 PPAs 。通过以下命令，可获取最新的稳定版本： sudo add-apt-repository ppa:ethereum/ethereum sudo apt-get update sudo apt-get install solc 当然，你也可安装尝鲜的开发者版本： sudo add-apt-repository ppa:ethereum/ethereum sudo add-apt-repository ppa:ethereum/ethereum-dev sudo apt-get update sudo apt-get install solc 同时，也提供可安装 所有支持的Linux版本 下的 snap package 。通过以下命令，可获取最新的稳定版本： sudo snap install solc 或者，如果你想测试 develop 分支下的最新变更，可通过如下方式安装开发者版本： sudo snap install solc --edge 同样，Arch Linux 也有提供安装包，但仅限于最新的开发者版本： pacman -S solidity 在写本文时，Homebrew 上还没有提供预构建的二进制包（因为我们从 Jenkins 迁移到了 TravisCI ）。 我们将尽快提供 homebrew 下的二进制安装包，但至少从源码构建的方式还是行得通的： brew update brew upgrade brew tap ethereum/ethereum brew install solidity 如果你需要特定版本的 Solidity ，你需要从 Github 上安装一个 Homebrew formula 你可查阅 solidity.rb commits on Github 的提交记录，去寻找包含 solidity.rb 文件改动的特殊提交。然后使用 brew 进行安装： brew unlink solidity # Install 0.4.8 brew install https://raw.githubusercontent.com/ethereum/homebrew-ethereum/77cce03da9f289e5a3ffe579840d3c5dc0a62717/solidity.rb Gentoo Linux 下也提供了安装包，可使用 emerge 进行安装： emerge dev-lang/solidity 从源代码编译 克隆代码库 执行以下命令，克隆源代码： git clone --recursive https://github.com/ethereum/solidity.git cd solidity 如果你想参与 Solidity 的开发, 你可分叉 Solidity 源码库后，用你个人的分叉库作为第二远程源： cd solidity git remote add personal git@github.com:[username]/solidity.git Solidity 有 Git 子模块，需确保完全加载它们： git submodule update --init --recursive 先决条件 - macOS 在 macOS 中，需确保有安装最新版的 Xcode， Xcode 包含 Clang C++ 编译器， 而 Xcode IDE 和其他苹果开发工具是 OSX 下编译 C++ 应用所必须的。如果你是第一次安装 Xcode 或者刚好更新了 Xcode 新版本，则在使用命令行构建前，需同意 Xcode 的使用协议： sudo xcodebuild -license accept Solidity 在 OS X 下构建，必须 安装Homebrew 包管理器来安装依赖。 如果你想从头开始，这里是卸载Homebrew的方法 先决条件 - Windows 在Windows下构建Solidity，需下载的依赖软件包： 软件 备注 Git for Windows_ C从Github上获取源码的命令行工具 CMake_ 跨平台构建文件生成器 Visual Studio 2017 Build Tools_ C++ 编译器 Visual Studio 2017_ (Optional) C++ 编译器和开发环境 如果你已经有了 IDE，仅需要编译器和相关的库，你可以安装 Visual Studio 2017 Build Tools。 Visual Studio 2017 提供了 IDE 以及必要的编译器和库。所以如果你还没有一个 IDE 并且想要开发 Solidity，那么 Visual Studio 2017 将是一个可以使你获得所有工具的简单选择。 这里是一个在 Visual Studio 2017 Build Tools 或 Visual Studio 2017 中应该安装的组件列表： Visual Studio C++ core features VC++ 2017 v141 toolset (x86,x64) Windows Universal CRT SDK Windows 8.1 SDK C++/CLI support 外部依赖 在 macOS、Windows和其他 Linux 发行版上，有一个脚本可以“一键”安装所需的外部依赖库。本来是需要人工参与的多步操作，现在只需一行命令: ./scripts/install_deps.sh Windows 下执行： scripts\\install_deps.bat 命令行构建 确保你已安装外部依赖（见上面） Solidity 使用 CMake 来配置构建。Linux、macOS 和其他 Unix系统上的构建方式都差不多： mkdir build cd build cmake .. && make 也有更简单的： #note: 将安装 solc 和 soltest 到 usr/local/bin 目录 ./scripts/build.sh 对于 Windows 执行： mkdir build cd build cmake -G \"Visual Studio 15 2017 Win64\" .. 这组指令的最后一句，会在 build 目录下创建一个 solidity.sln 文件，双击后，默认会使用 Visual Studio 打开。我们建议在VS上创建 RelWithDebugInfo 配置文件。 或者用命令创建： cmake --build . --config RelWithDebInfo CMake参数 如果你对 CMake 命令选项有兴趣，可执行 cmake .. -LH 进行查看。 版本号字符串详解 Solidity 版本名包含四部分： 版本号 预发布版本号，通常为 develop.YYYY.MM.DD 或者 nightly.YYYY.MM.DD 以 commit.GITHASH 格式展示的提交号 由若干条平台、编译器详细信息构成的平台标识 如果本地有修改，则 commit 部分有后缀 .mod。 这些部分按照 Semver 的要求来组合， Solidity 预发布版本号等价于 Semver 预发布版本号， Solidity 提交号和平台标识则组成 Semver 的构建元数据。 发行版样例：0.4.8+commit.60cc1668.Emscripten.clang. 预发布版样例： 0.4.9-nightly.2017.1.17+commit.6ecb4aa3.Emscripten.clang 版本信息详情 在版本发布之后，补丁版本号会增加，因为我们假定只有补丁级别的变更会在之后发生。当变更被合并后，版本应该根据semver和变更的剧烈程度进行调整。最后，发行版本总是与当前每日构建版本的版本号一致，但没有 prerelease 指示符。 例如： 0.4.0 版本发布 从现在开始，每晚构建为 0.4.1 版本 引入非破坏性变更 —— 不改变版本号 引入破坏性变更 —— 版本跳跃到 0.5.0 0.5.0 版本发布 该方式与version pragma一起运行良好。 "},"29_writeContract/":{"url":"29_writeContract/","title":"编写合约","keywords":"","body":"一. 项目代码管理 项目的代码库 二. 单个众筹合约实现 1.创建空合约CrowFunding 进⼊到项⽬⽬录，创建⽂件basicFunding.sol 并添加如下代码： pragma solidity ^0.4.24; contractCrowFunding { } 2.基本属性(状态变量) 状态变量 类型 作⽤ creator address 项⽬发起⼈，负责创建合约、花费申请、花费执⾏ projectName string 众筹项⽬名称 supportBalance uint 众筹⽀持⾦额 targetBalance uint 众筹项⽬⽬标筹集⾦额 endTime uint 众筹截⽌⽇期，到此时间时若筹不⻬⾦额则众筹失败 3.构造函数实现 pragma solidity ^0.4.24; contract CrowFunding { address public creator; // 发起人 string public projectName; // 项目名称 uint public supportBalance; // 参与众筹金额 uint public targetBalance; // 众筹目标金额 uint public endTime; // 众筹截止时间 constructor(string _projectName, uint _supportBalance, uint _targetBalance, uin t _durationInSeconds) public { creator = msg.sender; projectName = _projectName; supportBalance = _supportBalance; targetBalance = _targetBalance; //传递进来剩余的秒数，比如若众筹30天，则传入：30天 * 24小时 * 60分 * 60秒 = 2592000 endTime = now + _durationInSeconds; //2592000 } } 测试 4.参与众筹 实现 添加参与人属性 address[] public investors; //参与众筹的人，即投资人 参与众筹即向合约中转账，并将参与人的地址添加到集合中，代码如下： function invest() public payable { require(investorExistMap[msg.sender] == false);//每个人只能参与一次 require(msg.value == supportBalance); // 支持固定金额 investors.push(msg.sender); // 添加到众筹人数组中 investorExistMap[msg.sender] = true; // 标记当前账户为参与人 } 为了能够快速校验一个账户是否在参与人数组中，我们提供一个mapping(address=>bool)来进行标记，mapping的特点是所有的key都默认存在，只不过默认值是false，如果不存在，则返回false,我们将用户地址作为key,设置值为true,即可完成索引，mapping是线性索引的，比使用for循环遍历investors数组高效且经济，所以还需要添加如下属性： mapping(address => bool) public investorExistMap; //标记一个人是否参与了当前众筹 测试 测试，请部署后按照数字顺序操作 众筹失败退款（实现） 退款即将所有筹到的钱逐一退换还给投资者人。同时增加了两个辅助函数，便于测试。 //众筹失败，退款 function drawBack() public { for (uint i = 0 ; i 测试 花费请求(实现) 定义结构 众筹成功，项目启动，需要指出一笔费用，这笔费用需要包含如下信息： 用途：买什么？ 花费金额：需要多少钱？ 商家地址：向谁购买？ 当前已经赞成的票数：多少人赞成了，超半数则批准支出 这个花费申请的当前状态：这个申请的当前状态：完成？待批准？代执行？ 标记已经投过票的人的集合：mapping(address=>bool),赞成人的标记集合，防止一人投票多次。 根据分析，定义结构代码： struct Request { string purpose; //买什么？ uint cost; //需要多少钱？ address shopAddress; // 向谁购买？ uint voteCount; // 多少人赞成了，超半数则批准支出 mapping(address => bool) investorVotedMap; //赞成人的标记集合，防止一人重复投票多次 RequestStatus status; //这个申请的当前状态：投票中？已批准？已完成？ } 定义一个枚举，描述申请状态： enum RequestStatus {Voting,Approved,Completed} 定义方法 这个函数比较简单，创建一个新的请求结构，然后添加到数组中即可。 代码如下： Request[] public requests; //请求可能有多个，所以定义一个数组 function createRequest(string _purpose, uint _cost, address _shopAddress) public { Request memory request = Request({ purpose : _purpose, cost : _cost, shopAddress : _shopAddress, voteCount : 0, status : RequestStatus.Voting }); requests.push(request); //将新的请求添加至数组中 } 测试 在createRequest中添加参数： \"小胖子减肥\", 100, \"0xca35b7d915458ef540ade6068dfe2f44e8fa733c\" 在request中搜索第0个请求，图示如下： 批准支付申请 实现 项目方发起申请后，由众筹人进行审批，如果投资人不支持。则无需理会，默认为false(不支持)，如果想支持，则需要执行批准动作。即对申请结构的数据进行状态修改，包括： 检验这个人是否投票过，若未通过，则允许投票，反之退出。 voteCount 数据加1。 将该投票人再investorVotedMap映射中的值设为true。 代码如下： //批准⽀付申请 function approveRequest(uint256 index) public { // 1. 检验这个⼈是否投过票，若未投过，则允许投票，反之退出 // 2. voteCount数据加1。 // 3. 将该投票⼈在investorVotedMap映射中的值设置为true。 //⾸先要确保是参与众筹的⼈，否则⽆权投票 require(investExitMapping[msg.sender]); //根据索引找到特定的请求 Request storage req = requests[index]; //确保没有投过票，⼈⼿⼀票 require(req.investorVotedMap[msg.sender] == false); //如果已经完成，或者已经获得批准了，就不⽤投票了，当前投票不会影响决策。 require(req.status == RequestStatus.Voting); //⽀持票数加1 req.voteCount += 1; //标记为已投票 req.investorVotedMap[msg.sender] = true; if (req.voteCount * 2 > investors.length) { req.status == RequestStatus.Approved; } } 测试 批准侯查看该请求，voteCount变为1 完成花费请求 实现 当投票人数过半时，花费被批准，可以由项目方执行花费动作，也可以由项目方执行花费动作，也可以由合约自动执行。我们选择手动执行，因为有可能项目方改变注意了，计划右边不需要购买了等等因素，所以我们把权利下放到项目方。 这个函数主要做两件事： 1.票数过半，则执行转账。 2.更新request的状态 代卖如下： function finalizeRequest(uint256 index) public onlyManager{ // 这个函数主要做两件事： // 1. 票数过半，则执⾏转账。 // 2. 更新request的状态。 Request storage req = requests[index]; //合约⾦额充⾜才可以执⾏ require(address(this).balance >= req.cost); //赞成⼈数过半 require(req.voteCount * 2 > investors.length); //转账 req.shopAddress.transfer(req.cost); //更新请求状态为已完成 req.status = RequestStatus.Completed; } 测试 三个人投资，一个人赞成，两个人反对，执行支付失败。 两个人赞成，执行支付成功 智能合约全部实现还需要实现几个方法，以及合约方法的互相调用。这些都可以直接在看源码学习。但是合约的编写，以及测试都在上面的几个基础方法中现在。 "},"30_frontRealize/":{"url":"30_frontRealize/","title":"前端实现","keywords":"","body":"初始化React项目 前端是基于React框架开发的，所以我们首先进行项目初始化操作。 初始化项目 create-react-app funding-eth-react 精简项目 通lottery项目，src下仅留App.js和index.js，调整对应代码。 import React, { Component } from 'react'; class App extends Component { render() { return ( Hello World ); } } export default App; 执行如下命令： npm start 安装依赖库 npm install --save web3 npm install --save semantic-ui-react npm install --save semantic-ui-css 引用web3.js 实现 在src下创建名为utils的文件夹，并在内部创建文件getWeb3.js import Web3 from 'web3'; let web3; if (typeof window.web3 !== 'undefined') { console.log('found injected web3'); web3 = new Web3(window.web3.currentProvider); } else { console.log('found local web3'); web3 = new Web3('http://localhost:7545'); } export default web3; 调用众筹合约 部署Funding至Simplechain测试网络 获取合约地址： 0x8ff3a13157f1a0aa99beb84d393f1aac4dd470e3 调用Funding合约ABI 获取合约实例 首先在src下创建目录sipc,并创建文件contracts.js。 ABI格式为json格式，可以把ABI拷贝到浏览器的地址栏中格式化为一行再复制回来，这样省空间 import web3 from '../utils/getWeb3'; //将ABI添加到这里 const fundingFactoryABI = [ { \"constant\": true, \"inputs\": [], \"name\": \"platformProv ider\", \"outputs\": [ { \"name\": \"\", \"type\": \"address\" } ], \"payable\": false, \"stateMu tability\": \"view\", \"type\": \"function\" }, { \"constant\": true, \"inputs\": [], \"name\": \"getInvestorFunding\", \"outputs\": [ { \"name\": \"\", \"type\": \"address[]\" } ], \"payable\" : false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": true, \"inpu ts\": [], \"name\": \"getCreatorFunding\", \"outputs\": [ { \"name\": \"\", \"type\": \"address[]\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constan t\": true, \"inputs\": [], \"name\": \"getAllFunding\", \"outputs\": [ { \"name\": \"\", \"type\": \"address[]\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": true, \"inputs\": [ { \"name\": \"\", \"type\": \"uint256\" } ], \"name\": \"crow FundingArray\", \"outputs\": [ { \"name\": \"\", \"type\": \"address\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": true, \"inputs\": [ { \"name\": \"\", \"type\": \"address\" }, { \"name\": \"\", \"type\": \"uint256\" } ], \"name\": \"crea torFundingMap\", \"outputs\": [ { \"name\": \"\", \"type\": \"address\" } ], \"payable\": false, \"stateMutability\": \"view\", \"type\": \"function\" }, { \"constant\": false, \"inputs\": [ { \"name\": \"_projectName\", \"type\": \"string\" }, { \"name\": \"_supportMoney\", \"type\": \"uin t256\" }, { \"name\": \"_goalMoney\", \"type\": \"uint256\" }, { \"name\": \"_duration\", \"type\" : \"uint256\" } ], \"name\": \"createFunding\", \"outputs\": [], \"payable\": false, \"stateMu tability\": \"nonpayable\", \"type\": \"function\" }, { \"inputs\": [], \"payable\": false, \"s tateMutability\": \"nonpayable\", \"type\": \"constructor\" } ]; const fundingFactoryAddress = '0x8ff3a13157f1a0aa99beb84d393f1aac4dd470e3'; //创建fundingFactory合约实例 let fundingFactoryContract = new web3.eth.Contract(fundingFactoryABI, fundingFactor yAddress); let contracts = { fundingFactoryContract, } export default contracts; 整个前端的开发还有很多模块，下面的界面开发步骤图我们可以看到整个界面包括我发起的众筹，所有的众筹，以及我参与的众筹等模块。如下图： 上面的步骤已经实现了整个前端页面的基础框架，以及合约调用案例。其它模块的开发和上面的步骤类似。就不再做详细介绍，可以直接查看源码学习。 "},"31_mining.html":{"url":"31_mining.html","title":"sipc挖矿","keywords":"","body":"挖矿是获取sipc的一种途径，也是参与到Simplechain生态最底层的一个环节。目前支持Simplechain挖矿的矿池有3家。 分别是: Matpool Dxpool Simpool 目前可以挖矿的矿机类型主要有SimpleNode X1,如下图： 购买链接: https://www.suanli.com/ "},"32_miningPool/":{"url":"32_miningPool/","title":"矿池接入","keywords":"","body":"Sipc目前支持3个矿池进行挖矿，分别是: Matpool Dxpool Simpool Simpool矿池挖矿教程 挖矿方式 方式1： 在矿池官网Simpool中注册账户挖矿； 方式2： 用simpleNode（V1.0.0版本）连接矿池挖矿。 Simpool挖矿 矿池注册 注册矿池账户（账户名不要输入中文）；账户注册地址：https://simpool.sipc.vip/enroll 进入「账户管理」设置收款地址（不然系统无法打币）。 链接矿池挖矿： 特别注意的地方： name后面跟的是矿工用户名，格式最好的是 账户名.xxx（矿工名不要有中文）或者直接就是账户名 挖矿的矿工属于哪个账户很重要，收益是根据所对应的账户名下的收款地址去进行分配 下载GPU所需要的文件 地址在这里：https://github.com/simplechain-org/gpuminer/releases （一定要下载最新版，最新版效率更高哦！当前最新版本是1.0.4） 解压修改文件 把压缩文件下载下来之后，解压成文件夹，如下图： 点进去，找到文件start.bat文件，用记事本编辑它： —— gpuplatform 1选择A卡进行挖矿； —— gpuplatform 2选择N卡进行挖矿； —— gpuplatform 3选择混合多卡挖矿。 修改之后保存并关掉，双击start.bat即可链接矿池，成功后的截图： 接入矿池后即可在矿池官网登录自己的矿池账户查看自己收益。 SimpleNode（V1.0.0版本）矿池挖矿 SimpleNode下载地址：https://www.simplechain.com/，根据自己系统选择对应的版本安装，安装成功后启动应用 具体挖矿步骤： 启动SimpleNode，点击右上角“开始挖矿”按钮，出现挖矿方式弹窗 挖矿方式：在挖矿方式弹窗中选择“矿池挖矿”； 矿工名：若未注册过Simpool矿池账户，需要在矿工名右侧点击“点击注册”按钮跳转到Simpool矿池注册页面，注册成功后返回之前SimpleNode挖矿页面；若已注册过Simpool矿池账户，直接在矿工名编辑框处输入矿工名称（矿工名中不要有中文） 显卡类型：选择显卡类型，根据自己电脑的显卡来选择（选择错误，挖矿就没有算力） 特别注意的地方： 在Simpool中注册账户或者添加账户时，账户名不要有中文 矿工名，格式最好的是 账户名.xxx（账户名为Simpool矿池中的账户名）或者直接就是账户名 挖矿的矿工属于哪个账户很重要，收益是根据所对应的账户名下的收款地址去进行分配 点击确定按钮，就可以进行挖矿了，可以在右上角中点击查看收益进行查看自己的收益情况 "},"33_gpuMining/":{"url":"33_gpuMining/","title":"GPU挖矿","keywords":"","body":"Window版本 注：该GPU挖矿只支持链接矿池 SImpool网址：https://simpool.vip GPU挖矿所需要的软件下载：http://suo.im/5E6IrE 矿池注册流程： 第一步：注册矿池账户（用户名最好是英文）； 第二步：进入账户设置； 第三步：在个人中心设计收款地址（不然系统没办法打币）； 特别注意的地方： 账户名称很重要，name后面跟的一定是矿池后面的账户用户名。 下载GPU所需要的文件 下载地址：https://github.com/simplechain-org/gpuminer/releases（一定要下载最新版，最新版效率更高哦！最新版本是1.0.3） 解压修改文件 把压缩文件解压成文件夹。点进去，找到文件start.bat文件，用记事本编辑它： 修改完之后，双击start.bat即可链接矿池，成功后的截图： 接入矿池后即可在各个矿池官网登录自己的矿池账户查看自己收益。 Mac版本 SimpleChain 官方GPU挖矿教程（MAC） 注：该GPU挖矿只支持链接矿池 SImpool网址：https://simpool.vip GPU挖矿所需要的软件下载：http://suo.im/5E6IrE 矿池注册流程： 第一步：注册矿池账户（用户名最好是英文）； 第二步：进入账户设置； 第三步：在个人中心设计收款地址（不然系统没办法打币）； 特别注意的地方 账户名称很重要，name后面跟的一定是矿池后面的账户用户名。 下载GPU所需要的文件 下载地址：hhttp://suo.im/5E6IrE 解压修改文件 把压缩文件解压成文件，放到桌面： 然后打开命令行模式，找到终端、终端在实用工具里： 先用cd desktop进入桌面（默认刚刚下载的文件在桌面），然后获得操作刚刚下载文件的权限，chmod +x gpuminer（如果文件在桌面，负责粘贴就可以用！）： 获得权限后，输入命令启动文件： ./gpuminer –server simpool.vip:8801 –name abc(118.31.45.65:8801是矿池地址，每个矿池的地址不一样，abc是账户名称,一定填自己账户。)运行成功后： "},"34_SimPool/":{"url":"34_SimPool/","title":"Simpool挖矿","keywords":"","body":"Simpool矿池挖矿教程 挖矿方式 方式1: 在矿池官网Simpool中注册账户挖矿。 方式2: 用simpleNode（V1.0.0版本）连接矿池挖矿。 矿池注册 注册矿池账户（账户名不要输入中文); 账户注册地址：https://simpool.sipc.vip/enroll 进入「账户管理」设置收款地址（不然系统无法打币）。 链接矿池挖矿 特别注意的地方： name后面跟的是矿工用户名，格式最好的是 账户名.xxx（矿工名不要有中文）或者直接就是账户名 挖矿的矿工属于哪个账户很重要，收益是根据所对应的账户名下的收款地址去进行分配 下载GPU所需要的文件 地址在这里：https://github.com/simplechain-org/gpuminer/releases（一定要下载最新版，最新版效率更高哦！`最新版本是1.0.4`） 解压修改文件 把压缩文件下载下来之后，解压成文件夹。点进去，找到文件start.bat文件，用记事本编辑它： -gpuplatform 1选择A卡进行挖矿； -gpuplatform 2选择N卡进行挖矿； -gpuplatform 3选择混合多卡挖矿。 修改之后保存并关掉，双击start.bat即可链接矿池，成功后截图。接入矿池后即可在矿池官网登录自己的矿池账户查看自己收益。 SimpleNode（V1.0.0版本）矿池挖矿 SimpleNode下载地址：https://www.simplechain.com/，根据自己系统选择对应的版本安装，安装成功后启动应用。 具体挖矿步骤： 一. 启动SimpleNode，点击右上角“开始挖矿”按钮，出现挖矿方式弹窗 二. 挖矿方式选择: 挖矿方式：在挖矿方式弹窗中选择“矿池挖矿”； 矿工名：若未注册过Simpool矿池账户，需要在矿工名右侧点击“点击注册”按钮跳转到Simpool矿池注册页面，注册成功后返回之前SimpleNode挖矿页面；若已注册过Simpool矿池账户，直接在矿工名编辑框处输入矿工名称（矿工名中不要有中文） 显卡类型：选择显卡类型，根据自己电脑的显卡来选择（选择错误，挖矿就没有算力） 特别注意的地方： 在Simpool中注册账户或者添加账户时，账户名不要有中文 矿工名，格式最好的是 账户名.xxx（账户名为Simpool矿池中的账户名）或者直接就是账户名 挖矿的矿工属于哪个账户很重要，收益是根据所对应的账户名下的收款地址去进行分配 三. 点击确定按钮，就可以进行挖矿了，可以在右上角中点击查看收益进行查看自己的收益情况 "},"35_SimpleNode_x1/":{"url":"35_SimpleNode_x1/","title":"SimpleNode x1挖矿教程","keywords":"","body":"当拿到矿机之后，需要完成以下三步，就可以让矿机运转起来，挖出收益！ 准备SimpleNode软件 安装矿机驱动（Windows系统需要安装，MacOS和Linux无需安装） 加入官方矿池Simpool,开始挖矿！ 准备SimpleNode软件 到SimpleChain官网（www.simplechain.com），找到SimpleNode，根据您的电脑系统下载相应版本的安装程序 打开SimpleNode安装程序，根据提示完成安装 完成安装后，运行SimpleNode 数据同步完成后，请根据提示新建账户或者导入已有账户。创建账户之后请做好备份，保证您的资金安全！ 安装矿机驱动 Windows系统需要安装，MacOS和Linux无需安装 创建好账户后，在SimpleNode软件中选择“矿机挖矿”后面的“Solo挖矿”或者“矿池挖矿”，弹出提示框，点击 “矿机驱动”蓝色字样，自动下载矿机驱动安装包。 矿机驱动安装包为压缩文件，请解压文件。解压文件后点击”stmicroel_virtual_131_64”应用程序开始安装矿机驱动。 根据安装向导提示，完成矿机驱动的安装。 开始挖矿！ 驱动安装完成后，插入矿机，重新到SimpleNode软件中选择“矿机挖矿”后面的“Solo挖矿”或者“矿池挖矿”，即可开始矿机挖矿、盆满钵满之旅！ 推荐使用“矿池挖矿”方式，加入官方矿池Simpool，收益更多！选择这种方式需要到官方矿池Simpool注册账户。 点击“矿机挖矿“后面的”矿池挖矿“，点击蓝色字样”点击注册“进入官方矿池Simpool注册页面 根据提示完成Simpool账号注册 注册成功后，在左侧导航栏找到“账户管理”，点击进入 点击右上角的“新增挖矿账户”；需要您输入“账户名称”和“SIPC支付地址” 账户名称：支持英文大小写字母及数字（不支持汉字哦！） SIPC支付地址：该地址即为挖矿收益的接收地址，请填写自己的SIPC钱包账户地址 您的钱包账户地址，可以在SimpleNode里面查看；如果您有在使用官方推出的Chainbox钱包和sipc.vip数字资源平台，也可以填入其中您的地址（注意：请正确填入您本人的、支持SIPC的地址，挖矿收益将会打到该地址！） 在Simpool中的操作完成后，回到SimpleNode软件，重新点击“矿机挖矿”后面的“矿池挖矿”，填入矿工名（矿工名即为刚刚在Simpool新增挖矿账户时填写的“账户名称”），点击确认后，点击确认后，挖矿就开始了（矿机的蓝色灯呈闪烁状态）！ "},"36_SIPC.html":{"url":"36_SIPC.html","title":"SIPC.VIP","keywords":"","body":"当拿到矿机之后，需要完成以下三步，就可以让矿机运转起来，挖出收益！ 准备SimpleNode软件 安装矿机驱动（Windows系统需要安装，MacOS和Linux无需安装） 加入官方矿池Simpool,开始挖矿！ 准备SimpleNode软件 到SimpleChain官网（www.simplechain.com），找到SimpleNode，根据您的电脑系统下载相应版本的安装程序 打开SimpleNode安装程序，根据提示完成安装 完成安装后，运行SimpleNode 数据同步完成后，请根据提示新建账户或者导入已有账户。创建账户之后请做好备份，保证您的资金安全！ 安装矿机驱动 Windows系统需要安装，MacOS和Linux无需安装 创建好账户后，在SimpleNode软件中选择“矿机挖矿”后面的“Solo挖矿”或者“矿池挖矿”，弹出提示框，点击 “矿机驱动”蓝色字样，自动下载矿机驱动安装包。 矿机驱动安装包为压缩文件，请解压文件。解压文件后点击”stmicroel_virtual_131_64”应用程序开始安装矿机驱动。 根据安装向导提示，完成矿机驱动的安装。 开始挖矿！ 驱动安装完成后，插入矿机，重新到SimpleNode软件中选择“矿机挖矿”后面的“Solo挖矿”或者“矿池挖矿”，即可开始矿机挖矿、盆满钵满之旅！ 推荐使用“矿池挖矿”方式，加入官方矿池Simpool，收益更多！选择这种方式需要到官方矿池Simpool注册账户。 点击“矿机挖矿“后面的”矿池挖矿“，点击蓝色字样”点击注册“进入官方矿池Simpool注册页面 根据提示完成Simpool账号注册 注册成功后，在左侧导航栏找到“账户管理”，点击进入 点击右上角的“新增挖矿账户”；需要您输入“账户名称”和“SIPC支付地址” 账户名称：支持英文大小写字母及数字（不支持汉字哦！） SIPC支付地址：该地址即为挖矿收益的接收地址，请填写自己的SIPC钱包账户地址 您的钱包账户地址，可以在SimpleNode里面查看；如果您有在使用官方推出的Chainbox钱包和sipc.vip数字资源平台，也可以填入其中您的地址（注意：请正确填入您本人的、支持SIPC的地址，挖矿收益将会打到该地址！） 在Simpool中的操作完成后，回到SimpleNode软件，重新点击“矿机挖矿”后面的“矿池挖矿”，填入矿工名（矿工名即为刚刚在Simpool新增挖矿账户时填写的“账户名称”），点击确认后，点击确认后，挖矿就开始了（矿机的蓝色灯呈闪烁状态）！ "},"37_wallet/":{"url":"37_wallet/","title":"sipc全节点钱包","keywords":"","body":" 打开Simplechain的官网,然后下拉找到SimpleNode模块，如下图： 目前全节点钱包有三种版本，分别是windows,Mac OS, Linux。据自己的电脑(服务器)系统下载对应的版本，下载后按照提示安装步骤进行安装。下面以苹果电脑为例：下载 Mac OS 的安装包以后，解压文件就可以看到钱包的logo。然后点击打开，如下图： 打开钱包以后，会看到钱包页面在提示：正在链接节点，如下图： 连接好节点以后，我们可以看到桌面钱包提示正在同步区块数据。点击跳过，就可以直接进入钱包。如下图： 进入钱包以后，如果你已经使用过钱包，可以选择导入账户，如果你是第一次使用钱包。则需要点击创建账户，如下图： 如果选择导入账户，则出现3种导入钱包的方式，分别是keystore文件导入, keystore明文导入，私钥导入。你可以根据自己有的私钥形式进行导入。 如果是第一次使用SimpleNode，则需要创建账户。只需要设置自己钱包的密码以及确认密码，确认后钱包就创建成功。 创建成功，我们就可以看到钱包账户地址，防止我们忘记密码导致钱包丢失。所以应立即备份。如下图： 我这里点击的是备份私钥，也可以选择备份keystore文件。 然后就可以看到我们备份的私钥信息。然后点击开启SimpleNode,就进入了钱包。 进入钱包以后，就可以看到自己的SIPC总数，当前同步的区块高度，以及钱包地址。点击收款码就可以用来接收SIPC，如下图： 当然也可以用来转账，点击转账按钮就出现转账页面，输入对应接收人的地址，转SIPC的数量。以及调节Gas费用，就可以进行转账。如下图： "},"38_ChainBox/":{"url":"38_ChainBox/","title":"ChainBox","keywords":"","body":"下载ChainBox钱包 苹果安卓安装地址: https://www.simplechain.com/download或者扫描下方二维码进行下载。 IOS安装完成后，请: 打开设置———通用———设备管理———Broadway International Sp . z.o.o———信任应用———回到桌面打开钱包APP———创建注册。 创建注册钱包 先输入钱包名称（中英文都可），再输入钱包密码（至少8位，同时包含数字和字母），其次勾选协议，最后点击创建钱包，钱包创建完成。 钱包创建成功 备份钱包：记下助记词，下一步辅助验证助记词正确与否（助记词只可截图，不可复制），按照顺序无误输入助记词，确认。---创建成功跳转至钱包页面 如果想快速进入钱包页面--可选右上角暂不备份直接跳转至钱包页面---下次可在钱包设置中备份钱包（强烈建议先备份） 导入钱包（左上角功能键进入） 如果你曾经下载过ChainBox钱包且创建过钱包，你可以选择导入你曾经的钱包。 可以用助记词，官方钱包（keystore），私钥，任意一种方式导入，然后重新设置密码。 钱包列表（左上角功能键进入） 你创建或导入的多个钱包，在钱包列表里可以一目了然看到：钱包资产，钱包地址。 同时也可以在钱包总览里选择你导入或创建的某个钱包。 钱包设置（左上角功能键进入） 1.可以修改钱包名称，修改密码； 如果你需要导出钱包，可以在钱包设置里导出私钥，keystore，备份助记词 如果你有多余的钱包，想删除也是可以从钱包设置中底下删除钱包 转账/收款（左上角功能键进入） 在钱包里点击SIPC，进入详情页面：转账/收款 点击转账：普通转账/离线转账（额外备注转账高级选项中Data数据就是转账备注，一般情况下不写，因为备注信息gas费大幅度增加） 普通转账（热钱包功能）：填写对方地址，数量，矿工费。下一步输入密码。 [离线转账（冷钱包功能）：填写转账地址，收账地址，转账数量，矿工费。 通用：联系人/消息中心/检查更新（左上角功能键进入） 联系人：添加常用转账地址，便于二次转账。 消息中心：可以看到转账，收款信息汇总 检查更新：检查更新最新钱包版本 "},"39_blockBrowser/":{"url":"39_blockBrowser/","title":"Explore","keywords":"","body":"Visit the browser: Browser Address Open the Blockchain browser and switch to the Main NetWork or Test NetWork as needed. As shown below: Block search Information about all blocks-from Genesis blocks to all current blocks-can be found on this page, including the block height, its previous block, and the corresponding byte size. Transaction search You can search for transaction records on this page. You can find the information with the sending transaction address and receiving address, the number of sipcs transmitted, the block height of the transaction record, the corresponding hash and the production time. You can also use the search bar to find specific transactions for hashes. View uncle block On this page, you can view the height of each block, the block height corresponding to its uncle block, the block time, and the rewards of packaged miners and miners. As shown below: Verification contract If you want to verify the contract, enter the contract address to be verified, and select the contract compiler type and compiler version to verify the contract. As shown below: List of verified contracts Click the verify contract list to view the information of 20 verified contracts. The information shows the contract address, contract name, compiler, version, account balance, verification time, etc! There are three verification methods for contract verification: Single file verification method Multi-file authentication method Json file validation method Single file verification pragma solidity ^0.5.12; contract PayALL{ event PayLog(address name,uint reward); event PayLog2(address name); constructor() public payable{ } function() external payable{ emit PayLog(msg.sender, msg.value); } function setMethd() public payable { emit PayLog2(msg.sender); } } Paste source code: After the verification is passed： Multi-file verification Because in the contract writing process, the dependency of the file can refer to another file. // test1.sol文件 pragma solidity ^0.5.17; contract Hello { uint value; function hello() public pure returns(string memory){ return \"hello world_1\"; } function set(uint x) public { value = x; } } // test2.sol文件 pragma solidity ^0.5.17; import {Hello} from \"./test1.sol\" ; contract Test2 is Hello { function test() public pure returns(string memory){ return Hello.hello(); } } Execution result: This type of authentication is used for multi-file authentication. The verification method is as follows to obtain the deployed contract address: 0x6e1ace6e6cf09a4ab096f272cfc029c0a1d883ac Optimizationit refers to the number of contract compilation times. The number of optimized times is selected for contract deployment. Therefore, the corresponding number of times must be selected for verification. By default, no optimization is performed. Constructor Arguments ABI-encoded indicates whether the contract has construction parameters. The construction parameters are generated during deployment. You do not need to fill in the construction parameters for verification. Contract Library Address When it comes to library contracts, ordinary contracts are not filled in. Details of this type of verification will be added later. View verification successful Multi-file contract source code after current verification The source code is displayed in json format, including two file source codes. Json file validation: The Json file verification method is relatively copied. You need to know the compilation parameters of solidity. solidity compiles the json file passed by the user, provided that the json file meets the compilation requirements. Json file： { \"language\": \"Solidity\", \"sources\": { \"myFile.sol\": { \"content\": \"pragma solidity ^0.5.12;contract Multiply7 { event Print(uint); event CjLog(address, uint); uint public a ; uint public b ; constructor (uint _a, uint _b) public { a = _a; b = _b; } function multiply(uint input1) public view returns (uint) { return input1 * 6 + a + b; } function multiplyplus(uint input1, uint input2) public returns (uint) { emit Print(input1 * 6 * input2); emit CjLog(msg.sender, a+b); return input1 * 6 * input2 + a + b; }}\" } }, \"settings\": { \"metadata\": { \"useLiteralContent\": true }, \"outputSelection\": { \"*\": { \"*\": [ \"*\" ], \"\": [ \"ast\" ] } } } } Library contract verification First of all, understand what is a library contract Browser support library the contract verification of the library,Library during the deployment process, contracts are deployed in sequence and nested. All contracts are deployed with multiple contracts (including library libraries inside the contracts, which are deployed together) and multiple hash records are generated. Contract source code: /** *Submitted for verification at Etherscan.io on 2020-02-27 */ pragma solidity ^0.6.0; library SetHFG { // 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。 struct Data { mapping(uint => bool) flags; } // 注意第一个参数是“storage reference”类型，因此在调用中参数传递的只是它的存储地址而不是内容。 // 这是库函数的一个特性。如果该函数可以被视为对象的方法，则习惯称第一个参数为 `self` 。 function insert(Data storage self, uint value) public returns (bool) { if (self.flags[value]) return false; // 已经存在 self.flags[value] = true; Acc.hi(); return true; } the following is the deployment record: CHU as the main contract: 0x1c622ed2035acc8514259788caafb3cf69d9bbe3 The contract address of the Library is: Bcc：0x0da8bd0dd96f78ac6e155b2d5e9fb6d15ca89fad Fcc：0x7b05897e605a3878d3511069924d750ef3954da5 Acc：0x13a6cb372333394caa8ea0e5876a4a52167a95ce SetHFG: 0x5386710eb4d02b41e7a253d3ebb00ca8795c930f Verification way and single-file same, as shown below: Verification passed "},"40_tradePlateform.html":{"url":"40_tradePlateform.html","title":"交易所对接","keywords":"","body":"搭建SimpleChain节点 docker 搭建 获取镜像： docker pull simplechain/sipe:latest 开启RPC docker run -it -p 8545:8545 -p 30312:30312 simplechain/sipe --rpc --rpcaddr \"0.0.0.0\" 可以通过以下命令查看自己的节点是否启动成功： curl -X POST localhost:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":68}' 源码搭建 前期准备:Go 语言环境(1.10 或以上版本)、C 语言编译器 1.下载 SimpleChain 可以通过 git 将项目 clone 到本地，也可以在 https://github.com/simplechain-org/go- simplechain 页面直接下载。 git clone https://github.com/simplechain-org/go-simplechain.git 2.安装 sipe 1.进入 go-simplechain 根目录。 cd go-simplechain 2.使用 make 工具安装 sipe。 make sipe >>> /usr/local/go/bin/go install -ldflags -X main.gitCommit=9d73f67e1dc5587a95f52c13fee93be6434b42ac -s -v ./cmd/sipe github.com/simplechain-org/go-simplechain/core ... github.com/simplechain-org/go-simplechain/cmd/sipe Done building. Run \"/Users/yuanchao/go/src/github.com/simplechain-org/go-simplechain/build/bin/sipe\" to launch sipe. 当终端出现以上输出时，表示 make 执行成功，此时在 go-simplechain/build/bin 目录下 将会生成 sipe 可执行文件。可以将其移动到任何目录下或将其加入到环境变量中，以此 来便利得运行sipe程序。 启动sipe 1.创建用于存储节点数据的文件夹,如果不 mkdir chaindata 2.启动sipe主网节点 开启 RPC 服务并指定 RPC 监听地址为 127.0.0.1，端口 8545。节点数据存储目录为 chaindata ./sipe --rpc --rpcaddr 127.0.0.1 --rpcport 8545 --datadir chaindata 当出现类似以下输出时，表示启动成功，并开始同步 SimpleChain 主网区块。 INFO [06-19|09:35:01.481] Maximum peer count ETH=25 LES=0 total=25 INFO [06-19|09:35:01.492] Starting peer-to-peer node instance=Sipe/v1.0.2-stable-0cbf2a41/darwin-amd64/go1.12.1 ... INFO [06-19|09:35:33.700] Block synchronisation started INFO [06-19|09:35:36.756] Imported new block headers count=192\\ elapsed=22.273ms number=192 hash=bb758a...bea1b6 ignored=0 社区节点 rpc地址和端口号： 47.110.48.207:8545 测试： //Request curl -X POST 47.110.48.207:8545 -H \"Content-Type:application/json\" --data '{\"jsonrpc\":\"2.0\",\"method\":\"web3_clientVersion\",\"params\":[],\"id\":68}' //Response { \"jsonrpc\": \"2.0\", \"id\": 68, \"result\": \"Sipe/v1.1.0-stable-0800d402/linux-amd64/go1.14.1\" } 连接SimpleChain节点 创建一个 sipc.js，然后编写如下代码： const config = require('../../config') //节点服务器的配置信息 const Web3 = require('web3') module.exports = new Web3(config.uri) 创建SimpleChain钱包服务 现在开始进入Simplechain钱包服务的核心特性开发阶段。 创建新的Simplechain账户 交易所和支付网关需要为客户生成新地址，以便用户可以向服务充值，或者为产品付费。生成一个没有用过的sipc地址是任何数字资产服务的基本需求，因此看一下具体实现。 首先，创建一个commands.js，在其中我们订阅队列中的消息。主要包括以下几个步骤： 连接到command主题，监听新的create_account命令 当收到新的create_account命令时，创建新的密钥对并存入密码库 生成account_created消息并发送到队列的account_created主题 代码如下： const web3 = require(\"./ethereum\") /** * Create a new ethereum address and return the address */ async function create_account(meta = {}) { // generate the address const account = await web3.eth.accounts.create() // disable checksum when storing the address const address = account.address.toLowerCase() // save the public address in Redis without any transactions received yet await redis.setAsync(`eth:address:public:${address}`, JSON.stringify({})) // Store the private key in a vault. // For demo purposes we use the same Redis instance, but this should be changed in production await redis.setAsync(`eth:address:private:${address}`, account.privateKey) return Object.assign({}, meta, {address: account.address}) } module.exports.listen_to_commands = listen_to_commands 处理新交易 我们的钱包还没写完，当我们创建的地址收到用户充值时应当得到通知才对。为此，Simplechain的web3客户端提供了newBlockHeaders订阅机制。此外，如果我们的服务偶然宕机，那么服务就会错过在宕机期间生产的区块，因此我们还需要检查钱包是否已经同步到了网络的最新区块。 创建 sync_blocks.js 文件，编写如下代码： const web3 = require('./ethereum') /** * Sync blocks and start listening for new blocks * @param {Number} current_block_number - The last block processed * @param {Object} opts - A list of options with callbacks for events */ async function sync_blocks(current_block_number, opts) { // first sync the wallet to the latest block let latest_block_number = await web3.eth.getBlockNumber() let synced_block_number = await sync_to_block(current_block_number, latest_block_number, opts) // subscribe to new blocks web3.eth.subscribe('newBlockHeaders', (error, result) => error && console.log(error)) .on(\"data\", async function(blockHeader) { return await process_block(blockHeader.number, opts) }) return synced_block_number } // Load all data about the given block and call the callbacks if defined async function process_block(block_hash_or_id, opts) { // load block information by id or hash const block = await web3.eth.getBlock(block_hash_or_id, true) // call the onTransactions callback if defined opts.onTransactions ? opts.onTransactions(block.transactions) : null; // call the onBlock callback if defined opts.onBlock ? opts.onBlock(block_hash_or_id) : null; return block } // Traverse all unprocessed blocks between the current index and the lastest block number async function sync_to_block(index, latest, opts) { if (index >= latest) { return index; } await process_block(index + 1, opts) return await sync_to_block(index + 1, latest, opts) } module.exports = sync_blocks 在上面的代码中，我们从钱包服务之前处理的最新区块开始，一直同步到区块链的当前最新区块。一旦我们同步到最新区块，就开始订阅新区块事件。对于每一个区块，我们都执行如下的回调函数以处理区块头以及区块中的交易列表： onTransactions onBlock 通常包含如下的处理步骤： 监听新区块，获取区块中的全部交易 过滤掉与钱包地址无关的交易 将每个相关的交易都发往队列 将地址上的资金归集到安全的存储 更新已处理的区块编号 最终的代码如下： const web3 = require(\"web3\") //调用web3 const redis = require('./redis') //调用redis数据库，将区块数据获取下来存入redis数据库中 const queue = require('./queue') //调用消息队列 const sync_blocks = require('./sync_blocks') //同步区块 /** * Start syncing blocks and listen for new transactions on the blockchain */ async function start_syncing_blocks() { // start from the last block number processed or 0 (you can use the current block before deploying for the first time) let last_block_number = await redis.getAsync('eth:last-block') last_block_number = last_block_number || 0 // start syncing blocks sync_blocks(last_block_number, { // for every new block update the latest block value in redis onBlock: update_block_head, // for new transactions check each transaction and see if it's new onTransactions: async (transactions) => { for (let i in transactions) { await process_transaction(transactions[i]) } } }) } // save the lastest block on redis async function update_block_head(head) { return await redis.setAsync('eth:last-block', head) } // process a new transaction async function process_transaction(transaction) { const address = transaction.to.toLowerCase() const amount_in_ether = web3.utils.fromWei(transaction.value) // check if the receiving address has been generated by our wallet const watched_address = await redis.existsAsync(`eth:address:public:${address}`) if (watched_address !== 1) { return false } // then check if it's a new transaction that should be taken into account const transaction_exists = await redis.existsAsync(`eth:address:public:${address}`) if (transaction_exists === 1) { return false } // update the list of transactions for that address const data = await redis.getAsync(`eth:address:public:${address}`) let addr_data = JSON.parse(data) addr_data[transaction.hash] = { value: amount_in_ether } await redis.setAsync(`eth:address:public:${address}`, JSON.stringify(addr_data)) await redis.setAsync(`eth:transaction:${transaction.hash}`, transaction) // move funds to the cold wallet address // const cold_txid = await move_to_cold_storage(address, amount_in_ether) // send notification to the kafka server await queue_producer.send('transaction', [{ txid: transaction.hash, value: amount_in_ether, to: transaction.to, from: transaction.from, //cold_txid: cold_txid, }]) return true } module.exports = start_syncing_blocks 总结 我们已经完成了交易所Simplechain钱包服务的设计与实现，这个服务还可以从以下几个方面加以改进： 增加错误处理 增加命令类型 交易签名与交易广播 部署合约 "},"41_commityProduct.html":{"url":"41_commityProduct.html","title":"社区项目","keywords":"","body":"Simplechain作为一个社区开源项目，长期以来受到很多社区开发者的支持。下面是社区开发这贡献的一些优秀的项目： SDK Java-SDK Python-SDK JavaScript-SDK Google 插件钱包 插件钱包下载及使用教程 "},"42_commityActity.html":{"url":"42_commityActity.html","title":"社区活动","keywords":"","body":"Hello! 欢迎来到Simplechain技术社区，感谢你们一直以来对Simplechain的支持! 我们社区活动以及激励计划会每季度更新，请持续关注。 参与SimpleChain开源共建 欢迎参与 Simplechain 开源社区共建，您可以通过以下的方式参与共建： 参与代码或文档贡献 Fork，fork 项目到自己的 Github 账户，； Clone，clone 项目到本地开发环境； Hack，hack 代码或文档（创建新分支完成更新）； Push，push 已经 commit 的分支到远程 Github 账户； PR，创建新的 pull request 完成贡献； 文档， 编写文档库，整理基础工具使用相关的文档； 参与技术社区布道 文稿征集: 原创Simplechain相关文章并成功在渠道发布以上。 技术短视频: 剪辑关于Simplechain的短视频，并发布在相关平台。 社区节点搭建:搭建Simplechain节点，对外公开IP地址和端口号，方便社区开发者直接使用。 活跃技术社区:在技术社区引导话题，活跃技术社区气氛（比如微博超话） 社区项目贡献 参与社区项目贡献主要有两种形式； 开发者可以基于Simplechain自己选择开发。不需要跟官方进行沟通，这种是没有任何激励的。纯属于社区开发者个人行为，与Simplechain技术社区无关。 开发者觉得某一基础工具对于Simplechain的发展很有必要，但是目前还没有。可以反馈给技术社区负责人，经技术人员评估觉得有必要。就可进行开发，开发者还将获得一定的代币激励。 社区任务 BUG猎人 寻找Simplechain的bug并在github上提交，获得核心团队评估肯定以后，会根据bug的严重程度予以不同的奖励。 落地小能手 企业落地 负责SimpleChain跟企业的合作，主要负责宣传讲解SimpleChain的技术以及落地案例。与企业达成合作，以及后期合作过程中的技术支持工作。经Simplechain基金会评估达标后将获得丰厚奖金。 政务合作 对接Simplechain跟政府项目合作，负责与政府沟通。给政府人员做基于SimpleChain的区块链培训，并达成政务合作。经Simplechain基金会评估达标后将获得丰厚奖金。 社区KOL SimpleChain技术社区长期招募KOL，欢迎广大开发者积极参与到SimpleChian的技术生态当中。每季度根据个人表现会发放一定的激励。 社区KOL的主要工作如下： 组织开发者，基于SimpleChain开发，并提供技术支持。以及后期项目的跟踪推进。 组建开发者社群，分享SimpleChain的相关技术，并活跃社群气氛。以及开发者关系维护。 发布技术文章，技术视屏。成为内容创作者和输出者。 "},"43_commityEnters/":{"url":"43_commityEnters/","title":"社区入口","keywords":"","body":"SimpleChain是一个由社区主导，对外开源的公有底层区块链平台，由SimpleChain基金会成立的开源工作组与技术社区成员写作打造。 Simplechain资源列表 Github主页 技术文档 深度解析系列文章 贡献代码 反馈问题 应用案例集合 加入Simlechain社区 "},"44_case.html":{"url":"44_case.html","title":"落地案例","keywords":"","body":"SimpleChain（SIPC）是一款以“简单上链、共促共赢”为设计理念的公有链。作为一项革命性的区块链应用基础设施设计，上链支持主链底层共识—POW算法，子链通过支持多元共识和性能要求来保障平稳安全运行，从而满足丰富的商业应用场景。通过体系化工具模组为各类应用场景提供简便的配置、部署与开发环境，实现简单上链。在区块链应用的道路上SimpleChain正在探索更广阔的空间，并在司法存证、文化版权、游戏娱乐、场景支付等多重领域成绩斐然。从Simplechain主网上线以来，经过社区开发者的共同努力。基于Simplechain开发的应用越来越多，下面是一些详细的落地案例。 司法存证： “全国首例区块链存证案例”的独家技术支持方保全网作为基于SimpleChain底层技术的首条司法领域子链——保全链，与数家律所和司法鉴定机构达成合作外，更与国内三大互联网法院及全国首家互联网公证处建立紧密联系，其5.0版本的中国标准院测评报告也即将发布； 文化版权： 除子链保全网（保全链）为国内诸如维权骑士、好剧邦、巴比特等文化传媒公司提供“区块链+”存证服务外，也与一站式小说阅读和版权投资平台版趣达成深度合作； 游戏娱乐： 海外游戏平台GWC在SimpleChain上做了一套基于游戏行业信用评级、质量评分的体系，参与者可以通过对游戏及其制作团队打分，获得相应的游戏运营分红； 场景支付： SimpleChain团队与浙大创业团队共同打造了全球首款区块链智能咖啡机，其咖啡机已被陆续投放在共享办公空间、独立创业公司等场所，其系统支持SIPC支付，无需拥有微信、支付宝等中心化支付工具，即可享受最便捷的区块链支付方式。 公益慈善： SimplecChain继携手数秦科技保全网捐赠溯源平台，向武汉九州通人寿堂养老院、浙江大学医学院附属第二医院等机构捐赠万余件防护服，以支援一线医护人员。通过区块链技术实现了捐赠物资流转过程、时间节点的全流程存证、记录与跟踪，为疫情中慈善捐赠提供全流程上链解决方案。同时，还与与Bithelp全球性的数字公益平台达成战略合作协议，共同发起了公益募捐活动。 社交电商： SimpleChain帮助精品社交电商平台全球时刻打造“区块链+社交电商”模式，将平台商户、电商平台、社群用户三者生态关系打通，改变了以往平台中心化的模式，三方利益生态将会被重新整合，他们将共同参与整个利益链条，而且是作为平等的关系存在。 资产加密： SimpleChain与Keystore 合作，共同推进区块链技术和应用的发展。双方在资产托管、节点服务、市场拓展等领域展开合作，携手拓展企业级加密资产服务市场。 "},"45_faq.html":{"url":"45_faq.html","title":"FAQ","keywords":"","body":"矿池相关问题 1.收款地址我该填什么？ 建议填写SIPC钱包地址，因为你掌握了币种的私钥，是更安全的。 2.SimPool 可以挖哪些币？ 当前支持SIPC挖矿。 3. 如何挖矿？ 大致步骤为：注册账户——创建挖矿账户——配置电脑——查看收益。具体步骤见SIPC挖矿教程。 4. 我的算力有多高？ 实际连接上矿池挖矿后的算力不一定等于标称算力，具体以矿池显示算力为准。 5. 为什么我的收益在减少？ 首先确认以下几点： (1) 挖矿设备是否正常运行； (2) 挖矿配置是否正确； (3) 网络连接是否正常； (4) 挖矿难度是否变化（若难度变动之后收益会有波动）；并且随着挖矿设备的增多、全网算力的增加，挖矿难度会增大，单个设备挖矿收益会逐渐变少。 5. 每日收益什么时候结算？ 每个小时进行一次整点结算，然后凌晨12点打币，个人收益（每小时）具体计算方法如下： 矿池收益=矿池平均算力/全网算力*全网每天产出SIPC数+叔快收益； 个人收益=个人接受数总和/全网接受数*矿池收益； 6. 为什么有时候网络不稳定？ 有时候会有技术上的调整，调整的时候不太稳定，但是调整一般30分钟到2小时就能解决；也有可能有攻击，攻击有针对比特币网络的攻击，也有针对矿池服务器的攻击。如果是个人网络问题，则需要个人调试解决或寻求网络运营商的帮助。 7. 算力下降了怎么办？ 请您先检查如下问题: (1) 挖矿设备是否正常运行； (2) 挖矿配置是否正确； (3) 网络连接是否正常； 上述故障排除后算力仍然下降请在Simpool群内找客服解决。 8. 什么是工作量？网络难度是什么？ 工作量是指矿工为挖取新块付出的算力贡献，网络难度是指全网爆块的计算难度，它会根据所有矿工的算力总和动态调整。 9. 矿池有哪几种结算方式？ 目前矿池采用PPLNS结算方式（全称Pay Per Last N Shares），意思是说“依据过去的N个股份来支付收益”。这意味着，全部的矿工一旦发现了一个区块，大家将依据每一个人自己贡献的股份数量占比来分配区块中的货币。 10. 没有设置收款地址收益会丢失吗？ 若你没有填写收款地址，你的收益会暂时存放在Simpool账户里。等你设置地址后，我们会在地址生效后给你支付收益。 11. 用SimpleNode钱包选择矿池挖矿时，高级选项显卡参数怎么设置？ 已知显卡调优参数： (1) NVIDIA GTX-750-Ti gpuplatform=2, memsize=1999, globalworksize=10240, localworksize=512, lookupgap=4 (2) AMD Ellesmere RX 570 gpuplatform=1, memsize=2048, globalworksize=8000, localworksize=64, lookupgap=2 (3) GeForce GT 1030 gpuplatform=2, memsize=2048, globalworksize=4096, localworksize=64, lookupgap=4 gpuplatform: AMD显卡填1, NVIDIA显卡填2 memsize: 筛选不小于这个显存容量(默认2048MB)的显卡，NVIDIA GTX-750-Ti 显存是1999MB globalworksize: 并行计算项，一般是1024的倍数，最大不能大于显卡的Max work item sizes ，但调优时，AMD的RX570设置8000效率最高。 localworksize: 每个显卡计算单元的工作项，一般是64/128/256/512，globalworksize/localworksize不能大于显卡支持的 Max work group size lookupgap: 这个值最后调，取值范围1/2/4/8，默认是2，在性能与显存之间做调整。等于1时，用的显存最多，以此为基准，等于2时用其二分之一，等于8时用其八分之一。 SimpleNode X1 1.一个账户可以多关联几台矿机吗？ 可以，只要保证矿机的供电量充足，一台电脑上可以串联多台矿机。 如果使用Solo挖矿方式，则收益直接打入挖矿的账户地址； 如果使用矿池挖矿方式，则收益打入与矿工关联的账户地址。 2.关联多台矿机后，如何查看各台矿机的状态？ 如有多台矿机同时挖矿，在SimpleNode软件上点击“停止挖矿”后面的小箭头即可查看各台矿机的状态。 3.家里的网络和电脑最多可以拖几台矿机？ 网络带宽对矿机影响较小，只要保证SimpleNode能连上Simpool矿池即可；只要保证矿机的供电量充足，每台电脑可以串联多台矿机，一般最多可支持2-3台左右；增加需要外接电源。 "},"46_supportOnline/":{"url":"46_supportOnline/","title":"在线技术支持","keywords":"","body":"开发者电报社群： 一对一技术支持： "},"39_bolckBrowser/":{"url":"39_bolckBrowser/","title":"区块链浏览器","keywords":"","body":"访问浏览器: 浏览器地址 打开区块链浏览器，根据自己的需要切换 Main NetWork(主网) 或者 Test NetWork(测试网)。如下图： 区块搜索 有关所有块的信息 - 从创世块到所有当前块 - 可以在此页面上找到，包括块高度，其前一个块以及相应的字节大小。 交易搜索 您可以在此页面上搜索交易记录。 可以找到有发送交易地址和接收地址的信息，传输的SIPC数量，交易记录的块高度，相应的哈希和生产时间。 您还可以使用搜索栏查找哈希的特定交易。 查看叔块 再此页面上，可以查看每一个区块高度，以及其叔块对应的区块高度，出块时间，以及打包矿工和矿工获得奖励。如下图： 验证合约 如果想验证合约，输入要验证的合约地址，选择合约编译器类型和编译器版本，就可以验证合约。如下图： 验证后的合约列表 点击验证合约列表，可以查看到20条验证的合约信息。信息展示着合约地址，合约名称，编译器，版本，账户余额，验证时间等！ 合约验证一共有三种验证方式： 单文件文件验证方式 多文件验证方式 Json文件验证方式 单文件验证 pragma solidity ^0.5.12; contract PayALL{ event PayLog(address name,uint reward); event PayLog2(address name); constructor() public payable{ } function() external payable{ emit PayLog(msg.sender, msg.value); } function setMethd() public payable { emit PayLog2(msg.sender); } } 粘贴源码： 验证通过后； 多文件验证 因在合约书写过程中，文件的依赖可以引用另一个文件。 // test1.sol文件 pragma solidity ^0.5.17; contract Hello { uint value; function hello() public pure returns(string memory){ return \"hello world_1\"; } function set(uint x) public { value = x; } } // test2.sol文件 pragma solidity ^0.5.17; import {Hello} from \"./test1.sol\" ; contract Test2 is Hello { function test() public pure returns(string memory){ return Hello.hello(); } } 执行结果： 此类验证使用，多文件验证。验证方式如下，获取已部署的合约地址： 0x6e1ace6e6cf09a4ab096f272cfc029c0a1d883ac Optimization指的是合约编译的次数，如何合约的部署是选择了优化次数，那么在验证时，也需要选择相应的次数，默认不优化。 Constructor Arguments ABI-encoded表示合约是否填有构造参数，构造参数是部署时产生，验证这里不需要用户填写。 Contract Library Address涉及library合约，普通合约不做填写。后续会增加此类验证的详解。 查看验证成功 当前验证后的多文件合约源码 源码通过json 格式展示，分别包含两个文件源码。 Json 文件验证： Json 文件验证方式较为复制，需要用户了解solidity的编译参数，solidity会通过用户传递的json文件进行编译，但前提是这份json文件必须满足编译的规范。 Json文件： { \"language\": \"Solidity\", \"sources\": { \"myFile.sol\": { \"content\": \"pragma solidity ^0.5.12;contract Multiply7 { event Print(uint); event CjLog(address, uint); uint public a ; uint public b ; constructor (uint _a, uint _b) public { a = _a; b = _b; } function multiply(uint input1) public view returns (uint) { return input1 * 6 + a + b; } function multiplyplus(uint input1, uint input2) public returns (uint) { emit Print(input1 * 6 * input2); emit CjLog(msg.sender, a+b); return input1 * 6 * input2 + a + b; }}\" } }, \"settings\": { \"metadata\": { \"useLiteralContent\": true }, \"outputSelection\": { \"*\": { \"*\": [ \"*\" ], \"\": [ \"ast\" ] } } } } Library 的合约验证 首先了解一下什么是library合约 浏览器是支持library库的合约验证的，Library 合约在部署过程中，会连续并且嵌套依次部署合约，所有会部署多条合约（合约内部包括library库，会被一同部署)并产生多条hash。 合约源码: /** *Submitted for verification at Etherscan.io on 2020-02-27 */ pragma solidity ^0.6.0; library SetHFG { // 我们定义了一个新的结构体数据类型，用于在调用合约中保存数据。 struct Data { mapping(uint => bool) flags; } // 注意第一个参数是“storage reference”类型，因此在调用中参数传递的只是它的存储地址而不是内容。 // 这是库函数的一个特性。如果该函数可以被视为对象的方法，则习惯称第一个参数为 `self` 。 function insert(Data storage self, uint value) public returns (bool) { if (self.flags[value]) return false; // 已经存在 self.flags[value] = true; Acc.hi(); return true; } 如下是部署记录： CHU 为主合约: 0x1c622ed2035acc8514259788caafb3cf69d9bbe3 Library合约地址分别为： Bcc：0x0da8bd0dd96f78ac6e155b2d5e9fb6d15ca89fad Fcc：0x7b05897e605a3878d3511069924d750ef3954da5 Acc：0x13a6cb372333394caa8ea0e5876a4a52167a95ce SetHFG: 0x5386710eb4d02b41e7a253d3ebb00ca8795c930f 验证方式与单文件相同, 如下图： 验证通过 "}}